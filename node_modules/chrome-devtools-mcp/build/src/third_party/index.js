import require$$2, { strictEqual, notStrictEqual } from 'assert';
import require$$1$4, { resolve, dirname, normalize, join, relative, extname, basename } from 'path';
import require$$0$7, { statSync, readdirSync, readFileSync, writeFile } from 'fs';
import require$$0$2, { format as format$1, inspect } from 'util';
import require$$5, { fileURLToPath } from 'url';
import { createRequire } from 'node:module';
import fs, { readdirSync as readdirSync$1, readFileSync as readFileSync$1, accessSync, existsSync } from 'node:fs';
import require$$1 from 'tty';
import require$$0$1 from 'os';
import process$2 from 'node:process';
import { mkdtemp, unlink, rename } from 'node:fs/promises';
import os, { tmpdir } from 'node:os';
import path$1, { join as join$1, dirname as dirname$1 } from 'node:path';
import childProcess, { execSync, spawnSync, spawn } from 'node:child_process';
import { EventEmitter as EventEmitter$1 } from 'node:events';
import readline from 'node:readline';
import * as http$1 from 'node:http';
import * as https$1 from 'node:https';
import { urlToHttpOptions, URL as URL$1 } from 'node:url';
import require$$0$3 from 'http';
import require$$1$1 from 'https';
import require$$0$4 from 'net';
import require$$1$2 from 'tls';
import require$$0$5 from 'events';
import require$$0$6 from 'buffer';
import require$$1$3 from 'stream';
import require$$3$1 from 'dns';
import require$$2$1 from 'crypto';
import 'node:assert';
import { PassThrough } from 'node:stream';
import require$$0$8 from 'zlib';

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function getAugmentedNamespace(n) {
  if (Object.prototype.hasOwnProperty.call(n, '__esModule')) return n;
  var f = n.default;
	if (typeof f == "function") {
		var a = function a () {
			var isInstance = false;
      try {
        isInstance = this instanceof a;
      } catch {}
			if (isInstance) {
        return Reflect.construct(f, arguments, this.constructor);
			}
			return f.apply(this, arguments);
		};
		a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}

var es_promise_withResolvers = {};

var globalThis_1;
var hasRequiredGlobalThis;

function requireGlobalThis () {
	if (hasRequiredGlobalThis) return globalThis_1;
	hasRequiredGlobalThis = 1;
	var check = function (it) {
	  return it && it.Math === Math && it;
	};
	globalThis_1 =
	  check(typeof globalThis == 'object' && globalThis) ||
	  check(typeof window == 'object' && window) ||
	  check(typeof self == 'object' && self) ||
	  check(typeof commonjsGlobal == 'object' && commonjsGlobal) ||
	  check(typeof globalThis_1 == 'object' && globalThis_1) ||
	  (function () { return this; })() || Function('return this')();
	return globalThis_1;
}

var objectGetOwnPropertyDescriptor = {};

var fails;
var hasRequiredFails;

function requireFails () {
	if (hasRequiredFails) return fails;
	hasRequiredFails = 1;
	fails = function (exec) {
	  try {
	    return !!exec();
	  } catch (error) {
	    return true;
	  }
	};
	return fails;
}

var descriptors;
var hasRequiredDescriptors;

function requireDescriptors () {
	if (hasRequiredDescriptors) return descriptors;
	hasRequiredDescriptors = 1;
	var fails = requireFails();
	descriptors = !fails(function () {
	  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] !== 7;
	});
	return descriptors;
}

var functionBindNative;
var hasRequiredFunctionBindNative;

function requireFunctionBindNative () {
	if (hasRequiredFunctionBindNative) return functionBindNative;
	hasRequiredFunctionBindNative = 1;
	var fails = requireFails();
	functionBindNative = !fails(function () {
	  var test = (function () {  }).bind();
	  return typeof test != 'function' || test.hasOwnProperty('prototype');
	});
	return functionBindNative;
}

var functionCall;
var hasRequiredFunctionCall;

function requireFunctionCall () {
	if (hasRequiredFunctionCall) return functionCall;
	hasRequiredFunctionCall = 1;
	var NATIVE_BIND = requireFunctionBindNative();
	var call = Function.prototype.call;
	functionCall = NATIVE_BIND ? call.bind(call) : function () {
	  return call.apply(call, arguments);
	};
	return functionCall;
}

var objectPropertyIsEnumerable = {};

var hasRequiredObjectPropertyIsEnumerable;

function requireObjectPropertyIsEnumerable () {
	if (hasRequiredObjectPropertyIsEnumerable) return objectPropertyIsEnumerable;
	hasRequiredObjectPropertyIsEnumerable = 1;
	var $propertyIsEnumerable = {}.propertyIsEnumerable;
	var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
	var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);
	objectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
	  var descriptor = getOwnPropertyDescriptor(this, V);
	  return !!descriptor && descriptor.enumerable;
	} : $propertyIsEnumerable;
	return objectPropertyIsEnumerable;
}

var createPropertyDescriptor;
var hasRequiredCreatePropertyDescriptor;

function requireCreatePropertyDescriptor () {
	if (hasRequiredCreatePropertyDescriptor) return createPropertyDescriptor;
	hasRequiredCreatePropertyDescriptor = 1;
	createPropertyDescriptor = function (bitmap, value) {
	  return {
	    enumerable: !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable: !(bitmap & 4),
	    value: value
	  };
	};
	return createPropertyDescriptor;
}

var functionUncurryThis;
var hasRequiredFunctionUncurryThis;

function requireFunctionUncurryThis () {
	if (hasRequiredFunctionUncurryThis) return functionUncurryThis;
	hasRequiredFunctionUncurryThis = 1;
	var NATIVE_BIND = requireFunctionBindNative();
	var FunctionPrototype = Function.prototype;
	var call = FunctionPrototype.call;
	var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);
	functionUncurryThis = NATIVE_BIND ? uncurryThisWithBind : function (fn) {
	  return function () {
	    return call.apply(fn, arguments);
	  };
	};
	return functionUncurryThis;
}

var classofRaw;
var hasRequiredClassofRaw;

function requireClassofRaw () {
	if (hasRequiredClassofRaw) return classofRaw;
	hasRequiredClassofRaw = 1;
	var uncurryThis = requireFunctionUncurryThis();
	var toString = uncurryThis({}.toString);
	var stringSlice = uncurryThis(''.slice);
	classofRaw = function (it) {
	  return stringSlice(toString(it), 8, -1);
	};
	return classofRaw;
}

var indexedObject;
var hasRequiredIndexedObject;

function requireIndexedObject () {
	if (hasRequiredIndexedObject) return indexedObject;
	hasRequiredIndexedObject = 1;
	var uncurryThis = requireFunctionUncurryThis();
	var fails = requireFails();
	var classof = requireClassofRaw();
	var $Object = Object;
	var split = uncurryThis(''.split);
	indexedObject = fails(function () {
	  return !$Object('z').propertyIsEnumerable(0);
	}) ? function (it) {
	  return classof(it) === 'String' ? split(it, '') : $Object(it);
	} : $Object;
	return indexedObject;
}

var isNullOrUndefined;
var hasRequiredIsNullOrUndefined;

function requireIsNullOrUndefined () {
	if (hasRequiredIsNullOrUndefined) return isNullOrUndefined;
	hasRequiredIsNullOrUndefined = 1;
	isNullOrUndefined = function (it) {
	  return it === null || it === undefined;
	};
	return isNullOrUndefined;
}

var requireObjectCoercible;
var hasRequiredRequireObjectCoercible;

function requireRequireObjectCoercible () {
	if (hasRequiredRequireObjectCoercible) return requireObjectCoercible;
	hasRequiredRequireObjectCoercible = 1;
	var isNullOrUndefined = requireIsNullOrUndefined();
	var $TypeError = TypeError;
	requireObjectCoercible = function (it) {
	  if (isNullOrUndefined(it)) throw new $TypeError("Can't call method on " + it);
	  return it;
	};
	return requireObjectCoercible;
}

var toIndexedObject;
var hasRequiredToIndexedObject;

function requireToIndexedObject () {
	if (hasRequiredToIndexedObject) return toIndexedObject;
	hasRequiredToIndexedObject = 1;
	var IndexedObject = requireIndexedObject();
	var requireObjectCoercible = requireRequireObjectCoercible();
	toIndexedObject = function (it) {
	  return IndexedObject(requireObjectCoercible(it));
	};
	return toIndexedObject;
}

var isCallable;
var hasRequiredIsCallable;

function requireIsCallable () {
	if (hasRequiredIsCallable) return isCallable;
	hasRequiredIsCallable = 1;
	var documentAll = typeof document == 'object' && document.all;
	isCallable = typeof documentAll == 'undefined' && documentAll !== undefined ? function (argument) {
	  return typeof argument == 'function' || argument === documentAll;
	} : function (argument) {
	  return typeof argument == 'function';
	};
	return isCallable;
}

var isObject;
var hasRequiredIsObject;

function requireIsObject () {
	if (hasRequiredIsObject) return isObject;
	hasRequiredIsObject = 1;
	var isCallable = requireIsCallable();
	isObject = function (it) {
	  return typeof it == 'object' ? it !== null : isCallable(it);
	};
	return isObject;
}

var getBuiltIn;
var hasRequiredGetBuiltIn;

function requireGetBuiltIn () {
	if (hasRequiredGetBuiltIn) return getBuiltIn;
	hasRequiredGetBuiltIn = 1;
	var globalThis = requireGlobalThis();
	var isCallable = requireIsCallable();
	var aFunction = function (argument) {
	  return isCallable(argument) ? argument : undefined;
	};
	getBuiltIn = function (namespace, method) {
	  return arguments.length < 2 ? aFunction(globalThis[namespace]) : globalThis[namespace] && globalThis[namespace][method];
	};
	return getBuiltIn;
}

var objectIsPrototypeOf;
var hasRequiredObjectIsPrototypeOf;

function requireObjectIsPrototypeOf () {
	if (hasRequiredObjectIsPrototypeOf) return objectIsPrototypeOf;
	hasRequiredObjectIsPrototypeOf = 1;
	var uncurryThis = requireFunctionUncurryThis();
	objectIsPrototypeOf = uncurryThis({}.isPrototypeOf);
	return objectIsPrototypeOf;
}

var environmentUserAgent;
var hasRequiredEnvironmentUserAgent;

function requireEnvironmentUserAgent () {
	if (hasRequiredEnvironmentUserAgent) return environmentUserAgent;
	hasRequiredEnvironmentUserAgent = 1;
	var globalThis = requireGlobalThis();
	var navigator = globalThis.navigator;
	var userAgent = navigator && navigator.userAgent;
	environmentUserAgent = userAgent ? String(userAgent) : '';
	return environmentUserAgent;
}

var environmentV8Version;
var hasRequiredEnvironmentV8Version;

function requireEnvironmentV8Version () {
	if (hasRequiredEnvironmentV8Version) return environmentV8Version;
	hasRequiredEnvironmentV8Version = 1;
	var globalThis = requireGlobalThis();
	var userAgent = requireEnvironmentUserAgent();
	var process = globalThis.process;
	var Deno = globalThis.Deno;
	var versions = process && process.versions || Deno && Deno.version;
	var v8 = versions && versions.v8;
	var match, version;
	if (v8) {
	  match = v8.split('.');
	  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
	}
	if (!version && userAgent) {
	  match = userAgent.match(/Edge\/(\d+)/);
	  if (!match || match[1] >= 74) {
	    match = userAgent.match(/Chrome\/(\d+)/);
	    if (match) version = +match[1];
	  }
	}
	environmentV8Version = version;
	return environmentV8Version;
}

var symbolConstructorDetection;
var hasRequiredSymbolConstructorDetection;

function requireSymbolConstructorDetection () {
	if (hasRequiredSymbolConstructorDetection) return symbolConstructorDetection;
	hasRequiredSymbolConstructorDetection = 1;
	var V8_VERSION = requireEnvironmentV8Version();
	var fails = requireFails();
	var globalThis = requireGlobalThis();
	var $String = globalThis.String;
	symbolConstructorDetection = !!Object.getOwnPropertySymbols && !fails(function () {
	  var symbol = Symbol('symbol detection');
	  return !$String(symbol) || !(Object(symbol) instanceof Symbol) ||
	    !Symbol.sham && V8_VERSION && V8_VERSION < 41;
	});
	return symbolConstructorDetection;
}

var useSymbolAsUid;
var hasRequiredUseSymbolAsUid;

function requireUseSymbolAsUid () {
	if (hasRequiredUseSymbolAsUid) return useSymbolAsUid;
	hasRequiredUseSymbolAsUid = 1;
	var NATIVE_SYMBOL = requireSymbolConstructorDetection();
	useSymbolAsUid = NATIVE_SYMBOL &&
	  !Symbol.sham &&
	  typeof Symbol.iterator == 'symbol';
	return useSymbolAsUid;
}

var isSymbol;
var hasRequiredIsSymbol;

function requireIsSymbol () {
	if (hasRequiredIsSymbol) return isSymbol;
	hasRequiredIsSymbol = 1;
	var getBuiltIn = requireGetBuiltIn();
	var isCallable = requireIsCallable();
	var isPrototypeOf = requireObjectIsPrototypeOf();
	var USE_SYMBOL_AS_UID = requireUseSymbolAsUid();
	var $Object = Object;
	isSymbol = USE_SYMBOL_AS_UID ? function (it) {
	  return typeof it == 'symbol';
	} : function (it) {
	  var $Symbol = getBuiltIn('Symbol');
	  return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
	};
	return isSymbol;
}

var tryToString;
var hasRequiredTryToString;

function requireTryToString () {
	if (hasRequiredTryToString) return tryToString;
	hasRequiredTryToString = 1;
	var $String = String;
	tryToString = function (argument) {
	  try {
	    return $String(argument);
	  } catch (error) {
	    return 'Object';
	  }
	};
	return tryToString;
}

var aCallable;
var hasRequiredACallable;

function requireACallable () {
	if (hasRequiredACallable) return aCallable;
	hasRequiredACallable = 1;
	var isCallable = requireIsCallable();
	var tryToString = requireTryToString();
	var $TypeError = TypeError;
	aCallable = function (argument) {
	  if (isCallable(argument)) return argument;
	  throw new $TypeError(tryToString(argument) + ' is not a function');
	};
	return aCallable;
}

var getMethod;
var hasRequiredGetMethod;

function requireGetMethod () {
	if (hasRequiredGetMethod) return getMethod;
	hasRequiredGetMethod = 1;
	var aCallable = requireACallable();
	var isNullOrUndefined = requireIsNullOrUndefined();
	getMethod = function (V, P) {
	  var func = V[P];
	  return isNullOrUndefined(func) ? undefined : aCallable(func);
	};
	return getMethod;
}

var ordinaryToPrimitive;
var hasRequiredOrdinaryToPrimitive;

function requireOrdinaryToPrimitive () {
	if (hasRequiredOrdinaryToPrimitive) return ordinaryToPrimitive;
	hasRequiredOrdinaryToPrimitive = 1;
	var call = requireFunctionCall();
	var isCallable = requireIsCallable();
	var isObject = requireIsObject();
	var $TypeError = TypeError;
	ordinaryToPrimitive = function (input, pref) {
	  var fn, val;
	  if (pref === 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
	  if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input))) return val;
	  if (pref !== 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
	  throw new $TypeError("Can't convert object to primitive value");
	};
	return ordinaryToPrimitive;
}

var sharedStore = {exports: {}};

var isPure;
var hasRequiredIsPure;

function requireIsPure () {
	if (hasRequiredIsPure) return isPure;
	hasRequiredIsPure = 1;
	isPure = false;
	return isPure;
}

var defineGlobalProperty;
var hasRequiredDefineGlobalProperty;

function requireDefineGlobalProperty () {
	if (hasRequiredDefineGlobalProperty) return defineGlobalProperty;
	hasRequiredDefineGlobalProperty = 1;
	var globalThis = requireGlobalThis();
	var defineProperty = Object.defineProperty;
	defineGlobalProperty = function (key, value) {
	  try {
	    defineProperty(globalThis, key, { value: value, configurable: true, writable: true });
	  } catch (error) {
	    globalThis[key] = value;
	  } return value;
	};
	return defineGlobalProperty;
}

var hasRequiredSharedStore;

function requireSharedStore () {
	if (hasRequiredSharedStore) return sharedStore.exports;
	hasRequiredSharedStore = 1;
	var IS_PURE = requireIsPure();
	var globalThis = requireGlobalThis();
	var defineGlobalProperty = requireDefineGlobalProperty();
	var SHARED = '__core-js_shared__';
	var store = sharedStore.exports = globalThis[SHARED] || defineGlobalProperty(SHARED, {});
	(store.versions || (store.versions = [])).push({
	  version: '3.46.0',
	  mode: IS_PURE ? 'pure' : 'global',
	  copyright: 'Â© 2014-2025 Denis Pushkarev (zloirock.ru), 2025 CoreJS Company (core-js.io)',
	  license: 'https://github.com/zloirock/core-js/blob/v3.46.0/LICENSE',
	  source: 'https://github.com/zloirock/core-js'
	});
	return sharedStore.exports;
}

var shared$1;
var hasRequiredShared$1;

function requireShared$1 () {
	if (hasRequiredShared$1) return shared$1;
	hasRequiredShared$1 = 1;
	var store = requireSharedStore();
	shared$1 = function (key, value) {
	  return store[key] || (store[key] = value || {});
	};
	return shared$1;
}

var toObject;
var hasRequiredToObject;

function requireToObject () {
	if (hasRequiredToObject) return toObject;
	hasRequiredToObject = 1;
	var requireObjectCoercible = requireRequireObjectCoercible();
	var $Object = Object;
	toObject = function (argument) {
	  return $Object(requireObjectCoercible(argument));
	};
	return toObject;
}

var hasOwnProperty_1;
var hasRequiredHasOwnProperty;

function requireHasOwnProperty () {
	if (hasRequiredHasOwnProperty) return hasOwnProperty_1;
	hasRequiredHasOwnProperty = 1;
	var uncurryThis = requireFunctionUncurryThis();
	var toObject = requireToObject();
	var hasOwnProperty = uncurryThis({}.hasOwnProperty);
	hasOwnProperty_1 = Object.hasOwn || function hasOwn(it, key) {
	  return hasOwnProperty(toObject(it), key);
	};
	return hasOwnProperty_1;
}

var uid;
var hasRequiredUid;

function requireUid () {
	if (hasRequiredUid) return uid;
	hasRequiredUid = 1;
	var uncurryThis = requireFunctionUncurryThis();
	var id = 0;
	var postfix = Math.random();
	var toString = uncurryThis(1.1.toString);
	uid = function (key) {
	  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString(++id + postfix, 36);
	};
	return uid;
}

var wellKnownSymbol;
var hasRequiredWellKnownSymbol;

function requireWellKnownSymbol () {
	if (hasRequiredWellKnownSymbol) return wellKnownSymbol;
	hasRequiredWellKnownSymbol = 1;
	var globalThis = requireGlobalThis();
	var shared = requireShared$1();
	var hasOwn = requireHasOwnProperty();
	var uid = requireUid();
	var NATIVE_SYMBOL = requireSymbolConstructorDetection();
	var USE_SYMBOL_AS_UID = requireUseSymbolAsUid();
	var Symbol = globalThis.Symbol;
	var WellKnownSymbolsStore = shared('wks');
	var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol['for'] || Symbol : Symbol && Symbol.withoutSetter || uid;
	wellKnownSymbol = function (name) {
	  if (!hasOwn(WellKnownSymbolsStore, name)) {
	    WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn(Symbol, name)
	      ? Symbol[name]
	      : createWellKnownSymbol('Symbol.' + name);
	  } return WellKnownSymbolsStore[name];
	};
	return wellKnownSymbol;
}

var toPrimitive;
var hasRequiredToPrimitive;

function requireToPrimitive () {
	if (hasRequiredToPrimitive) return toPrimitive;
	hasRequiredToPrimitive = 1;
	var call = requireFunctionCall();
	var isObject = requireIsObject();
	var isSymbol = requireIsSymbol();
	var getMethod = requireGetMethod();
	var ordinaryToPrimitive = requireOrdinaryToPrimitive();
	var wellKnownSymbol = requireWellKnownSymbol();
	var $TypeError = TypeError;
	var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');
	toPrimitive = function (input, pref) {
	  if (!isObject(input) || isSymbol(input)) return input;
	  var exoticToPrim = getMethod(input, TO_PRIMITIVE);
	  var result;
	  if (exoticToPrim) {
	    if (pref === undefined) pref = 'default';
	    result = call(exoticToPrim, input, pref);
	    if (!isObject(result) || isSymbol(result)) return result;
	    throw new $TypeError("Can't convert object to primitive value");
	  }
	  if (pref === undefined) pref = 'number';
	  return ordinaryToPrimitive(input, pref);
	};
	return toPrimitive;
}

var toPropertyKey;
var hasRequiredToPropertyKey;

function requireToPropertyKey () {
	if (hasRequiredToPropertyKey) return toPropertyKey;
	hasRequiredToPropertyKey = 1;
	var toPrimitive = requireToPrimitive();
	var isSymbol = requireIsSymbol();
	toPropertyKey = function (argument) {
	  var key = toPrimitive(argument, 'string');
	  return isSymbol(key) ? key : key + '';
	};
	return toPropertyKey;
}

var documentCreateElement;
var hasRequiredDocumentCreateElement;

function requireDocumentCreateElement () {
	if (hasRequiredDocumentCreateElement) return documentCreateElement;
	hasRequiredDocumentCreateElement = 1;
	var globalThis = requireGlobalThis();
	var isObject = requireIsObject();
	var document = globalThis.document;
	var EXISTS = isObject(document) && isObject(document.createElement);
	documentCreateElement = function (it) {
	  return EXISTS ? document.createElement(it) : {};
	};
	return documentCreateElement;
}

var ie8DomDefine;
var hasRequiredIe8DomDefine;

function requireIe8DomDefine () {
	if (hasRequiredIe8DomDefine) return ie8DomDefine;
	hasRequiredIe8DomDefine = 1;
	var DESCRIPTORS = requireDescriptors();
	var fails = requireFails();
	var createElement = requireDocumentCreateElement();
	ie8DomDefine = !DESCRIPTORS && !fails(function () {
	  return Object.defineProperty(createElement('div'), 'a', {
	    get: function () { return 7; }
	  }).a !== 7;
	});
	return ie8DomDefine;
}

var hasRequiredObjectGetOwnPropertyDescriptor;

function requireObjectGetOwnPropertyDescriptor () {
	if (hasRequiredObjectGetOwnPropertyDescriptor) return objectGetOwnPropertyDescriptor;
	hasRequiredObjectGetOwnPropertyDescriptor = 1;
	var DESCRIPTORS = requireDescriptors();
	var call = requireFunctionCall();
	var propertyIsEnumerableModule = requireObjectPropertyIsEnumerable();
	var createPropertyDescriptor = requireCreatePropertyDescriptor();
	var toIndexedObject = requireToIndexedObject();
	var toPropertyKey = requireToPropertyKey();
	var hasOwn = requireHasOwnProperty();
	var IE8_DOM_DEFINE = requireIe8DomDefine();
	var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
	objectGetOwnPropertyDescriptor.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
	  O = toIndexedObject(O);
	  P = toPropertyKey(P);
	  if (IE8_DOM_DEFINE) try {
	    return $getOwnPropertyDescriptor(O, P);
	  } catch (error) {  }
	  if (hasOwn(O, P)) return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);
	};
	return objectGetOwnPropertyDescriptor;
}

var objectDefineProperty = {};

var v8PrototypeDefineBug;
var hasRequiredV8PrototypeDefineBug;

function requireV8PrototypeDefineBug () {
	if (hasRequiredV8PrototypeDefineBug) return v8PrototypeDefineBug;
	hasRequiredV8PrototypeDefineBug = 1;
	var DESCRIPTORS = requireDescriptors();
	var fails = requireFails();
	v8PrototypeDefineBug = DESCRIPTORS && fails(function () {
	  return Object.defineProperty(function () {  }, 'prototype', {
	    value: 42,
	    writable: false
	  }).prototype !== 42;
	});
	return v8PrototypeDefineBug;
}

var anObject;
var hasRequiredAnObject;

function requireAnObject () {
	if (hasRequiredAnObject) return anObject;
	hasRequiredAnObject = 1;
	var isObject = requireIsObject();
	var $String = String;
	var $TypeError = TypeError;
	anObject = function (argument) {
	  if (isObject(argument)) return argument;
	  throw new $TypeError($String(argument) + ' is not an object');
	};
	return anObject;
}

var hasRequiredObjectDefineProperty;

function requireObjectDefineProperty () {
	if (hasRequiredObjectDefineProperty) return objectDefineProperty;
	hasRequiredObjectDefineProperty = 1;
	var DESCRIPTORS = requireDescriptors();
	var IE8_DOM_DEFINE = requireIe8DomDefine();
	var V8_PROTOTYPE_DEFINE_BUG = requireV8PrototypeDefineBug();
	var anObject = requireAnObject();
	var toPropertyKey = requireToPropertyKey();
	var $TypeError = TypeError;
	var $defineProperty = Object.defineProperty;
	var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
	var ENUMERABLE = 'enumerable';
	var CONFIGURABLE = 'configurable';
	var WRITABLE = 'writable';
	objectDefineProperty.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
	  anObject(O);
	  P = toPropertyKey(P);
	  anObject(Attributes);
	  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
	    var current = $getOwnPropertyDescriptor(O, P);
	    if (current && current[WRITABLE]) {
	      O[P] = Attributes.value;
	      Attributes = {
	        configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
	        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
	        writable: false
	      };
	    }
	  } return $defineProperty(O, P, Attributes);
	} : $defineProperty : function defineProperty(O, P, Attributes) {
	  anObject(O);
	  P = toPropertyKey(P);
	  anObject(Attributes);
	  if (IE8_DOM_DEFINE) try {
	    return $defineProperty(O, P, Attributes);
	  } catch (error) {  }
	  if ('get' in Attributes || 'set' in Attributes) throw new $TypeError('Accessors not supported');
	  if ('value' in Attributes) O[P] = Attributes.value;
	  return O;
	};
	return objectDefineProperty;
}

var createNonEnumerableProperty;
var hasRequiredCreateNonEnumerableProperty;

function requireCreateNonEnumerableProperty () {
	if (hasRequiredCreateNonEnumerableProperty) return createNonEnumerableProperty;
	hasRequiredCreateNonEnumerableProperty = 1;
	var DESCRIPTORS = requireDescriptors();
	var definePropertyModule = requireObjectDefineProperty();
	var createPropertyDescriptor = requireCreatePropertyDescriptor();
	createNonEnumerableProperty = DESCRIPTORS ? function (object, key, value) {
	  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
	} : function (object, key, value) {
	  object[key] = value;
	  return object;
	};
	return createNonEnumerableProperty;
}

var makeBuiltIn = {exports: {}};

var functionName;
var hasRequiredFunctionName;

function requireFunctionName () {
	if (hasRequiredFunctionName) return functionName;
	hasRequiredFunctionName = 1;
	var DESCRIPTORS = requireDescriptors();
	var hasOwn = requireHasOwnProperty();
	var FunctionPrototype = Function.prototype;
	var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;
	var EXISTS = hasOwn(FunctionPrototype, 'name');
	var PROPER = EXISTS && (function something() {  }).name === 'something';
	var CONFIGURABLE = EXISTS && (!DESCRIPTORS || (DESCRIPTORS && getDescriptor(FunctionPrototype, 'name').configurable));
	functionName = {
	  EXISTS: EXISTS,
	  PROPER: PROPER,
	  CONFIGURABLE: CONFIGURABLE
	};
	return functionName;
}

var inspectSource;
var hasRequiredInspectSource;

function requireInspectSource () {
	if (hasRequiredInspectSource) return inspectSource;
	hasRequiredInspectSource = 1;
	var uncurryThis = requireFunctionUncurryThis();
	var isCallable = requireIsCallable();
	var store = requireSharedStore();
	var functionToString = uncurryThis(Function.toString);
	if (!isCallable(store.inspectSource)) {
	  store.inspectSource = function (it) {
	    return functionToString(it);
	  };
	}
	inspectSource = store.inspectSource;
	return inspectSource;
}

var weakMapBasicDetection;
var hasRequiredWeakMapBasicDetection;

function requireWeakMapBasicDetection () {
	if (hasRequiredWeakMapBasicDetection) return weakMapBasicDetection;
	hasRequiredWeakMapBasicDetection = 1;
	var globalThis = requireGlobalThis();
	var isCallable = requireIsCallable();
	var WeakMap = globalThis.WeakMap;
	weakMapBasicDetection = isCallable(WeakMap) && /native code/.test(String(WeakMap));
	return weakMapBasicDetection;
}

var sharedKey;
var hasRequiredSharedKey;

function requireSharedKey () {
	if (hasRequiredSharedKey) return sharedKey;
	hasRequiredSharedKey = 1;
	var shared = requireShared$1();
	var uid = requireUid();
	var keys = shared('keys');
	sharedKey = function (key) {
	  return keys[key] || (keys[key] = uid(key));
	};
	return sharedKey;
}

var hiddenKeys;
var hasRequiredHiddenKeys;

function requireHiddenKeys () {
	if (hasRequiredHiddenKeys) return hiddenKeys;
	hasRequiredHiddenKeys = 1;
	hiddenKeys = {};
	return hiddenKeys;
}

var internalState;
var hasRequiredInternalState;

function requireInternalState () {
	if (hasRequiredInternalState) return internalState;
	hasRequiredInternalState = 1;
	var NATIVE_WEAK_MAP = requireWeakMapBasicDetection();
	var globalThis = requireGlobalThis();
	var isObject = requireIsObject();
	var createNonEnumerableProperty = requireCreateNonEnumerableProperty();
	var hasOwn = requireHasOwnProperty();
	var shared = requireSharedStore();
	var sharedKey = requireSharedKey();
	var hiddenKeys = requireHiddenKeys();
	var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
	var TypeError = globalThis.TypeError;
	var WeakMap = globalThis.WeakMap;
	var set, get, has;
	var enforce = function (it) {
	  return has(it) ? get(it) : set(it, {});
	};
	var getterFor = function (TYPE) {
	  return function (it) {
	    var state;
	    if (!isObject(it) || (state = get(it)).type !== TYPE) {
	      throw new TypeError('Incompatible receiver, ' + TYPE + ' required');
	    } return state;
	  };
	};
	if (NATIVE_WEAK_MAP || shared.state) {
	  var store = shared.state || (shared.state = new WeakMap());
	  store.get = store.get;
	  store.has = store.has;
	  store.set = store.set;
	  set = function (it, metadata) {
	    if (store.has(it)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
	    metadata.facade = it;
	    store.set(it, metadata);
	    return metadata;
	  };
	  get = function (it) {
	    return store.get(it) || {};
	  };
	  has = function (it) {
	    return store.has(it);
	  };
	} else {
	  var STATE = sharedKey('state');
	  hiddenKeys[STATE] = true;
	  set = function (it, metadata) {
	    if (hasOwn(it, STATE)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
	    metadata.facade = it;
	    createNonEnumerableProperty(it, STATE, metadata);
	    return metadata;
	  };
	  get = function (it) {
	    return hasOwn(it, STATE) ? it[STATE] : {};
	  };
	  has = function (it) {
	    return hasOwn(it, STATE);
	  };
	}
	internalState = {
	  set: set,
	  get: get,
	  has: has,
	  enforce: enforce,
	  getterFor: getterFor
	};
	return internalState;
}

var hasRequiredMakeBuiltIn;

function requireMakeBuiltIn () {
	if (hasRequiredMakeBuiltIn) return makeBuiltIn.exports;
	hasRequiredMakeBuiltIn = 1;
	var uncurryThis = requireFunctionUncurryThis();
	var fails = requireFails();
	var isCallable = requireIsCallable();
	var hasOwn = requireHasOwnProperty();
	var DESCRIPTORS = requireDescriptors();
	var CONFIGURABLE_FUNCTION_NAME = requireFunctionName().CONFIGURABLE;
	var inspectSource = requireInspectSource();
	var InternalStateModule = requireInternalState();
	var enforceInternalState = InternalStateModule.enforce;
	var getInternalState = InternalStateModule.get;
	var $String = String;
	var defineProperty = Object.defineProperty;
	var stringSlice = uncurryThis(''.slice);
	var replace = uncurryThis(''.replace);
	var join = uncurryThis([].join);
	var CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function () {
	  return defineProperty(function () {  }, 'length', { value: 8 }).length !== 8;
	});
	var TEMPLATE = String(String).split('String');
	var makeBuiltIn$1 = makeBuiltIn.exports = function (value, name, options) {
	  if (stringSlice($String(name), 0, 7) === 'Symbol(') {
	    name = '[' + replace($String(name), /^Symbol\(([^)]*)\).*$/, '$1') + ']';
	  }
	  if (options && options.getter) name = 'get ' + name;
	  if (options && options.setter) name = 'set ' + name;
	  if (!hasOwn(value, 'name') || (CONFIGURABLE_FUNCTION_NAME && value.name !== name)) {
	    if (DESCRIPTORS) defineProperty(value, 'name', { value: name, configurable: true });
	    else value.name = name;
	  }
	  if (CONFIGURABLE_LENGTH && options && hasOwn(options, 'arity') && value.length !== options.arity) {
	    defineProperty(value, 'length', { value: options.arity });
	  }
	  try {
	    if (options && hasOwn(options, 'constructor') && options.constructor) {
	      if (DESCRIPTORS) defineProperty(value, 'prototype', { writable: false });
	    } else if (value.prototype) value.prototype = undefined;
	  } catch (error) {  }
	  var state = enforceInternalState(value);
	  if (!hasOwn(state, 'source')) {
	    state.source = join(TEMPLATE, typeof name == 'string' ? name : '');
	  } return value;
	};
	Function.prototype.toString = makeBuiltIn$1(function toString() {
	  return isCallable(this) && getInternalState(this).source || inspectSource(this);
	}, 'toString');
	return makeBuiltIn.exports;
}

var defineBuiltIn;
var hasRequiredDefineBuiltIn;

function requireDefineBuiltIn () {
	if (hasRequiredDefineBuiltIn) return defineBuiltIn;
	hasRequiredDefineBuiltIn = 1;
	var isCallable = requireIsCallable();
	var definePropertyModule = requireObjectDefineProperty();
	var makeBuiltIn = requireMakeBuiltIn();
	var defineGlobalProperty = requireDefineGlobalProperty();
	defineBuiltIn = function (O, key, value, options) {
	  if (!options) options = {};
	  var simple = options.enumerable;
	  var name = options.name !== undefined ? options.name : key;
	  if (isCallable(value)) makeBuiltIn(value, name, options);
	  if (options.global) {
	    if (simple) O[key] = value;
	    else defineGlobalProperty(key, value);
	  } else {
	    try {
	      if (!options.unsafe) delete O[key];
	      else if (O[key]) simple = true;
	    } catch (error) {  }
	    if (simple) O[key] = value;
	    else definePropertyModule.f(O, key, {
	      value: value,
	      enumerable: false,
	      configurable: !options.nonConfigurable,
	      writable: !options.nonWritable
	    });
	  } return O;
	};
	return defineBuiltIn;
}

var objectGetOwnPropertyNames = {};

var mathTrunc;
var hasRequiredMathTrunc;

function requireMathTrunc () {
	if (hasRequiredMathTrunc) return mathTrunc;
	hasRequiredMathTrunc = 1;
	var ceil = Math.ceil;
	var floor = Math.floor;
	mathTrunc = Math.trunc || function trunc(x) {
	  var n = +x;
	  return (n > 0 ? floor : ceil)(n);
	};
	return mathTrunc;
}

var toIntegerOrInfinity;
var hasRequiredToIntegerOrInfinity;

function requireToIntegerOrInfinity () {
	if (hasRequiredToIntegerOrInfinity) return toIntegerOrInfinity;
	hasRequiredToIntegerOrInfinity = 1;
	var trunc = requireMathTrunc();
	toIntegerOrInfinity = function (argument) {
	  var number = +argument;
	  return number !== number || number === 0 ? 0 : trunc(number);
	};
	return toIntegerOrInfinity;
}

var toAbsoluteIndex;
var hasRequiredToAbsoluteIndex;

function requireToAbsoluteIndex () {
	if (hasRequiredToAbsoluteIndex) return toAbsoluteIndex;
	hasRequiredToAbsoluteIndex = 1;
	var toIntegerOrInfinity = requireToIntegerOrInfinity();
	var max = Math.max;
	var min = Math.min;
	toAbsoluteIndex = function (index, length) {
	  var integer = toIntegerOrInfinity(index);
	  return integer < 0 ? max(integer + length, 0) : min(integer, length);
	};
	return toAbsoluteIndex;
}

var toLength;
var hasRequiredToLength;

function requireToLength () {
	if (hasRequiredToLength) return toLength;
	hasRequiredToLength = 1;
	var toIntegerOrInfinity = requireToIntegerOrInfinity();
	var min = Math.min;
	toLength = function (argument) {
	  var len = toIntegerOrInfinity(argument);
	  return len > 0 ? min(len, 0x1FFFFFFFFFFFFF) : 0;
	};
	return toLength;
}

var lengthOfArrayLike;
var hasRequiredLengthOfArrayLike;

function requireLengthOfArrayLike () {
	if (hasRequiredLengthOfArrayLike) return lengthOfArrayLike;
	hasRequiredLengthOfArrayLike = 1;
	var toLength = requireToLength();
	lengthOfArrayLike = function (obj) {
	  return toLength(obj.length);
	};
	return lengthOfArrayLike;
}

var arrayIncludes;
var hasRequiredArrayIncludes;

function requireArrayIncludes () {
	if (hasRequiredArrayIncludes) return arrayIncludes;
	hasRequiredArrayIncludes = 1;
	var toIndexedObject = requireToIndexedObject();
	var toAbsoluteIndex = requireToAbsoluteIndex();
	var lengthOfArrayLike = requireLengthOfArrayLike();
	var createMethod = function (IS_INCLUDES) {
	  return function ($this, el, fromIndex) {
	    var O = toIndexedObject($this);
	    var length = lengthOfArrayLike(O);
	    if (length === 0) return !IS_INCLUDES && -1;
	    var index = toAbsoluteIndex(fromIndex, length);
	    var value;
	    if (IS_INCLUDES && el !== el) while (length > index) {
	      value = O[index++];
	      if (value !== value) return true;
	    } else for (;length > index; index++) {
	      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};
	arrayIncludes = {
	  includes: createMethod(true),
	  indexOf: createMethod(false)
	};
	return arrayIncludes;
}

var objectKeysInternal;
var hasRequiredObjectKeysInternal;

function requireObjectKeysInternal () {
	if (hasRequiredObjectKeysInternal) return objectKeysInternal;
	hasRequiredObjectKeysInternal = 1;
	var uncurryThis = requireFunctionUncurryThis();
	var hasOwn = requireHasOwnProperty();
	var toIndexedObject = requireToIndexedObject();
	var indexOf = requireArrayIncludes().indexOf;
	var hiddenKeys = requireHiddenKeys();
	var push = uncurryThis([].push);
	objectKeysInternal = function (object, names) {
	  var O = toIndexedObject(object);
	  var i = 0;
	  var result = [];
	  var key;
	  for (key in O) !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);
	  while (names.length > i) if (hasOwn(O, key = names[i++])) {
	    ~indexOf(result, key) || push(result, key);
	  }
	  return result;
	};
	return objectKeysInternal;
}

var enumBugKeys;
var hasRequiredEnumBugKeys;

function requireEnumBugKeys () {
	if (hasRequiredEnumBugKeys) return enumBugKeys;
	hasRequiredEnumBugKeys = 1;
	enumBugKeys = [
	  'constructor',
	  'hasOwnProperty',
	  'isPrototypeOf',
	  'propertyIsEnumerable',
	  'toLocaleString',
	  'toString',
	  'valueOf'
	];
	return enumBugKeys;
}

var hasRequiredObjectGetOwnPropertyNames;

function requireObjectGetOwnPropertyNames () {
	if (hasRequiredObjectGetOwnPropertyNames) return objectGetOwnPropertyNames;
	hasRequiredObjectGetOwnPropertyNames = 1;
	var internalObjectKeys = requireObjectKeysInternal();
	var enumBugKeys = requireEnumBugKeys();
	var hiddenKeys = enumBugKeys.concat('length', 'prototype');
	objectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
	  return internalObjectKeys(O, hiddenKeys);
	};
	return objectGetOwnPropertyNames;
}

var objectGetOwnPropertySymbols = {};

var hasRequiredObjectGetOwnPropertySymbols;

function requireObjectGetOwnPropertySymbols () {
	if (hasRequiredObjectGetOwnPropertySymbols) return objectGetOwnPropertySymbols;
	hasRequiredObjectGetOwnPropertySymbols = 1;
	objectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;
	return objectGetOwnPropertySymbols;
}

var ownKeys$1;
var hasRequiredOwnKeys;

function requireOwnKeys () {
	if (hasRequiredOwnKeys) return ownKeys$1;
	hasRequiredOwnKeys = 1;
	var getBuiltIn = requireGetBuiltIn();
	var uncurryThis = requireFunctionUncurryThis();
	var getOwnPropertyNamesModule = requireObjectGetOwnPropertyNames();
	var getOwnPropertySymbolsModule = requireObjectGetOwnPropertySymbols();
	var anObject = requireAnObject();
	var concat = uncurryThis([].concat);
	ownKeys$1 = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
	  var keys = getOwnPropertyNamesModule.f(anObject(it));
	  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
	  return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;
	};
	return ownKeys$1;
}

var copyConstructorProperties;
var hasRequiredCopyConstructorProperties;

function requireCopyConstructorProperties () {
	if (hasRequiredCopyConstructorProperties) return copyConstructorProperties;
	hasRequiredCopyConstructorProperties = 1;
	var hasOwn = requireHasOwnProperty();
	var ownKeys = requireOwnKeys();
	var getOwnPropertyDescriptorModule = requireObjectGetOwnPropertyDescriptor();
	var definePropertyModule = requireObjectDefineProperty();
	copyConstructorProperties = function (target, source, exceptions) {
	  var keys = ownKeys(source);
	  var defineProperty = definePropertyModule.f;
	  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
	  for (var i = 0; i < keys.length; i++) {
	    var key = keys[i];
	    if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {
	      defineProperty(target, key, getOwnPropertyDescriptor(source, key));
	    }
	  }
	};
	return copyConstructorProperties;
}

var isForced_1;
var hasRequiredIsForced;

function requireIsForced () {
	if (hasRequiredIsForced) return isForced_1;
	hasRequiredIsForced = 1;
	var fails = requireFails();
	var isCallable = requireIsCallable();
	var replacement = /#|\.prototype\./;
	var isForced = function (feature, detection) {
	  var value = data[normalize(feature)];
	  return value === POLYFILL ? true
	    : value === NATIVE ? false
	    : isCallable(detection) ? fails(detection)
	    : !!detection;
	};
	var normalize = isForced.normalize = function (string) {
	  return String(string).replace(replacement, '.').toLowerCase();
	};
	var data = isForced.data = {};
	var NATIVE = isForced.NATIVE = 'N';
	var POLYFILL = isForced.POLYFILL = 'P';
	isForced_1 = isForced;
	return isForced_1;
}

var _export;
var hasRequired_export;

function require_export () {
	if (hasRequired_export) return _export;
	hasRequired_export = 1;
	var globalThis = requireGlobalThis();
	var getOwnPropertyDescriptor = requireObjectGetOwnPropertyDescriptor().f;
	var createNonEnumerableProperty = requireCreateNonEnumerableProperty();
	var defineBuiltIn = requireDefineBuiltIn();
	var defineGlobalProperty = requireDefineGlobalProperty();
	var copyConstructorProperties = requireCopyConstructorProperties();
	var isForced = requireIsForced();
	_export = function (options, source) {
	  var TARGET = options.target;
	  var GLOBAL = options.global;
	  var STATIC = options.stat;
	  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
	  if (GLOBAL) {
	    target = globalThis;
	  } else if (STATIC) {
	    target = globalThis[TARGET] || defineGlobalProperty(TARGET, {});
	  } else {
	    target = globalThis[TARGET] && globalThis[TARGET].prototype;
	  }
	  if (target) for (key in source) {
	    sourceProperty = source[key];
	    if (options.dontCallGetSet) {
	      descriptor = getOwnPropertyDescriptor(target, key);
	      targetProperty = descriptor && descriptor.value;
	    } else targetProperty = target[key];
	    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
	    if (!FORCED && targetProperty !== undefined) {
	      if (typeof sourceProperty == typeof targetProperty) continue;
	      copyConstructorProperties(sourceProperty, targetProperty);
	    }
	    if (options.sham || (targetProperty && targetProperty.sham)) {
	      createNonEnumerableProperty(sourceProperty, 'sham', true);
	    }
	    defineBuiltIn(target, key, sourceProperty, options);
	  }
	};
	return _export;
}

var newPromiseCapability = {};

var hasRequiredNewPromiseCapability;

function requireNewPromiseCapability () {
	if (hasRequiredNewPromiseCapability) return newPromiseCapability;
	hasRequiredNewPromiseCapability = 1;
	var aCallable = requireACallable();
	var $TypeError = TypeError;
	var PromiseCapability = function (C) {
	  var resolve, reject;
	  this.promise = new C(function ($$resolve, $$reject) {
	    if (resolve !== undefined || reject !== undefined) throw new $TypeError('Bad Promise constructor');
	    resolve = $$resolve;
	    reject = $$reject;
	  });
	  this.resolve = aCallable(resolve);
	  this.reject = aCallable(reject);
	};
	newPromiseCapability.f = function (C) {
	  return new PromiseCapability(C);
	};
	return newPromiseCapability;
}

var hasRequiredEs_promise_withResolvers;

function requireEs_promise_withResolvers () {
	if (hasRequiredEs_promise_withResolvers) return es_promise_withResolvers;
	hasRequiredEs_promise_withResolvers = 1;
	var $ = require_export();
	var newPromiseCapabilityModule = requireNewPromiseCapability();
	$({ target: 'Promise', stat: true }, {
	  withResolvers: function withResolvers() {
	    var promiseCapability = newPromiseCapabilityModule.f(this);
	    return {
	      promise: promiseCapability.promise,
	      resolve: promiseCapability.resolve,
	      reject: promiseCapability.reject
	    };
	  }
	});
	return es_promise_withResolvers;
}

requireEs_promise_withResolvers();

var iteratorHelpers = {};

var iteratorHelpersStage3 = {};

var esnext_asyncIterator_constructor = {};

var anInstance;
var hasRequiredAnInstance;

function requireAnInstance () {
	if (hasRequiredAnInstance) return anInstance;
	hasRequiredAnInstance = 1;
	var isPrototypeOf = requireObjectIsPrototypeOf();
	var $TypeError = TypeError;
	anInstance = function (it, Prototype) {
	  if (isPrototypeOf(Prototype, it)) return it;
	  throw new $TypeError('Incorrect invocation');
	};
	return anInstance;
}

var correctPrototypeGetter;
var hasRequiredCorrectPrototypeGetter;

function requireCorrectPrototypeGetter () {
	if (hasRequiredCorrectPrototypeGetter) return correctPrototypeGetter;
	hasRequiredCorrectPrototypeGetter = 1;
	var fails = requireFails();
	correctPrototypeGetter = !fails(function () {
	  function F() {  }
	  F.prototype.constructor = null;
	  return Object.getPrototypeOf(new F()) !== F.prototype;
	});
	return correctPrototypeGetter;
}

var objectGetPrototypeOf;
var hasRequiredObjectGetPrototypeOf;

function requireObjectGetPrototypeOf () {
	if (hasRequiredObjectGetPrototypeOf) return objectGetPrototypeOf;
	hasRequiredObjectGetPrototypeOf = 1;
	var hasOwn = requireHasOwnProperty();
	var isCallable = requireIsCallable();
	var toObject = requireToObject();
	var sharedKey = requireSharedKey();
	var CORRECT_PROTOTYPE_GETTER = requireCorrectPrototypeGetter();
	var IE_PROTO = sharedKey('IE_PROTO');
	var $Object = Object;
	var ObjectPrototype = $Object.prototype;
	objectGetPrototypeOf = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function (O) {
	  var object = toObject(O);
	  if (hasOwn(object, IE_PROTO)) return object[IE_PROTO];
	  var constructor = object.constructor;
	  if (isCallable(constructor) && object instanceof constructor) {
	    return constructor.prototype;
	  } return object instanceof $Object ? ObjectPrototype : null;
	};
	return objectGetPrototypeOf;
}

var objectDefineProperties = {};

var objectKeys$1;
var hasRequiredObjectKeys;

function requireObjectKeys () {
	if (hasRequiredObjectKeys) return objectKeys$1;
	hasRequiredObjectKeys = 1;
	var internalObjectKeys = requireObjectKeysInternal();
	var enumBugKeys = requireEnumBugKeys();
	objectKeys$1 = Object.keys || function keys(O) {
	  return internalObjectKeys(O, enumBugKeys);
	};
	return objectKeys$1;
}

var hasRequiredObjectDefineProperties;

function requireObjectDefineProperties () {
	if (hasRequiredObjectDefineProperties) return objectDefineProperties;
	hasRequiredObjectDefineProperties = 1;
	var DESCRIPTORS = requireDescriptors();
	var V8_PROTOTYPE_DEFINE_BUG = requireV8PrototypeDefineBug();
	var definePropertyModule = requireObjectDefineProperty();
	var anObject = requireAnObject();
	var toIndexedObject = requireToIndexedObject();
	var objectKeys = requireObjectKeys();
	objectDefineProperties.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
	  anObject(O);
	  var props = toIndexedObject(Properties);
	  var keys = objectKeys(Properties);
	  var length = keys.length;
	  var index = 0;
	  var key;
	  while (length > index) definePropertyModule.f(O, key = keys[index++], props[key]);
	  return O;
	};
	return objectDefineProperties;
}

var html;
var hasRequiredHtml;

function requireHtml () {
	if (hasRequiredHtml) return html;
	hasRequiredHtml = 1;
	var getBuiltIn = requireGetBuiltIn();
	html = getBuiltIn('document', 'documentElement');
	return html;
}

var objectCreate;
var hasRequiredObjectCreate;

function requireObjectCreate () {
	if (hasRequiredObjectCreate) return objectCreate;
	hasRequiredObjectCreate = 1;
	var anObject = requireAnObject();
	var definePropertiesModule = requireObjectDefineProperties();
	var enumBugKeys = requireEnumBugKeys();
	var hiddenKeys = requireHiddenKeys();
	var html = requireHtml();
	var documentCreateElement = requireDocumentCreateElement();
	var sharedKey = requireSharedKey();
	var GT = '>';
	var LT = '<';
	var PROTOTYPE = 'prototype';
	var SCRIPT = 'script';
	var IE_PROTO = sharedKey('IE_PROTO');
	var EmptyConstructor = function () {  };
	var scriptTag = function (content) {
	  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
	};
	var NullProtoObjectViaActiveX = function (activeXDocument) {
	  activeXDocument.write(scriptTag(''));
	  activeXDocument.close();
	  var temp = activeXDocument.parentWindow.Object;
	  activeXDocument = null;
	  return temp;
	};
	var NullProtoObjectViaIFrame = function () {
	  var iframe = documentCreateElement('iframe');
	  var JS = 'java' + SCRIPT + ':';
	  var iframeDocument;
	  iframe.style.display = 'none';
	  html.appendChild(iframe);
	  iframe.src = String(JS);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write(scriptTag('document.F=Object'));
	  iframeDocument.close();
	  return iframeDocument.F;
	};
	var activeXDocument;
	var NullProtoObject = function () {
	  try {
	    activeXDocument = new ActiveXObject('htmlfile');
	  } catch (error) {  }
	  NullProtoObject = typeof document != 'undefined'
	    ? document.domain && activeXDocument
	      ? NullProtoObjectViaActiveX(activeXDocument)
	      : NullProtoObjectViaIFrame()
	    : NullProtoObjectViaActiveX(activeXDocument);
	  var length = enumBugKeys.length;
	  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
	  return NullProtoObject();
	};
	hiddenKeys[IE_PROTO] = true;
	objectCreate = Object.create || function create(O, Properties) {
	  var result;
	  if (O !== null) {
	    EmptyConstructor[PROTOTYPE] = anObject(O);
	    result = new EmptyConstructor();
	    EmptyConstructor[PROTOTYPE] = null;
	    result[IE_PROTO] = O;
	  } else result = NullProtoObject();
	  return Properties === undefined ? result : definePropertiesModule.f(result, Properties);
	};
	return objectCreate;
}

var asyncIteratorPrototype;
var hasRequiredAsyncIteratorPrototype;

function requireAsyncIteratorPrototype () {
	if (hasRequiredAsyncIteratorPrototype) return asyncIteratorPrototype;
	hasRequiredAsyncIteratorPrototype = 1;
	var globalThis = requireGlobalThis();
	var shared = requireSharedStore();
	var isCallable = requireIsCallable();
	var create = requireObjectCreate();
	var getPrototypeOf = requireObjectGetPrototypeOf();
	var defineBuiltIn = requireDefineBuiltIn();
	var wellKnownSymbol = requireWellKnownSymbol();
	var IS_PURE = requireIsPure();
	var USE_FUNCTION_CONSTRUCTOR = 'USE_FUNCTION_CONSTRUCTOR';
	var ASYNC_ITERATOR = wellKnownSymbol('asyncIterator');
	var AsyncIterator = globalThis.AsyncIterator;
	var PassedAsyncIteratorPrototype = shared.AsyncIteratorPrototype;
	var AsyncIteratorPrototype, prototype;
	if (PassedAsyncIteratorPrototype) {
	  AsyncIteratorPrototype = PassedAsyncIteratorPrototype;
	} else if (isCallable(AsyncIterator)) {
	  AsyncIteratorPrototype = AsyncIterator.prototype;
	} else if (shared[USE_FUNCTION_CONSTRUCTOR] || globalThis[USE_FUNCTION_CONSTRUCTOR]) {
	  try {
	    prototype = getPrototypeOf(getPrototypeOf(getPrototypeOf(Function('return async function*(){}()')())));
	    if (getPrototypeOf(prototype) === Object.prototype) AsyncIteratorPrototype = prototype;
	  } catch (error) {  }
	}
	if (!AsyncIteratorPrototype) AsyncIteratorPrototype = {};
	else if (IS_PURE) AsyncIteratorPrototype = create(AsyncIteratorPrototype);
	if (!isCallable(AsyncIteratorPrototype[ASYNC_ITERATOR])) {
	  defineBuiltIn(AsyncIteratorPrototype, ASYNC_ITERATOR, function () {
	    return this;
	  });
	}
	asyncIteratorPrototype = AsyncIteratorPrototype;
	return asyncIteratorPrototype;
}

var hasRequiredEsnext_asyncIterator_constructor;

function requireEsnext_asyncIterator_constructor () {
	if (hasRequiredEsnext_asyncIterator_constructor) return esnext_asyncIterator_constructor;
	hasRequiredEsnext_asyncIterator_constructor = 1;
	var $ = require_export();
	var anInstance = requireAnInstance();
	var getPrototypeOf = requireObjectGetPrototypeOf();
	var createNonEnumerableProperty = requireCreateNonEnumerableProperty();
	var hasOwn = requireHasOwnProperty();
	var wellKnownSymbol = requireWellKnownSymbol();
	var AsyncIteratorPrototype = requireAsyncIteratorPrototype();
	var IS_PURE = requireIsPure();
	var TO_STRING_TAG = wellKnownSymbol('toStringTag');
	var $TypeError = TypeError;
	var AsyncIteratorConstructor = function AsyncIterator() {
	  anInstance(this, AsyncIteratorPrototype);
	  if (getPrototypeOf(this) === AsyncIteratorPrototype) throw new $TypeError('Abstract class AsyncIterator not directly constructable');
	};
	AsyncIteratorConstructor.prototype = AsyncIteratorPrototype;
	if (!hasOwn(AsyncIteratorPrototype, TO_STRING_TAG)) {
	  createNonEnumerableProperty(AsyncIteratorPrototype, TO_STRING_TAG, 'AsyncIterator');
	}
	if (IS_PURE || !hasOwn(AsyncIteratorPrototype, 'constructor') || AsyncIteratorPrototype.constructor === Object) {
	  createNonEnumerableProperty(AsyncIteratorPrototype, 'constructor', AsyncIteratorConstructor);
	}
	$({ global: true, constructor: true, forced: IS_PURE }, {
	  AsyncIterator: AsyncIteratorConstructor
	});
	return esnext_asyncIterator_constructor;
}

var esnext_asyncIterator_drop = {};

var getIteratorDirect;
var hasRequiredGetIteratorDirect;

function requireGetIteratorDirect () {
	if (hasRequiredGetIteratorDirect) return getIteratorDirect;
	hasRequiredGetIteratorDirect = 1;
	getIteratorDirect = function (obj) {
	  return {
	    iterator: obj,
	    next: obj.next,
	    done: false
	  };
	};
	return getIteratorDirect;
}

var notANan;
var hasRequiredNotANan;

function requireNotANan () {
	if (hasRequiredNotANan) return notANan;
	hasRequiredNotANan = 1;
	var $RangeError = RangeError;
	notANan = function (it) {
	  if (it === it) return it;
	  throw new $RangeError('NaN is not allowed');
	};
	return notANan;
}

var toPositiveInteger;
var hasRequiredToPositiveInteger;

function requireToPositiveInteger () {
	if (hasRequiredToPositiveInteger) return toPositiveInteger;
	hasRequiredToPositiveInteger = 1;
	var toIntegerOrInfinity = requireToIntegerOrInfinity();
	var $RangeError = RangeError;
	toPositiveInteger = function (it) {
	  var result = toIntegerOrInfinity(it);
	  if (result < 0) throw new $RangeError("The argument can't be less than 0");
	  return result;
	};
	return toPositiveInteger;
}

var perform;
var hasRequiredPerform;

function requirePerform () {
	if (hasRequiredPerform) return perform;
	hasRequiredPerform = 1;
	perform = function (exec) {
	  try {
	    return { error: false, value: exec() };
	  } catch (error) {
	    return { error: true, value: error };
	  }
	};
	return perform;
}

var defineBuiltIns;
var hasRequiredDefineBuiltIns;

function requireDefineBuiltIns () {
	if (hasRequiredDefineBuiltIns) return defineBuiltIns;
	hasRequiredDefineBuiltIns = 1;
	var defineBuiltIn = requireDefineBuiltIn();
	defineBuiltIns = function (target, src, options) {
	  for (var key in src) defineBuiltIn(target, key, src[key], options);
	  return target;
	};
	return defineBuiltIns;
}

var createIterResultObject;
var hasRequiredCreateIterResultObject;

function requireCreateIterResultObject () {
	if (hasRequiredCreateIterResultObject) return createIterResultObject;
	hasRequiredCreateIterResultObject = 1;
	createIterResultObject = function (value, done) {
	  return { value: value, done: done };
	};
	return createIterResultObject;
}

var iteratorClose;
var hasRequiredIteratorClose;

function requireIteratorClose () {
	if (hasRequiredIteratorClose) return iteratorClose;
	hasRequiredIteratorClose = 1;
	var call = requireFunctionCall();
	var anObject = requireAnObject();
	var getMethod = requireGetMethod();
	iteratorClose = function (iterator, kind, value) {
	  var innerResult, innerError;
	  anObject(iterator);
	  try {
	    innerResult = getMethod(iterator, 'return');
	    if (!innerResult) {
	      if (kind === 'throw') throw value;
	      return value;
	    }
	    innerResult = call(innerResult, iterator);
	  } catch (error) {
	    innerError = true;
	    innerResult = error;
	  }
	  if (kind === 'throw') throw value;
	  if (innerError) throw innerResult;
	  anObject(innerResult);
	  return value;
	};
	return iteratorClose;
}

var asyncIteratorCreateProxy;
var hasRequiredAsyncIteratorCreateProxy;

function requireAsyncIteratorCreateProxy () {
	if (hasRequiredAsyncIteratorCreateProxy) return asyncIteratorCreateProxy;
	hasRequiredAsyncIteratorCreateProxy = 1;
	var call = requireFunctionCall();
	var perform = requirePerform();
	var anObject = requireAnObject();
	var create = requireObjectCreate();
	var createNonEnumerableProperty = requireCreateNonEnumerableProperty();
	var defineBuiltIns = requireDefineBuiltIns();
	var wellKnownSymbol = requireWellKnownSymbol();
	var InternalStateModule = requireInternalState();
	var getBuiltIn = requireGetBuiltIn();
	var getMethod = requireGetMethod();
	var AsyncIteratorPrototype = requireAsyncIteratorPrototype();
	var createIterResultObject = requireCreateIterResultObject();
	var iteratorClose = requireIteratorClose();
	var Promise = getBuiltIn('Promise');
	var TO_STRING_TAG = wellKnownSymbol('toStringTag');
	var ASYNC_ITERATOR_HELPER = 'AsyncIteratorHelper';
	var WRAP_FOR_VALID_ASYNC_ITERATOR = 'WrapForValidAsyncIterator';
	var setInternalState = InternalStateModule.set;
	var createAsyncIteratorProxyPrototype = function (IS_ITERATOR) {
	  var IS_GENERATOR = !IS_ITERATOR;
	  var getInternalState = InternalStateModule.getterFor(IS_ITERATOR ? WRAP_FOR_VALID_ASYNC_ITERATOR : ASYNC_ITERATOR_HELPER);
	  var getStateOrEarlyExit = function (that) {
	    var stateCompletion = perform(function () {
	      return getInternalState(that);
	    });
	    var stateError = stateCompletion.error;
	    var state = stateCompletion.value;
	    if (stateError || (IS_GENERATOR && state.done)) {
	      return { exit: true, value: stateError ? Promise.reject(state) : Promise.resolve(createIterResultObject(undefined, true)) };
	    } return { exit: false, value: state };
	  };
	  return defineBuiltIns(create(AsyncIteratorPrototype), {
	    next: function next() {
	      var stateCompletion = getStateOrEarlyExit(this);
	      var state = stateCompletion.value;
	      if (stateCompletion.exit) return state;
	      var handlerCompletion = perform(function () {
	        return anObject(state.nextHandler(Promise));
	      });
	      var handlerError = handlerCompletion.error;
	      var value = handlerCompletion.value;
	      if (handlerError) state.done = true;
	      return handlerError ? Promise.reject(value) : Promise.resolve(value);
	    },
	    'return': function () {
	      var stateCompletion = getStateOrEarlyExit(this);
	      var state = stateCompletion.value;
	      if (stateCompletion.exit) return state;
	      state.done = true;
	      var iterator = state.iterator;
	      var returnMethod, result;
	      var completion = perform(function () {
	        if (state.inner) try {
	          iteratorClose(state.inner.iterator, 'normal');
	        } catch (error) {
	          return iteratorClose(iterator, 'throw', error);
	        }
	        return getMethod(iterator, 'return');
	      });
	      returnMethod = result = completion.value;
	      if (completion.error) return Promise.reject(result);
	      if (returnMethod === undefined) return Promise.resolve(createIterResultObject(undefined, true));
	      completion = perform(function () {
	        return call(returnMethod, iterator);
	      });
	      result = completion.value;
	      if (completion.error) return Promise.reject(result);
	      return IS_ITERATOR ? Promise.resolve(result) : Promise.resolve(result).then(function (resolved) {
	        anObject(resolved);
	        return createIterResultObject(undefined, true);
	      });
	    }
	  });
	};
	var WrapForValidAsyncIteratorPrototype = createAsyncIteratorProxyPrototype(true);
	var AsyncIteratorHelperPrototype = createAsyncIteratorProxyPrototype(false);
	createNonEnumerableProperty(AsyncIteratorHelperPrototype, TO_STRING_TAG, 'Async Iterator Helper');
	asyncIteratorCreateProxy = function (nextHandler, IS_ITERATOR) {
	  var AsyncIteratorProxy = function AsyncIterator(record, state) {
	    if (state) {
	      state.iterator = record.iterator;
	      state.next = record.next;
	    } else state = record;
	    state.type = IS_ITERATOR ? WRAP_FOR_VALID_ASYNC_ITERATOR : ASYNC_ITERATOR_HELPER;
	    state.nextHandler = nextHandler;
	    state.counter = 0;
	    state.done = false;
	    setInternalState(this, state);
	  };
	  AsyncIteratorProxy.prototype = IS_ITERATOR ? WrapForValidAsyncIteratorPrototype : AsyncIteratorHelperPrototype;
	  return AsyncIteratorProxy;
	};
	return asyncIteratorCreateProxy;
}

var hasRequiredEsnext_asyncIterator_drop;

function requireEsnext_asyncIterator_drop () {
	if (hasRequiredEsnext_asyncIterator_drop) return esnext_asyncIterator_drop;
	hasRequiredEsnext_asyncIterator_drop = 1;
	var $ = require_export();
	var call = requireFunctionCall();
	var anObject = requireAnObject();
	var getIteratorDirect = requireGetIteratorDirect();
	var notANaN = requireNotANan();
	var toPositiveInteger = requireToPositiveInteger();
	var createAsyncIteratorProxy = requireAsyncIteratorCreateProxy();
	var createIterResultObject = requireCreateIterResultObject();
	var AsyncIteratorProxy = createAsyncIteratorProxy(function (Promise) {
	  var state = this;
	  return new Promise(function (resolve, reject) {
	    var doneAndReject = function (error) {
	      state.done = true;
	      reject(error);
	    };
	    var loop = function () {
	      try {
	        Promise.resolve(anObject(call(state.next, state.iterator))).then(function (step) {
	          try {
	            if (anObject(step).done) {
	              state.done = true;
	              resolve(createIterResultObject(undefined, true));
	            } else if (state.remaining) {
	              state.remaining--;
	              loop();
	            } else resolve(createIterResultObject(step.value, false));
	          } catch (err) { doneAndReject(err); }
	        }, doneAndReject);
	      } catch (error) { doneAndReject(error); }
	    };
	    loop();
	  });
	});
	$({ target: 'AsyncIterator', proto: true, real: true, forced: true }, {
	  drop: function drop(limit) {
	    anObject(this);
	    var remaining = toPositiveInteger(notANaN(+limit));
	    return new AsyncIteratorProxy(getIteratorDirect(this), {
	      remaining: remaining
	    });
	  }
	});
	return esnext_asyncIterator_drop;
}

var esnext_asyncIterator_every = {};

var doesNotExceedSafeInteger;
var hasRequiredDoesNotExceedSafeInteger;

function requireDoesNotExceedSafeInteger () {
	if (hasRequiredDoesNotExceedSafeInteger) return doesNotExceedSafeInteger;
	hasRequiredDoesNotExceedSafeInteger = 1;
	var $TypeError = TypeError;
	var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;
	doesNotExceedSafeInteger = function (it) {
	  if (it > MAX_SAFE_INTEGER) throw $TypeError('Maximum allowed index exceeded');
	  return it;
	};
	return doesNotExceedSafeInteger;
}

var asyncIteratorClose;
var hasRequiredAsyncIteratorClose;

function requireAsyncIteratorClose () {
	if (hasRequiredAsyncIteratorClose) return asyncIteratorClose;
	hasRequiredAsyncIteratorClose = 1;
	var call = requireFunctionCall();
	var getBuiltIn = requireGetBuiltIn();
	var getMethod = requireGetMethod();
	asyncIteratorClose = function (iterator, method, argument, reject) {
	  try {
	    var returnMethod = getMethod(iterator, 'return');
	    if (returnMethod) {
	      return getBuiltIn('Promise').resolve(call(returnMethod, iterator)).then(function () {
	        method(argument);
	      }, function (error) {
	        reject(error);
	      });
	    }
	  } catch (error2) {
	    return reject(error2);
	  } method(argument);
	};
	return asyncIteratorClose;
}

var asyncIteratorIteration;
var hasRequiredAsyncIteratorIteration;

function requireAsyncIteratorIteration () {
	if (hasRequiredAsyncIteratorIteration) return asyncIteratorIteration;
	hasRequiredAsyncIteratorIteration = 1;
	var call = requireFunctionCall();
	var aCallable = requireACallable();
	var anObject = requireAnObject();
	var isObject = requireIsObject();
	var doesNotExceedSafeInteger = requireDoesNotExceedSafeInteger();
	var getBuiltIn = requireGetBuiltIn();
	var getIteratorDirect = requireGetIteratorDirect();
	var closeAsyncIteration = requireAsyncIteratorClose();
	var createMethod = function (TYPE) {
	  var IS_TO_ARRAY = TYPE === 0;
	  var IS_FOR_EACH = TYPE === 1;
	  var IS_EVERY = TYPE === 2;
	  var IS_SOME = TYPE === 3;
	  return function (object, fn, target) {
	    anObject(object);
	    var MAPPING = fn !== undefined;
	    if (MAPPING || !IS_TO_ARRAY) aCallable(fn);
	    var record = getIteratorDirect(object);
	    var Promise = getBuiltIn('Promise');
	    var iterator = record.iterator;
	    var next = record.next;
	    var counter = 0;
	    return new Promise(function (resolve, reject) {
	      var ifAbruptCloseAsyncIterator = function (error) {
	        closeAsyncIteration(iterator, reject, error, reject);
	      };
	      var loop = function () {
	        try {
	          if (MAPPING) try {
	            doesNotExceedSafeInteger(counter);
	          } catch (error5) { ifAbruptCloseAsyncIterator(error5); }
	          Promise.resolve(anObject(call(next, iterator))).then(function (step) {
	            try {
	              if (anObject(step).done) {
	                if (IS_TO_ARRAY) {
	                  target.length = counter;
	                  resolve(target);
	                } else resolve(IS_SOME ? false : IS_EVERY || undefined);
	              } else {
	                var value = step.value;
	                try {
	                  if (MAPPING) {
	                    var result = fn(value, counter);
	                    var handler = function ($result) {
	                      if (IS_FOR_EACH) {
	                        loop();
	                      } else if (IS_EVERY) {
	                        $result ? loop() : closeAsyncIteration(iterator, resolve, false, reject);
	                      } else if (IS_TO_ARRAY) {
	                        try {
	                          target[counter++] = $result;
	                          loop();
	                        } catch (error4) { ifAbruptCloseAsyncIterator(error4); }
	                      } else {
	                        $result ? closeAsyncIteration(iterator, resolve, IS_SOME || value, reject) : loop();
	                      }
	                    };
	                    if (isObject(result)) Promise.resolve(result).then(handler, ifAbruptCloseAsyncIterator);
	                    else handler(result);
	                  } else {
	                    target[counter++] = value;
	                    loop();
	                  }
	                } catch (error3) { ifAbruptCloseAsyncIterator(error3); }
	              }
	            } catch (error2) { reject(error2); }
	          }, reject);
	        } catch (error) { reject(error); }
	      };
	      loop();
	    });
	  };
	};
	asyncIteratorIteration = {
	  toArray: createMethod(0),
	  forEach: createMethod(1),
	  every: createMethod(2),
	  some: createMethod(3),
	  find: createMethod(4)
	};
	return asyncIteratorIteration;
}

var hasRequiredEsnext_asyncIterator_every;

function requireEsnext_asyncIterator_every () {
	if (hasRequiredEsnext_asyncIterator_every) return esnext_asyncIterator_every;
	hasRequiredEsnext_asyncIterator_every = 1;
	var $ = require_export();
	var $every = requireAsyncIteratorIteration().every;
	$({ target: 'AsyncIterator', proto: true, real: true, forced: true }, {
	  every: function every(predicate) {
	    return $every(this, predicate);
	  }
	});
	return esnext_asyncIterator_every;
}

var esnext_asyncIterator_filter = {};

var hasRequiredEsnext_asyncIterator_filter;

function requireEsnext_asyncIterator_filter () {
	if (hasRequiredEsnext_asyncIterator_filter) return esnext_asyncIterator_filter;
	hasRequiredEsnext_asyncIterator_filter = 1;
	var $ = require_export();
	var call = requireFunctionCall();
	var aCallable = requireACallable();
	var anObject = requireAnObject();
	var isObject = requireIsObject();
	var getIteratorDirect = requireGetIteratorDirect();
	var createAsyncIteratorProxy = requireAsyncIteratorCreateProxy();
	var createIterResultObject = requireCreateIterResultObject();
	var closeAsyncIteration = requireAsyncIteratorClose();
	var AsyncIteratorProxy = createAsyncIteratorProxy(function (Promise) {
	  var state = this;
	  var iterator = state.iterator;
	  var predicate = state.predicate;
	  return new Promise(function (resolve, reject) {
	    var doneAndReject = function (error) {
	      state.done = true;
	      reject(error);
	    };
	    var ifAbruptCloseAsyncIterator = function (error) {
	      closeAsyncIteration(iterator, doneAndReject, error, doneAndReject);
	    };
	    var loop = function () {
	      try {
	        Promise.resolve(anObject(call(state.next, iterator))).then(function (step) {
	          try {
	            if (anObject(step).done) {
	              state.done = true;
	              resolve(createIterResultObject(undefined, true));
	            } else {
	              var value = step.value;
	              try {
	                var result = predicate(value, state.counter++);
	                var handler = function (selected) {
	                  selected ? resolve(createIterResultObject(value, false)) : loop();
	                };
	                if (isObject(result)) Promise.resolve(result).then(handler, ifAbruptCloseAsyncIterator);
	                else handler(result);
	              } catch (error3) { ifAbruptCloseAsyncIterator(error3); }
	            }
	          } catch (error2) { doneAndReject(error2); }
	        }, doneAndReject);
	      } catch (error) { doneAndReject(error); }
	    };
	    loop();
	  });
	});
	$({ target: 'AsyncIterator', proto: true, real: true, forced: true }, {
	  filter: function filter(predicate) {
	    anObject(this);
	    aCallable(predicate);
	    return new AsyncIteratorProxy(getIteratorDirect(this), {
	      predicate: predicate
	    });
	  }
	});
	return esnext_asyncIterator_filter;
}

var esnext_asyncIterator_find = {};

var hasRequiredEsnext_asyncIterator_find;

function requireEsnext_asyncIterator_find () {
	if (hasRequiredEsnext_asyncIterator_find) return esnext_asyncIterator_find;
	hasRequiredEsnext_asyncIterator_find = 1;
	var $ = require_export();
	var $find = requireAsyncIteratorIteration().find;
	$({ target: 'AsyncIterator', proto: true, real: true, forced: true }, {
	  find: function find(predicate) {
	    return $find(this, predicate);
	  }
	});
	return esnext_asyncIterator_find;
}

var esnext_asyncIterator_flatMap = {};

var toStringTagSupport;
var hasRequiredToStringTagSupport;

function requireToStringTagSupport () {
	if (hasRequiredToStringTagSupport) return toStringTagSupport;
	hasRequiredToStringTagSupport = 1;
	var wellKnownSymbol = requireWellKnownSymbol();
	var TO_STRING_TAG = wellKnownSymbol('toStringTag');
	var test = {};
	test[TO_STRING_TAG] = 'z';
	toStringTagSupport = String(test) === '[object z]';
	return toStringTagSupport;
}

var classof;
var hasRequiredClassof;

function requireClassof () {
	if (hasRequiredClassof) return classof;
	hasRequiredClassof = 1;
	var TO_STRING_TAG_SUPPORT = requireToStringTagSupport();
	var isCallable = requireIsCallable();
	var classofRaw = requireClassofRaw();
	var wellKnownSymbol = requireWellKnownSymbol();
	var TO_STRING_TAG = wellKnownSymbol('toStringTag');
	var $Object = Object;
	var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) === 'Arguments';
	var tryGet = function (it, key) {
	  try {
	    return it[key];
	  } catch (error) {  }
	};
	classof = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {
	  var O, tag, result;
	  return it === undefined ? 'Undefined' : it === null ? 'Null'
	    : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == 'string' ? tag
	    : CORRECT_ARGUMENTS ? classofRaw(O)
	    : (result = classofRaw(O)) === 'Object' && isCallable(O.callee) ? 'Arguments' : result;
	};
	return classof;
}

var iterators;
var hasRequiredIterators;

function requireIterators () {
	if (hasRequiredIterators) return iterators;
	hasRequiredIterators = 1;
	iterators = {};
	return iterators;
}

var getIteratorMethod;
var hasRequiredGetIteratorMethod;

function requireGetIteratorMethod () {
	if (hasRequiredGetIteratorMethod) return getIteratorMethod;
	hasRequiredGetIteratorMethod = 1;
	var classof = requireClassof();
	var getMethod = requireGetMethod();
	var isNullOrUndefined = requireIsNullOrUndefined();
	var Iterators = requireIterators();
	var wellKnownSymbol = requireWellKnownSymbol();
	var ITERATOR = wellKnownSymbol('iterator');
	getIteratorMethod = function (it) {
	  if (!isNullOrUndefined(it)) return getMethod(it, ITERATOR)
	    || getMethod(it, '@@iterator')
	    || Iterators[classof(it)];
	};
	return getIteratorMethod;
}

var asyncFromSyncIterator;
var hasRequiredAsyncFromSyncIterator;

function requireAsyncFromSyncIterator () {
	if (hasRequiredAsyncFromSyncIterator) return asyncFromSyncIterator;
	hasRequiredAsyncFromSyncIterator = 1;
	var call = requireFunctionCall();
	var anObject = requireAnObject();
	var create = requireObjectCreate();
	var getMethod = requireGetMethod();
	var defineBuiltIns = requireDefineBuiltIns();
	var InternalStateModule = requireInternalState();
	var iteratorClose = requireIteratorClose();
	var getBuiltIn = requireGetBuiltIn();
	var AsyncIteratorPrototype = requireAsyncIteratorPrototype();
	var createIterResultObject = requireCreateIterResultObject();
	var Promise = getBuiltIn('Promise');
	var ASYNC_FROM_SYNC_ITERATOR = 'AsyncFromSyncIterator';
	var setInternalState = InternalStateModule.set;
	var getInternalState = InternalStateModule.getterFor(ASYNC_FROM_SYNC_ITERATOR);
	var asyncFromSyncIteratorContinuation = function (result, resolve, reject, syncIterator, closeOnRejection) {
	  var done = result.done;
	  Promise.resolve(result.value).then(function (value) {
	    resolve(createIterResultObject(value, done));
	  }, function (error) {
	    if (!done && closeOnRejection) {
	      try {
	        iteratorClose(syncIterator, 'throw', error);
	      } catch (error2) {
	        error = error2;
	      }
	    }
	    reject(error);
	  });
	};
	var AsyncFromSyncIterator = function AsyncIterator(iteratorRecord) {
	  iteratorRecord.type = ASYNC_FROM_SYNC_ITERATOR;
	  setInternalState(this, iteratorRecord);
	};
	AsyncFromSyncIterator.prototype = defineBuiltIns(create(AsyncIteratorPrototype), {
	  next: function next() {
	    var state = getInternalState(this);
	    return new Promise(function (resolve, reject) {
	      var result = anObject(call(state.next, state.iterator));
	      asyncFromSyncIteratorContinuation(result, resolve, reject, state.iterator, true);
	    });
	  },
	  'return': function () {
	    var iterator = getInternalState(this).iterator;
	    return new Promise(function (resolve, reject) {
	      var $return = getMethod(iterator, 'return');
	      if ($return === undefined) return resolve(createIterResultObject(undefined, true));
	      var result = anObject(call($return, iterator));
	      asyncFromSyncIteratorContinuation(result, resolve, reject, iterator);
	    });
	  }
	});
	asyncFromSyncIterator = AsyncFromSyncIterator;
	return asyncFromSyncIterator;
}

var getAsyncIteratorFlattenable;
var hasRequiredGetAsyncIteratorFlattenable;

function requireGetAsyncIteratorFlattenable () {
	if (hasRequiredGetAsyncIteratorFlattenable) return getAsyncIteratorFlattenable;
	hasRequiredGetAsyncIteratorFlattenable = 1;
	var call = requireFunctionCall();
	var isCallable = requireIsCallable();
	var anObject = requireAnObject();
	var getIteratorDirect = requireGetIteratorDirect();
	var getIteratorMethod = requireGetIteratorMethod();
	var getMethod = requireGetMethod();
	var wellKnownSymbol = requireWellKnownSymbol();
	var AsyncFromSyncIterator = requireAsyncFromSyncIterator();
	var ASYNC_ITERATOR = wellKnownSymbol('asyncIterator');
	getAsyncIteratorFlattenable = function (obj) {
	  var object = anObject(obj);
	  var alreadyAsync = true;
	  var method = getMethod(object, ASYNC_ITERATOR);
	  var iterator;
	  if (!isCallable(method)) {
	    method = getIteratorMethod(object);
	    alreadyAsync = false;
	  }
	  if (method !== undefined) {
	    iterator = call(method, object);
	  } else {
	    iterator = object;
	    alreadyAsync = true;
	  }
	  anObject(iterator);
	  return getIteratorDirect(alreadyAsync ? iterator : new AsyncFromSyncIterator(getIteratorDirect(iterator)));
	};
	return getAsyncIteratorFlattenable;
}

var hasRequiredEsnext_asyncIterator_flatMap;

function requireEsnext_asyncIterator_flatMap () {
	if (hasRequiredEsnext_asyncIterator_flatMap) return esnext_asyncIterator_flatMap;
	hasRequiredEsnext_asyncIterator_flatMap = 1;
	var $ = require_export();
	var call = requireFunctionCall();
	var aCallable = requireACallable();
	var anObject = requireAnObject();
	var isObject = requireIsObject();
	var getIteratorDirect = requireGetIteratorDirect();
	var createAsyncIteratorProxy = requireAsyncIteratorCreateProxy();
	var createIterResultObject = requireCreateIterResultObject();
	var getAsyncIteratorFlattenable = requireGetAsyncIteratorFlattenable();
	var closeAsyncIteration = requireAsyncIteratorClose();
	var AsyncIteratorProxy = createAsyncIteratorProxy(function (Promise) {
	  var state = this;
	  var iterator = state.iterator;
	  var mapper = state.mapper;
	  return new Promise(function (resolve, reject) {
	    var doneAndReject = function (error) {
	      state.done = true;
	      reject(error);
	    };
	    var ifAbruptCloseAsyncIterator = function (error) {
	      closeAsyncIteration(iterator, doneAndReject, error, doneAndReject);
	    };
	    var outerLoop = function () {
	      try {
	        Promise.resolve(anObject(call(state.next, iterator))).then(function (step) {
	          try {
	            if (anObject(step).done) {
	              state.done = true;
	              resolve(createIterResultObject(undefined, true));
	            } else {
	              var value = step.value;
	              try {
	                var result = mapper(value, state.counter++);
	                var handler = function (mapped) {
	                  try {
	                    state.inner = getAsyncIteratorFlattenable(mapped);
	                    innerLoop();
	                  } catch (error4) { ifAbruptCloseAsyncIterator(error4); }
	                };
	                if (isObject(result)) Promise.resolve(result).then(handler, ifAbruptCloseAsyncIterator);
	                else handler(result);
	              } catch (error3) { ifAbruptCloseAsyncIterator(error3); }
	            }
	          } catch (error2) { doneAndReject(error2); }
	        }, doneAndReject);
	      } catch (error) { doneAndReject(error); }
	    };
	    var innerLoop = function () {
	      var inner = state.inner;
	      if (inner) {
	        try {
	          Promise.resolve(anObject(call(inner.next, inner.iterator))).then(function (result) {
	            try {
	              if (anObject(result).done) {
	                state.inner = null;
	                outerLoop();
	              } else resolve(createIterResultObject(result.value, false));
	            } catch (error1) { ifAbruptCloseAsyncIterator(error1); }
	          }, ifAbruptCloseAsyncIterator);
	        } catch (error) { ifAbruptCloseAsyncIterator(error); }
	      } else outerLoop();
	    };
	    innerLoop();
	  });
	});
	$({ target: 'AsyncIterator', proto: true, real: true, forced: true }, {
	  flatMap: function flatMap(mapper) {
	    anObject(this);
	    aCallable(mapper);
	    return new AsyncIteratorProxy(getIteratorDirect(this), {
	      mapper: mapper,
	      inner: null
	    });
	  }
	});
	return esnext_asyncIterator_flatMap;
}

var esnext_asyncIterator_forEach = {};

var hasRequiredEsnext_asyncIterator_forEach;

function requireEsnext_asyncIterator_forEach () {
	if (hasRequiredEsnext_asyncIterator_forEach) return esnext_asyncIterator_forEach;
	hasRequiredEsnext_asyncIterator_forEach = 1;
	var $ = require_export();
	var $forEach = requireAsyncIteratorIteration().forEach;
	$({ target: 'AsyncIterator', proto: true, real: true, forced: true }, {
	  forEach: function forEach(fn) {
	    return $forEach(this, fn);
	  }
	});
	return esnext_asyncIterator_forEach;
}

var esnext_asyncIterator_from = {};

var asyncIteratorWrap;
var hasRequiredAsyncIteratorWrap;

function requireAsyncIteratorWrap () {
	if (hasRequiredAsyncIteratorWrap) return asyncIteratorWrap;
	hasRequiredAsyncIteratorWrap = 1;
	var call = requireFunctionCall();
	var createAsyncIteratorProxy = requireAsyncIteratorCreateProxy();
	asyncIteratorWrap = createAsyncIteratorProxy(function () {
	  return call(this.next, this.iterator);
	}, true);
	return asyncIteratorWrap;
}

var hasRequiredEsnext_asyncIterator_from;

function requireEsnext_asyncIterator_from () {
	if (hasRequiredEsnext_asyncIterator_from) return esnext_asyncIterator_from;
	hasRequiredEsnext_asyncIterator_from = 1;
	var $ = require_export();
	var toObject = requireToObject();
	var isPrototypeOf = requireObjectIsPrototypeOf();
	var getAsyncIteratorFlattenable = requireGetAsyncIteratorFlattenable();
	var AsyncIteratorPrototype = requireAsyncIteratorPrototype();
	var WrapAsyncIterator = requireAsyncIteratorWrap();
	$({ target: 'AsyncIterator', stat: true, forced: true }, {
	  from: function from(O) {
	    var iteratorRecord = getAsyncIteratorFlattenable(typeof O == 'string' ? toObject(O) : O);
	    return isPrototypeOf(AsyncIteratorPrototype, iteratorRecord.iterator)
	      ? iteratorRecord.iterator
	      : new WrapAsyncIterator(iteratorRecord);
	  }
	});
	return esnext_asyncIterator_from;
}

var esnext_asyncIterator_map = {};

var asyncIteratorMap;
var hasRequiredAsyncIteratorMap;

function requireAsyncIteratorMap () {
	if (hasRequiredAsyncIteratorMap) return asyncIteratorMap;
	hasRequiredAsyncIteratorMap = 1;
	var call = requireFunctionCall();
	var aCallable = requireACallable();
	var anObject = requireAnObject();
	var isObject = requireIsObject();
	var getIteratorDirect = requireGetIteratorDirect();
	var createAsyncIteratorProxy = requireAsyncIteratorCreateProxy();
	var createIterResultObject = requireCreateIterResultObject();
	var closeAsyncIteration = requireAsyncIteratorClose();
	var AsyncIteratorProxy = createAsyncIteratorProxy(function (Promise) {
	  var state = this;
	  var iterator = state.iterator;
	  var mapper = state.mapper;
	  return new Promise(function (resolve, reject) {
	    var doneAndReject = function (error) {
	      state.done = true;
	      reject(error);
	    };
	    var ifAbruptCloseAsyncIterator = function (error) {
	      closeAsyncIteration(iterator, doneAndReject, error, doneAndReject);
	    };
	    Promise.resolve(anObject(call(state.next, iterator))).then(function (step) {
	      try {
	        if (anObject(step).done) {
	          state.done = true;
	          resolve(createIterResultObject(undefined, true));
	        } else {
	          var value = step.value;
	          try {
	            var result = mapper(value, state.counter++);
	            var handler = function (mapped) {
	              resolve(createIterResultObject(mapped, false));
	            };
	            if (isObject(result)) Promise.resolve(result).then(handler, ifAbruptCloseAsyncIterator);
	            else handler(result);
	          } catch (error2) { ifAbruptCloseAsyncIterator(error2); }
	        }
	      } catch (error) { doneAndReject(error); }
	    }, doneAndReject);
	  });
	});
	asyncIteratorMap = function map(mapper) {
	  anObject(this);
	  aCallable(mapper);
	  return new AsyncIteratorProxy(getIteratorDirect(this), {
	    mapper: mapper
	  });
	};
	return asyncIteratorMap;
}

var hasRequiredEsnext_asyncIterator_map;

function requireEsnext_asyncIterator_map () {
	if (hasRequiredEsnext_asyncIterator_map) return esnext_asyncIterator_map;
	hasRequiredEsnext_asyncIterator_map = 1;
	var $ = require_export();
	var map = requireAsyncIteratorMap();
	$({ target: 'AsyncIterator', proto: true, real: true, forced: true }, {
	  map: map
	});
	return esnext_asyncIterator_map;
}

var esnext_asyncIterator_reduce = {};

var hasRequiredEsnext_asyncIterator_reduce;

function requireEsnext_asyncIterator_reduce () {
	if (hasRequiredEsnext_asyncIterator_reduce) return esnext_asyncIterator_reduce;
	hasRequiredEsnext_asyncIterator_reduce = 1;
	var $ = require_export();
	var call = requireFunctionCall();
	var aCallable = requireACallable();
	var anObject = requireAnObject();
	var isObject = requireIsObject();
	var getBuiltIn = requireGetBuiltIn();
	var getIteratorDirect = requireGetIteratorDirect();
	var closeAsyncIteration = requireAsyncIteratorClose();
	var Promise = getBuiltIn('Promise');
	var $TypeError = TypeError;
	$({ target: 'AsyncIterator', proto: true, real: true, forced: true }, {
	  reduce: function reduce(reducer ) {
	    anObject(this);
	    aCallable(reducer);
	    var record = getIteratorDirect(this);
	    var iterator = record.iterator;
	    var next = record.next;
	    var noInitial = arguments.length < 2;
	    var accumulator = noInitial ? undefined : arguments[1];
	    var counter = 0;
	    return new Promise(function (resolve, reject) {
	      var ifAbruptCloseAsyncIterator = function (error) {
	        closeAsyncIteration(iterator, reject, error, reject);
	      };
	      var loop = function () {
	        try {
	          Promise.resolve(anObject(call(next, iterator))).then(function (step) {
	            try {
	              if (anObject(step).done) {
	                noInitial ? reject(new $TypeError('Reduce of empty iterator with no initial value')) : resolve(accumulator);
	              } else {
	                var value = step.value;
	                if (noInitial) {
	                  noInitial = false;
	                  accumulator = value;
	                  loop();
	                } else try {
	                  var result = reducer(accumulator, value, counter);
	                  var handler = function ($result) {
	                    accumulator = $result;
	                    loop();
	                  };
	                  if (isObject(result)) Promise.resolve(result).then(handler, ifAbruptCloseAsyncIterator);
	                  else handler(result);
	                } catch (error3) { ifAbruptCloseAsyncIterator(error3); }
	              }
	              counter++;
	            } catch (error2) { reject(error2); }
	          }, reject);
	        } catch (error) { reject(error); }
	      };
	      loop();
	    });
	  }
	});
	return esnext_asyncIterator_reduce;
}

var esnext_asyncIterator_some = {};

var hasRequiredEsnext_asyncIterator_some;

function requireEsnext_asyncIterator_some () {
	if (hasRequiredEsnext_asyncIterator_some) return esnext_asyncIterator_some;
	hasRequiredEsnext_asyncIterator_some = 1;
	var $ = require_export();
	var $some = requireAsyncIteratorIteration().some;
	$({ target: 'AsyncIterator', proto: true, real: true, forced: true }, {
	  some: function some(predicate) {
	    return $some(this, predicate);
	  }
	});
	return esnext_asyncIterator_some;
}

var esnext_asyncIterator_take = {};

var hasRequiredEsnext_asyncIterator_take;

function requireEsnext_asyncIterator_take () {
	if (hasRequiredEsnext_asyncIterator_take) return esnext_asyncIterator_take;
	hasRequiredEsnext_asyncIterator_take = 1;
	var $ = require_export();
	var call = requireFunctionCall();
	var anObject = requireAnObject();
	var getIteratorDirect = requireGetIteratorDirect();
	var notANaN = requireNotANan();
	var toPositiveInteger = requireToPositiveInteger();
	var createAsyncIteratorProxy = requireAsyncIteratorCreateProxy();
	var createIterResultObject = requireCreateIterResultObject();
	var AsyncIteratorProxy = createAsyncIteratorProxy(function (Promise) {
	  var state = this;
	  var iterator = state.iterator;
	  var returnMethod;
	  if (!state.remaining--) {
	    var resultDone = createIterResultObject(undefined, true);
	    state.done = true;
	    returnMethod = iterator['return'];
	    if (returnMethod !== undefined) {
	      return Promise.resolve(call(returnMethod, iterator, undefined)).then(function () {
	        return resultDone;
	      });
	    }
	    return resultDone;
	  } return Promise.resolve(call(state.next, iterator)).then(function (step) {
	    if (anObject(step).done) {
	      state.done = true;
	      return createIterResultObject(undefined, true);
	    } return createIterResultObject(step.value, false);
	  }).then(null, function (error) {
	    state.done = true;
	    throw error;
	  });
	});
	$({ target: 'AsyncIterator', proto: true, real: true, forced: true }, {
	  take: function take(limit) {
	    anObject(this);
	    var remaining = toPositiveInteger(notANaN(+limit));
	    return new AsyncIteratorProxy(getIteratorDirect(this), {
	      remaining: remaining
	    });
	  }
	});
	return esnext_asyncIterator_take;
}

var esnext_asyncIterator_toArray = {};

var hasRequiredEsnext_asyncIterator_toArray;

function requireEsnext_asyncIterator_toArray () {
	if (hasRequiredEsnext_asyncIterator_toArray) return esnext_asyncIterator_toArray;
	hasRequiredEsnext_asyncIterator_toArray = 1;
	var $ = require_export();
	var $toArray = requireAsyncIteratorIteration().toArray;
	$({ target: 'AsyncIterator', proto: true, real: true, forced: true }, {
	  toArray: function toArray() {
	    return $toArray(this, undefined, []);
	  }
	});
	return esnext_asyncIterator_toArray;
}

var esnext_iterator_constructor = {};

var es_iterator_constructor = {};

var defineBuiltInAccessor;
var hasRequiredDefineBuiltInAccessor;

function requireDefineBuiltInAccessor () {
	if (hasRequiredDefineBuiltInAccessor) return defineBuiltInAccessor;
	hasRequiredDefineBuiltInAccessor = 1;
	var makeBuiltIn = requireMakeBuiltIn();
	var defineProperty = requireObjectDefineProperty();
	defineBuiltInAccessor = function (target, name, descriptor) {
	  if (descriptor.get) makeBuiltIn(descriptor.get, name, { getter: true });
	  if (descriptor.set) makeBuiltIn(descriptor.set, name, { setter: true });
	  return defineProperty.f(target, name, descriptor);
	};
	return defineBuiltInAccessor;
}

var createProperty;
var hasRequiredCreateProperty;

function requireCreateProperty () {
	if (hasRequiredCreateProperty) return createProperty;
	hasRequiredCreateProperty = 1;
	var DESCRIPTORS = requireDescriptors();
	var definePropertyModule = requireObjectDefineProperty();
	var createPropertyDescriptor = requireCreatePropertyDescriptor();
	createProperty = function (object, key, value) {
	  if (DESCRIPTORS) definePropertyModule.f(object, key, createPropertyDescriptor(0, value));
	  else object[key] = value;
	};
	return createProperty;
}

var iteratorsCore;
var hasRequiredIteratorsCore;

function requireIteratorsCore () {
	if (hasRequiredIteratorsCore) return iteratorsCore;
	hasRequiredIteratorsCore = 1;
	var fails = requireFails();
	var isCallable = requireIsCallable();
	var isObject = requireIsObject();
	var create = requireObjectCreate();
	var getPrototypeOf = requireObjectGetPrototypeOf();
	var defineBuiltIn = requireDefineBuiltIn();
	var wellKnownSymbol = requireWellKnownSymbol();
	var IS_PURE = requireIsPure();
	var ITERATOR = wellKnownSymbol('iterator');
	var BUGGY_SAFARI_ITERATORS = false;
	var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;
	if ([].keys) {
	  arrayIterator = [].keys();
	  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
	  else {
	    PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
	    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
	  }
	}
	var NEW_ITERATOR_PROTOTYPE = !isObject(IteratorPrototype) || fails(function () {
	  var test = {};
	  return IteratorPrototype[ITERATOR].call(test) !== test;
	});
	if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {};
	else if (IS_PURE) IteratorPrototype = create(IteratorPrototype);
	if (!isCallable(IteratorPrototype[ITERATOR])) {
	  defineBuiltIn(IteratorPrototype, ITERATOR, function () {
	    return this;
	  });
	}
	iteratorsCore = {
	  IteratorPrototype: IteratorPrototype,
	  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
	};
	return iteratorsCore;
}

var hasRequiredEs_iterator_constructor;

function requireEs_iterator_constructor () {
	if (hasRequiredEs_iterator_constructor) return es_iterator_constructor;
	hasRequiredEs_iterator_constructor = 1;
	var $ = require_export();
	var globalThis = requireGlobalThis();
	var anInstance = requireAnInstance();
	var anObject = requireAnObject();
	var isCallable = requireIsCallable();
	var getPrototypeOf = requireObjectGetPrototypeOf();
	var defineBuiltInAccessor = requireDefineBuiltInAccessor();
	var createProperty = requireCreateProperty();
	var fails = requireFails();
	var hasOwn = requireHasOwnProperty();
	var wellKnownSymbol = requireWellKnownSymbol();
	var IteratorPrototype = requireIteratorsCore().IteratorPrototype;
	var DESCRIPTORS = requireDescriptors();
	var IS_PURE = requireIsPure();
	var CONSTRUCTOR = 'constructor';
	var ITERATOR = 'Iterator';
	var TO_STRING_TAG = wellKnownSymbol('toStringTag');
	var $TypeError = TypeError;
	var NativeIterator = globalThis[ITERATOR];
	var FORCED = IS_PURE
	  || !isCallable(NativeIterator)
	  || NativeIterator.prototype !== IteratorPrototype
	  || !fails(function () { NativeIterator({}); });
	var IteratorConstructor = function Iterator() {
	  anInstance(this, IteratorPrototype);
	  if (getPrototypeOf(this) === IteratorPrototype) throw new $TypeError('Abstract class Iterator not directly constructable');
	};
	var defineIteratorPrototypeAccessor = function (key, value) {
	  if (DESCRIPTORS) {
	    defineBuiltInAccessor(IteratorPrototype, key, {
	      configurable: true,
	      get: function () {
	        return value;
	      },
	      set: function (replacement) {
	        anObject(this);
	        if (this === IteratorPrototype) throw new $TypeError("You can't redefine this property");
	        if (hasOwn(this, key)) this[key] = replacement;
	        else createProperty(this, key, replacement);
	      }
	    });
	  } else IteratorPrototype[key] = value;
	};
	if (!hasOwn(IteratorPrototype, TO_STRING_TAG)) defineIteratorPrototypeAccessor(TO_STRING_TAG, ITERATOR);
	if (FORCED || !hasOwn(IteratorPrototype, CONSTRUCTOR) || IteratorPrototype[CONSTRUCTOR] === Object) {
	  defineIteratorPrototypeAccessor(CONSTRUCTOR, IteratorConstructor);
	}
	IteratorConstructor.prototype = IteratorPrototype;
	$({ global: true, constructor: true, forced: FORCED }, {
	  Iterator: IteratorConstructor
	});
	return es_iterator_constructor;
}

var hasRequiredEsnext_iterator_constructor;

function requireEsnext_iterator_constructor () {
	if (hasRequiredEsnext_iterator_constructor) return esnext_iterator_constructor;
	hasRequiredEsnext_iterator_constructor = 1;
	requireEs_iterator_constructor();
	return esnext_iterator_constructor;
}

var esnext_iterator_drop = {};

var es_iterator_drop = {};

var iteratorCloseAll;
var hasRequiredIteratorCloseAll;

function requireIteratorCloseAll () {
	if (hasRequiredIteratorCloseAll) return iteratorCloseAll;
	hasRequiredIteratorCloseAll = 1;
	var iteratorClose = requireIteratorClose();
	iteratorCloseAll = function (iters, kind, value) {
	  for (var i = iters.length - 1; i >= 0; i--) {
	    if (iters[i] === undefined) continue;
	    try {
	      value = iteratorClose(iters[i].iterator, kind, value);
	    } catch (error) {
	      kind = 'throw';
	      value = error;
	    }
	  }
	  if (kind === 'throw') throw value;
	  return value;
	};
	return iteratorCloseAll;
}

var iteratorCreateProxy;
var hasRequiredIteratorCreateProxy;

function requireIteratorCreateProxy () {
	if (hasRequiredIteratorCreateProxy) return iteratorCreateProxy;
	hasRequiredIteratorCreateProxy = 1;
	var call = requireFunctionCall();
	var create = requireObjectCreate();
	var createNonEnumerableProperty = requireCreateNonEnumerableProperty();
	var defineBuiltIns = requireDefineBuiltIns();
	var wellKnownSymbol = requireWellKnownSymbol();
	var InternalStateModule = requireInternalState();
	var getMethod = requireGetMethod();
	var IteratorPrototype = requireIteratorsCore().IteratorPrototype;
	var createIterResultObject = requireCreateIterResultObject();
	var iteratorClose = requireIteratorClose();
	var iteratorCloseAll = requireIteratorCloseAll();
	var TO_STRING_TAG = wellKnownSymbol('toStringTag');
	var ITERATOR_HELPER = 'IteratorHelper';
	var WRAP_FOR_VALID_ITERATOR = 'WrapForValidIterator';
	var NORMAL = 'normal';
	var THROW = 'throw';
	var setInternalState = InternalStateModule.set;
	var createIteratorProxyPrototype = function (IS_ITERATOR) {
	  var getInternalState = InternalStateModule.getterFor(IS_ITERATOR ? WRAP_FOR_VALID_ITERATOR : ITERATOR_HELPER);
	  return defineBuiltIns(create(IteratorPrototype), {
	    next: function next() {
	      var state = getInternalState(this);
	      if (IS_ITERATOR) return state.nextHandler();
	      if (state.done) return createIterResultObject(undefined, true);
	      try {
	        var result = state.nextHandler();
	        return state.returnHandlerResult ? result : createIterResultObject(result, state.done);
	      } catch (error) {
	        state.done = true;
	        throw error;
	      }
	    },
	    'return': function () {
	      var state = getInternalState(this);
	      var iterator = state.iterator;
	      state.done = true;
	      if (IS_ITERATOR) {
	        var returnMethod = getMethod(iterator, 'return');
	        return returnMethod ? call(returnMethod, iterator) : createIterResultObject(undefined, true);
	      }
	      if (state.inner) try {
	        iteratorClose(state.inner.iterator, NORMAL);
	      } catch (error) {
	        return iteratorClose(iterator, THROW, error);
	      }
	      if (state.openIters) try {
	        iteratorCloseAll(state.openIters, NORMAL);
	      } catch (error) {
	        return iteratorClose(iterator, THROW, error);
	      }
	      if (iterator) iteratorClose(iterator, NORMAL);
	      return createIterResultObject(undefined, true);
	    }
	  });
	};
	var WrapForValidIteratorPrototype = createIteratorProxyPrototype(true);
	var IteratorHelperPrototype = createIteratorProxyPrototype(false);
	createNonEnumerableProperty(IteratorHelperPrototype, TO_STRING_TAG, 'Iterator Helper');
	iteratorCreateProxy = function (nextHandler, IS_ITERATOR, RETURN_HANDLER_RESULT) {
	  var IteratorProxy = function Iterator(record, state) {
	    if (state) {
	      state.iterator = record.iterator;
	      state.next = record.next;
	    } else state = record;
	    state.type = IS_ITERATOR ? WRAP_FOR_VALID_ITERATOR : ITERATOR_HELPER;
	    state.returnHandlerResult = !!RETURN_HANDLER_RESULT;
	    state.nextHandler = nextHandler;
	    state.counter = 0;
	    state.done = false;
	    setInternalState(this, state);
	  };
	  IteratorProxy.prototype = IS_ITERATOR ? WrapForValidIteratorPrototype : IteratorHelperPrototype;
	  return IteratorProxy;
	};
	return iteratorCreateProxy;
}

var iteratorHelperThrowsOnInvalidIterator;
var hasRequiredIteratorHelperThrowsOnInvalidIterator;

function requireIteratorHelperThrowsOnInvalidIterator () {
	if (hasRequiredIteratorHelperThrowsOnInvalidIterator) return iteratorHelperThrowsOnInvalidIterator;
	hasRequiredIteratorHelperThrowsOnInvalidIterator = 1;
	iteratorHelperThrowsOnInvalidIterator = function (methodName, argument) {
	  var method = typeof Iterator == 'function' && Iterator.prototype[methodName];
	  if (method) try {
	    method.call({ next: null }, argument).next();
	  } catch (error) {
	    return true;
	  }
	};
	return iteratorHelperThrowsOnInvalidIterator;
}

var iteratorHelperWithoutClosingOnEarlyError;
var hasRequiredIteratorHelperWithoutClosingOnEarlyError;

function requireIteratorHelperWithoutClosingOnEarlyError () {
	if (hasRequiredIteratorHelperWithoutClosingOnEarlyError) return iteratorHelperWithoutClosingOnEarlyError;
	hasRequiredIteratorHelperWithoutClosingOnEarlyError = 1;
	var globalThis = requireGlobalThis();
	iteratorHelperWithoutClosingOnEarlyError = function (METHOD_NAME, ExpectedError) {
	  var Iterator = globalThis.Iterator;
	  var IteratorPrototype = Iterator && Iterator.prototype;
	  var method = IteratorPrototype && IteratorPrototype[METHOD_NAME];
	  var CLOSED = false;
	  if (method) try {
	    method.call({
	      next: function () { return { done: true }; },
	      'return': function () { CLOSED = true; }
	    }, -1);
	  } catch (error) {
	    if (!(error instanceof ExpectedError)) CLOSED = false;
	  }
	  if (!CLOSED) return method;
	};
	return iteratorHelperWithoutClosingOnEarlyError;
}

var hasRequiredEs_iterator_drop;

function requireEs_iterator_drop () {
	if (hasRequiredEs_iterator_drop) return es_iterator_drop;
	hasRequiredEs_iterator_drop = 1;
	var $ = require_export();
	var call = requireFunctionCall();
	var anObject = requireAnObject();
	var getIteratorDirect = requireGetIteratorDirect();
	var notANaN = requireNotANan();
	var toPositiveInteger = requireToPositiveInteger();
	var iteratorClose = requireIteratorClose();
	var createIteratorProxy = requireIteratorCreateProxy();
	var iteratorHelperThrowsOnInvalidIterator = requireIteratorHelperThrowsOnInvalidIterator();
	var iteratorHelperWithoutClosingOnEarlyError = requireIteratorHelperWithoutClosingOnEarlyError();
	var IS_PURE = requireIsPure();
	var DROP_WITHOUT_THROWING_ON_INVALID_ITERATOR = !IS_PURE && !iteratorHelperThrowsOnInvalidIterator('drop', 0);
	var dropWithoutClosingOnEarlyError = !IS_PURE && !DROP_WITHOUT_THROWING_ON_INVALID_ITERATOR
	  && iteratorHelperWithoutClosingOnEarlyError('drop', RangeError);
	var FORCED = IS_PURE || DROP_WITHOUT_THROWING_ON_INVALID_ITERATOR || dropWithoutClosingOnEarlyError;
	var IteratorProxy = createIteratorProxy(function () {
	  var iterator = this.iterator;
	  var next = this.next;
	  var result, done;
	  while (this.remaining) {
	    this.remaining--;
	    result = anObject(call(next, iterator));
	    done = this.done = !!result.done;
	    if (done) return;
	  }
	  result = anObject(call(next, iterator));
	  done = this.done = !!result.done;
	  if (!done) return result.value;
	});
	$({ target: 'Iterator', proto: true, real: true, forced: FORCED }, {
	  drop: function drop(limit) {
	    anObject(this);
	    var remaining;
	    try {
	      remaining = toPositiveInteger(notANaN(+limit));
	    } catch (error) {
	      iteratorClose(this, 'throw', error);
	    }
	    if (dropWithoutClosingOnEarlyError) return call(dropWithoutClosingOnEarlyError, this, remaining);
	    return new IteratorProxy(getIteratorDirect(this), {
	      remaining: remaining
	    });
	  }
	});
	return es_iterator_drop;
}

var hasRequiredEsnext_iterator_drop;

function requireEsnext_iterator_drop () {
	if (hasRequiredEsnext_iterator_drop) return esnext_iterator_drop;
	hasRequiredEsnext_iterator_drop = 1;
	requireEs_iterator_drop();
	return esnext_iterator_drop;
}

var esnext_iterator_every = {};

var es_iterator_every = {};

var functionUncurryThisClause;
var hasRequiredFunctionUncurryThisClause;

function requireFunctionUncurryThisClause () {
	if (hasRequiredFunctionUncurryThisClause) return functionUncurryThisClause;
	hasRequiredFunctionUncurryThisClause = 1;
	var classofRaw = requireClassofRaw();
	var uncurryThis = requireFunctionUncurryThis();
	functionUncurryThisClause = function (fn) {
	  if (classofRaw(fn) === 'Function') return uncurryThis(fn);
	};
	return functionUncurryThisClause;
}

var functionBindContext;
var hasRequiredFunctionBindContext;

function requireFunctionBindContext () {
	if (hasRequiredFunctionBindContext) return functionBindContext;
	hasRequiredFunctionBindContext = 1;
	var uncurryThis = requireFunctionUncurryThisClause();
	var aCallable = requireACallable();
	var NATIVE_BIND = requireFunctionBindNative();
	var bind = uncurryThis(uncurryThis.bind);
	functionBindContext = function (fn, that) {
	  aCallable(fn);
	  return that === undefined ? fn : NATIVE_BIND ? bind(fn, that) : function () {
	    return fn.apply(that, arguments);
	  };
	};
	return functionBindContext;
}

var isArrayIteratorMethod;
var hasRequiredIsArrayIteratorMethod;

function requireIsArrayIteratorMethod () {
	if (hasRequiredIsArrayIteratorMethod) return isArrayIteratorMethod;
	hasRequiredIsArrayIteratorMethod = 1;
	var wellKnownSymbol = requireWellKnownSymbol();
	var Iterators = requireIterators();
	var ITERATOR = wellKnownSymbol('iterator');
	var ArrayPrototype = Array.prototype;
	isArrayIteratorMethod = function (it) {
	  return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
	};
	return isArrayIteratorMethod;
}

var getIterator;
var hasRequiredGetIterator;

function requireGetIterator () {
	if (hasRequiredGetIterator) return getIterator;
	hasRequiredGetIterator = 1;
	var call = requireFunctionCall();
	var aCallable = requireACallable();
	var anObject = requireAnObject();
	var tryToString = requireTryToString();
	var getIteratorMethod = requireGetIteratorMethod();
	var $TypeError = TypeError;
	getIterator = function (argument, usingIterator) {
	  var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;
	  if (aCallable(iteratorMethod)) return anObject(call(iteratorMethod, argument));
	  throw new $TypeError(tryToString(argument) + ' is not iterable');
	};
	return getIterator;
}

var iterate;
var hasRequiredIterate;

function requireIterate () {
	if (hasRequiredIterate) return iterate;
	hasRequiredIterate = 1;
	var bind = requireFunctionBindContext();
	var call = requireFunctionCall();
	var anObject = requireAnObject();
	var tryToString = requireTryToString();
	var isArrayIteratorMethod = requireIsArrayIteratorMethod();
	var lengthOfArrayLike = requireLengthOfArrayLike();
	var isPrototypeOf = requireObjectIsPrototypeOf();
	var getIterator = requireGetIterator();
	var getIteratorMethod = requireGetIteratorMethod();
	var iteratorClose = requireIteratorClose();
	var $TypeError = TypeError;
	var Result = function (stopped, result) {
	  this.stopped = stopped;
	  this.result = result;
	};
	var ResultPrototype = Result.prototype;
	iterate = function (iterable, unboundFunction, options) {
	  var that = options && options.that;
	  var AS_ENTRIES = !!(options && options.AS_ENTRIES);
	  var IS_RECORD = !!(options && options.IS_RECORD);
	  var IS_ITERATOR = !!(options && options.IS_ITERATOR);
	  var INTERRUPTED = !!(options && options.INTERRUPTED);
	  var fn = bind(unboundFunction, that);
	  var iterator, iterFn, index, length, result, next, step;
	  var stop = function (condition) {
	    if (iterator) iteratorClose(iterator, 'normal');
	    return new Result(true, condition);
	  };
	  var callFn = function (value) {
	    if (AS_ENTRIES) {
	      anObject(value);
	      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
	    } return INTERRUPTED ? fn(value, stop) : fn(value);
	  };
	  if (IS_RECORD) {
	    iterator = iterable.iterator;
	  } else if (IS_ITERATOR) {
	    iterator = iterable;
	  } else {
	    iterFn = getIteratorMethod(iterable);
	    if (!iterFn) throw new $TypeError(tryToString(iterable) + ' is not iterable');
	    if (isArrayIteratorMethod(iterFn)) {
	      for (index = 0, length = lengthOfArrayLike(iterable); length > index; index++) {
	        result = callFn(iterable[index]);
	        if (result && isPrototypeOf(ResultPrototype, result)) return result;
	      } return new Result(false);
	    }
	    iterator = getIterator(iterable, iterFn);
	  }
	  next = IS_RECORD ? iterable.next : iterator.next;
	  while (!(step = call(next, iterator)).done) {
	    try {
	      result = callFn(step.value);
	    } catch (error) {
	      iteratorClose(iterator, 'throw', error);
	    }
	    if (typeof result == 'object' && result && isPrototypeOf(ResultPrototype, result)) return result;
	  } return new Result(false);
	};
	return iterate;
}

var hasRequiredEs_iterator_every;

function requireEs_iterator_every () {
	if (hasRequiredEs_iterator_every) return es_iterator_every;
	hasRequiredEs_iterator_every = 1;
	var $ = require_export();
	var call = requireFunctionCall();
	var iterate = requireIterate();
	var aCallable = requireACallable();
	var anObject = requireAnObject();
	var getIteratorDirect = requireGetIteratorDirect();
	var iteratorClose = requireIteratorClose();
	var iteratorHelperWithoutClosingOnEarlyError = requireIteratorHelperWithoutClosingOnEarlyError();
	var everyWithoutClosingOnEarlyError = iteratorHelperWithoutClosingOnEarlyError('every', TypeError);
	$({ target: 'Iterator', proto: true, real: true, forced: everyWithoutClosingOnEarlyError }, {
	  every: function every(predicate) {
	    anObject(this);
	    try {
	      aCallable(predicate);
	    } catch (error) {
	      iteratorClose(this, 'throw', error);
	    }
	    if (everyWithoutClosingOnEarlyError) return call(everyWithoutClosingOnEarlyError, this, predicate);
	    var record = getIteratorDirect(this);
	    var counter = 0;
	    return !iterate(record, function (value, stop) {
	      if (!predicate(value, counter++)) return stop();
	    }, { IS_RECORD: true, INTERRUPTED: true }).stopped;
	  }
	});
	return es_iterator_every;
}

var hasRequiredEsnext_iterator_every;

function requireEsnext_iterator_every () {
	if (hasRequiredEsnext_iterator_every) return esnext_iterator_every;
	hasRequiredEsnext_iterator_every = 1;
	requireEs_iterator_every();
	return esnext_iterator_every;
}

var esnext_iterator_filter = {};

var es_iterator_filter = {};

var callWithSafeIterationClosing;
var hasRequiredCallWithSafeIterationClosing;

function requireCallWithSafeIterationClosing () {
	if (hasRequiredCallWithSafeIterationClosing) return callWithSafeIterationClosing;
	hasRequiredCallWithSafeIterationClosing = 1;
	var anObject = requireAnObject();
	var iteratorClose = requireIteratorClose();
	callWithSafeIterationClosing = function (iterator, fn, value, ENTRIES) {
	  try {
	    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
	  } catch (error) {
	    iteratorClose(iterator, 'throw', error);
	  }
	};
	return callWithSafeIterationClosing;
}

var hasRequiredEs_iterator_filter;

function requireEs_iterator_filter () {
	if (hasRequiredEs_iterator_filter) return es_iterator_filter;
	hasRequiredEs_iterator_filter = 1;
	var $ = require_export();
	var call = requireFunctionCall();
	var aCallable = requireACallable();
	var anObject = requireAnObject();
	var getIteratorDirect = requireGetIteratorDirect();
	var createIteratorProxy = requireIteratorCreateProxy();
	var callWithSafeIterationClosing = requireCallWithSafeIterationClosing();
	var IS_PURE = requireIsPure();
	var iteratorClose = requireIteratorClose();
	var iteratorHelperThrowsOnInvalidIterator = requireIteratorHelperThrowsOnInvalidIterator();
	var iteratorHelperWithoutClosingOnEarlyError = requireIteratorHelperWithoutClosingOnEarlyError();
	var FILTER_WITHOUT_THROWING_ON_INVALID_ITERATOR = !IS_PURE && !iteratorHelperThrowsOnInvalidIterator('filter', function () {  });
	var filterWithoutClosingOnEarlyError = !IS_PURE && !FILTER_WITHOUT_THROWING_ON_INVALID_ITERATOR
	  && iteratorHelperWithoutClosingOnEarlyError('filter', TypeError);
	var FORCED = IS_PURE || FILTER_WITHOUT_THROWING_ON_INVALID_ITERATOR || filterWithoutClosingOnEarlyError;
	var IteratorProxy = createIteratorProxy(function () {
	  var iterator = this.iterator;
	  var predicate = this.predicate;
	  var next = this.next;
	  var result, done, value;
	  while (true) {
	    result = anObject(call(next, iterator));
	    done = this.done = !!result.done;
	    if (done) return;
	    value = result.value;
	    if (callWithSafeIterationClosing(iterator, predicate, [value, this.counter++], true)) return value;
	  }
	});
	$({ target: 'Iterator', proto: true, real: true, forced: FORCED }, {
	  filter: function filter(predicate) {
	    anObject(this);
	    try {
	      aCallable(predicate);
	    } catch (error) {
	      iteratorClose(this, 'throw', error);
	    }
	    if (filterWithoutClosingOnEarlyError) return call(filterWithoutClosingOnEarlyError, this, predicate);
	    return new IteratorProxy(getIteratorDirect(this), {
	      predicate: predicate
	    });
	  }
	});
	return es_iterator_filter;
}

var hasRequiredEsnext_iterator_filter;

function requireEsnext_iterator_filter () {
	if (hasRequiredEsnext_iterator_filter) return esnext_iterator_filter;
	hasRequiredEsnext_iterator_filter = 1;
	requireEs_iterator_filter();
	return esnext_iterator_filter;
}

var esnext_iterator_find = {};

var es_iterator_find = {};

var hasRequiredEs_iterator_find;

function requireEs_iterator_find () {
	if (hasRequiredEs_iterator_find) return es_iterator_find;
	hasRequiredEs_iterator_find = 1;
	var $ = require_export();
	var call = requireFunctionCall();
	var iterate = requireIterate();
	var aCallable = requireACallable();
	var anObject = requireAnObject();
	var getIteratorDirect = requireGetIteratorDirect();
	var iteratorClose = requireIteratorClose();
	var iteratorHelperWithoutClosingOnEarlyError = requireIteratorHelperWithoutClosingOnEarlyError();
	var findWithoutClosingOnEarlyError = iteratorHelperWithoutClosingOnEarlyError('find', TypeError);
	$({ target: 'Iterator', proto: true, real: true, forced: findWithoutClosingOnEarlyError }, {
	  find: function find(predicate) {
	    anObject(this);
	    try {
	      aCallable(predicate);
	    } catch (error) {
	      iteratorClose(this, 'throw', error);
	    }
	    if (findWithoutClosingOnEarlyError) return call(findWithoutClosingOnEarlyError, this, predicate);
	    var record = getIteratorDirect(this);
	    var counter = 0;
	    return iterate(record, function (value, stop) {
	      if (predicate(value, counter++)) return stop(value);
	    }, { IS_RECORD: true, INTERRUPTED: true }).result;
	  }
	});
	return es_iterator_find;
}

var hasRequiredEsnext_iterator_find;

function requireEsnext_iterator_find () {
	if (hasRequiredEsnext_iterator_find) return esnext_iterator_find;
	hasRequiredEsnext_iterator_find = 1;
	requireEs_iterator_find();
	return esnext_iterator_find;
}

var esnext_iterator_flatMap = {};

var es_iterator_flatMap = {};

var getIteratorFlattenable;
var hasRequiredGetIteratorFlattenable;

function requireGetIteratorFlattenable () {
	if (hasRequiredGetIteratorFlattenable) return getIteratorFlattenable;
	hasRequiredGetIteratorFlattenable = 1;
	var call = requireFunctionCall();
	var anObject = requireAnObject();
	var getIteratorDirect = requireGetIteratorDirect();
	var getIteratorMethod = requireGetIteratorMethod();
	getIteratorFlattenable = function (obj, stringHandling) {
	  if (!stringHandling || typeof obj !== 'string') anObject(obj);
	  var method = getIteratorMethod(obj);
	  return getIteratorDirect(anObject(method !== undefined ? call(method, obj) : obj));
	};
	return getIteratorFlattenable;
}

var hasRequiredEs_iterator_flatMap;

function requireEs_iterator_flatMap () {
	if (hasRequiredEs_iterator_flatMap) return es_iterator_flatMap;
	hasRequiredEs_iterator_flatMap = 1;
	var $ = require_export();
	var call = requireFunctionCall();
	var aCallable = requireACallable();
	var anObject = requireAnObject();
	var getIteratorDirect = requireGetIteratorDirect();
	var getIteratorFlattenable = requireGetIteratorFlattenable();
	var createIteratorProxy = requireIteratorCreateProxy();
	var iteratorClose = requireIteratorClose();
	var IS_PURE = requireIsPure();
	var iteratorHelperThrowsOnInvalidIterator = requireIteratorHelperThrowsOnInvalidIterator();
	var iteratorHelperWithoutClosingOnEarlyError = requireIteratorHelperWithoutClosingOnEarlyError();
	var FLAT_MAP_WITHOUT_THROWING_ON_INVALID_ITERATOR = !IS_PURE
	  && !iteratorHelperThrowsOnInvalidIterator('flatMap', function () {  });
	var flatMapWithoutClosingOnEarlyError = !IS_PURE && !FLAT_MAP_WITHOUT_THROWING_ON_INVALID_ITERATOR
	  && iteratorHelperWithoutClosingOnEarlyError('flatMap', TypeError);
	var FORCED = IS_PURE || FLAT_MAP_WITHOUT_THROWING_ON_INVALID_ITERATOR || flatMapWithoutClosingOnEarlyError;
	var IteratorProxy = createIteratorProxy(function () {
	  var iterator = this.iterator;
	  var mapper = this.mapper;
	  var result, inner;
	  while (true) {
	    if (inner = this.inner) try {
	      result = anObject(call(inner.next, inner.iterator));
	      if (!result.done) return result.value;
	      this.inner = null;
	    } catch (error) { iteratorClose(iterator, 'throw', error); }
	    result = anObject(call(this.next, iterator));
	    if (this.done = !!result.done) return;
	    try {
	      this.inner = getIteratorFlattenable(mapper(result.value, this.counter++), false);
	    } catch (error) { iteratorClose(iterator, 'throw', error); }
	  }
	});
	$({ target: 'Iterator', proto: true, real: true, forced: FORCED }, {
	  flatMap: function flatMap(mapper) {
	    anObject(this);
	    try {
	      aCallable(mapper);
	    } catch (error) {
	      iteratorClose(this, 'throw', error);
	    }
	    if (flatMapWithoutClosingOnEarlyError) return call(flatMapWithoutClosingOnEarlyError, this, mapper);
	    return new IteratorProxy(getIteratorDirect(this), {
	      mapper: mapper,
	      inner: null
	    });
	  }
	});
	return es_iterator_flatMap;
}

var hasRequiredEsnext_iterator_flatMap;

function requireEsnext_iterator_flatMap () {
	if (hasRequiredEsnext_iterator_flatMap) return esnext_iterator_flatMap;
	hasRequiredEsnext_iterator_flatMap = 1;
	requireEs_iterator_flatMap();
	return esnext_iterator_flatMap;
}

var esnext_iterator_forEach = {};

var es_iterator_forEach = {};

var hasRequiredEs_iterator_forEach;

function requireEs_iterator_forEach () {
	if (hasRequiredEs_iterator_forEach) return es_iterator_forEach;
	hasRequiredEs_iterator_forEach = 1;
	var $ = require_export();
	var call = requireFunctionCall();
	var iterate = requireIterate();
	var aCallable = requireACallable();
	var anObject = requireAnObject();
	var getIteratorDirect = requireGetIteratorDirect();
	var iteratorClose = requireIteratorClose();
	var iteratorHelperWithoutClosingOnEarlyError = requireIteratorHelperWithoutClosingOnEarlyError();
	var forEachWithoutClosingOnEarlyError = iteratorHelperWithoutClosingOnEarlyError('forEach', TypeError);
	$({ target: 'Iterator', proto: true, real: true, forced: forEachWithoutClosingOnEarlyError }, {
	  forEach: function forEach(fn) {
	    anObject(this);
	    try {
	      aCallable(fn);
	    } catch (error) {
	      iteratorClose(this, 'throw', error);
	    }
	    if (forEachWithoutClosingOnEarlyError) return call(forEachWithoutClosingOnEarlyError, this, fn);
	    var record = getIteratorDirect(this);
	    var counter = 0;
	    iterate(record, function (value) {
	      fn(value, counter++);
	    }, { IS_RECORD: true });
	  }
	});
	return es_iterator_forEach;
}

var hasRequiredEsnext_iterator_forEach;

function requireEsnext_iterator_forEach () {
	if (hasRequiredEsnext_iterator_forEach) return esnext_iterator_forEach;
	hasRequiredEsnext_iterator_forEach = 1;
	requireEs_iterator_forEach();
	return esnext_iterator_forEach;
}

var esnext_iterator_from = {};

var es_iterator_from = {};

var hasRequiredEs_iterator_from;

function requireEs_iterator_from () {
	if (hasRequiredEs_iterator_from) return es_iterator_from;
	hasRequiredEs_iterator_from = 1;
	var $ = require_export();
	var call = requireFunctionCall();
	var toObject = requireToObject();
	var isPrototypeOf = requireObjectIsPrototypeOf();
	var IteratorPrototype = requireIteratorsCore().IteratorPrototype;
	var createIteratorProxy = requireIteratorCreateProxy();
	var getIteratorFlattenable = requireGetIteratorFlattenable();
	var IS_PURE = requireIsPure();
	var FORCED = IS_PURE || function () {
	  try {
	    Iterator.from({ 'return': null })['return']();
	  } catch (error) {
	    return true;
	  }
	}();
	var IteratorProxy = createIteratorProxy(function () {
	  return call(this.next, this.iterator);
	}, true);
	$({ target: 'Iterator', stat: true, forced: FORCED }, {
	  from: function from(O) {
	    var iteratorRecord = getIteratorFlattenable(typeof O == 'string' ? toObject(O) : O, true);
	    return isPrototypeOf(IteratorPrototype, iteratorRecord.iterator)
	      ? iteratorRecord.iterator
	      : new IteratorProxy(iteratorRecord);
	  }
	});
	return es_iterator_from;
}

var hasRequiredEsnext_iterator_from;

function requireEsnext_iterator_from () {
	if (hasRequiredEsnext_iterator_from) return esnext_iterator_from;
	hasRequiredEsnext_iterator_from = 1;
	requireEs_iterator_from();
	return esnext_iterator_from;
}

var esnext_iterator_map = {};

var es_iterator_map = {};

var hasRequiredEs_iterator_map;

function requireEs_iterator_map () {
	if (hasRequiredEs_iterator_map) return es_iterator_map;
	hasRequiredEs_iterator_map = 1;
	var $ = require_export();
	var call = requireFunctionCall();
	var aCallable = requireACallable();
	var anObject = requireAnObject();
	var getIteratorDirect = requireGetIteratorDirect();
	var createIteratorProxy = requireIteratorCreateProxy();
	var callWithSafeIterationClosing = requireCallWithSafeIterationClosing();
	var iteratorClose = requireIteratorClose();
	var iteratorHelperThrowsOnInvalidIterator = requireIteratorHelperThrowsOnInvalidIterator();
	var iteratorHelperWithoutClosingOnEarlyError = requireIteratorHelperWithoutClosingOnEarlyError();
	var IS_PURE = requireIsPure();
	var MAP_WITHOUT_THROWING_ON_INVALID_ITERATOR = !IS_PURE && !iteratorHelperThrowsOnInvalidIterator('map', function () {  });
	var mapWithoutClosingOnEarlyError = !IS_PURE && !MAP_WITHOUT_THROWING_ON_INVALID_ITERATOR
	  && iteratorHelperWithoutClosingOnEarlyError('map', TypeError);
	var FORCED = IS_PURE || MAP_WITHOUT_THROWING_ON_INVALID_ITERATOR || mapWithoutClosingOnEarlyError;
	var IteratorProxy = createIteratorProxy(function () {
	  var iterator = this.iterator;
	  var result = anObject(call(this.next, iterator));
	  var done = this.done = !!result.done;
	  if (!done) return callWithSafeIterationClosing(iterator, this.mapper, [result.value, this.counter++], true);
	});
	$({ target: 'Iterator', proto: true, real: true, forced: FORCED }, {
	  map: function map(mapper) {
	    anObject(this);
	    try {
	      aCallable(mapper);
	    } catch (error) {
	      iteratorClose(this, 'throw', error);
	    }
	    if (mapWithoutClosingOnEarlyError) return call(mapWithoutClosingOnEarlyError, this, mapper);
	    return new IteratorProxy(getIteratorDirect(this), {
	      mapper: mapper
	    });
	  }
	});
	return es_iterator_map;
}

var hasRequiredEsnext_iterator_map;

function requireEsnext_iterator_map () {
	if (hasRequiredEsnext_iterator_map) return esnext_iterator_map;
	hasRequiredEsnext_iterator_map = 1;
	requireEs_iterator_map();
	return esnext_iterator_map;
}

var esnext_iterator_reduce = {};

var es_iterator_reduce = {};

var functionApply;
var hasRequiredFunctionApply;

function requireFunctionApply () {
	if (hasRequiredFunctionApply) return functionApply;
	hasRequiredFunctionApply = 1;
	var NATIVE_BIND = requireFunctionBindNative();
	var FunctionPrototype = Function.prototype;
	var apply = FunctionPrototype.apply;
	var call = FunctionPrototype.call;
	functionApply = typeof Reflect == 'object' && Reflect.apply || (NATIVE_BIND ? call.bind(apply) : function () {
	  return call.apply(apply, arguments);
	});
	return functionApply;
}

var hasRequiredEs_iterator_reduce;

function requireEs_iterator_reduce () {
	if (hasRequiredEs_iterator_reduce) return es_iterator_reduce;
	hasRequiredEs_iterator_reduce = 1;
	var $ = require_export();
	var iterate = requireIterate();
	var aCallable = requireACallable();
	var anObject = requireAnObject();
	var getIteratorDirect = requireGetIteratorDirect();
	var iteratorClose = requireIteratorClose();
	var iteratorHelperWithoutClosingOnEarlyError = requireIteratorHelperWithoutClosingOnEarlyError();
	var apply = requireFunctionApply();
	var fails = requireFails();
	var $TypeError = TypeError;
	var FAILS_ON_INITIAL_UNDEFINED = fails(function () {
	  [].keys().reduce(function () {  }, undefined);
	});
	var reduceWithoutClosingOnEarlyError = !FAILS_ON_INITIAL_UNDEFINED && iteratorHelperWithoutClosingOnEarlyError('reduce', $TypeError);
	$({ target: 'Iterator', proto: true, real: true, forced: FAILS_ON_INITIAL_UNDEFINED || reduceWithoutClosingOnEarlyError }, {
	  reduce: function reduce(reducer ) {
	    anObject(this);
	    try {
	      aCallable(reducer);
	    } catch (error) {
	      iteratorClose(this, 'throw', error);
	    }
	    var noInitial = arguments.length < 2;
	    var accumulator = noInitial ? undefined : arguments[1];
	    if (reduceWithoutClosingOnEarlyError) {
	      return apply(reduceWithoutClosingOnEarlyError, this, noInitial ? [reducer] : [reducer, accumulator]);
	    }
	    var record = getIteratorDirect(this);
	    var counter = 0;
	    iterate(record, function (value) {
	      if (noInitial) {
	        noInitial = false;
	        accumulator = value;
	      } else {
	        accumulator = reducer(accumulator, value, counter);
	      }
	      counter++;
	    }, { IS_RECORD: true });
	    if (noInitial) throw new $TypeError('Reduce of empty iterator with no initial value');
	    return accumulator;
	  }
	});
	return es_iterator_reduce;
}

var hasRequiredEsnext_iterator_reduce;

function requireEsnext_iterator_reduce () {
	if (hasRequiredEsnext_iterator_reduce) return esnext_iterator_reduce;
	hasRequiredEsnext_iterator_reduce = 1;
	requireEs_iterator_reduce();
	return esnext_iterator_reduce;
}

var esnext_iterator_some = {};

var es_iterator_some = {};

var hasRequiredEs_iterator_some;

function requireEs_iterator_some () {
	if (hasRequiredEs_iterator_some) return es_iterator_some;
	hasRequiredEs_iterator_some = 1;
	var $ = require_export();
	var call = requireFunctionCall();
	var iterate = requireIterate();
	var aCallable = requireACallable();
	var anObject = requireAnObject();
	var getIteratorDirect = requireGetIteratorDirect();
	var iteratorClose = requireIteratorClose();
	var iteratorHelperWithoutClosingOnEarlyError = requireIteratorHelperWithoutClosingOnEarlyError();
	var someWithoutClosingOnEarlyError = iteratorHelperWithoutClosingOnEarlyError('some', TypeError);
	$({ target: 'Iterator', proto: true, real: true, forced: someWithoutClosingOnEarlyError }, {
	  some: function some(predicate) {
	    anObject(this);
	    try {
	      aCallable(predicate);
	    } catch (error) {
	      iteratorClose(this, 'throw', error);
	    }
	    if (someWithoutClosingOnEarlyError) return call(someWithoutClosingOnEarlyError, this, predicate);
	    var record = getIteratorDirect(this);
	    var counter = 0;
	    return iterate(record, function (value, stop) {
	      if (predicate(value, counter++)) return stop();
	    }, { IS_RECORD: true, INTERRUPTED: true }).stopped;
	  }
	});
	return es_iterator_some;
}

var hasRequiredEsnext_iterator_some;

function requireEsnext_iterator_some () {
	if (hasRequiredEsnext_iterator_some) return esnext_iterator_some;
	hasRequiredEsnext_iterator_some = 1;
	requireEs_iterator_some();
	return esnext_iterator_some;
}

var esnext_iterator_take = {};

var es_iterator_take = {};

var hasRequiredEs_iterator_take;

function requireEs_iterator_take () {
	if (hasRequiredEs_iterator_take) return es_iterator_take;
	hasRequiredEs_iterator_take = 1;
	var $ = require_export();
	var call = requireFunctionCall();
	var anObject = requireAnObject();
	var getIteratorDirect = requireGetIteratorDirect();
	var notANaN = requireNotANan();
	var toPositiveInteger = requireToPositiveInteger();
	var createIteratorProxy = requireIteratorCreateProxy();
	var iteratorClose = requireIteratorClose();
	var iteratorHelperWithoutClosingOnEarlyError = requireIteratorHelperWithoutClosingOnEarlyError();
	var IS_PURE = requireIsPure();
	var takeWithoutClosingOnEarlyError = !IS_PURE && iteratorHelperWithoutClosingOnEarlyError('take', RangeError);
	var IteratorProxy = createIteratorProxy(function () {
	  var iterator = this.iterator;
	  if (!this.remaining--) {
	    this.done = true;
	    return iteratorClose(iterator, 'normal', undefined);
	  }
	  var result = anObject(call(this.next, iterator));
	  var done = this.done = !!result.done;
	  if (!done) return result.value;
	});
	$({ target: 'Iterator', proto: true, real: true, forced: IS_PURE || takeWithoutClosingOnEarlyError }, {
	  take: function take(limit) {
	    anObject(this);
	    var remaining;
	    try {
	      remaining = toPositiveInteger(notANaN(+limit));
	    } catch (error) {
	      iteratorClose(this, 'throw', error);
	    }
	    if (takeWithoutClosingOnEarlyError) return call(takeWithoutClosingOnEarlyError, this, remaining);
	    return new IteratorProxy(getIteratorDirect(this), {
	      remaining: remaining
	    });
	  }
	});
	return es_iterator_take;
}

var hasRequiredEsnext_iterator_take;

function requireEsnext_iterator_take () {
	if (hasRequiredEsnext_iterator_take) return esnext_iterator_take;
	hasRequiredEsnext_iterator_take = 1;
	requireEs_iterator_take();
	return esnext_iterator_take;
}

var esnext_iterator_toArray = {};

var es_iterator_toArray = {};

var hasRequiredEs_iterator_toArray;

function requireEs_iterator_toArray () {
	if (hasRequiredEs_iterator_toArray) return es_iterator_toArray;
	hasRequiredEs_iterator_toArray = 1;
	var $ = require_export();
	var anObject = requireAnObject();
	var iterate = requireIterate();
	var getIteratorDirect = requireGetIteratorDirect();
	var push = [].push;
	$({ target: 'Iterator', proto: true, real: true }, {
	  toArray: function toArray() {
	    var result = [];
	    iterate(getIteratorDirect(anObject(this)), push, { that: result, IS_RECORD: true });
	    return result;
	  }
	});
	return es_iterator_toArray;
}

var hasRequiredEsnext_iterator_toArray;

function requireEsnext_iterator_toArray () {
	if (hasRequiredEsnext_iterator_toArray) return esnext_iterator_toArray;
	hasRequiredEsnext_iterator_toArray = 1;
	requireEs_iterator_toArray();
	return esnext_iterator_toArray;
}

var esnext_iterator_toAsync = {};

var hasRequiredEsnext_iterator_toAsync;

function requireEsnext_iterator_toAsync () {
	if (hasRequiredEsnext_iterator_toAsync) return esnext_iterator_toAsync;
	hasRequiredEsnext_iterator_toAsync = 1;
	var $ = require_export();
	var anObject = requireAnObject();
	var AsyncFromSyncIterator = requireAsyncFromSyncIterator();
	var WrapAsyncIterator = requireAsyncIteratorWrap();
	var getIteratorDirect = requireGetIteratorDirect();
	$({ target: 'Iterator', proto: true, real: true, forced: true }, {
	  toAsync: function toAsync() {
	    return new WrapAsyncIterator(getIteratorDirect(new AsyncFromSyncIterator(getIteratorDirect(anObject(this)))));
	  }
	});
	return esnext_iterator_toAsync;
}

var hasRequiredIteratorHelpersStage3;

function requireIteratorHelpersStage3 () {
	if (hasRequiredIteratorHelpersStage3) return iteratorHelpersStage3;
	hasRequiredIteratorHelpersStage3 = 1;
	requireEsnext_asyncIterator_constructor();
	requireEsnext_asyncIterator_drop();
	requireEsnext_asyncIterator_every();
	requireEsnext_asyncIterator_filter();
	requireEsnext_asyncIterator_find();
	requireEsnext_asyncIterator_flatMap();
	requireEsnext_asyncIterator_forEach();
	requireEsnext_asyncIterator_from();
	requireEsnext_asyncIterator_map();
	requireEsnext_asyncIterator_reduce();
	requireEsnext_asyncIterator_some();
	requireEsnext_asyncIterator_take();
	requireEsnext_asyncIterator_toArray();
	requireEsnext_iterator_constructor();
	requireEsnext_iterator_drop();
	requireEsnext_iterator_every();
	requireEsnext_iterator_filter();
	requireEsnext_iterator_find();
	requireEsnext_iterator_flatMap();
	requireEsnext_iterator_forEach();
	requireEsnext_iterator_from();
	requireEsnext_iterator_map();
	requireEsnext_iterator_reduce();
	requireEsnext_iterator_some();
	requireEsnext_iterator_take();
	requireEsnext_iterator_toArray();
	requireEsnext_iterator_toAsync();
	return iteratorHelpersStage3;
}

var esnext_asyncIterator_asIndexedPairs = {};

var asyncIteratorIndexed;
var hasRequiredAsyncIteratorIndexed;

function requireAsyncIteratorIndexed () {
	if (hasRequiredAsyncIteratorIndexed) return asyncIteratorIndexed;
	hasRequiredAsyncIteratorIndexed = 1;
	var call = requireFunctionCall();
	var map = requireAsyncIteratorMap();
	var callback = function (value, counter) {
	  return [counter, value];
	};
	asyncIteratorIndexed = function indexed() {
	  return call(map, this, callback);
	};
	return asyncIteratorIndexed;
}

var hasRequiredEsnext_asyncIterator_asIndexedPairs;

function requireEsnext_asyncIterator_asIndexedPairs () {
	if (hasRequiredEsnext_asyncIterator_asIndexedPairs) return esnext_asyncIterator_asIndexedPairs;
	hasRequiredEsnext_asyncIterator_asIndexedPairs = 1;
	var $ = require_export();
	var indexed = requireAsyncIteratorIndexed();
	$({ target: 'AsyncIterator', name: 'indexed', proto: true, real: true, forced: true }, {
	  asIndexedPairs: indexed
	});
	return esnext_asyncIterator_asIndexedPairs;
}

var esnext_asyncIterator_indexed = {};

var hasRequiredEsnext_asyncIterator_indexed;

function requireEsnext_asyncIterator_indexed () {
	if (hasRequiredEsnext_asyncIterator_indexed) return esnext_asyncIterator_indexed;
	hasRequiredEsnext_asyncIterator_indexed = 1;
	var $ = require_export();
	var indexed = requireAsyncIteratorIndexed();
	$({ target: 'AsyncIterator', proto: true, real: true, forced: true }, {
	  indexed: indexed
	});
	return esnext_asyncIterator_indexed;
}

var esnext_iterator_asIndexedPairs = {};

var iteratorIndexed;
var hasRequiredIteratorIndexed;

function requireIteratorIndexed () {
	if (hasRequiredIteratorIndexed) return iteratorIndexed;
	hasRequiredIteratorIndexed = 1;
	requireEs_iterator_map();
	var call = requireFunctionCall();
	var map = requireIteratorsCore().IteratorPrototype.map;
	var callback = function (value, counter) {
	  return [counter, value];
	};
	iteratorIndexed = function indexed() {
	  return call(map, this, callback);
	};
	return iteratorIndexed;
}

var hasRequiredEsnext_iterator_asIndexedPairs;

function requireEsnext_iterator_asIndexedPairs () {
	if (hasRequiredEsnext_iterator_asIndexedPairs) return esnext_iterator_asIndexedPairs;
	hasRequiredEsnext_iterator_asIndexedPairs = 1;
	var $ = require_export();
	var indexed = requireIteratorIndexed();
	$({ target: 'Iterator', name: 'indexed', proto: true, real: true, forced: true }, {
	  asIndexedPairs: indexed
	});
	return esnext_iterator_asIndexedPairs;
}

var esnext_iterator_indexed = {};

var hasRequiredEsnext_iterator_indexed;

function requireEsnext_iterator_indexed () {
	if (hasRequiredEsnext_iterator_indexed) return esnext_iterator_indexed;
	hasRequiredEsnext_iterator_indexed = 1;
	var $ = require_export();
	var indexed = requireIteratorIndexed();
	$({ target: 'Iterator', proto: true, real: true, forced: true }, {
	  indexed: indexed
	});
	return esnext_iterator_indexed;
}

var hasRequiredIteratorHelpers;

function requireIteratorHelpers () {
	if (hasRequiredIteratorHelpers) return iteratorHelpers;
	hasRequiredIteratorHelpers = 1;
	requireIteratorHelpersStage3();
	requireEsnext_asyncIterator_asIndexedPairs();
	requireEsnext_asyncIterator_indexed();
	requireEsnext_iterator_asIndexedPairs();
	requireEsnext_iterator_indexed();
	return iteratorHelpers;
}

requireIteratorHelpers();

const align = {
    right: alignRight,
    center: alignCenter
};
const top = 0;
const right = 1;
const bottom = 2;
const left = 3;
class UI {
    constructor(opts) {
        var _a;
        this.width = opts.width;
        this.wrap = (_a = opts.wrap) !== null && _a !== void 0 ? _a : true;
        this.rows = [];
    }
    span(...args) {
        const cols = this.div(...args);
        cols.span = true;
    }
    resetOutput() {
        this.rows = [];
    }
    div(...args) {
        if (args.length === 0) {
            this.div('');
        }
        if (this.wrap && this.shouldApplyLayoutDSL(...args) && typeof args[0] === 'string') {
            return this.applyLayoutDSL(args[0]);
        }
        const cols = args.map(arg => {
            if (typeof arg === 'string') {
                return this.colFromString(arg);
            }
            return arg;
        });
        this.rows.push(cols);
        return cols;
    }
    shouldApplyLayoutDSL(...args) {
        return args.length === 1 && typeof args[0] === 'string' &&
            /[\t\n]/.test(args[0]);
    }
    applyLayoutDSL(str) {
        const rows = str.split('\n').map(row => row.split('\t'));
        let leftColumnWidth = 0;
        rows.forEach(columns => {
            if (columns.length > 1 && mixin$1.stringWidth(columns[0]) > leftColumnWidth) {
                leftColumnWidth = Math.min(Math.floor(this.width * 0.5), mixin$1.stringWidth(columns[0]));
            }
        });
        rows.forEach(columns => {
            this.div(...columns.map((r, i) => {
                return {
                    text: r.trim(),
                    padding: this.measurePadding(r),
                    width: (i === 0 && columns.length > 1) ? leftColumnWidth : undefined
                };
            }));
        });
        return this.rows[this.rows.length - 1];
    }
    colFromString(text) {
        return {
            text,
            padding: this.measurePadding(text)
        };
    }
    measurePadding(str) {
        const noAnsi = mixin$1.stripAnsi(str);
        return [0, noAnsi.match(/\s*$/)[0].length, 0, noAnsi.match(/^\s*/)[0].length];
    }
    toString() {
        const lines = [];
        this.rows.forEach(row => {
            this.rowToString(row, lines);
        });
        return lines
            .filter(line => !line.hidden)
            .map(line => line.text)
            .join('\n');
    }
    rowToString(row, lines) {
        this.rasterize(row).forEach((rrow, r) => {
            let str = '';
            rrow.forEach((col, c) => {
                const { width } = row[c];
                const wrapWidth = this.negatePadding(row[c]);
                let ts = col;
                if (wrapWidth > mixin$1.stringWidth(col)) {
                    ts += ' '.repeat(wrapWidth - mixin$1.stringWidth(col));
                }
                if (row[c].align && row[c].align !== 'left' && this.wrap) {
                    const fn = align[row[c].align];
                    ts = fn(ts, wrapWidth);
                    if (mixin$1.stringWidth(ts) < wrapWidth) {
                        ts += ' '.repeat((width || 0) - mixin$1.stringWidth(ts) - 1);
                    }
                }
                const padding = row[c].padding || [0, 0, 0, 0];
                if (padding[left]) {
                    str += ' '.repeat(padding[left]);
                }
                str += addBorder(row[c], ts, '| ');
                str += ts;
                str += addBorder(row[c], ts, ' |');
                if (padding[right]) {
                    str += ' '.repeat(padding[right]);
                }
                if (r === 0 && lines.length > 0) {
                    str = this.renderInline(str, lines[lines.length - 1]);
                }
            });
            lines.push({
                text: str.replace(/ +$/, ''),
                span: row.span
            });
        });
        return lines;
    }
    renderInline(source, previousLine) {
        const match = source.match(/^ */);
        const leadingWhitespace = match ? match[0].length : 0;
        const target = previousLine.text;
        const targetTextWidth = mixin$1.stringWidth(target.trimRight());
        if (!previousLine.span) {
            return source;
        }
        if (!this.wrap) {
            previousLine.hidden = true;
            return target + source;
        }
        if (leadingWhitespace < targetTextWidth) {
            return source;
        }
        previousLine.hidden = true;
        return target.trimRight() + ' '.repeat(leadingWhitespace - targetTextWidth) + source.trimLeft();
    }
    rasterize(row) {
        const rrows = [];
        const widths = this.columnWidths(row);
        let wrapped;
        row.forEach((col, c) => {
            col.width = widths[c];
            if (this.wrap) {
                wrapped = mixin$1.wrap(col.text, this.negatePadding(col), { hard: true }).split('\n');
            }
            else {
                wrapped = col.text.split('\n');
            }
            if (col.border) {
                wrapped.unshift('.' + '-'.repeat(this.negatePadding(col) + 2) + '.');
                wrapped.push("'" + '-'.repeat(this.negatePadding(col) + 2) + "'");
            }
            if (col.padding) {
                wrapped.unshift(...new Array(col.padding[top] || 0).fill(''));
                wrapped.push(...new Array(col.padding[bottom] || 0).fill(''));
            }
            wrapped.forEach((str, r) => {
                if (!rrows[r]) {
                    rrows.push([]);
                }
                const rrow = rrows[r];
                for (let i = 0; i < c; i++) {
                    if (rrow[i] === undefined) {
                        rrow.push('');
                    }
                }
                rrow.push(str);
            });
        });
        return rrows;
    }
    negatePadding(col) {
        let wrapWidth = col.width || 0;
        if (col.padding) {
            wrapWidth -= (col.padding[left] || 0) + (col.padding[right] || 0);
        }
        if (col.border) {
            wrapWidth -= 4;
        }
        return wrapWidth;
    }
    columnWidths(row) {
        if (!this.wrap) {
            return row.map(col => {
                return col.width || mixin$1.stringWidth(col.text);
            });
        }
        let unset = row.length;
        let remainingWidth = this.width;
        const widths = row.map(col => {
            if (col.width) {
                unset--;
                remainingWidth -= col.width;
                return col.width;
            }
            return undefined;
        });
        const unsetWidth = unset ? Math.floor(remainingWidth / unset) : 0;
        return widths.map((w, i) => {
            if (w === undefined) {
                return Math.max(unsetWidth, _minWidth(row[i]));
            }
            return w;
        });
    }
}
function addBorder(col, ts, style) {
    if (col.border) {
        if (/[.']-+[.']/.test(ts)) {
            return '';
        }
        if (ts.trim().length !== 0) {
            return style;
        }
        return '  ';
    }
    return '';
}
function _minWidth(col) {
    const padding = col.padding || [];
    const minWidth = 1 + (padding[left] || 0) + (padding[right] || 0);
    if (col.border) {
        return minWidth + 4;
    }
    return minWidth;
}
function getWindowWidth() {
    if (typeof process === 'object' && process.stdout && process.stdout.columns) {
        return process.stdout.columns;
    }
    return 80;
}
function alignRight(str, width) {
    str = str.trim();
    const strWidth = mixin$1.stringWidth(str);
    if (strWidth < width) {
        return ' '.repeat(width - strWidth) + str;
    }
    return str;
}
function alignCenter(str, width) {
    str = str.trim();
    const strWidth = mixin$1.stringWidth(str);
    if (strWidth >= width) {
        return str;
    }
    return ' '.repeat((width - strWidth) >> 1) + str;
}
let mixin$1;
function cliui(opts, _mixin) {
    mixin$1 = _mixin;
    return new UI({
        width: (opts === null || opts === void 0 ? void 0 : opts.width) || getWindowWidth(),
        wrap: opts === null || opts === void 0 ? void 0 : opts.wrap
    });
}

function ansiRegex({onlyFirst = false} = {}) {
	const ST = '(?:\\u0007|\\u001B\\u005C|\\u009C)';
	const osc = `(?:\\u001B\\][\\s\\S]*?${ST})`;
	const csi = '[\\u001B\\u009B][[\\]()#;?]*(?:\\d{1,4}(?:[;:]\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]';
	const pattern = `${osc}|${csi}`;
	return new RegExp(pattern, onlyFirst ? undefined : 'g');
}

const regex = ansiRegex();
function stripAnsi(string) {
	if (typeof string !== 'string') {
		throw new TypeError(`Expected a \`string\`, got \`${typeof string}\``);
	}
	return string.replace(regex, '');
}

function isAmbiguous(x) {
	return x === 0xA1
		|| x === 0xA4
		|| x === 0xA7
		|| x === 0xA8
		|| x === 0xAA
		|| x === 0xAD
		|| x === 0xAE
		|| x >= 0xB0 && x <= 0xB4
		|| x >= 0xB6 && x <= 0xBA
		|| x >= 0xBC && x <= 0xBF
		|| x === 0xC6
		|| x === 0xD0
		|| x === 0xD7
		|| x === 0xD8
		|| x >= 0xDE && x <= 0xE1
		|| x === 0xE6
		|| x >= 0xE8 && x <= 0xEA
		|| x === 0xEC
		|| x === 0xED
		|| x === 0xF0
		|| x === 0xF2
		|| x === 0xF3
		|| x >= 0xF7 && x <= 0xFA
		|| x === 0xFC
		|| x === 0xFE
		|| x === 0x101
		|| x === 0x111
		|| x === 0x113
		|| x === 0x11B
		|| x === 0x126
		|| x === 0x127
		|| x === 0x12B
		|| x >= 0x131 && x <= 0x133
		|| x === 0x138
		|| x >= 0x13F && x <= 0x142
		|| x === 0x144
		|| x >= 0x148 && x <= 0x14B
		|| x === 0x14D
		|| x === 0x152
		|| x === 0x153
		|| x === 0x166
		|| x === 0x167
		|| x === 0x16B
		|| x === 0x1CE
		|| x === 0x1D0
		|| x === 0x1D2
		|| x === 0x1D4
		|| x === 0x1D6
		|| x === 0x1D8
		|| x === 0x1DA
		|| x === 0x1DC
		|| x === 0x251
		|| x === 0x261
		|| x === 0x2C4
		|| x === 0x2C7
		|| x >= 0x2C9 && x <= 0x2CB
		|| x === 0x2CD
		|| x === 0x2D0
		|| x >= 0x2D8 && x <= 0x2DB
		|| x === 0x2DD
		|| x === 0x2DF
		|| x >= 0x300 && x <= 0x36F
		|| x >= 0x391 && x <= 0x3A1
		|| x >= 0x3A3 && x <= 0x3A9
		|| x >= 0x3B1 && x <= 0x3C1
		|| x >= 0x3C3 && x <= 0x3C9
		|| x === 0x401
		|| x >= 0x410 && x <= 0x44F
		|| x === 0x451
		|| x === 0x2010
		|| x >= 0x2013 && x <= 0x2016
		|| x === 0x2018
		|| x === 0x2019
		|| x === 0x201C
		|| x === 0x201D
		|| x >= 0x2020 && x <= 0x2022
		|| x >= 0x2024 && x <= 0x2027
		|| x === 0x2030
		|| x === 0x2032
		|| x === 0x2033
		|| x === 0x2035
		|| x === 0x203B
		|| x === 0x203E
		|| x === 0x2074
		|| x === 0x207F
		|| x >= 0x2081 && x <= 0x2084
		|| x === 0x20AC
		|| x === 0x2103
		|| x === 0x2105
		|| x === 0x2109
		|| x === 0x2113
		|| x === 0x2116
		|| x === 0x2121
		|| x === 0x2122
		|| x === 0x2126
		|| x === 0x212B
		|| x === 0x2153
		|| x === 0x2154
		|| x >= 0x215B && x <= 0x215E
		|| x >= 0x2160 && x <= 0x216B
		|| x >= 0x2170 && x <= 0x2179
		|| x === 0x2189
		|| x >= 0x2190 && x <= 0x2199
		|| x === 0x21B8
		|| x === 0x21B9
		|| x === 0x21D2
		|| x === 0x21D4
		|| x === 0x21E7
		|| x === 0x2200
		|| x === 0x2202
		|| x === 0x2203
		|| x === 0x2207
		|| x === 0x2208
		|| x === 0x220B
		|| x === 0x220F
		|| x === 0x2211
		|| x === 0x2215
		|| x === 0x221A
		|| x >= 0x221D && x <= 0x2220
		|| x === 0x2223
		|| x === 0x2225
		|| x >= 0x2227 && x <= 0x222C
		|| x === 0x222E
		|| x >= 0x2234 && x <= 0x2237
		|| x === 0x223C
		|| x === 0x223D
		|| x === 0x2248
		|| x === 0x224C
		|| x === 0x2252
		|| x === 0x2260
		|| x === 0x2261
		|| x >= 0x2264 && x <= 0x2267
		|| x === 0x226A
		|| x === 0x226B
		|| x === 0x226E
		|| x === 0x226F
		|| x === 0x2282
		|| x === 0x2283
		|| x === 0x2286
		|| x === 0x2287
		|| x === 0x2295
		|| x === 0x2299
		|| x === 0x22A5
		|| x === 0x22BF
		|| x === 0x2312
		|| x >= 0x2460 && x <= 0x24E9
		|| x >= 0x24EB && x <= 0x254B
		|| x >= 0x2550 && x <= 0x2573
		|| x >= 0x2580 && x <= 0x258F
		|| x >= 0x2592 && x <= 0x2595
		|| x === 0x25A0
		|| x === 0x25A1
		|| x >= 0x25A3 && x <= 0x25A9
		|| x === 0x25B2
		|| x === 0x25B3
		|| x === 0x25B6
		|| x === 0x25B7
		|| x === 0x25BC
		|| x === 0x25BD
		|| x === 0x25C0
		|| x === 0x25C1
		|| x >= 0x25C6 && x <= 0x25C8
		|| x === 0x25CB
		|| x >= 0x25CE && x <= 0x25D1
		|| x >= 0x25E2 && x <= 0x25E5
		|| x === 0x25EF
		|| x === 0x2605
		|| x === 0x2606
		|| x === 0x2609
		|| x === 0x260E
		|| x === 0x260F
		|| x === 0x261C
		|| x === 0x261E
		|| x === 0x2640
		|| x === 0x2642
		|| x === 0x2660
		|| x === 0x2661
		|| x >= 0x2663 && x <= 0x2665
		|| x >= 0x2667 && x <= 0x266A
		|| x === 0x266C
		|| x === 0x266D
		|| x === 0x266F
		|| x === 0x269E
		|| x === 0x269F
		|| x === 0x26BF
		|| x >= 0x26C6 && x <= 0x26CD
		|| x >= 0x26CF && x <= 0x26D3
		|| x >= 0x26D5 && x <= 0x26E1
		|| x === 0x26E3
		|| x === 0x26E8
		|| x === 0x26E9
		|| x >= 0x26EB && x <= 0x26F1
		|| x === 0x26F4
		|| x >= 0x26F6 && x <= 0x26F9
		|| x === 0x26FB
		|| x === 0x26FC
		|| x === 0x26FE
		|| x === 0x26FF
		|| x === 0x273D
		|| x >= 0x2776 && x <= 0x277F
		|| x >= 0x2B56 && x <= 0x2B59
		|| x >= 0x3248 && x <= 0x324F
		|| x >= 0xE000 && x <= 0xF8FF
		|| x >= 0xFE00 && x <= 0xFE0F
		|| x === 0xFFFD
		|| x >= 0x1F100 && x <= 0x1F10A
		|| x >= 0x1F110 && x <= 0x1F12D
		|| x >= 0x1F130 && x <= 0x1F169
		|| x >= 0x1F170 && x <= 0x1F18D
		|| x === 0x1F18F
		|| x === 0x1F190
		|| x >= 0x1F19B && x <= 0x1F1AC
		|| x >= 0xE0100 && x <= 0xE01EF
		|| x >= 0xF0000 && x <= 0xFFFFD
		|| x >= 0x100000 && x <= 0x10FFFD;
}
function isFullWidth(x) {
	return x === 0x3000
		|| x >= 0xFF01 && x <= 0xFF60
		|| x >= 0xFFE0 && x <= 0xFFE6;
}
function isWide(x) {
	return x >= 0x1100 && x <= 0x115F
		|| x === 0x231A
		|| x === 0x231B
		|| x === 0x2329
		|| x === 0x232A
		|| x >= 0x23E9 && x <= 0x23EC
		|| x === 0x23F0
		|| x === 0x23F3
		|| x === 0x25FD
		|| x === 0x25FE
		|| x === 0x2614
		|| x === 0x2615
		|| x >= 0x2630 && x <= 0x2637
		|| x >= 0x2648 && x <= 0x2653
		|| x === 0x267F
		|| x >= 0x268A && x <= 0x268F
		|| x === 0x2693
		|| x === 0x26A1
		|| x === 0x26AA
		|| x === 0x26AB
		|| x === 0x26BD
		|| x === 0x26BE
		|| x === 0x26C4
		|| x === 0x26C5
		|| x === 0x26CE
		|| x === 0x26D4
		|| x === 0x26EA
		|| x === 0x26F2
		|| x === 0x26F3
		|| x === 0x26F5
		|| x === 0x26FA
		|| x === 0x26FD
		|| x === 0x2705
		|| x === 0x270A
		|| x === 0x270B
		|| x === 0x2728
		|| x === 0x274C
		|| x === 0x274E
		|| x >= 0x2753 && x <= 0x2755
		|| x === 0x2757
		|| x >= 0x2795 && x <= 0x2797
		|| x === 0x27B0
		|| x === 0x27BF
		|| x === 0x2B1B
		|| x === 0x2B1C
		|| x === 0x2B50
		|| x === 0x2B55
		|| x >= 0x2E80 && x <= 0x2E99
		|| x >= 0x2E9B && x <= 0x2EF3
		|| x >= 0x2F00 && x <= 0x2FD5
		|| x >= 0x2FF0 && x <= 0x2FFF
		|| x >= 0x3001 && x <= 0x303E
		|| x >= 0x3041 && x <= 0x3096
		|| x >= 0x3099 && x <= 0x30FF
		|| x >= 0x3105 && x <= 0x312F
		|| x >= 0x3131 && x <= 0x318E
		|| x >= 0x3190 && x <= 0x31E5
		|| x >= 0x31EF && x <= 0x321E
		|| x >= 0x3220 && x <= 0x3247
		|| x >= 0x3250 && x <= 0xA48C
		|| x >= 0xA490 && x <= 0xA4C6
		|| x >= 0xA960 && x <= 0xA97C
		|| x >= 0xAC00 && x <= 0xD7A3
		|| x >= 0xF900 && x <= 0xFAFF
		|| x >= 0xFE10 && x <= 0xFE19
		|| x >= 0xFE30 && x <= 0xFE52
		|| x >= 0xFE54 && x <= 0xFE66
		|| x >= 0xFE68 && x <= 0xFE6B
		|| x >= 0x16FE0 && x <= 0x16FE4
		|| x >= 0x16FF0 && x <= 0x16FF6
		|| x >= 0x17000 && x <= 0x18CD5
		|| x >= 0x18CFF && x <= 0x18D1E
		|| x >= 0x18D80 && x <= 0x18DF2
		|| x >= 0x1AFF0 && x <= 0x1AFF3
		|| x >= 0x1AFF5 && x <= 0x1AFFB
		|| x === 0x1AFFD
		|| x === 0x1AFFE
		|| x >= 0x1B000 && x <= 0x1B122
		|| x === 0x1B132
		|| x >= 0x1B150 && x <= 0x1B152
		|| x === 0x1B155
		|| x >= 0x1B164 && x <= 0x1B167
		|| x >= 0x1B170 && x <= 0x1B2FB
		|| x >= 0x1D300 && x <= 0x1D356
		|| x >= 0x1D360 && x <= 0x1D376
		|| x === 0x1F004
		|| x === 0x1F0CF
		|| x === 0x1F18E
		|| x >= 0x1F191 && x <= 0x1F19A
		|| x >= 0x1F200 && x <= 0x1F202
		|| x >= 0x1F210 && x <= 0x1F23B
		|| x >= 0x1F240 && x <= 0x1F248
		|| x === 0x1F250
		|| x === 0x1F251
		|| x >= 0x1F260 && x <= 0x1F265
		|| x >= 0x1F300 && x <= 0x1F320
		|| x >= 0x1F32D && x <= 0x1F335
		|| x >= 0x1F337 && x <= 0x1F37C
		|| x >= 0x1F37E && x <= 0x1F393
		|| x >= 0x1F3A0 && x <= 0x1F3CA
		|| x >= 0x1F3CF && x <= 0x1F3D3
		|| x >= 0x1F3E0 && x <= 0x1F3F0
		|| x === 0x1F3F4
		|| x >= 0x1F3F8 && x <= 0x1F43E
		|| x === 0x1F440
		|| x >= 0x1F442 && x <= 0x1F4FC
		|| x >= 0x1F4FF && x <= 0x1F53D
		|| x >= 0x1F54B && x <= 0x1F54E
		|| x >= 0x1F550 && x <= 0x1F567
		|| x === 0x1F57A
		|| x === 0x1F595
		|| x === 0x1F596
		|| x === 0x1F5A4
		|| x >= 0x1F5FB && x <= 0x1F64F
		|| x >= 0x1F680 && x <= 0x1F6C5
		|| x === 0x1F6CC
		|| x >= 0x1F6D0 && x <= 0x1F6D2
		|| x >= 0x1F6D5 && x <= 0x1F6D8
		|| x >= 0x1F6DC && x <= 0x1F6DF
		|| x === 0x1F6EB
		|| x === 0x1F6EC
		|| x >= 0x1F6F4 && x <= 0x1F6FC
		|| x >= 0x1F7E0 && x <= 0x1F7EB
		|| x === 0x1F7F0
		|| x >= 0x1F90C && x <= 0x1F93A
		|| x >= 0x1F93C && x <= 0x1F945
		|| x >= 0x1F947 && x <= 0x1F9FF
		|| x >= 0x1FA70 && x <= 0x1FA7C
		|| x >= 0x1FA80 && x <= 0x1FA8A
		|| x >= 0x1FA8E && x <= 0x1FAC6
		|| x === 0x1FAC8
		|| x >= 0x1FACD && x <= 0x1FADC
		|| x >= 0x1FADF && x <= 0x1FAEA
		|| x >= 0x1FAEF && x <= 0x1FAF8
		|| x >= 0x20000 && x <= 0x2FFFD
		|| x >= 0x30000 && x <= 0x3FFFD;
}

function validate$1(codePoint) {
	if (!Number.isSafeInteger(codePoint)) {
		throw new TypeError(`Expected a code point, got \`${typeof codePoint}\`.`);
	}
}
function eastAsianWidth(codePoint, {ambiguousAsWide = false} = {}) {
	validate$1(codePoint);
	if (
		isFullWidth(codePoint)
		|| isWide(codePoint)
		|| (ambiguousAsWide && isAmbiguous(codePoint))
	) {
		return 2;
	}
	return 1;
}

var emojiRegex$2 = () => {
	return /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E-\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED8\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFC-\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFB-\uDFFE])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFB-\uDFFE])))?))?|\uDD75(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3C-\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE8A\uDE8E-\uDEC2\uDEC6\uDEC8\uDECD-\uDEDC\uDEDF-\uDEEA\uDEEF]|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
};

const segmenter = new Intl.Segmenter();
const defaultIgnorableCodePointRegex = /^\p{Default_Ignorable_Code_Point}$/u;
function stringWidth(string, options = {}) {
	if (typeof string !== 'string' || string.length === 0) {
		return 0;
	}
	const {
		ambiguousIsNarrow = true,
		countAnsiEscapeCodes = false,
	} = options;
	if (!countAnsiEscapeCodes) {
		string = stripAnsi(string);
	}
	if (string.length === 0) {
		return 0;
	}
	let width = 0;
	const eastAsianWidthOptions = {ambiguousAsWide: !ambiguousIsNarrow};
	for (const {segment: character} of segmenter.segment(string)) {
		const codePoint = character.codePointAt(0);
		if (codePoint <= 0x1F || (codePoint >= 0x7F && codePoint <= 0x9F)) {
			continue;
		}
		if (
			(codePoint >= 0x20_0B && codePoint <= 0x20_0F)
			|| codePoint === 0xFE_FF
		) {
			continue;
		}
		if (
			(codePoint >= 0x3_00 && codePoint <= 0x3_6F)
			|| (codePoint >= 0x1A_B0 && codePoint <= 0x1A_FF)
			|| (codePoint >= 0x1D_C0 && codePoint <= 0x1D_FF)
			|| (codePoint >= 0x20_D0 && codePoint <= 0x20_FF)
			|| (codePoint >= 0xFE_20 && codePoint <= 0xFE_2F)
		) {
			continue;
		}
		if (codePoint >= 0xD8_00 && codePoint <= 0xDF_FF) {
			continue;
		}
		if (codePoint >= 0xFE_00 && codePoint <= 0xFE_0F) {
			continue;
		}
		if (defaultIgnorableCodePointRegex.test(character)) {
			continue;
		}
		if (emojiRegex$2().test(character)) {
			width += 2;
			continue;
		}
		width += eastAsianWidth(codePoint, eastAsianWidthOptions);
	}
	return width;
}

const ANSI_BACKGROUND_OFFSET = 10;
const wrapAnsi16 = (offset = 0) => code => `\u001B[${code + offset}m`;
const wrapAnsi256 = (offset = 0) => code => `\u001B[${38 + offset};5;${code}m`;
const wrapAnsi16m = (offset = 0) => (red, green, blue) => `\u001B[${38 + offset};2;${red};${green};${blue}m`;
const styles = {
	modifier: {
		reset: [0, 0],
		bold: [1, 22],
		dim: [2, 22],
		italic: [3, 23],
		underline: [4, 24],
		overline: [53, 55],
		inverse: [7, 27],
		hidden: [8, 28],
		strikethrough: [9, 29],
	},
	color: {
		black: [30, 39],
		red: [31, 39],
		green: [32, 39],
		yellow: [33, 39],
		blue: [34, 39],
		magenta: [35, 39],
		cyan: [36, 39],
		white: [37, 39],
		blackBright: [90, 39],
		gray: [90, 39],
		grey: [90, 39],
		redBright: [91, 39],
		greenBright: [92, 39],
		yellowBright: [93, 39],
		blueBright: [94, 39],
		magentaBright: [95, 39],
		cyanBright: [96, 39],
		whiteBright: [97, 39],
	},
	bgColor: {
		bgBlack: [40, 49],
		bgRed: [41, 49],
		bgGreen: [42, 49],
		bgYellow: [43, 49],
		bgBlue: [44, 49],
		bgMagenta: [45, 49],
		bgCyan: [46, 49],
		bgWhite: [47, 49],
		bgBlackBright: [100, 49],
		bgGray: [100, 49],
		bgGrey: [100, 49],
		bgRedBright: [101, 49],
		bgGreenBright: [102, 49],
		bgYellowBright: [103, 49],
		bgBlueBright: [104, 49],
		bgMagentaBright: [105, 49],
		bgCyanBright: [106, 49],
		bgWhiteBright: [107, 49],
	},
};
Object.keys(styles.modifier);
const foregroundColorNames = Object.keys(styles.color);
const backgroundColorNames = Object.keys(styles.bgColor);
[...foregroundColorNames, ...backgroundColorNames];
function assembleStyles() {
	const codes = new Map();
	for (const [groupName, group] of Object.entries(styles)) {
		for (const [styleName, style] of Object.entries(group)) {
			styles[styleName] = {
				open: `\u001B[${style[0]}m`,
				close: `\u001B[${style[1]}m`,
			};
			group[styleName] = styles[styleName];
			codes.set(style[0], style[1]);
		}
		Object.defineProperty(styles, groupName, {
			value: group,
			enumerable: false,
		});
	}
	Object.defineProperty(styles, 'codes', {
		value: codes,
		enumerable: false,
	});
	styles.color.close = '\u001B[39m';
	styles.bgColor.close = '\u001B[49m';
	styles.color.ansi = wrapAnsi16();
	styles.color.ansi256 = wrapAnsi256();
	styles.color.ansi16m = wrapAnsi16m();
	styles.bgColor.ansi = wrapAnsi16(ANSI_BACKGROUND_OFFSET);
	styles.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
	styles.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
	Object.defineProperties(styles, {
		rgbToAnsi256: {
			value(red, green, blue) {
				if (red === green && green === blue) {
					if (red < 8) {
						return 16;
					}
					if (red > 248) {
						return 231;
					}
					return Math.round(((red - 8) / 247) * 24) + 232;
				}
				return 16
					+ (36 * Math.round(red / 255 * 5))
					+ (6 * Math.round(green / 255 * 5))
					+ Math.round(blue / 255 * 5);
			},
			enumerable: false,
		},
		hexToRgb: {
			value(hex) {
				const matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
				if (!matches) {
					return [0, 0, 0];
				}
				let [colorString] = matches;
				if (colorString.length === 3) {
					colorString = [...colorString].map(character => character + character).join('');
				}
				const integer = Number.parseInt(colorString, 16);
				return [
					(integer >> 16) & 0xFF,
					(integer >> 8) & 0xFF,
					integer & 0xFF,
				];
			},
			enumerable: false,
		},
		hexToAnsi256: {
			value: hex => styles.rgbToAnsi256(...styles.hexToRgb(hex)),
			enumerable: false,
		},
		ansi256ToAnsi: {
			value(code) {
				if (code < 8) {
					return 30 + code;
				}
				if (code < 16) {
					return 90 + (code - 8);
				}
				let red;
				let green;
				let blue;
				if (code >= 232) {
					red = (((code - 232) * 10) + 8) / 255;
					green = red;
					blue = red;
				} else {
					code -= 16;
					const remainder = code % 36;
					red = Math.floor(code / 36) / 5;
					green = Math.floor(remainder / 6) / 5;
					blue = (remainder % 6) / 5;
				}
				const value = Math.max(red, green, blue) * 2;
				if (value === 0) {
					return 30;
				}
				let result = 30 + ((Math.round(blue) << 2) | (Math.round(green) << 1) | Math.round(red));
				if (value === 2) {
					result += 60;
				}
				return result;
			},
			enumerable: false,
		},
		rgbToAnsi: {
			value: (red, green, blue) => styles.ansi256ToAnsi(styles.rgbToAnsi256(red, green, blue)),
			enumerable: false,
		},
		hexToAnsi: {
			value: hex => styles.ansi256ToAnsi(styles.hexToAnsi256(hex)),
			enumerable: false,
		},
	});
	return styles;
}
const ansiStyles = assembleStyles();

const ESCAPES = new Set([
	'\u001B',
	'\u009B',
]);
const END_CODE = 39;
const ANSI_ESCAPE_BELL = '\u0007';
const ANSI_CSI = '[';
const ANSI_OSC = ']';
const ANSI_SGR_TERMINATOR = 'm';
const ANSI_ESCAPE_LINK = `${ANSI_OSC}8;;`;
const wrapAnsiCode = code => `${ESCAPES.values().next().value}${ANSI_CSI}${code}${ANSI_SGR_TERMINATOR}`;
const wrapAnsiHyperlink = url => `${ESCAPES.values().next().value}${ANSI_ESCAPE_LINK}${url}${ANSI_ESCAPE_BELL}`;
const wordLengths = string => string.split(' ').map(character => stringWidth(character));
const wrapWord = (rows, word, columns) => {
	const characters = [...word];
	let isInsideEscape = false;
	let isInsideLinkEscape = false;
	let visible = stringWidth(stripAnsi(rows.at(-1)));
	for (const [index, character] of characters.entries()) {
		const characterLength = stringWidth(character);
		if (visible + characterLength <= columns) {
			rows[rows.length - 1] += character;
		} else {
			rows.push(character);
			visible = 0;
		}
		if (ESCAPES.has(character)) {
			isInsideEscape = true;
			const ansiEscapeLinkCandidate = characters.slice(index + 1, index + 1 + ANSI_ESCAPE_LINK.length).join('');
			isInsideLinkEscape = ansiEscapeLinkCandidate === ANSI_ESCAPE_LINK;
		}
		if (isInsideEscape) {
			if (isInsideLinkEscape) {
				if (character === ANSI_ESCAPE_BELL) {
					isInsideEscape = false;
					isInsideLinkEscape = false;
				}
			} else if (character === ANSI_SGR_TERMINATOR) {
				isInsideEscape = false;
			}
			continue;
		}
		visible += characterLength;
		if (visible === columns && index < characters.length - 1) {
			rows.push('');
			visible = 0;
		}
	}
	if (!visible && rows.at(-1).length > 0 && rows.length > 1) {
		rows[rows.length - 2] += rows.pop();
	}
};
const stringVisibleTrimSpacesRight = string => {
	const words = string.split(' ');
	let last = words.length;
	while (last > 0) {
		if (stringWidth(words[last - 1]) > 0) {
			break;
		}
		last--;
	}
	if (last === words.length) {
		return string;
	}
	return words.slice(0, last).join(' ') + words.slice(last).join('');
};
const exec = (string, columns, options = {}) => {
	if (options.trim !== false && string.trim() === '') {
		return '';
	}
	let returnValue = '';
	let escapeCode;
	let escapeUrl;
	const lengths = wordLengths(string);
	let rows = [''];
	for (const [index, word] of string.split(' ').entries()) {
		if (options.trim !== false) {
			rows[rows.length - 1] = rows.at(-1).trimStart();
		}
		let rowLength = stringWidth(rows.at(-1));
		if (index !== 0) {
			if (rowLength >= columns && (options.wordWrap === false || options.trim === false)) {
				rows.push('');
				rowLength = 0;
			}
			if (rowLength > 0 || options.trim === false) {
				rows[rows.length - 1] += ' ';
				rowLength++;
			}
		}
		if (options.hard && lengths[index] > columns) {
			const remainingColumns = (columns - rowLength);
			const breaksStartingThisLine = 1 + Math.floor((lengths[index] - remainingColumns - 1) / columns);
			const breaksStartingNextLine = Math.floor((lengths[index] - 1) / columns);
			if (breaksStartingNextLine < breaksStartingThisLine) {
				rows.push('');
			}
			wrapWord(rows, word, columns);
			continue;
		}
		if (rowLength + lengths[index] > columns && rowLength > 0 && lengths[index] > 0) {
			if (options.wordWrap === false && rowLength < columns) {
				wrapWord(rows, word, columns);
				continue;
			}
			rows.push('');
		}
		if (rowLength + lengths[index] > columns && options.wordWrap === false) {
			wrapWord(rows, word, columns);
			continue;
		}
		rows[rows.length - 1] += word;
	}
	if (options.trim !== false) {
		rows = rows.map(row => stringVisibleTrimSpacesRight(row));
	}
	const preString = rows.join('\n');
	const pre = [...preString];
	let preStringIndex = 0;
	for (const [index, character] of pre.entries()) {
		returnValue += character;
		if (ESCAPES.has(character)) {
			const {groups} = new RegExp(`(?:\\${ANSI_CSI}(?<code>\\d+)m|\\${ANSI_ESCAPE_LINK}(?<uri>.*)${ANSI_ESCAPE_BELL})`).exec(preString.slice(preStringIndex)) || {groups: {}};
			if (groups.code !== undefined) {
				const code = Number.parseFloat(groups.code);
				escapeCode = code === END_CODE ? undefined : code;
			} else if (groups.uri !== undefined) {
				escapeUrl = groups.uri.length === 0 ? undefined : groups.uri;
			}
		}
		const code = ansiStyles.codes.get(Number(escapeCode));
		if (pre[index + 1] === '\n') {
			if (escapeUrl) {
				returnValue += wrapAnsiHyperlink('');
			}
			if (escapeCode && code) {
				returnValue += wrapAnsiCode(code);
			}
		} else if (character === '\n') {
			if (escapeCode && code) {
				returnValue += wrapAnsiCode(escapeCode);
			}
			if (escapeUrl) {
				returnValue += wrapAnsiHyperlink(escapeUrl);
			}
		}
		preStringIndex += character.length;
	}
	return returnValue;
};
function wrapAnsi(string, columns, options) {
	return String(string)
		.normalize()
		.replaceAll('\r\n', '\n')
		.split('\n')
		.map(line => exec(line, columns, options))
		.join('\n');
}

function ui (opts) {
  return cliui(opts, {
    stringWidth,
    stripAnsi,
    wrap: wrapAnsi
  })
}

function escalade (start, callback) {
	let dir = resolve('.', start);
	let tmp, stats = statSync(dir);
	if (!stats.isDirectory()) {
		dir = dirname(dir);
	}
	while (true) {
		tmp = callback(dir, readdirSync(dir));
		if (tmp) return resolve(dir, tmp);
		dir = dirname(tmp = dir);
		if (tmp === dir) break;
	}
}

/**
 * @license
 * Copyright (c) 2016, Contributors
 * SPDX-License-Identifier: ISC
 */
function camelCase(str) {
    const isCamelCase = str !== str.toLowerCase() && str !== str.toUpperCase();
    if (!isCamelCase) {
        str = str.toLowerCase();
    }
    if (str.indexOf('-') === -1 && str.indexOf('_') === -1) {
        return str;
    }
    else {
        let camelcase = '';
        let nextChrUpper = false;
        const leadingHyphens = str.match(/^-+/);
        for (let i = leadingHyphens ? leadingHyphens[0].length : 0; i < str.length; i++) {
            let chr = str.charAt(i);
            if (nextChrUpper) {
                nextChrUpper = false;
                chr = chr.toUpperCase();
            }
            if (i !== 0 && (chr === '-' || chr === '_')) {
                nextChrUpper = true;
            }
            else if (chr !== '-' && chr !== '_') {
                camelcase += chr;
            }
        }
        return camelcase;
    }
}
function decamelize(str, joinString) {
    const lowercase = str.toLowerCase();
    joinString = joinString || '-';
    let notCamelcase = '';
    for (let i = 0; i < str.length; i++) {
        const chrLower = lowercase.charAt(i);
        const chrString = str.charAt(i);
        if (chrLower !== chrString && i > 0) {
            notCamelcase += `${joinString}${lowercase.charAt(i)}`;
        }
        else {
            notCamelcase += chrString;
        }
    }
    return notCamelcase;
}
function looksLikeNumber(x) {
    if (x === null || x === undefined)
        return false;
    if (typeof x === 'number')
        return true;
    if (/^0x[0-9a-f]+$/i.test(x))
        return true;
    if (/^0[^.]/.test(x))
        return false;
    return /^[-]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x);
}

/**
 * @license
 * Copyright (c) 2016, Contributors
 * SPDX-License-Identifier: ISC
 */
function tokenizeArgString(argString) {
    if (Array.isArray(argString)) {
        return argString.map(e => typeof e !== 'string' ? e + '' : e);
    }
    argString = argString.trim();
    let i = 0;
    let prevC = null;
    let c = null;
    let opening = null;
    const args = [];
    for (let ii = 0; ii < argString.length; ii++) {
        prevC = c;
        c = argString.charAt(ii);
        if (c === ' ' && !opening) {
            if (!(prevC === ' ')) {
                i++;
            }
            continue;
        }
        if (c === opening) {
            opening = null;
        }
        else if ((c === "'" || c === '"') && !opening) {
            opening = c;
        }
        if (!args[i])
            args[i] = '';
        args[i] += c;
    }
    return args;
}

/**
 * @license
 * Copyright (c) 2016, Contributors
 * SPDX-License-Identifier: ISC
 */
var DefaultValuesForTypeKey;
(function (DefaultValuesForTypeKey) {
    DefaultValuesForTypeKey["BOOLEAN"] = "boolean";
    DefaultValuesForTypeKey["STRING"] = "string";
    DefaultValuesForTypeKey["NUMBER"] = "number";
    DefaultValuesForTypeKey["ARRAY"] = "array";
})(DefaultValuesForTypeKey || (DefaultValuesForTypeKey = {}));

/**
 * @license
 * Copyright (c) 2016, Contributors
 * SPDX-License-Identifier: ISC
 */
let mixin;
class YargsParser {
    constructor(_mixin) {
        mixin = _mixin;
    }
    parse(argsInput, options) {
        const opts = Object.assign({
            alias: undefined,
            array: undefined,
            boolean: undefined,
            config: undefined,
            configObjects: undefined,
            configuration: undefined,
            coerce: undefined,
            count: undefined,
            default: undefined,
            envPrefix: undefined,
            narg: undefined,
            normalize: undefined,
            string: undefined,
            number: undefined,
            __: undefined,
            key: undefined
        }, options);
        const args = tokenizeArgString(argsInput);
        const inputIsString = typeof argsInput === 'string';
        const aliases = combineAliases(Object.assign(Object.create(null), opts.alias));
        const configuration = Object.assign({
            'boolean-negation': true,
            'camel-case-expansion': true,
            'combine-arrays': false,
            'dot-notation': true,
            'duplicate-arguments-array': true,
            'flatten-duplicate-arrays': true,
            'greedy-arrays': true,
            'halt-at-non-option': false,
            'nargs-eats-options': false,
            'negation-prefix': 'no-',
            'parse-numbers': true,
            'parse-positional-numbers': true,
            'populate--': false,
            'set-placeholder-key': false,
            'short-option-groups': true,
            'strip-aliased': false,
            'strip-dashed': false,
            'unknown-options-as-args': false
        }, opts.configuration);
        const defaults = Object.assign(Object.create(null), opts.default);
        const configObjects = opts.configObjects || [];
        const envPrefix = opts.envPrefix;
        const notFlagsOption = configuration['populate--'];
        const notFlagsArgv = notFlagsOption ? '--' : '_';
        const newAliases = Object.create(null);
        const defaulted = Object.create(null);
        const __ = opts.__ || mixin.format;
        const flags = {
            aliases: Object.create(null),
            arrays: Object.create(null),
            bools: Object.create(null),
            strings: Object.create(null),
            numbers: Object.create(null),
            counts: Object.create(null),
            normalize: Object.create(null),
            configs: Object.create(null),
            nargs: Object.create(null),
            coercions: Object.create(null),
            keys: []
        };
        const negative = /^-([0-9]+(\.[0-9]+)?|\.[0-9]+)$/;
        const negatedBoolean = new RegExp('^--' + configuration['negation-prefix'] + '(.+)');
        [].concat(opts.array || []).filter(Boolean).forEach(function (opt) {
            const key = typeof opt === 'object' ? opt.key : opt;
            const assignment = Object.keys(opt).map(function (key) {
                const arrayFlagKeys = {
                    boolean: 'bools',
                    string: 'strings',
                    number: 'numbers'
                };
                return arrayFlagKeys[key];
            }).filter(Boolean).pop();
            if (assignment) {
                flags[assignment][key] = true;
            }
            flags.arrays[key] = true;
            flags.keys.push(key);
        });
        [].concat(opts.boolean || []).filter(Boolean).forEach(function (key) {
            flags.bools[key] = true;
            flags.keys.push(key);
        });
        [].concat(opts.string || []).filter(Boolean).forEach(function (key) {
            flags.strings[key] = true;
            flags.keys.push(key);
        });
        [].concat(opts.number || []).filter(Boolean).forEach(function (key) {
            flags.numbers[key] = true;
            flags.keys.push(key);
        });
        [].concat(opts.count || []).filter(Boolean).forEach(function (key) {
            flags.counts[key] = true;
            flags.keys.push(key);
        });
        [].concat(opts.normalize || []).filter(Boolean).forEach(function (key) {
            flags.normalize[key] = true;
            flags.keys.push(key);
        });
        if (typeof opts.narg === 'object') {
            Object.entries(opts.narg).forEach(([key, value]) => {
                if (typeof value === 'number') {
                    flags.nargs[key] = value;
                    flags.keys.push(key);
                }
            });
        }
        if (typeof opts.coerce === 'object') {
            Object.entries(opts.coerce).forEach(([key, value]) => {
                if (typeof value === 'function') {
                    flags.coercions[key] = value;
                    flags.keys.push(key);
                }
            });
        }
        if (typeof opts.config !== 'undefined') {
            if (Array.isArray(opts.config) || typeof opts.config === 'string') {
                [].concat(opts.config).filter(Boolean).forEach(function (key) {
                    flags.configs[key] = true;
                });
            }
            else if (typeof opts.config === 'object') {
                Object.entries(opts.config).forEach(([key, value]) => {
                    if (typeof value === 'boolean' || typeof value === 'function') {
                        flags.configs[key] = value;
                    }
                });
            }
        }
        extendAliases(opts.key, aliases, opts.default, flags.arrays);
        Object.keys(defaults).forEach(function (key) {
            (flags.aliases[key] || []).forEach(function (alias) {
                defaults[alias] = defaults[key];
            });
        });
        let error = null;
        checkConfiguration();
        let notFlags = [];
        const argv = Object.assign(Object.create(null), { _: [] });
        const argvReturn = {};
        for (let i = 0; i < args.length; i++) {
            const arg = args[i];
            const truncatedArg = arg.replace(/^-{3,}/, '---');
            let broken;
            let key;
            let letters;
            let m;
            let next;
            let value;
            if (arg !== '--' && /^-/.test(arg) && isUnknownOptionAsArg(arg)) {
                pushPositional(arg);
            }
            else if (truncatedArg.match(/^---+(=|$)/)) {
                pushPositional(arg);
                continue;
            }
            else if (arg.match(/^--.+=/) || (!configuration['short-option-groups'] && arg.match(/^-.+=/))) {
                m = arg.match(/^--?([^=]+)=([\s\S]*)$/);
                if (m !== null && Array.isArray(m) && m.length >= 3) {
                    if (checkAllAliases(m[1], flags.arrays)) {
                        i = eatArray(i, m[1], args, m[2]);
                    }
                    else if (checkAllAliases(m[1], flags.nargs) !== false) {
                        i = eatNargs(i, m[1], args, m[2]);
                    }
                    else {
                        setArg(m[1], m[2], true);
                    }
                }
            }
            else if (arg.match(negatedBoolean) && configuration['boolean-negation']) {
                m = arg.match(negatedBoolean);
                if (m !== null && Array.isArray(m) && m.length >= 2) {
                    key = m[1];
                    setArg(key, checkAllAliases(key, flags.arrays) ? [false] : false);
                }
            }
            else if (arg.match(/^--.+/) || (!configuration['short-option-groups'] && arg.match(/^-[^-]+/))) {
                m = arg.match(/^--?(.+)/);
                if (m !== null && Array.isArray(m) && m.length >= 2) {
                    key = m[1];
                    if (checkAllAliases(key, flags.arrays)) {
                        i = eatArray(i, key, args);
                    }
                    else if (checkAllAliases(key, flags.nargs) !== false) {
                        i = eatNargs(i, key, args);
                    }
                    else {
                        next = args[i + 1];
                        if (next !== undefined && (!next.match(/^-/) ||
                            next.match(negative)) &&
                            !checkAllAliases(key, flags.bools) &&
                            !checkAllAliases(key, flags.counts)) {
                            setArg(key, next);
                            i++;
                        }
                        else if (/^(true|false)$/.test(next)) {
                            setArg(key, next);
                            i++;
                        }
                        else {
                            setArg(key, defaultValue(key));
                        }
                    }
                }
            }
            else if (arg.match(/^-.\..+=/)) {
                m = arg.match(/^-([^=]+)=([\s\S]*)$/);
                if (m !== null && Array.isArray(m) && m.length >= 3) {
                    setArg(m[1], m[2]);
                }
            }
            else if (arg.match(/^-.\..+/) && !arg.match(negative)) {
                next = args[i + 1];
                m = arg.match(/^-(.\..+)/);
                if (m !== null && Array.isArray(m) && m.length >= 2) {
                    key = m[1];
                    if (next !== undefined && !next.match(/^-/) &&
                        !checkAllAliases(key, flags.bools) &&
                        !checkAllAliases(key, flags.counts)) {
                        setArg(key, next);
                        i++;
                    }
                    else {
                        setArg(key, defaultValue(key));
                    }
                }
            }
            else if (arg.match(/^-[^-]+/) && !arg.match(negative)) {
                letters = arg.slice(1, -1).split('');
                broken = false;
                for (let j = 0; j < letters.length; j++) {
                    next = arg.slice(j + 2);
                    if (letters[j + 1] && letters[j + 1] === '=') {
                        value = arg.slice(j + 3);
                        key = letters[j];
                        if (checkAllAliases(key, flags.arrays)) {
                            i = eatArray(i, key, args, value);
                        }
                        else if (checkAllAliases(key, flags.nargs) !== false) {
                            i = eatNargs(i, key, args, value);
                        }
                        else {
                            setArg(key, value);
                        }
                        broken = true;
                        break;
                    }
                    if (next === '-') {
                        setArg(letters[j], next);
                        continue;
                    }
                    if (/[A-Za-z]/.test(letters[j]) &&
                        /^-?\d+(\.\d*)?(e-?\d+)?$/.test(next) &&
                        checkAllAliases(next, flags.bools) === false) {
                        setArg(letters[j], next);
                        broken = true;
                        break;
                    }
                    if (letters[j + 1] && letters[j + 1].match(/\W/)) {
                        setArg(letters[j], next);
                        broken = true;
                        break;
                    }
                    else {
                        setArg(letters[j], defaultValue(letters[j]));
                    }
                }
                key = arg.slice(-1)[0];
                if (!broken && key !== '-') {
                    if (checkAllAliases(key, flags.arrays)) {
                        i = eatArray(i, key, args);
                    }
                    else if (checkAllAliases(key, flags.nargs) !== false) {
                        i = eatNargs(i, key, args);
                    }
                    else {
                        next = args[i + 1];
                        if (next !== undefined && (!/^(-|--)[^-]/.test(next) ||
                            next.match(negative)) &&
                            !checkAllAliases(key, flags.bools) &&
                            !checkAllAliases(key, flags.counts)) {
                            setArg(key, next);
                            i++;
                        }
                        else if (/^(true|false)$/.test(next)) {
                            setArg(key, next);
                            i++;
                        }
                        else {
                            setArg(key, defaultValue(key));
                        }
                    }
                }
            }
            else if (arg.match(/^-[0-9]$/) &&
                arg.match(negative) &&
                checkAllAliases(arg.slice(1), flags.bools)) {
                key = arg.slice(1);
                setArg(key, defaultValue(key));
            }
            else if (arg === '--') {
                notFlags = args.slice(i + 1);
                break;
            }
            else if (configuration['halt-at-non-option']) {
                notFlags = args.slice(i);
                break;
            }
            else {
                pushPositional(arg);
            }
        }
        applyEnvVars(argv, true);
        applyEnvVars(argv, false);
        setConfig(argv);
        setConfigObjects();
        applyDefaultsAndAliases(argv, flags.aliases, defaults, true);
        applyCoercions(argv);
        if (configuration['set-placeholder-key'])
            setPlaceholderKeys(argv);
        Object.keys(flags.counts).forEach(function (key) {
            if (!hasKey(argv, key.split('.')))
                setArg(key, 0);
        });
        if (notFlagsOption && notFlags.length)
            argv[notFlagsArgv] = [];
        notFlags.forEach(function (key) {
            argv[notFlagsArgv].push(key);
        });
        if (configuration['camel-case-expansion'] && configuration['strip-dashed']) {
            Object.keys(argv).filter(key => key !== '--' && key.includes('-')).forEach(key => {
                delete argv[key];
            });
        }
        if (configuration['strip-aliased']) {
            [].concat(...Object.keys(aliases).map(k => aliases[k])).forEach(alias => {
                if (configuration['camel-case-expansion'] && alias.includes('-')) {
                    delete argv[alias.split('.').map(prop => camelCase(prop)).join('.')];
                }
                delete argv[alias];
            });
        }
        function pushPositional(arg) {
            const maybeCoercedNumber = maybeCoerceNumber('_', arg);
            if (typeof maybeCoercedNumber === 'string' || typeof maybeCoercedNumber === 'number') {
                argv._.push(maybeCoercedNumber);
            }
        }
        function eatNargs(i, key, args, argAfterEqualSign) {
            let ii;
            let toEat = checkAllAliases(key, flags.nargs);
            toEat = typeof toEat !== 'number' || isNaN(toEat) ? 1 : toEat;
            if (toEat === 0) {
                if (!isUndefined(argAfterEqualSign)) {
                    error = Error(__('Argument unexpected for: %s', key));
                }
                setArg(key, defaultValue(key));
                return i;
            }
            let available = isUndefined(argAfterEqualSign) ? 0 : 1;
            if (configuration['nargs-eats-options']) {
                if (args.length - (i + 1) + available < toEat) {
                    error = Error(__('Not enough arguments following: %s', key));
                }
                available = toEat;
            }
            else {
                for (ii = i + 1; ii < args.length; ii++) {
                    if (!args[ii].match(/^-[^0-9]/) || args[ii].match(negative) || isUnknownOptionAsArg(args[ii]))
                        available++;
                    else
                        break;
                }
                if (available < toEat)
                    error = Error(__('Not enough arguments following: %s', key));
            }
            let consumed = Math.min(available, toEat);
            if (!isUndefined(argAfterEqualSign) && consumed > 0) {
                setArg(key, argAfterEqualSign);
                consumed--;
            }
            for (ii = i + 1; ii < (consumed + i + 1); ii++) {
                setArg(key, args[ii]);
            }
            return (i + consumed);
        }
        function eatArray(i, key, args, argAfterEqualSign) {
            let argsToSet = [];
            let next = argAfterEqualSign || args[i + 1];
            const nargsCount = checkAllAliases(key, flags.nargs);
            if (checkAllAliases(key, flags.bools) && !(/^(true|false)$/.test(next))) {
                argsToSet.push(true);
            }
            else if (isUndefined(next) ||
                (isUndefined(argAfterEqualSign) && /^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next))) {
                if (defaults[key] !== undefined) {
                    const defVal = defaults[key];
                    argsToSet = Array.isArray(defVal) ? defVal : [defVal];
                }
            }
            else {
                if (!isUndefined(argAfterEqualSign)) {
                    argsToSet.push(processValue(key, argAfterEqualSign, true));
                }
                for (let ii = i + 1; ii < args.length; ii++) {
                    if ((!configuration['greedy-arrays'] && argsToSet.length > 0) ||
                        (nargsCount && typeof nargsCount === 'number' && argsToSet.length >= nargsCount))
                        break;
                    next = args[ii];
                    if (/^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next))
                        break;
                    i = ii;
                    argsToSet.push(processValue(key, next, inputIsString));
                }
            }
            if (typeof nargsCount === 'number' && ((nargsCount && argsToSet.length < nargsCount) ||
                (isNaN(nargsCount) && argsToSet.length === 0))) {
                error = Error(__('Not enough arguments following: %s', key));
            }
            setArg(key, argsToSet);
            return i;
        }
        function setArg(key, val, shouldStripQuotes = inputIsString) {
            if (/-/.test(key) && configuration['camel-case-expansion']) {
                const alias = key.split('.').map(function (prop) {
                    return camelCase(prop);
                }).join('.');
                addNewAlias(key, alias);
            }
            const value = processValue(key, val, shouldStripQuotes);
            const splitKey = key.split('.');
            setKey(argv, splitKey, value);
            if (flags.aliases[key]) {
                flags.aliases[key].forEach(function (x) {
                    const keyProperties = x.split('.');
                    setKey(argv, keyProperties, value);
                });
            }
            if (splitKey.length > 1 && configuration['dot-notation']) {
                (flags.aliases[splitKey[0]] || []).forEach(function (x) {
                    let keyProperties = x.split('.');
                    const a = [].concat(splitKey);
                    a.shift();
                    keyProperties = keyProperties.concat(a);
                    if (!(flags.aliases[key] || []).includes(keyProperties.join('.'))) {
                        setKey(argv, keyProperties, value);
                    }
                });
            }
            if (checkAllAliases(key, flags.normalize) && !checkAllAliases(key, flags.arrays)) {
                const keys = [key].concat(flags.aliases[key] || []);
                keys.forEach(function (key) {
                    Object.defineProperty(argvReturn, key, {
                        enumerable: true,
                        get() {
                            return val;
                        },
                        set(value) {
                            val = typeof value === 'string' ? mixin.normalize(value) : value;
                        }
                    });
                });
            }
        }
        function addNewAlias(key, alias) {
            if (!(flags.aliases[key] && flags.aliases[key].length)) {
                flags.aliases[key] = [alias];
                newAliases[alias] = true;
            }
            if (!(flags.aliases[alias] && flags.aliases[alias].length)) {
                addNewAlias(alias, key);
            }
        }
        function processValue(key, val, shouldStripQuotes) {
            if (shouldStripQuotes) {
                val = stripQuotes(val);
            }
            if (checkAllAliases(key, flags.bools) || checkAllAliases(key, flags.counts)) {
                if (typeof val === 'string')
                    val = val === 'true';
            }
            let value = Array.isArray(val)
                ? val.map(function (v) { return maybeCoerceNumber(key, v); })
                : maybeCoerceNumber(key, val);
            if (checkAllAliases(key, flags.counts) && (isUndefined(value) || typeof value === 'boolean')) {
                value = increment();
            }
            if (checkAllAliases(key, flags.normalize) && checkAllAliases(key, flags.arrays)) {
                if (Array.isArray(val))
                    value = val.map((val) => { return mixin.normalize(val); });
                else
                    value = mixin.normalize(val);
            }
            return value;
        }
        function maybeCoerceNumber(key, value) {
            if (!configuration['parse-positional-numbers'] && key === '_')
                return value;
            if (!checkAllAliases(key, flags.strings) && !checkAllAliases(key, flags.bools) && !Array.isArray(value)) {
                const shouldCoerceNumber = looksLikeNumber(value) && configuration['parse-numbers'] && (Number.isSafeInteger(Math.floor(parseFloat(`${value}`))));
                if (shouldCoerceNumber || (!isUndefined(value) && checkAllAliases(key, flags.numbers))) {
                    value = Number(value);
                }
            }
            return value;
        }
        function setConfig(argv) {
            const configLookup = Object.create(null);
            applyDefaultsAndAliases(configLookup, flags.aliases, defaults);
            Object.keys(flags.configs).forEach(function (configKey) {
                const configPath = argv[configKey] || configLookup[configKey];
                if (configPath) {
                    try {
                        let config = null;
                        const resolvedConfigPath = mixin.resolve(mixin.cwd(), configPath);
                        const resolveConfig = flags.configs[configKey];
                        if (typeof resolveConfig === 'function') {
                            try {
                                config = resolveConfig(resolvedConfigPath);
                            }
                            catch (e) {
                                config = e;
                            }
                            if (config instanceof Error) {
                                error = config;
                                return;
                            }
                        }
                        else {
                            config = mixin.require(resolvedConfigPath);
                        }
                        setConfigObject(config);
                    }
                    catch (ex) {
                        if (ex.name === 'PermissionDenied')
                            error = ex;
                        else if (argv[configKey])
                            error = Error(__('Invalid JSON config file: %s', configPath));
                    }
                }
            });
        }
        function setConfigObject(config, prev) {
            Object.keys(config).forEach(function (key) {
                const value = config[key];
                const fullKey = prev ? prev + '.' + key : key;
                if (typeof value === 'object' && value !== null && !Array.isArray(value) && configuration['dot-notation']) {
                    setConfigObject(value, fullKey);
                }
                else {
                    if (!hasKey(argv, fullKey.split('.')) || (checkAllAliases(fullKey, flags.arrays) && configuration['combine-arrays'])) {
                        setArg(fullKey, value);
                    }
                }
            });
        }
        function setConfigObjects() {
            if (typeof configObjects !== 'undefined') {
                configObjects.forEach(function (configObject) {
                    setConfigObject(configObject);
                });
            }
        }
        function applyEnvVars(argv, configOnly) {
            if (typeof envPrefix === 'undefined')
                return;
            const prefix = typeof envPrefix === 'string' ? envPrefix : '';
            const env = mixin.env();
            Object.keys(env).forEach(function (envVar) {
                if (prefix === '' || envVar.lastIndexOf(prefix, 0) === 0) {
                    const keys = envVar.split('__').map(function (key, i) {
                        if (i === 0) {
                            key = key.substring(prefix.length);
                        }
                        return camelCase(key);
                    });
                    if (((configOnly && flags.configs[keys.join('.')]) || !configOnly) && !hasKey(argv, keys)) {
                        setArg(keys.join('.'), env[envVar]);
                    }
                }
            });
        }
        function applyCoercions(argv) {
            let coerce;
            const applied = new Set();
            Object.keys(argv).forEach(function (key) {
                if (!applied.has(key)) {
                    coerce = checkAllAliases(key, flags.coercions);
                    if (typeof coerce === 'function') {
                        try {
                            const value = maybeCoerceNumber(key, coerce(argv[key]));
                            ([].concat(flags.aliases[key] || [], key)).forEach(ali => {
                                applied.add(ali);
                                argv[ali] = value;
                            });
                        }
                        catch (err) {
                            error = err;
                        }
                    }
                }
            });
        }
        function setPlaceholderKeys(argv) {
            flags.keys.forEach((key) => {
                if (~key.indexOf('.'))
                    return;
                if (typeof argv[key] === 'undefined')
                    argv[key] = undefined;
            });
            return argv;
        }
        function applyDefaultsAndAliases(obj, aliases, defaults, canLog = false) {
            Object.keys(defaults).forEach(function (key) {
                if (!hasKey(obj, key.split('.'))) {
                    setKey(obj, key.split('.'), defaults[key]);
                    if (canLog)
                        defaulted[key] = true;
                    (aliases[key] || []).forEach(function (x) {
                        if (hasKey(obj, x.split('.')))
                            return;
                        setKey(obj, x.split('.'), defaults[key]);
                    });
                }
            });
        }
        function hasKey(obj, keys) {
            let o = obj;
            if (!configuration['dot-notation'])
                keys = [keys.join('.')];
            keys.slice(0, -1).forEach(function (key) {
                o = (o[key] || {});
            });
            const key = keys[keys.length - 1];
            if (typeof o !== 'object')
                return false;
            else
                return key in o;
        }
        function setKey(obj, keys, value) {
            let o = obj;
            if (!configuration['dot-notation'])
                keys = [keys.join('.')];
            keys.slice(0, -1).forEach(function (key) {
                key = sanitizeKey(key);
                if (typeof o === 'object' && o[key] === undefined) {
                    o[key] = {};
                }
                if (typeof o[key] !== 'object' || Array.isArray(o[key])) {
                    if (Array.isArray(o[key])) {
                        o[key].push({});
                    }
                    else {
                        o[key] = [o[key], {}];
                    }
                    o = o[key][o[key].length - 1];
                }
                else {
                    o = o[key];
                }
            });
            const key = sanitizeKey(keys[keys.length - 1]);
            const isTypeArray = checkAllAliases(keys.join('.'), flags.arrays);
            const isValueArray = Array.isArray(value);
            let duplicate = configuration['duplicate-arguments-array'];
            if (!duplicate && checkAllAliases(key, flags.nargs)) {
                duplicate = true;
                if ((!isUndefined(o[key]) && flags.nargs[key] === 1) || (Array.isArray(o[key]) && o[key].length === flags.nargs[key])) {
                    o[key] = undefined;
                }
            }
            if (value === increment()) {
                o[key] = increment(o[key]);
            }
            else if (Array.isArray(o[key])) {
                if (duplicate && isTypeArray && isValueArray) {
                    o[key] = configuration['flatten-duplicate-arrays'] ? o[key].concat(value) : (Array.isArray(o[key][0]) ? o[key] : [o[key]]).concat([value]);
                }
                else if (!duplicate && Boolean(isTypeArray) === Boolean(isValueArray)) {
                    o[key] = value;
                }
                else {
                    o[key] = o[key].concat([value]);
                }
            }
            else if (o[key] === undefined && isTypeArray) {
                o[key] = isValueArray ? value : [value];
            }
            else if (duplicate && !(o[key] === undefined ||
                checkAllAliases(key, flags.counts) ||
                checkAllAliases(key, flags.bools))) {
                o[key] = [o[key], value];
            }
            else {
                o[key] = value;
            }
        }
        function extendAliases(...args) {
            args.forEach(function (obj) {
                Object.keys(obj || {}).forEach(function (key) {
                    if (flags.aliases[key])
                        return;
                    flags.aliases[key] = [].concat(aliases[key] || []);
                    flags.aliases[key].concat(key).forEach(function (x) {
                        if (/-/.test(x) && configuration['camel-case-expansion']) {
                            const c = camelCase(x);
                            if (c !== key && flags.aliases[key].indexOf(c) === -1) {
                                flags.aliases[key].push(c);
                                newAliases[c] = true;
                            }
                        }
                    });
                    flags.aliases[key].concat(key).forEach(function (x) {
                        if (x.length > 1 && /[A-Z]/.test(x) && configuration['camel-case-expansion']) {
                            const c = decamelize(x, '-');
                            if (c !== key && flags.aliases[key].indexOf(c) === -1) {
                                flags.aliases[key].push(c);
                                newAliases[c] = true;
                            }
                        }
                    });
                    flags.aliases[key].forEach(function (x) {
                        flags.aliases[x] = [key].concat(flags.aliases[key].filter(function (y) {
                            return x !== y;
                        }));
                    });
                });
            });
        }
        function checkAllAliases(key, flag) {
            const toCheck = [].concat(flags.aliases[key] || [], key);
            const keys = Object.keys(flag);
            const setAlias = toCheck.find(key => keys.includes(key));
            return setAlias ? flag[setAlias] : false;
        }
        function hasAnyFlag(key) {
            const flagsKeys = Object.keys(flags);
            const toCheck = [].concat(flagsKeys.map(k => flags[k]));
            return toCheck.some(function (flag) {
                return Array.isArray(flag) ? flag.includes(key) : flag[key];
            });
        }
        function hasFlagsMatching(arg, ...patterns) {
            const toCheck = [].concat(...patterns);
            return toCheck.some(function (pattern) {
                const match = arg.match(pattern);
                return match && hasAnyFlag(match[1]);
            });
        }
        function hasAllShortFlags(arg) {
            if (arg.match(negative) || !arg.match(/^-[^-]+/)) {
                return false;
            }
            let hasAllFlags = true;
            let next;
            const letters = arg.slice(1).split('');
            for (let j = 0; j < letters.length; j++) {
                next = arg.slice(j + 2);
                if (!hasAnyFlag(letters[j])) {
                    hasAllFlags = false;
                    break;
                }
                if ((letters[j + 1] && letters[j + 1] === '=') ||
                    next === '-' ||
                    (/[A-Za-z]/.test(letters[j]) && /^-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) ||
                    (letters[j + 1] && letters[j + 1].match(/\W/))) {
                    break;
                }
            }
            return hasAllFlags;
        }
        function isUnknownOptionAsArg(arg) {
            return configuration['unknown-options-as-args'] && isUnknownOption(arg);
        }
        function isUnknownOption(arg) {
            arg = arg.replace(/^-{3,}/, '--');
            if (arg.match(negative)) {
                return false;
            }
            if (hasAllShortFlags(arg)) {
                return false;
            }
            const flagWithEquals = /^-+([^=]+?)=[\s\S]*$/;
            const normalFlag = /^-+([^=]+?)$/;
            const flagEndingInHyphen = /^-+([^=]+?)-$/;
            const flagEndingInDigits = /^-+([^=]+?\d+)$/;
            const flagEndingInNonWordCharacters = /^-+([^=]+?)\W+.*$/;
            return !hasFlagsMatching(arg, flagWithEquals, negatedBoolean, normalFlag, flagEndingInHyphen, flagEndingInDigits, flagEndingInNonWordCharacters);
        }
        function defaultValue(key) {
            if (!checkAllAliases(key, flags.bools) &&
                !checkAllAliases(key, flags.counts) &&
                `${key}` in defaults) {
                return defaults[key];
            }
            else {
                return defaultForType(guessType(key));
            }
        }
        function defaultForType(type) {
            const def = {
                [DefaultValuesForTypeKey.BOOLEAN]: true,
                [DefaultValuesForTypeKey.STRING]: '',
                [DefaultValuesForTypeKey.NUMBER]: undefined,
                [DefaultValuesForTypeKey.ARRAY]: []
            };
            return def[type];
        }
        function guessType(key) {
            let type = DefaultValuesForTypeKey.BOOLEAN;
            if (checkAllAliases(key, flags.strings))
                type = DefaultValuesForTypeKey.STRING;
            else if (checkAllAliases(key, flags.numbers))
                type = DefaultValuesForTypeKey.NUMBER;
            else if (checkAllAliases(key, flags.bools))
                type = DefaultValuesForTypeKey.BOOLEAN;
            else if (checkAllAliases(key, flags.arrays))
                type = DefaultValuesForTypeKey.ARRAY;
            return type;
        }
        function isUndefined(num) {
            return num === undefined;
        }
        function checkConfiguration() {
            Object.keys(flags.counts).find(key => {
                if (checkAllAliases(key, flags.arrays)) {
                    error = Error(__('Invalid configuration: %s, opts.count excludes opts.array.', key));
                    return true;
                }
                else if (checkAllAliases(key, flags.nargs)) {
                    error = Error(__('Invalid configuration: %s, opts.count excludes opts.narg.', key));
                    return true;
                }
                return false;
            });
        }
        return {
            aliases: Object.assign({}, flags.aliases),
            argv: Object.assign(argvReturn, argv),
            configuration: configuration,
            defaulted: Object.assign({}, defaulted),
            error: error,
            newAliases: Object.assign({}, newAliases)
        };
    }
}
function combineAliases(aliases) {
    const aliasArrays = [];
    const combined = Object.create(null);
    let change = true;
    Object.keys(aliases).forEach(function (key) {
        aliasArrays.push([].concat(aliases[key], key));
    });
    while (change) {
        change = false;
        for (let i = 0; i < aliasArrays.length; i++) {
            for (let ii = i + 1; ii < aliasArrays.length; ii++) {
                const intersect = aliasArrays[i].filter(function (v) {
                    return aliasArrays[ii].indexOf(v) !== -1;
                });
                if (intersect.length) {
                    aliasArrays[i] = aliasArrays[i].concat(aliasArrays[ii]);
                    aliasArrays.splice(ii, 1);
                    change = true;
                    break;
                }
            }
        }
    }
    aliasArrays.forEach(function (aliasArray) {
        aliasArray = aliasArray.filter(function (v, i, self) {
            return self.indexOf(v) === i;
        });
        const lastAlias = aliasArray.pop();
        if (lastAlias !== undefined && typeof lastAlias === 'string') {
            combined[lastAlias] = aliasArray;
        }
    });
    return combined;
}
function increment(orig) {
    return orig !== undefined ? orig + 1 : 1;
}
function sanitizeKey(key) {
    if (key === '__proto__')
        return '___proto___';
    return key;
}
function stripQuotes(val) {
    return (typeof val === 'string' &&
        (val[0] === "'" || val[0] === '"') &&
        val[val.length - 1] === val[0])
        ? val.substring(1, val.length - 1)
        : val;
}

/**
 * @fileoverview Main entrypoint for libraries using yargs-parser in Node.js
 *
 * @license
 * Copyright (c) 2016, Contributors
 * SPDX-License-Identifier: ISC
 */
var _a, _b, _c;
const minNodeVersion = (process && process.env && process.env.YARGS_MIN_NODE_VERSION)
    ? Number(process.env.YARGS_MIN_NODE_VERSION)
    : 20;
const nodeVersion = (_b = (_a = process === null || process === void 0 ? void 0 : process.versions) === null || _a === void 0 ? void 0 : _a.node) !== null && _b !== void 0 ? _b : (_c = process === null || process === void 0 ? void 0 : process.version) === null || _c === void 0 ? void 0 : _c.slice(1);
if (nodeVersion) {
    const major = Number(nodeVersion.match(/^([^.]+)/)[1]);
    if (major < minNodeVersion) {
        throw Error(`yargs parser supports a minimum Node.js version of ${minNodeVersion}. Read our version support policy: https://github.com/yargs/yargs-parser#supported-nodejs-versions`);
    }
}
const env = process ? process.env : {};
const require$2 = createRequire ? createRequire(import.meta.url) : undefined;
const parser = new YargsParser({
    cwd: process.cwd,
    env: () => {
        return env;
    },
    format: format$1,
    normalize,
    resolve,
    require: (path) => {
        if (typeof require$2 !== 'undefined') {
            return require$2(path);
        }
        else if (path.match(/\.json$/)) {
            return JSON.parse(readFileSync(path, 'utf8'));
        }
        else {
            throw Error('only .json config files are supported in ESM');
        }
    }
});
const yargsParser = function Parser(args, opts) {
    const result = parser.parse(args.slice(), opts);
    return result.argv;
};
yargsParser.detailed = function (args, opts) {
    return parser.parse(args.slice(), opts);
};
yargsParser.camelCase = camelCase;
yargsParser.decamelize = decamelize;
yargsParser.looksLikeNumber = looksLikeNumber;

function getProcessArgvBinIndex() {
    if (isBundledElectronApp())
        return 0;
    return 1;
}
function isBundledElectronApp() {
    return isElectronApp() && !process.defaultApp;
}
function isElectronApp() {
    return !!process.versions.electron;
}
function hideBin(argv) {
    return argv.slice(getProcessArgvBinIndex() + 1);
}
function getProcessArgvBin() {
    return process.argv[getProcessArgvBinIndex()];
}

var shim$3 = {
    fs: {
        readFileSync,
        writeFile
    },
    format: format$1,
    resolve,
    exists: (file) => {
        try {
            return statSync(file).isFile();
        }
        catch (err) {
            return false;
        }
    }
};

let shim$2;
class Y18N {
    constructor(opts) {
        opts = opts || {};
        this.directory = opts.directory || './locales';
        this.updateFiles = typeof opts.updateFiles === 'boolean' ? opts.updateFiles : true;
        this.locale = opts.locale || 'en';
        this.fallbackToLanguage = typeof opts.fallbackToLanguage === 'boolean' ? opts.fallbackToLanguage : true;
        this.cache = Object.create(null);
        this.writeQueue = [];
    }
    __(...args) {
        if (typeof arguments[0] !== 'string') {
            return this._taggedLiteral(arguments[0], ...arguments);
        }
        const str = args.shift();
        let cb = function () { };
        if (typeof args[args.length - 1] === 'function')
            cb = args.pop();
        cb = cb || function () { };
        if (!this.cache[this.locale])
            this._readLocaleFile();
        if (!this.cache[this.locale][str] && this.updateFiles) {
            this.cache[this.locale][str] = str;
            this._enqueueWrite({
                directory: this.directory,
                locale: this.locale,
                cb
            });
        }
        else {
            cb();
        }
        return shim$2.format.apply(shim$2.format, [this.cache[this.locale][str] || str].concat(args));
    }
    __n() {
        const args = Array.prototype.slice.call(arguments);
        const singular = args.shift();
        const plural = args.shift();
        const quantity = args.shift();
        let cb = function () { };
        if (typeof args[args.length - 1] === 'function')
            cb = args.pop();
        if (!this.cache[this.locale])
            this._readLocaleFile();
        let str = quantity === 1 ? singular : plural;
        if (this.cache[this.locale][singular]) {
            const entry = this.cache[this.locale][singular];
            str = entry[quantity === 1 ? 'one' : 'other'];
        }
        if (!this.cache[this.locale][singular] && this.updateFiles) {
            this.cache[this.locale][singular] = {
                one: singular,
                other: plural
            };
            this._enqueueWrite({
                directory: this.directory,
                locale: this.locale,
                cb
            });
        }
        else {
            cb();
        }
        const values = [str];
        if (~str.indexOf('%d'))
            values.push(quantity);
        return shim$2.format.apply(shim$2.format, values.concat(args));
    }
    setLocale(locale) {
        this.locale = locale;
    }
    getLocale() {
        return this.locale;
    }
    updateLocale(obj) {
        if (!this.cache[this.locale])
            this._readLocaleFile();
        for (const key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
                this.cache[this.locale][key] = obj[key];
            }
        }
    }
    _taggedLiteral(parts, ...args) {
        let str = '';
        parts.forEach(function (part, i) {
            const arg = args[i + 1];
            str += part;
            if (typeof arg !== 'undefined') {
                str += '%s';
            }
        });
        return this.__.apply(this, [str].concat([].slice.call(args, 1)));
    }
    _enqueueWrite(work) {
        this.writeQueue.push(work);
        if (this.writeQueue.length === 1)
            this._processWriteQueue();
    }
    _processWriteQueue() {
        const _this = this;
        const work = this.writeQueue[0];
        const directory = work.directory;
        const locale = work.locale;
        const cb = work.cb;
        const languageFile = this._resolveLocaleFile(directory, locale);
        const serializedLocale = JSON.stringify(this.cache[locale], null, 2);
        shim$2.fs.writeFile(languageFile, serializedLocale, 'utf-8', function (err) {
            _this.writeQueue.shift();
            if (_this.writeQueue.length > 0)
                _this._processWriteQueue();
            cb(err);
        });
    }
    _readLocaleFile() {
        let localeLookup = {};
        const languageFile = this._resolveLocaleFile(this.directory, this.locale);
        try {
            if (shim$2.fs.readFileSync) {
                localeLookup = JSON.parse(shim$2.fs.readFileSync(languageFile, 'utf-8'));
            }
        }
        catch (err) {
            if (err instanceof SyntaxError) {
                err.message = 'syntax error in ' + languageFile;
            }
            if (err.code === 'ENOENT')
                localeLookup = {};
            else
                throw err;
        }
        this.cache[this.locale] = localeLookup;
    }
    _resolveLocaleFile(directory, locale) {
        let file = shim$2.resolve(directory, './', locale + '.json');
        if (this.fallbackToLanguage && !this._fileExistsSync(file) && ~locale.lastIndexOf('_')) {
            const languageFile = shim$2.resolve(directory, './', locale.split('_')[0] + '.json');
            if (this._fileExistsSync(languageFile))
                file = languageFile;
        }
        return file;
    }
    _fileExistsSync(file) {
        return shim$2.exists(file);
    }
}
function y18n$1(opts, _shim) {
    shim$2 = _shim;
    const y18n = new Y18N(opts);
    return {
        __: y18n.__.bind(y18n),
        __n: y18n.__n.bind(y18n),
        setLocale: y18n.setLocale.bind(y18n),
        getLocale: y18n.getLocale.bind(y18n),
        updateLocale: y18n.updateLocale.bind(y18n),
        locale: y18n.locale
    };
}

const y18n = (opts) => {
  return y18n$1(opts, shim$3)
};

var getCallerFile$1;
var hasRequiredGetCallerFile;

function requireGetCallerFile () {
	if (hasRequiredGetCallerFile) return getCallerFile$1;
	hasRequiredGetCallerFile = 1;
	getCallerFile$1 = function getCallerFile(position) {
	    if (position === void 0) { position = 2; }
	    if (position >= Error.stackTraceLimit) {
	        throw new TypeError('getCallerFile(position) requires position be less then Error.stackTraceLimit but position was: `' + position + '` and Error.stackTraceLimit was: `' + Error.stackTraceLimit + '`');
	    }
	    var oldPrepareStackTrace = Error.prepareStackTrace;
	    Error.prepareStackTrace = function (_, stack) { return stack; };
	    var stack = new Error().stack;
	    Error.prepareStackTrace = oldPrepareStackTrace;
	    if (stack !== null && typeof stack === 'object') {
	        return stack[position] ? stack[position].getFileName() : undefined;
	    }
	};
	return getCallerFile$1;
}

var getCallerFileExports = requireGetCallerFile();
var getCallerFile = /*@__PURE__*/getDefaultExportFromCjs(getCallerFileExports);

const __dirname$1 = fileURLToPath(import.meta.url);
const mainFilename = __dirname$1.substring(0, __dirname$1.lastIndexOf('node_modules'));
const require$1 = createRequire(import.meta.url);
var shim$1 = {
  assert: {
    notStrictEqual,
    strictEqual
  },
  cliui: ui,
  findUp: escalade,
  getEnv: (key) => {
    return process.env[key]
  },
  inspect,
  getProcessArgvBin,
  mainFilename: mainFilename || process.cwd(),
  Parser: yargsParser,
  path: {
    basename,
    dirname,
    extname,
    relative,
    resolve,
    join
  },
  process: {
    argv: () => process.argv,
    cwd: process.cwd,
    emitWarning: (warning, type) => process.emitWarning(warning, type),
    execPath: () => process.execPath,
    exit: (code) => {
      process.exit(code);
    },
    nextTick: process.nextTick,
    stdColumns: typeof process.stdout.columns !== 'undefined' ? process.stdout.columns : null
  },
  readFileSync: readFileSync$1,
  readdirSync: readdirSync$1,
  require: require$1,
  getCallerFile: () => {
    const callerFile = getCallerFile(3);
    return callerFile.match(/^file:\/\//) ? fileURLToPath(callerFile) : callerFile;
  },
  stringWidth,
  y18n: y18n({
    directory: resolve(__dirname$1, '../../../locales'),
    updateFiles: false
  })
};

function assertNotStrictEqual(actual, expected, shim, message) {
    shim.assert.notStrictEqual(actual, expected, message);
}
function assertSingleKey(actual, shim) {
    shim.assert.strictEqual(typeof actual, 'string');
}
function objectKeys(object) {
    return Object.keys(object);
}

function isPromise$1(maybePromise) {
    return (!!maybePromise &&
        !!maybePromise.then &&
        typeof maybePromise.then === 'function');
}

class YError extends Error {
    constructor(msg) {
        super(msg || 'yargs error');
        this.name = 'YError';
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, YError);
        }
    }
}

function parseCommand(cmd) {
    const extraSpacesStrippedCommand = cmd.replace(/\s{2,}/g, ' ');
    const splitCommand = extraSpacesStrippedCommand.split(/\s+(?![^[]*]|[^<]*>)/);
    const bregex = /\.*[\][<>]/g;
    const firstCommand = splitCommand.shift();
    if (!firstCommand)
        throw new Error(`No command found in: ${cmd}`);
    const parsedCommand = {
        cmd: firstCommand.replace(bregex, ''),
        demanded: [],
        optional: [],
    };
    splitCommand.forEach((cmd, i) => {
        let variadic = false;
        cmd = cmd.replace(/\s/g, '');
        if (/\.+[\]>]/.test(cmd) && i === splitCommand.length - 1)
            variadic = true;
        if (/^\[/.test(cmd)) {
            parsedCommand.optional.push({
                cmd: cmd.replace(bregex, '').split('|'),
                variadic,
            });
        }
        else {
            parsedCommand.demanded.push({
                cmd: cmd.replace(bregex, '').split('|'),
                variadic,
            });
        }
    });
    return parsedCommand;
}

const positionName = ['first', 'second', 'third', 'fourth', 'fifth', 'sixth'];
function argsert(arg1, arg2, arg3) {
    function parseArgs() {
        return typeof arg1 === 'object'
            ? [{ demanded: [], optional: [] }, arg1, arg2]
            : [
                parseCommand(`cmd ${arg1}`),
                arg2,
                arg3,
            ];
    }
    try {
        let position = 0;
        const [parsed, callerArguments, _length] = parseArgs();
        const args = [].slice.call(callerArguments);
        while (args.length && args[args.length - 1] === undefined)
            args.pop();
        const length = _length || args.length;
        if (length < parsed.demanded.length) {
            throw new YError(`Not enough arguments provided. Expected ${parsed.demanded.length} but received ${args.length}.`);
        }
        const totalCommands = parsed.demanded.length + parsed.optional.length;
        if (length > totalCommands) {
            throw new YError(`Too many arguments provided. Expected max ${totalCommands} but received ${length}.`);
        }
        parsed.demanded.forEach(demanded => {
            const arg = args.shift();
            const observedType = guessType(arg);
            const matchingTypes = demanded.cmd.filter(type => type === observedType || type === '*');
            if (matchingTypes.length === 0)
                argumentTypeError(observedType, demanded.cmd, position);
            position += 1;
        });
        parsed.optional.forEach(optional => {
            if (args.length === 0)
                return;
            const arg = args.shift();
            const observedType = guessType(arg);
            const matchingTypes = optional.cmd.filter(type => type === observedType || type === '*');
            if (matchingTypes.length === 0)
                argumentTypeError(observedType, optional.cmd, position);
            position += 1;
        });
    }
    catch (err) {
        console.warn(err.stack);
    }
}
function guessType(arg) {
    if (Array.isArray(arg)) {
        return 'array';
    }
    else if (arg === null) {
        return 'null';
    }
    return typeof arg;
}
function argumentTypeError(observedType, allowedTypes, position) {
    throw new YError(`Invalid ${positionName[position] || 'manyith'} argument. Expected ${allowedTypes.join(' or ')} but received ${observedType}.`);
}

class GlobalMiddleware {
    constructor(yargs) {
        this.globalMiddleware = [];
        this.frozens = [];
        this.yargs = yargs;
    }
    addMiddleware(callback, applyBeforeValidation, global = true, mutates = false) {
        argsert('<array|function> [boolean] [boolean] [boolean]', [callback, applyBeforeValidation, global], arguments.length);
        if (Array.isArray(callback)) {
            for (let i = 0; i < callback.length; i++) {
                if (typeof callback[i] !== 'function') {
                    throw Error('middleware must be a function');
                }
                const m = callback[i];
                m.applyBeforeValidation = applyBeforeValidation;
                m.global = global;
            }
            Array.prototype.push.apply(this.globalMiddleware, callback);
        }
        else if (typeof callback === 'function') {
            const m = callback;
            m.applyBeforeValidation = applyBeforeValidation;
            m.global = global;
            m.mutates = mutates;
            this.globalMiddleware.push(callback);
        }
        return this.yargs;
    }
    addCoerceMiddleware(callback, option) {
        const aliases = this.yargs.getAliases();
        this.globalMiddleware = this.globalMiddleware.filter(m => {
            const toCheck = [...(aliases[option] || []), option];
            if (!m.option)
                return true;
            else
                return !toCheck.includes(m.option);
        });
        callback.option = option;
        return this.addMiddleware(callback, true, true, true);
    }
    getMiddleware() {
        return this.globalMiddleware;
    }
    freeze() {
        this.frozens.push([...this.globalMiddleware]);
    }
    unfreeze() {
        const frozen = this.frozens.pop();
        if (frozen !== undefined)
            this.globalMiddleware = frozen;
    }
    reset() {
        this.globalMiddleware = this.globalMiddleware.filter(m => m.global);
    }
}
function commandMiddlewareFactory(commandMiddleware) {
    if (!commandMiddleware)
        return [];
    return commandMiddleware.map(middleware => {
        middleware.applyBeforeValidation = false;
        return middleware;
    });
}
function applyMiddleware(argv, yargs, middlewares, beforeValidation) {
    return middlewares.reduce((acc, middleware) => {
        if (middleware.applyBeforeValidation !== beforeValidation) {
            return acc;
        }
        if (middleware.mutates) {
            if (middleware.applied)
                return acc;
            middleware.applied = true;
        }
        if (isPromise$1(acc)) {
            return acc
                .then(initialObj => Promise.all([initialObj, middleware(initialObj, yargs)]))
                .then(([initialObj, middlewareObj]) => Object.assign(initialObj, middlewareObj));
        }
        else {
            const result = middleware(acc, yargs);
            return isPromise$1(result)
                ? result.then(middlewareObj => Object.assign(acc, middlewareObj))
                : Object.assign(acc, result);
        }
    }, argv);
}

function maybeAsyncResult(getResult, resultHandler, errorHandler = (err) => {
    throw err;
}) {
    try {
        const result = isFunction$1(getResult) ? getResult() : getResult;
        return isPromise$1(result)
            ? result.then((result) => resultHandler(result))
            : resultHandler(result);
    }
    catch (err) {
        return errorHandler(err);
    }
}
function isFunction$1(arg) {
    return typeof arg === 'function';
}

const DEFAULT_MARKER = /(^\*)|(^\$0)/;
class CommandInstance {
    constructor(usage, validation, globalMiddleware, shim) {
        this.requireCache = new Set();
        this.handlers = {};
        this.aliasMap = {};
        this.frozens = [];
        this.shim = shim;
        this.usage = usage;
        this.globalMiddleware = globalMiddleware;
        this.validation = validation;
    }
    addDirectory(dir, req, callerFile, opts) {
        opts = opts || {};
        this.requireCache.add(callerFile);
        const fullDirPath = this.shim.path.resolve(this.shim.path.dirname(callerFile), dir);
        const files = this.shim.readdirSync(fullDirPath, {
            recursive: opts.recurse ? true : false,
        });
        if (!Array.isArray(opts.extensions))
            opts.extensions = ['js'];
        const visit = typeof opts.visit === 'function' ? opts.visit : (o) => o;
        for (const fileb of files) {
            const file = fileb.toString();
            if (opts.exclude) {
                let exclude = false;
                if (typeof opts.exclude === 'function') {
                    exclude = opts.exclude(file);
                }
                else {
                    exclude = opts.exclude.test(file);
                }
                if (exclude)
                    continue;
            }
            if (opts.include) {
                let include = false;
                if (typeof opts.include === 'function') {
                    include = opts.include(file);
                }
                else {
                    include = opts.include.test(file);
                }
                if (!include)
                    continue;
            }
            let supportedExtension = false;
            for (const ext of opts.extensions) {
                if (file.endsWith(ext))
                    supportedExtension = true;
            }
            if (supportedExtension) {
                const joined = this.shim.path.join(fullDirPath, file);
                const module = req(joined);
                const extendableModule = Object.create(null, Object.getOwnPropertyDescriptors({ ...module }));
                const visited = visit(extendableModule, joined, file);
                if (visited) {
                    if (this.requireCache.has(joined))
                        continue;
                    else
                        this.requireCache.add(joined);
                    if (!extendableModule.command) {
                        extendableModule.command = this.shim.path.basename(joined, this.shim.path.extname(joined));
                    }
                    this.addHandler(extendableModule);
                }
            }
        }
    }
    addHandler(cmd, description, builder, handler, commandMiddleware, deprecated) {
        let aliases = [];
        const middlewares = commandMiddlewareFactory(commandMiddleware);
        handler = handler || (() => { });
        if (Array.isArray(cmd)) {
            if (isCommandAndAliases(cmd)) {
                [cmd, ...aliases] = cmd;
            }
            else {
                for (const command of cmd) {
                    this.addHandler(command);
                }
            }
        }
        else if (isCommandHandlerDefinition(cmd)) {
            let command = Array.isArray(cmd.command) || typeof cmd.command === 'string'
                ? cmd.command
                : null;
            if (command === null) {
                throw new Error(`No command name given for module: ${this.shim.inspect(cmd)}`);
            }
            if (cmd.aliases)
                command = [].concat(command).concat(cmd.aliases);
            this.addHandler(command, this.extractDesc(cmd), cmd.builder, cmd.handler, cmd.middlewares, cmd.deprecated);
            return;
        }
        else if (isCommandBuilderDefinition(builder)) {
            this.addHandler([cmd].concat(aliases), description, builder.builder, builder.handler, builder.middlewares, builder.deprecated);
            return;
        }
        if (typeof cmd === 'string') {
            const parsedCommand = parseCommand(cmd);
            aliases = aliases.map(alias => parseCommand(alias).cmd);
            let isDefault = false;
            const parsedAliases = [parsedCommand.cmd].concat(aliases).filter(c => {
                if (DEFAULT_MARKER.test(c)) {
                    isDefault = true;
                    return false;
                }
                return true;
            });
            if (parsedAliases.length === 0 && isDefault)
                parsedAliases.push('$0');
            if (isDefault) {
                parsedCommand.cmd = parsedAliases[0];
                aliases = parsedAliases.slice(1);
                cmd = cmd.replace(DEFAULT_MARKER, parsedCommand.cmd);
            }
            aliases.forEach(alias => {
                this.aliasMap[alias] = parsedCommand.cmd;
            });
            if (description !== false) {
                this.usage.command(cmd, description, isDefault, aliases, deprecated);
            }
            this.handlers[parsedCommand.cmd] = {
                original: cmd,
                description,
                handler,
                builder: builder || {},
                middlewares,
                deprecated,
                demanded: parsedCommand.demanded,
                optional: parsedCommand.optional,
            };
            if (isDefault)
                this.defaultCommand = this.handlers[parsedCommand.cmd];
        }
    }
    getCommandHandlers() {
        return this.handlers;
    }
    getCommands() {
        return Object.keys(this.handlers).concat(Object.keys(this.aliasMap));
    }
    hasDefaultCommand() {
        return !!this.defaultCommand;
    }
    runCommand(command, yargs, parsed, commandIndex, helpOnly, helpOrVersionSet) {
        const commandHandler = this.handlers[command] ||
            this.handlers[this.aliasMap[command]] ||
            this.defaultCommand;
        const currentContext = yargs.getInternalMethods().getContext();
        const parentCommands = currentContext.commands.slice();
        const isDefaultCommand = !command;
        if (command) {
            currentContext.commands.push(command);
            currentContext.fullCommands.push(commandHandler.original);
        }
        const builderResult = this.applyBuilderUpdateUsageAndParse(isDefaultCommand, commandHandler, yargs, parsed.aliases, parentCommands, commandIndex, helpOnly, helpOrVersionSet);
        return isPromise$1(builderResult)
            ? builderResult.then(result => this.applyMiddlewareAndGetResult(isDefaultCommand, commandHandler, result.innerArgv, currentContext, helpOnly, result.aliases, yargs))
            : this.applyMiddlewareAndGetResult(isDefaultCommand, commandHandler, builderResult.innerArgv, currentContext, helpOnly, builderResult.aliases, yargs);
    }
    applyBuilderUpdateUsageAndParse(isDefaultCommand, commandHandler, yargs, aliases, parentCommands, commandIndex, helpOnly, helpOrVersionSet) {
        const builder = commandHandler.builder;
        let innerYargs = yargs;
        if (isCommandBuilderCallback(builder)) {
            yargs.getInternalMethods().getUsageInstance().freeze();
            const builderOutput = builder(yargs.getInternalMethods().reset(aliases), helpOrVersionSet);
            if (isPromise$1(builderOutput)) {
                return builderOutput.then(output => {
                    innerYargs = isYargsInstance(output) ? output : yargs;
                    return this.parseAndUpdateUsage(isDefaultCommand, commandHandler, innerYargs, parentCommands, commandIndex, helpOnly);
                });
            }
        }
        else if (isCommandBuilderOptionDefinitions(builder)) {
            yargs.getInternalMethods().getUsageInstance().freeze();
            innerYargs = yargs.getInternalMethods().reset(aliases);
            Object.keys(commandHandler.builder).forEach(key => {
                innerYargs.option(key, builder[key]);
            });
        }
        return this.parseAndUpdateUsage(isDefaultCommand, commandHandler, innerYargs, parentCommands, commandIndex, helpOnly);
    }
    parseAndUpdateUsage(isDefaultCommand, commandHandler, innerYargs, parentCommands, commandIndex, helpOnly) {
        if (isDefaultCommand)
            innerYargs.getInternalMethods().getUsageInstance().unfreeze(true);
        if (this.shouldUpdateUsage(innerYargs)) {
            innerYargs
                .getInternalMethods()
                .getUsageInstance()
                .usage(this.usageFromParentCommandsCommandHandler(parentCommands, commandHandler), commandHandler.description);
        }
        const innerArgv = innerYargs
            .getInternalMethods()
            .runYargsParserAndExecuteCommands(null, undefined, true, commandIndex, helpOnly);
        return isPromise$1(innerArgv)
            ? innerArgv.then(argv => ({
                aliases: innerYargs.parsed.aliases,
                innerArgv: argv,
            }))
            : {
                aliases: innerYargs.parsed.aliases,
                innerArgv: innerArgv,
            };
    }
    shouldUpdateUsage(yargs) {
        return (!yargs.getInternalMethods().getUsageInstance().getUsageDisabled() &&
            yargs.getInternalMethods().getUsageInstance().getUsage().length === 0);
    }
    usageFromParentCommandsCommandHandler(parentCommands, commandHandler) {
        const c = DEFAULT_MARKER.test(commandHandler.original)
            ? commandHandler.original.replace(DEFAULT_MARKER, '').trim()
            : commandHandler.original;
        const pc = parentCommands.filter(c => {
            return !DEFAULT_MARKER.test(c);
        });
        pc.push(c);
        return `$0 ${pc.join(' ')}`;
    }
    handleValidationAndGetResult(isDefaultCommand, commandHandler, innerArgv, currentContext, aliases, yargs, middlewares, positionalMap) {
        if (!yargs.getInternalMethods().getHasOutput()) {
            const validation = yargs
                .getInternalMethods()
                .runValidation(aliases, positionalMap, yargs.parsed.error, isDefaultCommand);
            innerArgv = maybeAsyncResult(innerArgv, result => {
                validation(result);
                return result;
            });
        }
        if (commandHandler.handler && !yargs.getInternalMethods().getHasOutput()) {
            yargs.getInternalMethods().setHasOutput();
            const populateDoubleDash = !!yargs.getOptions().configuration['populate--'];
            yargs
                .getInternalMethods()
                .postProcess(innerArgv, populateDoubleDash, false, false);
            innerArgv = applyMiddleware(innerArgv, yargs, middlewares, false);
            innerArgv = maybeAsyncResult(innerArgv, result => {
                const handlerResult = commandHandler.handler(result);
                return isPromise$1(handlerResult)
                    ? handlerResult.then(() => result)
                    : result;
            });
            if (!isDefaultCommand) {
                yargs.getInternalMethods().getUsageInstance().cacheHelpMessage();
            }
            if (isPromise$1(innerArgv) &&
                !yargs.getInternalMethods().hasParseCallback()) {
                innerArgv.catch(error => {
                    try {
                        yargs.getInternalMethods().getUsageInstance().fail(null, error);
                    }
                    catch (_err) {
                    }
                });
            }
        }
        if (!isDefaultCommand) {
            currentContext.commands.pop();
            currentContext.fullCommands.pop();
        }
        return innerArgv;
    }
    applyMiddlewareAndGetResult(isDefaultCommand, commandHandler, innerArgv, currentContext, helpOnly, aliases, yargs) {
        let positionalMap = {};
        if (helpOnly)
            return innerArgv;
        if (!yargs.getInternalMethods().getHasOutput()) {
            positionalMap = this.populatePositionals(commandHandler, innerArgv, currentContext, yargs);
        }
        const middlewares = this.globalMiddleware
            .getMiddleware()
            .slice(0)
            .concat(commandHandler.middlewares);
        const maybePromiseArgv = applyMiddleware(innerArgv, yargs, middlewares, true);
        return isPromise$1(maybePromiseArgv)
            ? maybePromiseArgv.then(resolvedInnerArgv => this.handleValidationAndGetResult(isDefaultCommand, commandHandler, resolvedInnerArgv, currentContext, aliases, yargs, middlewares, positionalMap))
            : this.handleValidationAndGetResult(isDefaultCommand, commandHandler, maybePromiseArgv, currentContext, aliases, yargs, middlewares, positionalMap);
    }
    populatePositionals(commandHandler, argv, context, yargs) {
        argv._ = argv._.slice(context.commands.length);
        const demanded = commandHandler.demanded.slice(0);
        const optional = commandHandler.optional.slice(0);
        const positionalMap = {};
        this.validation.positionalCount(demanded.length, argv._.length);
        while (demanded.length) {
            const demand = demanded.shift();
            this.populatePositional(demand, argv, positionalMap);
        }
        while (optional.length) {
            const maybe = optional.shift();
            this.populatePositional(maybe, argv, positionalMap);
        }
        argv._ = context.commands.concat(argv._.map(a => '' + a));
        this.postProcessPositionals(argv, positionalMap, this.cmdToParseOptions(commandHandler.original), yargs);
        return positionalMap;
    }
    populatePositional(positional, argv, positionalMap) {
        const cmd = positional.cmd[0];
        if (positional.variadic) {
            positionalMap[cmd] = argv._.splice(0).map(String);
        }
        else {
            if (argv._.length)
                positionalMap[cmd] = [String(argv._.shift())];
        }
    }
    cmdToParseOptions(cmdString) {
        const parseOptions = {
            array: [],
            default: {},
            alias: {},
            demand: {},
        };
        const parsed = parseCommand(cmdString);
        parsed.demanded.forEach(d => {
            const [cmd, ...aliases] = d.cmd;
            if (d.variadic) {
                parseOptions.array.push(cmd);
                parseOptions.default[cmd] = [];
            }
            parseOptions.alias[cmd] = aliases;
            parseOptions.demand[cmd] = true;
        });
        parsed.optional.forEach(o => {
            const [cmd, ...aliases] = o.cmd;
            if (o.variadic) {
                parseOptions.array.push(cmd);
                parseOptions.default[cmd] = [];
            }
            parseOptions.alias[cmd] = aliases;
        });
        return parseOptions;
    }
    postProcessPositionals(argv, positionalMap, parseOptions, yargs) {
        const options = Object.assign({}, yargs.getOptions());
        options.default = Object.assign(parseOptions.default, options.default);
        for (const key of Object.keys(parseOptions.alias)) {
            options.alias[key] = (options.alias[key] || []).concat(parseOptions.alias[key]);
        }
        options.array = options.array.concat(parseOptions.array);
        options.config = {};
        const unparsed = [];
        Object.keys(positionalMap).forEach(key => {
            positionalMap[key].map(value => {
                if (options.configuration['unknown-options-as-args'])
                    options.key[key] = true;
                unparsed.push(`--${key}`);
                unparsed.push(value);
            });
        });
        if (!unparsed.length)
            return;
        const config = Object.assign({}, options.configuration, {
            'populate--': false,
        });
        const parsed = this.shim.Parser.detailed(unparsed, Object.assign({}, options, {
            configuration: config,
        }));
        if (parsed.error) {
            yargs
                .getInternalMethods()
                .getUsageInstance()
                .fail(parsed.error.message, parsed.error);
        }
        else {
            const positionalKeys = Object.keys(positionalMap);
            Object.keys(positionalMap).forEach(key => {
                positionalKeys.push(...parsed.aliases[key]);
            });
            Object.keys(parsed.argv).forEach(key => {
                if (positionalKeys.includes(key)) {
                    if (!positionalMap[key])
                        positionalMap[key] = parsed.argv[key];
                    if (!this.isInConfigs(yargs, key) &&
                        !this.isDefaulted(yargs, key) &&
                        Object.prototype.hasOwnProperty.call(argv, key) &&
                        Object.prototype.hasOwnProperty.call(parsed.argv, key) &&
                        (Array.isArray(argv[key]) || Array.isArray(parsed.argv[key]))) {
                        argv[key] = [].concat(argv[key], parsed.argv[key]);
                    }
                    else {
                        argv[key] = parsed.argv[key];
                    }
                }
            });
        }
    }
    isDefaulted(yargs, key) {
        const { default: defaults } = yargs.getOptions();
        return (Object.prototype.hasOwnProperty.call(defaults, key) ||
            Object.prototype.hasOwnProperty.call(defaults, this.shim.Parser.camelCase(key)));
    }
    isInConfigs(yargs, key) {
        const { configObjects } = yargs.getOptions();
        return (configObjects.some(c => Object.prototype.hasOwnProperty.call(c, key)) ||
            configObjects.some(c => Object.prototype.hasOwnProperty.call(c, this.shim.Parser.camelCase(key))));
    }
    runDefaultBuilderOn(yargs) {
        if (!this.defaultCommand)
            return;
        if (this.shouldUpdateUsage(yargs)) {
            const commandString = DEFAULT_MARKER.test(this.defaultCommand.original)
                ? this.defaultCommand.original
                : this.defaultCommand.original.replace(/^[^[\]<>]*/, '$0 ');
            yargs
                .getInternalMethods()
                .getUsageInstance()
                .usage(commandString, this.defaultCommand.description);
        }
        const builder = this.defaultCommand.builder;
        if (isCommandBuilderCallback(builder)) {
            return builder(yargs, true);
        }
        else if (!isCommandBuilderDefinition(builder)) {
            Object.keys(builder).forEach(key => {
                yargs.option(key, builder[key]);
            });
        }
        return undefined;
    }
    extractDesc({ describe, description, desc }) {
        for (const test of [describe, description, desc]) {
            if (typeof test === 'string' || test === false)
                return test;
            assertNotStrictEqual(test, true, this.shim);
        }
        return false;
    }
    freeze() {
        this.frozens.push({
            handlers: this.handlers,
            aliasMap: this.aliasMap,
            defaultCommand: this.defaultCommand,
        });
    }
    unfreeze() {
        const frozen = this.frozens.pop();
        assertNotStrictEqual(frozen, undefined, this.shim);
        ({
            handlers: this.handlers,
            aliasMap: this.aliasMap,
            defaultCommand: this.defaultCommand,
        } = frozen);
    }
    reset() {
        this.handlers = {};
        this.aliasMap = {};
        this.defaultCommand = undefined;
        this.requireCache = new Set();
        return this;
    }
}
function command(usage, validation, globalMiddleware, shim) {
    return new CommandInstance(usage, validation, globalMiddleware, shim);
}
function isCommandBuilderDefinition(builder) {
    return (typeof builder === 'object' &&
        !!builder.builder &&
        typeof builder.handler === 'function');
}
function isCommandAndAliases(cmd) {
    return cmd.every(c => typeof c === 'string');
}
function isCommandBuilderCallback(builder) {
    return typeof builder === 'function';
}
function isCommandBuilderOptionDefinitions(builder) {
    return typeof builder === 'object';
}
function isCommandHandlerDefinition(cmd) {
    return typeof cmd === 'object' && !Array.isArray(cmd);
}

function objFilter(original = {}, filter = () => true) {
    const obj = {};
    objectKeys(original).forEach(key => {
        if (filter(key, original[key])) {
            obj[key] = original[key];
        }
    });
    return obj;
}

function setBlocking(blocking) {
    if (typeof process === 'undefined')
        return;
    [process.stdout, process.stderr].forEach(_stream => {
        const stream = _stream;
        if (stream._handle &&
            stream.isTTY &&
            typeof stream._handle.setBlocking === 'function') {
            stream._handle.setBlocking(blocking);
        }
    });
}

function isBoolean(fail) {
    return typeof fail === 'boolean';
}
function usage(yargs, shim) {
    const __ = shim.y18n.__;
    const self = {};
    const fails = [];
    self.failFn = function failFn(f) {
        fails.push(f);
    };
    let failMessage = null;
    let globalFailMessage = null;
    let showHelpOnFail = true;
    self.showHelpOnFail = function showHelpOnFailFn(arg1 = true, arg2) {
        const [enabled, message] = typeof arg1 === 'string' ? [true, arg1] : [arg1, arg2];
        if (yargs.getInternalMethods().isGlobalContext()) {
            globalFailMessage = message;
        }
        failMessage = message;
        showHelpOnFail = enabled;
        return self;
    };
    let failureOutput = false;
    self.fail = function fail(msg, err) {
        const logger = yargs.getInternalMethods().getLoggerInstance();
        if (fails.length) {
            for (let i = fails.length - 1; i >= 0; --i) {
                const fail = fails[i];
                if (isBoolean(fail)) {
                    if (err)
                        throw err;
                    else if (msg)
                        throw Error(msg);
                }
                else {
                    fail(msg, err, self);
                }
            }
        }
        else {
            if (yargs.getExitProcess())
                setBlocking(true);
            if (!failureOutput) {
                failureOutput = true;
                if (showHelpOnFail) {
                    yargs.showHelp('error');
                    logger.error();
                }
                if (msg || err)
                    logger.error(msg || err);
                const globalOrCommandFailMessage = failMessage || globalFailMessage;
                if (globalOrCommandFailMessage) {
                    if (msg || err)
                        logger.error('');
                    logger.error(globalOrCommandFailMessage);
                }
            }
            err = err || new YError(msg);
            if (yargs.getExitProcess()) {
                return yargs.exit(1);
            }
            else if (yargs.getInternalMethods().hasParseCallback()) {
                return yargs.exit(1, err);
            }
            else {
                throw err;
            }
        }
    };
    let usages = [];
    let usageDisabled = false;
    self.usage = (msg, description) => {
        if (msg === null) {
            usageDisabled = true;
            usages = [];
            return self;
        }
        usageDisabled = false;
        usages.push([msg, description || '']);
        return self;
    };
    self.getUsage = () => {
        return usages;
    };
    self.getUsageDisabled = () => {
        return usageDisabled;
    };
    self.getPositionalGroupName = () => {
        return __('Positionals:');
    };
    let examples = [];
    self.example = (cmd, description) => {
        examples.push([cmd, description || '']);
    };
    let commands = [];
    self.command = function command(cmd, description, isDefault, aliases, deprecated = false) {
        if (isDefault) {
            commands = commands.map(cmdArray => {
                cmdArray[2] = false;
                return cmdArray;
            });
        }
        commands.push([cmd, description || '', isDefault, aliases, deprecated]);
    };
    self.getCommands = () => commands;
    let descriptions = {};
    self.describe = function describe(keyOrKeys, desc) {
        if (Array.isArray(keyOrKeys)) {
            keyOrKeys.forEach(k => {
                self.describe(k, desc);
            });
        }
        else if (typeof keyOrKeys === 'object') {
            Object.keys(keyOrKeys).forEach(k => {
                self.describe(k, keyOrKeys[k]);
            });
        }
        else {
            descriptions[keyOrKeys] = desc;
        }
    };
    self.getDescriptions = () => descriptions;
    let epilogs = [];
    self.epilog = msg => {
        epilogs.push(msg);
    };
    let wrapSet = false;
    let wrap;
    self.wrap = cols => {
        wrapSet = true;
        wrap = cols;
    };
    self.getWrap = () => {
        if (shim.getEnv('YARGS_DISABLE_WRAP')) {
            return null;
        }
        if (!wrapSet) {
            wrap = windowWidth();
            wrapSet = true;
        }
        return wrap;
    };
    const deferY18nLookupPrefix = '__yargsString__:';
    self.deferY18nLookup = str => deferY18nLookupPrefix + str;
    self.help = function help() {
        if (cachedHelpMessage)
            return cachedHelpMessage;
        normalizeAliases();
        const base$0 = yargs.customScriptName
            ? yargs.$0
            : shim.path.basename(yargs.$0);
        const demandedOptions = yargs.getDemandedOptions();
        const demandedCommands = yargs.getDemandedCommands();
        const deprecatedOptions = yargs.getDeprecatedOptions();
        const groups = yargs.getGroups();
        const options = yargs.getOptions();
        let keys = [];
        keys = keys.concat(Object.keys(descriptions));
        keys = keys.concat(Object.keys(demandedOptions));
        keys = keys.concat(Object.keys(demandedCommands));
        keys = keys.concat(Object.keys(options.default));
        keys = keys.filter(filterHiddenOptions);
        keys = Object.keys(keys.reduce((acc, key) => {
            if (key !== '_')
                acc[key] = true;
            return acc;
        }, {}));
        const theWrap = self.getWrap();
        const ui = shim.cliui({
            width: theWrap,
            wrap: !!theWrap,
        });
        if (!usageDisabled) {
            if (usages.length) {
                usages.forEach(usage => {
                    ui.div({ text: `${usage[0].replace(/\$0/g, base$0)}` });
                    if (usage[1]) {
                        ui.div({ text: `${usage[1]}`, padding: [1, 0, 0, 0] });
                    }
                });
                ui.div();
            }
            else if (commands.length) {
                let u = null;
                if (demandedCommands._) {
                    u = `${base$0} <${__('command')}>\n`;
                }
                else {
                    u = `${base$0} [${__('command')}]\n`;
                }
                ui.div(`${u}`);
            }
        }
        if (commands.length > 1 || (commands.length === 1 && !commands[0][2])) {
            ui.div(__('Commands:'));
            const context = yargs.getInternalMethods().getContext();
            const parentCommands = context.commands.length
                ? `${context.commands.join(' ')} `
                : '';
            if (yargs.getInternalMethods().getParserConfiguration()['sort-commands'] ===
                true) {
                commands = commands.sort((a, b) => a[0].localeCompare(b[0]));
            }
            const prefix = base$0 ? `${base$0} ` : '';
            commands.forEach(command => {
                const commandString = `${prefix}${parentCommands}${command[0].replace(/^\$0 ?/, '')}`;
                ui.span({
                    text: commandString,
                    padding: [0, 2, 0, 2],
                    width: maxWidth(commands, theWrap, `${base$0}${parentCommands}`) + 4,
                }, { text: command[1] });
                const hints = [];
                if (command[2])
                    hints.push(`[${__('default')}]`);
                if (command[3] && command[3].length) {
                    hints.push(`[${__('aliases:')} ${command[3].join(', ')}]`);
                }
                if (command[4]) {
                    if (typeof command[4] === 'string') {
                        hints.push(`[${__('deprecated: %s', command[4])}]`);
                    }
                    else {
                        hints.push(`[${__('deprecated')}]`);
                    }
                }
                if (hints.length) {
                    ui.div({
                        text: hints.join(' '),
                        padding: [0, 0, 0, 2],
                        align: 'right',
                    });
                }
                else {
                    ui.div();
                }
            });
            ui.div();
        }
        const aliasKeys = (Object.keys(options.alias) || []).concat(Object.keys(yargs.parsed.newAliases) || []);
        keys = keys.filter(key => !yargs.parsed.newAliases[key] &&
            aliasKeys.every(alias => (options.alias[alias] || []).indexOf(key) === -1));
        const defaultGroup = __('Options:');
        if (!groups[defaultGroup])
            groups[defaultGroup] = [];
        addUngroupedKeys(keys, options.alias, groups, defaultGroup);
        const isLongSwitch = (sw) => /^--/.test(getText$1(sw));
        const displayedGroups = Object.keys(groups)
            .filter(groupName => groups[groupName].length > 0)
            .map(groupName => {
            const normalizedKeys = groups[groupName]
                .filter(filterHiddenOptions)
                .map(key => {
                if (aliasKeys.includes(key))
                    return key;
                for (let i = 0, aliasKey; (aliasKey = aliasKeys[i]) !== undefined; i++) {
                    if ((options.alias[aliasKey] || []).includes(key))
                        return aliasKey;
                }
                return key;
            });
            return { groupName, normalizedKeys };
        })
            .filter(({ normalizedKeys }) => normalizedKeys.length > 0)
            .map(({ groupName, normalizedKeys }) => {
            const switches = normalizedKeys.reduce((acc, key) => {
                acc[key] = [key]
                    .concat(options.alias[key] || [])
                    .map(sw => {
                    if (groupName === self.getPositionalGroupName())
                        return sw;
                    else {
                        return ((/^[0-9]$/.test(sw)
                            ? options.boolean.includes(key)
                                ? '-'
                                : '--'
                            : sw.length > 1
                                ? '--'
                                : '-') + sw);
                    }
                })
                    .sort((sw1, sw2) => isLongSwitch(sw1) === isLongSwitch(sw2)
                    ? 0
                    : isLongSwitch(sw1)
                        ? 1
                        : -1)
                    .join(', ');
                return acc;
            }, {});
            return { groupName, normalizedKeys, switches };
        });
        const shortSwitchesUsed = displayedGroups
            .filter(({ groupName }) => groupName !== self.getPositionalGroupName())
            .some(({ normalizedKeys, switches }) => !normalizedKeys.every(key => isLongSwitch(switches[key])));
        if (shortSwitchesUsed) {
            displayedGroups
                .filter(({ groupName }) => groupName !== self.getPositionalGroupName())
                .forEach(({ normalizedKeys, switches }) => {
                normalizedKeys.forEach(key => {
                    if (isLongSwitch(switches[key])) {
                        switches[key] = addIndentation(switches[key], '-x, '.length);
                    }
                });
            });
        }
        displayedGroups.forEach(({ groupName, normalizedKeys, switches }) => {
            ui.div(groupName);
            normalizedKeys.forEach(key => {
                const kswitch = switches[key];
                let desc = descriptions[key] || '';
                let type = null;
                if (desc.includes(deferY18nLookupPrefix))
                    desc = __(desc.substring(deferY18nLookupPrefix.length));
                if (options.boolean.includes(key))
                    type = `[${__('boolean')}]`;
                if (options.count.includes(key))
                    type = `[${__('count')}]`;
                if (options.string.includes(key))
                    type = `[${__('string')}]`;
                if (options.normalize.includes(key))
                    type = `[${__('string')}]`;
                if (options.array.includes(key))
                    type = `[${__('array')}]`;
                if (options.number.includes(key))
                    type = `[${__('number')}]`;
                const deprecatedExtra = (deprecated) => typeof deprecated === 'string'
                    ? `[${__('deprecated: %s', deprecated)}]`
                    : `[${__('deprecated')}]`;
                const extra = [
                    key in deprecatedOptions
                        ? deprecatedExtra(deprecatedOptions[key])
                        : null,
                    type,
                    key in demandedOptions ? `[${__('required')}]` : null,
                    options.choices && options.choices[key]
                        ? `[${__('choices:')} ${self.stringifiedValues(options.choices[key])}]`
                        : null,
                    defaultString(options.default[key], options.defaultDescription[key]),
                ]
                    .filter(Boolean)
                    .join(' ');
                ui.span({
                    text: getText$1(kswitch),
                    padding: [0, 2, 0, 2 + getIndentation(kswitch)],
                    width: maxWidth(switches, theWrap) + 4,
                }, desc);
                const shouldHideOptionExtras = yargs.getInternalMethods().getUsageConfiguration()['hide-types'] ===
                    true;
                if (extra && !shouldHideOptionExtras)
                    ui.div({ text: extra, padding: [0, 0, 0, 2], align: 'right' });
                else
                    ui.div();
            });
            ui.div();
        });
        if (examples.length) {
            ui.div(__('Examples:'));
            examples.forEach(example => {
                example[0] = example[0].replace(/\$0/g, base$0);
            });
            examples.forEach(example => {
                if (example[1] === '') {
                    ui.div({
                        text: example[0],
                        padding: [0, 2, 0, 2],
                    });
                }
                else {
                    ui.div({
                        text: example[0],
                        padding: [0, 2, 0, 2],
                        width: maxWidth(examples, theWrap) + 4,
                    }, {
                        text: example[1],
                    });
                }
            });
            ui.div();
        }
        if (epilogs.length > 0) {
            const e = epilogs
                .map(epilog => epilog.replace(/\$0/g, base$0))
                .join('\n');
            ui.div(`${e}\n`);
        }
        return ui.toString().replace(/\s*$/, '');
    };
    function maxWidth(table, theWrap, modifier) {
        let width = 0;
        if (!Array.isArray(table)) {
            table = Object.values(table).map(v => [v]);
        }
        table.forEach(v => {
            width = Math.max(shim.stringWidth(modifier ? `${modifier} ${getText$1(v[0])}` : getText$1(v[0])) + getIndentation(v[0]), width);
        });
        if (theWrap)
            width = Math.min(width, parseInt((theWrap * 0.5).toString(), 10));
        return width;
    }
    function normalizeAliases() {
        const demandedOptions = yargs.getDemandedOptions();
        const options = yargs.getOptions();
        (Object.keys(options.alias) || []).forEach(key => {
            options.alias[key].forEach(alias => {
                if (descriptions[alias])
                    self.describe(key, descriptions[alias]);
                if (alias in demandedOptions)
                    yargs.demandOption(key, demandedOptions[alias]);
                if (options.boolean.includes(alias))
                    yargs.boolean(key);
                if (options.count.includes(alias))
                    yargs.count(key);
                if (options.string.includes(alias))
                    yargs.string(key);
                if (options.normalize.includes(alias))
                    yargs.normalize(key);
                if (options.array.includes(alias))
                    yargs.array(key);
                if (options.number.includes(alias))
                    yargs.number(key);
            });
        });
    }
    let cachedHelpMessage;
    self.cacheHelpMessage = function () {
        cachedHelpMessage = this.help();
    };
    self.clearCachedHelpMessage = function () {
        cachedHelpMessage = undefined;
    };
    self.hasCachedHelpMessage = function () {
        return !!cachedHelpMessage;
    };
    function addUngroupedKeys(keys, aliases, groups, defaultGroup) {
        let groupedKeys = [];
        let toCheck = null;
        Object.keys(groups).forEach(group => {
            groupedKeys = groupedKeys.concat(groups[group]);
        });
        keys.forEach(key => {
            toCheck = [key].concat(aliases[key]);
            if (!toCheck.some(k => groupedKeys.indexOf(k) !== -1)) {
                groups[defaultGroup].push(key);
            }
        });
        return groupedKeys;
    }
    function filterHiddenOptions(key) {
        return (yargs.getOptions().hiddenOptions.indexOf(key) < 0 ||
            yargs.parsed.argv[yargs.getOptions().showHiddenOpt]);
    }
    self.showHelp = (level) => {
        const logger = yargs.getInternalMethods().getLoggerInstance();
        if (!level)
            level = 'error';
        const emit = typeof level === 'function' ? level : logger[level];
        emit(self.help());
    };
    self.functionDescription = fn => {
        const description = fn.name
            ? shim.Parser.decamelize(fn.name, '-')
            : __('generated-value');
        return ['(', description, ')'].join('');
    };
    self.stringifiedValues = function stringifiedValues(values, separator) {
        let string = '';
        const sep = separator || ', ';
        const array = [].concat(values);
        if (!values || !array.length)
            return string;
        array.forEach(value => {
            if (string.length)
                string += sep;
            string += JSON.stringify(value);
        });
        return string;
    };
    function defaultString(value, defaultDescription) {
        let string = `[${__('default:')} `;
        if (value === undefined && !defaultDescription)
            return null;
        if (defaultDescription) {
            string += defaultDescription;
        }
        else {
            switch (typeof value) {
                case 'string':
                    string += `"${value}"`;
                    break;
                case 'object':
                    string += JSON.stringify(value);
                    break;
                default:
                    string += value;
            }
        }
        return `${string}]`;
    }
    function windowWidth() {
        const maxWidth = 80;
        if (shim.process.stdColumns) {
            return Math.min(maxWidth, shim.process.stdColumns);
        }
        else {
            return maxWidth;
        }
    }
    let version = null;
    self.version = ver => {
        version = ver;
    };
    self.showVersion = level => {
        const logger = yargs.getInternalMethods().getLoggerInstance();
        if (!level)
            level = 'error';
        const emit = typeof level === 'function' ? level : logger[level];
        emit(version);
    };
    self.reset = function reset(localLookup) {
        failMessage = null;
        failureOutput = false;
        usages = [];
        usageDisabled = false;
        epilogs = [];
        examples = [];
        commands = [];
        descriptions = objFilter(descriptions, k => !localLookup[k]);
        return self;
    };
    const frozens = [];
    self.freeze = function freeze() {
        frozens.push({
            failMessage,
            failureOutput,
            usages,
            usageDisabled,
            epilogs,
            examples,
            commands,
            descriptions,
        });
    };
    self.unfreeze = function unfreeze(defaultCommand = false) {
        const frozen = frozens.pop();
        if (!frozen)
            return;
        if (defaultCommand) {
            descriptions = { ...frozen.descriptions, ...descriptions };
            commands = [...frozen.commands, ...commands];
            usages = [...frozen.usages, ...usages];
            examples = [...frozen.examples, ...examples];
            epilogs = [...frozen.epilogs, ...epilogs];
        }
        else {
            ({
                failMessage,
                failureOutput,
                usages,
                usageDisabled,
                epilogs,
                examples,
                commands,
                descriptions,
            } = frozen);
        }
    };
    return self;
}
function isIndentedText(text) {
    return typeof text === 'object';
}
function addIndentation(text, indent) {
    return isIndentedText(text)
        ? { text: text.text, indentation: text.indentation + indent }
        : { text, indentation: indent };
}
function getIndentation(text) {
    return isIndentedText(text) ? text.indentation : 0;
}
function getText$1(text) {
    return isIndentedText(text) ? text.text : text;
}

const completionShTemplate = `###-begin-{{app_name}}-completions-###
#
# yargs command completion script
#
# Installation: {{app_path}} {{completion_command}} >> ~/.bashrc
#    or {{app_path}} {{completion_command}} >> ~/.bash_profile on OSX.
#
_{{app_name}}_yargs_completions()
{
    local cur_word args type_list

    cur_word="\${COMP_WORDS[COMP_CWORD]}"
    args=("\${COMP_WORDS[@]}")

    # ask yargs to generate completions.
    # see https://stackoverflow.com/a/40944195/7080036 for the spaces-handling awk
    mapfile -t type_list < <({{app_path}} --get-yargs-completions "\${args[@]}")
    mapfile -t COMPREPLY < <(compgen -W "$( printf '%q ' "\${type_list[@]}" )" -- "\${cur_word}" |
        awk '/ / { print "\\""$0"\\"" } /^[^ ]+$/ { print $0 }')

    # if no match was found, fall back to filename completion
    if [ \${#COMPREPLY[@]} -eq 0 ]; then
      COMPREPLY=()
    fi

    return 0
}
complete -o bashdefault -o default -F _{{app_name}}_yargs_completions {{app_name}}
###-end-{{app_name}}-completions-###
`;
const completionZshTemplate = `#compdef {{app_name}}
###-begin-{{app_name}}-completions-###
#
# yargs command completion script
#
# Installation: {{app_path}} {{completion_command}} >> ~/.zshrc
#    or {{app_path}} {{completion_command}} >> ~/.zprofile on OSX.
#
_{{app_name}}_yargs_completions()
{
  local reply
  local si=$IFS
  IFS=$'\n' reply=($(COMP_CWORD="$((CURRENT-1))" COMP_LINE="$BUFFER" COMP_POINT="$CURSOR" {{app_path}} --get-yargs-completions "\${words[@]}"))
  IFS=$si
  if [[ \${#reply} -gt 0 ]]; then
    _describe 'values' reply
  else
    _default
  fi
}
if [[ "'\${zsh_eval_context[-1]}" == "loadautofunc" ]]; then
  _{{app_name}}_yargs_completions "$@"
else
  compdef _{{app_name}}_yargs_completions {{app_name}}
fi
###-end-{{app_name}}-completions-###
`;

class Completion {
    constructor(yargs, usage, command, shim) {
        var _a, _b, _c;
        this.yargs = yargs;
        this.usage = usage;
        this.command = command;
        this.shim = shim;
        this.completionKey = 'get-yargs-completions';
        this.aliases = null;
        this.customCompletionFunction = null;
        this.indexAfterLastReset = 0;
        this.zshShell =
            (_c = (((_a = this.shim.getEnv('SHELL')) === null || _a === void 0 ? void 0 : _a.includes('zsh')) ||
                ((_b = this.shim.getEnv('ZSH_NAME')) === null || _b === void 0 ? void 0 : _b.includes('zsh')))) !== null && _c !== void 0 ? _c : false;
    }
    defaultCompletion(args, argv, current, done) {
        const handlers = this.command.getCommandHandlers();
        for (let i = 0, ii = args.length; i < ii; ++i) {
            if (handlers[args[i]] && handlers[args[i]].builder) {
                const builder = handlers[args[i]].builder;
                if (isCommandBuilderCallback(builder)) {
                    this.indexAfterLastReset = i + 1;
                    const y = this.yargs.getInternalMethods().reset();
                    builder(y, true);
                    return y.argv;
                }
            }
        }
        const completions = [];
        this.commandCompletions(completions, args, current);
        this.optionCompletions(completions, args, argv, current);
        this.choicesFromOptionsCompletions(completions, args, argv, current);
        this.choicesFromPositionalsCompletions(completions, args, argv, current);
        done(null, completions);
    }
    commandCompletions(completions, args, current) {
        const parentCommands = this.yargs
            .getInternalMethods()
            .getContext().commands;
        if (!current.match(/^-/) &&
            parentCommands[parentCommands.length - 1] !== current &&
            !this.previousArgHasChoices(args)) {
            this.usage.getCommands().forEach(usageCommand => {
                const commandName = parseCommand(usageCommand[0]).cmd;
                if (args.indexOf(commandName) === -1) {
                    if (!this.zshShell) {
                        completions.push(commandName);
                    }
                    else {
                        const desc = usageCommand[1] || '';
                        completions.push(commandName.replace(/:/g, '\\:') + ':' + desc);
                    }
                }
            });
        }
    }
    optionCompletions(completions, args, argv, current) {
        if ((current.match(/^-/) || (current === '' && completions.length === 0)) &&
            !this.previousArgHasChoices(args)) {
            const options = this.yargs.getOptions();
            const positionalKeys = this.yargs.getGroups()[this.usage.getPositionalGroupName()] || [];
            Object.keys(options.key).forEach(key => {
                const negable = !!options.configuration['boolean-negation'] &&
                    options.boolean.includes(key);
                const isPositionalKey = positionalKeys.includes(key);
                if (!isPositionalKey &&
                    !options.hiddenOptions.includes(key) &&
                    !this.argsContainKey(args, key, negable)) {
                    this.completeOptionKey(key, completions, current, negable && !!options.default[key]);
                }
            });
        }
    }
    choicesFromOptionsCompletions(completions, args, argv, current) {
        if (this.previousArgHasChoices(args)) {
            const choices = this.getPreviousArgChoices(args);
            if (choices && choices.length > 0) {
                completions.push(...choices.map(c => c.replace(/:/g, '\\:')));
            }
        }
    }
    choicesFromPositionalsCompletions(completions, args, argv, current) {
        if (current === '' &&
            completions.length > 0 &&
            this.previousArgHasChoices(args)) {
            return;
        }
        const positionalKeys = this.yargs.getGroups()[this.usage.getPositionalGroupName()] || [];
        const offset = Math.max(this.indexAfterLastReset, this.yargs.getInternalMethods().getContext().commands.length +
            1);
        const positionalKey = positionalKeys[argv._.length - offset - 1];
        if (!positionalKey) {
            return;
        }
        const choices = this.yargs.getOptions().choices[positionalKey] || [];
        for (const choice of choices) {
            if (choice.startsWith(current)) {
                completions.push(choice.replace(/:/g, '\\:'));
            }
        }
    }
    getPreviousArgChoices(args) {
        if (args.length < 1)
            return;
        let previousArg = args[args.length - 1];
        let filter = '';
        if (!previousArg.startsWith('-') && args.length > 1) {
            filter = previousArg;
            previousArg = args[args.length - 2];
        }
        if (!previousArg.startsWith('-'))
            return;
        const previousArgKey = previousArg.replace(/^-+/, '');
        const options = this.yargs.getOptions();
        const possibleAliases = [
            previousArgKey,
            ...(this.yargs.getAliases()[previousArgKey] || []),
        ];
        let choices;
        for (const possibleAlias of possibleAliases) {
            if (Object.prototype.hasOwnProperty.call(options.key, possibleAlias) &&
                Array.isArray(options.choices[possibleAlias])) {
                choices = options.choices[possibleAlias];
                break;
            }
        }
        if (choices) {
            return choices.filter(choice => !filter || choice.startsWith(filter));
        }
    }
    previousArgHasChoices(args) {
        const choices = this.getPreviousArgChoices(args);
        return choices !== undefined && choices.length > 0;
    }
    argsContainKey(args, key, negable) {
        const argsContains = (s) => args.indexOf((/^[^0-9]$/.test(s) ? '-' : '--') + s) !== -1;
        if (argsContains(key))
            return true;
        if (negable && argsContains(`no-${key}`))
            return true;
        if (this.aliases) {
            for (const alias of this.aliases[key]) {
                if (argsContains(alias))
                    return true;
            }
        }
        return false;
    }
    completeOptionKey(key, completions, current, negable) {
        var _a, _b, _c, _d;
        let keyWithDesc = key;
        if (this.zshShell) {
            const descs = this.usage.getDescriptions();
            const aliasKey = (_b = (_a = this === null || this === void 0 ? void 0 : this.aliases) === null || _a === void 0 ? void 0 : _a[key]) === null || _b === void 0 ? void 0 : _b.find(alias => {
                const desc = descs[alias];
                return typeof desc === 'string' && desc.length > 0;
            });
            const descFromAlias = aliasKey ? descs[aliasKey] : undefined;
            const desc = (_d = (_c = descs[key]) !== null && _c !== void 0 ? _c : descFromAlias) !== null && _d !== void 0 ? _d : '';
            keyWithDesc = `${key.replace(/:/g, '\\:')}:${desc
                .replace('__yargsString__:', '')
                .replace(/(\r\n|\n|\r)/gm, ' ')}`;
        }
        const startsByTwoDashes = (s) => /^--/.test(s);
        const isShortOption = (s) => /^[^0-9]$/.test(s);
        const dashes = !startsByTwoDashes(current) && isShortOption(key) ? '-' : '--';
        completions.push(dashes + keyWithDesc);
        if (negable) {
            completions.push(dashes + 'no-' + keyWithDesc);
        }
    }
    customCompletion(args, argv, current, done) {
        assertNotStrictEqual(this.customCompletionFunction, null, this.shim);
        if (isSyncCompletionFunction(this.customCompletionFunction)) {
            const result = this.customCompletionFunction(current, argv);
            if (isPromise$1(result)) {
                return result
                    .then(list => {
                    this.shim.process.nextTick(() => {
                        done(null, list);
                    });
                })
                    .catch(err => {
                    this.shim.process.nextTick(() => {
                        done(err, undefined);
                    });
                });
            }
            return done(null, result);
        }
        else if (isFallbackCompletionFunction(this.customCompletionFunction)) {
            return this.customCompletionFunction(current, argv, (onCompleted = done) => this.defaultCompletion(args, argv, current, onCompleted), completions => {
                done(null, completions);
            });
        }
        else {
            return this.customCompletionFunction(current, argv, completions => {
                done(null, completions);
            });
        }
    }
    getCompletion(args, done) {
        const current = args.length ? args[args.length - 1] : '';
        const argv = this.yargs.parse(args, true);
        const completionFunction = this.customCompletionFunction
            ? (argv) => this.customCompletion(args, argv, current, done)
            : (argv) => this.defaultCompletion(args, argv, current, done);
        return isPromise$1(argv)
            ? argv.then(completionFunction)
            : completionFunction(argv);
    }
    generateCompletionScript($0, cmd) {
        let script = this.zshShell
            ? completionZshTemplate
            : completionShTemplate;
        const name = this.shim.path.basename($0);
        if ($0.match(/\.js$/))
            $0 = `./${$0}`;
        script = script.replace(/{{app_name}}/g, name);
        script = script.replace(/{{completion_command}}/g, cmd);
        return script.replace(/{{app_path}}/g, $0);
    }
    registerFunction(fn) {
        this.customCompletionFunction = fn;
    }
    setParsed(parsed) {
        this.aliases = parsed.aliases;
    }
}
function completion(yargs, usage, command, shim) {
    return new Completion(yargs, usage, command, shim);
}
function isSyncCompletionFunction(completionFunction) {
    return completionFunction.length < 3;
}
function isFallbackCompletionFunction(completionFunction) {
    return completionFunction.length > 3;
}

function levenshtein(a, b) {
    if (a.length === 0)
        return b.length;
    if (b.length === 0)
        return a.length;
    const matrix = [];
    let i;
    for (i = 0; i <= b.length; i++) {
        matrix[i] = [i];
    }
    let j;
    for (j = 0; j <= a.length; j++) {
        matrix[0][j] = j;
    }
    for (i = 1; i <= b.length; i++) {
        for (j = 1; j <= a.length; j++) {
            if (b.charAt(i - 1) === a.charAt(j - 1)) {
                matrix[i][j] = matrix[i - 1][j - 1];
            }
            else {
                if (i > 1 &&
                    j > 1 &&
                    b.charAt(i - 2) === a.charAt(j - 1) &&
                    b.charAt(i - 1) === a.charAt(j - 2)) {
                    matrix[i][j] = matrix[i - 2][j - 2] + 1;
                }
                else {
                    matrix[i][j] = Math.min(matrix[i - 1][j - 1] + 1, Math.min(matrix[i][j - 1] + 1, matrix[i - 1][j] + 1));
                }
            }
        }
    }
    return matrix[b.length][a.length];
}

const specialKeys = ['$0', '--', '_'];
function validation$1(yargs, usage, shim) {
    const __ = shim.y18n.__;
    const __n = shim.y18n.__n;
    const self = {};
    self.nonOptionCount = function nonOptionCount(argv) {
        const demandedCommands = yargs.getDemandedCommands();
        const positionalCount = argv._.length + (argv['--'] ? argv['--'].length : 0);
        const _s = positionalCount - yargs.getInternalMethods().getContext().commands.length;
        if (demandedCommands._ &&
            (_s < demandedCommands._.min || _s > demandedCommands._.max)) {
            if (_s < demandedCommands._.min) {
                if (demandedCommands._.minMsg !== undefined) {
                    usage.fail(demandedCommands._.minMsg
                        ? demandedCommands._.minMsg
                            .replace(/\$0/g, _s.toString())
                            .replace(/\$1/, demandedCommands._.min.toString())
                        : null);
                }
                else {
                    usage.fail(__n('Not enough non-option arguments: got %s, need at least %s', 'Not enough non-option arguments: got %s, need at least %s', _s, _s.toString(), demandedCommands._.min.toString()));
                }
            }
            else if (_s > demandedCommands._.max) {
                if (demandedCommands._.maxMsg !== undefined) {
                    usage.fail(demandedCommands._.maxMsg
                        ? demandedCommands._.maxMsg
                            .replace(/\$0/g, _s.toString())
                            .replace(/\$1/, demandedCommands._.max.toString())
                        : null);
                }
                else {
                    usage.fail(__n('Too many non-option arguments: got %s, maximum of %s', 'Too many non-option arguments: got %s, maximum of %s', _s, _s.toString(), demandedCommands._.max.toString()));
                }
            }
        }
    };
    self.positionalCount = function positionalCount(required, observed) {
        if (observed < required) {
            usage.fail(__n('Not enough non-option arguments: got %s, need at least %s', 'Not enough non-option arguments: got %s, need at least %s', observed, observed + '', required + ''));
        }
    };
    self.requiredArguments = function requiredArguments(argv, demandedOptions) {
        let missing = null;
        for (const key of Object.keys(demandedOptions)) {
            if (!Object.prototype.hasOwnProperty.call(argv, key) ||
                typeof argv[key] === 'undefined') {
                missing = missing || {};
                missing[key] = demandedOptions[key];
            }
        }
        if (missing) {
            const customMsgs = [];
            for (const key of Object.keys(missing)) {
                const msg = missing[key];
                if (msg && customMsgs.indexOf(msg) < 0) {
                    customMsgs.push(msg);
                }
            }
            const customMsg = customMsgs.length ? `\n${customMsgs.join('\n')}` : '';
            usage.fail(__n('Missing required argument: %s', 'Missing required arguments: %s', Object.keys(missing).length, Object.keys(missing).join(', ') + customMsg));
        }
    };
    self.unknownArguments = function unknownArguments(argv, aliases, positionalMap, isDefaultCommand, checkPositionals = true) {
        var _a;
        const commandKeys = yargs
            .getInternalMethods()
            .getCommandInstance()
            .getCommands();
        const unknown = [];
        const currentContext = yargs.getInternalMethods().getContext();
        Object.keys(argv).forEach(key => {
            if (!specialKeys.includes(key) &&
                !Object.prototype.hasOwnProperty.call(positionalMap, key) &&
                !Object.prototype.hasOwnProperty.call(yargs.getInternalMethods().getParseContext(), key) &&
                !self.isValidAndSomeAliasIsNotNew(key, aliases)) {
                unknown.push(key);
            }
        });
        if (checkPositionals &&
            (currentContext.commands.length > 0 ||
                commandKeys.length > 0 ||
                isDefaultCommand)) {
            argv._.slice(currentContext.commands.length).forEach(key => {
                if (!commandKeys.includes('' + key)) {
                    unknown.push('' + key);
                }
            });
        }
        if (checkPositionals) {
            const demandedCommands = yargs.getDemandedCommands();
            const maxNonOptDemanded = ((_a = demandedCommands._) === null || _a === void 0 ? void 0 : _a.max) || 0;
            const expected = currentContext.commands.length + maxNonOptDemanded;
            if (expected < argv._.length) {
                argv._.slice(expected).forEach(key => {
                    key = String(key);
                    if (!currentContext.commands.includes(key) &&
                        !unknown.includes(key)) {
                        unknown.push(key);
                    }
                });
            }
        }
        if (unknown.length) {
            usage.fail(__n('Unknown argument: %s', 'Unknown arguments: %s', unknown.length, unknown.map(s => (s.trim() ? s : `"${s}"`)).join(', ')));
        }
    };
    self.unknownCommands = function unknownCommands(argv) {
        const commandKeys = yargs
            .getInternalMethods()
            .getCommandInstance()
            .getCommands();
        const unknown = [];
        const currentContext = yargs.getInternalMethods().getContext();
        if (currentContext.commands.length > 0 || commandKeys.length > 0) {
            argv._.slice(currentContext.commands.length).forEach(key => {
                if (!commandKeys.includes('' + key)) {
                    unknown.push('' + key);
                }
            });
        }
        if (unknown.length > 0) {
            usage.fail(__n('Unknown command: %s', 'Unknown commands: %s', unknown.length, unknown.join(', ')));
            return true;
        }
        else {
            return false;
        }
    };
    self.isValidAndSomeAliasIsNotNew = function isValidAndSomeAliasIsNotNew(key, aliases) {
        if (!Object.prototype.hasOwnProperty.call(aliases, key)) {
            return false;
        }
        const newAliases = yargs.parsed.newAliases;
        return [key, ...aliases[key]].some(a => !Object.prototype.hasOwnProperty.call(newAliases, a) || !newAliases[key]);
    };
    self.limitedChoices = function limitedChoices(argv) {
        const options = yargs.getOptions();
        const invalid = {};
        if (!Object.keys(options.choices).length)
            return;
        Object.keys(argv).forEach(key => {
            if (specialKeys.indexOf(key) === -1 &&
                Object.prototype.hasOwnProperty.call(options.choices, key)) {
                [].concat(argv[key]).forEach(value => {
                    if (options.choices[key].indexOf(value) === -1 &&
                        value !== undefined) {
                        invalid[key] = (invalid[key] || []).concat(value);
                    }
                });
            }
        });
        const invalidKeys = Object.keys(invalid);
        if (!invalidKeys.length)
            return;
        let msg = __('Invalid values:');
        invalidKeys.forEach(key => {
            msg += `\n  ${__('Argument: %s, Given: %s, Choices: %s', key, usage.stringifiedValues(invalid[key]), usage.stringifiedValues(options.choices[key]))}`;
        });
        usage.fail(msg);
    };
    let implied = {};
    self.implies = function implies(key, value) {
        argsert('<string|object> [array|number|string]', [key, value], arguments.length);
        if (typeof key === 'object') {
            Object.keys(key).forEach(k => {
                self.implies(k, key[k]);
            });
        }
        else {
            yargs.global(key);
            if (!implied[key]) {
                implied[key] = [];
            }
            if (Array.isArray(value)) {
                value.forEach(i => self.implies(key, i));
            }
            else {
                assertNotStrictEqual(value, undefined, shim);
                implied[key].push(value);
            }
        }
    };
    self.getImplied = function getImplied() {
        return implied;
    };
    function keyExists(argv, val) {
        const num = Number(val);
        val = isNaN(num) ? val : num;
        if (typeof val === 'number') {
            val = argv._.length >= val;
        }
        else if (val.match(/^--no-.+/)) {
            val = val.match(/^--no-(.+)/)[1];
            val = !Object.prototype.hasOwnProperty.call(argv, val);
        }
        else {
            val = Object.prototype.hasOwnProperty.call(argv, val);
        }
        return val;
    }
    self.implications = function implications(argv) {
        const implyFail = [];
        Object.keys(implied).forEach(key => {
            const origKey = key;
            (implied[key] || []).forEach(value => {
                let key = origKey;
                const origValue = value;
                key = keyExists(argv, key);
                value = keyExists(argv, value);
                if (key && !value) {
                    implyFail.push(` ${origKey} -> ${origValue}`);
                }
            });
        });
        if (implyFail.length) {
            let msg = `${__('Implications failed:')}\n`;
            implyFail.forEach(value => {
                msg += value;
            });
            usage.fail(msg);
        }
    };
    let conflicting = {};
    self.conflicts = function conflicts(key, value) {
        argsert('<string|object> [array|string]', [key, value], arguments.length);
        if (typeof key === 'object') {
            Object.keys(key).forEach(k => {
                self.conflicts(k, key[k]);
            });
        }
        else {
            yargs.global(key);
            if (!conflicting[key]) {
                conflicting[key] = [];
            }
            if (Array.isArray(value)) {
                value.forEach(i => self.conflicts(key, i));
            }
            else {
                conflicting[key].push(value);
            }
        }
    };
    self.getConflicting = () => conflicting;
    self.conflicting = function conflictingFn(argv) {
        Object.keys(argv).forEach(key => {
            if (conflicting[key]) {
                conflicting[key].forEach(value => {
                    if (value && argv[key] !== undefined && argv[value] !== undefined) {
                        usage.fail(__('Arguments %s and %s are mutually exclusive', key, value));
                    }
                });
            }
        });
        if (yargs.getInternalMethods().getParserConfiguration()['strip-dashed']) {
            Object.keys(conflicting).forEach(key => {
                conflicting[key].forEach(value => {
                    if (value &&
                        argv[shim.Parser.camelCase(key)] !== undefined &&
                        argv[shim.Parser.camelCase(value)] !== undefined) {
                        usage.fail(__('Arguments %s and %s are mutually exclusive', key, value));
                    }
                });
            });
        }
    };
    self.recommendCommands = function recommendCommands(cmd, potentialCommands) {
        const threshold = 3;
        potentialCommands = potentialCommands.sort((a, b) => b.length - a.length);
        let recommended = null;
        let bestDistance = Infinity;
        for (let i = 0, candidate; (candidate = potentialCommands[i]) !== undefined; i++) {
            const d = levenshtein(cmd, candidate);
            if (d <= threshold && d < bestDistance) {
                bestDistance = d;
                recommended = candidate;
            }
        }
        if (recommended)
            usage.fail(__('Did you mean %s?', recommended));
    };
    self.reset = function reset(localLookup) {
        implied = objFilter(implied, k => !localLookup[k]);
        conflicting = objFilter(conflicting, k => !localLookup[k]);
        return self;
    };
    const frozens = [];
    self.freeze = function freeze() {
        frozens.push({
            implied,
            conflicting,
        });
    };
    self.unfreeze = function unfreeze() {
        const frozen = frozens.pop();
        assertNotStrictEqual(frozen, undefined, shim);
        ({ implied, conflicting } = frozen);
    };
    return self;
}

let previouslyVisitedConfigs = [];
let shim;
function applyExtends(config, cwd, mergeExtends, _shim) {
    shim = _shim;
    let defaultConfig = {};
    if (Object.prototype.hasOwnProperty.call(config, 'extends')) {
        if (typeof config.extends !== 'string')
            return defaultConfig;
        const isPath = /\.json|\..*rc$/.test(config.extends);
        let pathToDefault = null;
        if (!isPath) {
            try {
                pathToDefault = import.meta.resolve(config.extends);
            }
            catch (_err) {
                return config;
            }
        }
        else {
            pathToDefault = getPathToDefaultConfig(cwd, config.extends);
        }
        checkForCircularExtends(pathToDefault);
        previouslyVisitedConfigs.push(pathToDefault);
        defaultConfig = isPath
            ? JSON.parse(shim.readFileSync(pathToDefault, 'utf8'))
            : _shim.require(config.extends);
        delete config.extends;
        defaultConfig = applyExtends(defaultConfig, shim.path.dirname(pathToDefault), mergeExtends, shim);
    }
    previouslyVisitedConfigs = [];
    return mergeExtends
        ? mergeDeep(defaultConfig, config)
        : Object.assign({}, defaultConfig, config);
}
function checkForCircularExtends(cfgPath) {
    if (previouslyVisitedConfigs.indexOf(cfgPath) > -1) {
        throw new YError(`Circular extended configurations: '${cfgPath}'.`);
    }
}
function getPathToDefaultConfig(cwd, pathToExtend) {
    return shim.path.resolve(cwd, pathToExtend);
}
function mergeDeep(config1, config2) {
    const target = {};
    function isObject(obj) {
        return obj && typeof obj === 'object' && !Array.isArray(obj);
    }
    Object.assign(target, config1);
    for (const key of Object.keys(config2)) {
        if (isObject(config2[key]) && isObject(target[key])) {
            target[key] = mergeDeep(config1[key], config2[key]);
        }
        else {
            target[key] = config2[key];
        }
    }
    return target;
}

var __classPrivateFieldSet$1 = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet$1 = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _YargsInstance_command, _YargsInstance_cwd, _YargsInstance_context, _YargsInstance_completion, _YargsInstance_completionCommand, _YargsInstance_defaultShowHiddenOpt, _YargsInstance_exitError, _YargsInstance_detectLocale, _YargsInstance_emittedWarnings, _YargsInstance_exitProcess, _YargsInstance_frozens, _YargsInstance_globalMiddleware, _YargsInstance_groups, _YargsInstance_hasOutput, _YargsInstance_helpOpt, _YargsInstance_isGlobalContext, _YargsInstance_logger, _YargsInstance_output, _YargsInstance_options, _YargsInstance_parentRequire, _YargsInstance_parserConfig, _YargsInstance_parseFn, _YargsInstance_parseContext, _YargsInstance_pkgs, _YargsInstance_preservedGroups, _YargsInstance_processArgs, _YargsInstance_recommendCommands, _YargsInstance_shim, _YargsInstance_strict, _YargsInstance_strictCommands, _YargsInstance_strictOptions, _YargsInstance_usage, _YargsInstance_usageConfig, _YargsInstance_versionOpt, _YargsInstance_validation;
function YargsFactory(_shim) {
    return (processArgs = [], cwd = _shim.process.cwd(), parentRequire) => {
        const yargs = new YargsInstance(processArgs, cwd, parentRequire, _shim);
        Object.defineProperty(yargs, 'argv', {
            get: () => {
                return yargs.parse();
            },
            enumerable: true,
        });
        yargs.help();
        yargs.version();
        return yargs;
    };
}
const kCopyDoubleDash = Symbol('copyDoubleDash');
const kCreateLogger = Symbol('copyDoubleDash');
const kDeleteFromParserHintObject = Symbol('deleteFromParserHintObject');
const kEmitWarning = Symbol('emitWarning');
const kFreeze = Symbol('freeze');
const kGetDollarZero = Symbol('getDollarZero');
const kGetParserConfiguration = Symbol('getParserConfiguration');
const kGetUsageConfiguration = Symbol('getUsageConfiguration');
const kGuessLocale = Symbol('guessLocale');
const kGuessVersion = Symbol('guessVersion');
const kParsePositionalNumbers = Symbol('parsePositionalNumbers');
const kPkgUp = Symbol('pkgUp');
const kPopulateParserHintArray = Symbol('populateParserHintArray');
const kPopulateParserHintSingleValueDictionary = Symbol('populateParserHintSingleValueDictionary');
const kPopulateParserHintArrayDictionary = Symbol('populateParserHintArrayDictionary');
const kPopulateParserHintDictionary = Symbol('populateParserHintDictionary');
const kSanitizeKey = Symbol('sanitizeKey');
const kSetKey = Symbol('setKey');
const kUnfreeze = Symbol('unfreeze');
const kValidateAsync = Symbol('validateAsync');
const kGetCommandInstance = Symbol('getCommandInstance');
const kGetContext = Symbol('getContext');
const kGetHasOutput = Symbol('getHasOutput');
const kGetLoggerInstance = Symbol('getLoggerInstance');
const kGetParseContext = Symbol('getParseContext');
const kGetUsageInstance = Symbol('getUsageInstance');
const kGetValidationInstance = Symbol('getValidationInstance');
const kHasParseCallback = Symbol('hasParseCallback');
const kIsGlobalContext = Symbol('isGlobalContext');
const kPostProcess = Symbol('postProcess');
const kRebase = Symbol('rebase');
const kReset = Symbol('reset');
const kRunYargsParserAndExecuteCommands = Symbol('runYargsParserAndExecuteCommands');
const kRunValidation = Symbol('runValidation');
const kSetHasOutput = Symbol('setHasOutput');
const kTrackManuallySetKeys = Symbol('kTrackManuallySetKeys');
const DEFAULT_LOCALE = 'en_US';
class YargsInstance {
    constructor(processArgs = [], cwd, parentRequire, shim) {
        this.customScriptName = false;
        this.parsed = false;
        _YargsInstance_command.set(this, void 0);
        _YargsInstance_cwd.set(this, void 0);
        _YargsInstance_context.set(this, { commands: [], fullCommands: [] });
        _YargsInstance_completion.set(this, null);
        _YargsInstance_completionCommand.set(this, null);
        _YargsInstance_defaultShowHiddenOpt.set(this, 'show-hidden');
        _YargsInstance_exitError.set(this, null);
        _YargsInstance_detectLocale.set(this, true);
        _YargsInstance_emittedWarnings.set(this, {});
        _YargsInstance_exitProcess.set(this, true);
        _YargsInstance_frozens.set(this, []);
        _YargsInstance_globalMiddleware.set(this, void 0);
        _YargsInstance_groups.set(this, {});
        _YargsInstance_hasOutput.set(this, false);
        _YargsInstance_helpOpt.set(this, null);
        _YargsInstance_isGlobalContext.set(this, true);
        _YargsInstance_logger.set(this, void 0);
        _YargsInstance_output.set(this, '');
        _YargsInstance_options.set(this, void 0);
        _YargsInstance_parentRequire.set(this, void 0);
        _YargsInstance_parserConfig.set(this, {});
        _YargsInstance_parseFn.set(this, null);
        _YargsInstance_parseContext.set(this, null);
        _YargsInstance_pkgs.set(this, {});
        _YargsInstance_preservedGroups.set(this, {});
        _YargsInstance_processArgs.set(this, void 0);
        _YargsInstance_recommendCommands.set(this, false);
        _YargsInstance_shim.set(this, void 0);
        _YargsInstance_strict.set(this, false);
        _YargsInstance_strictCommands.set(this, false);
        _YargsInstance_strictOptions.set(this, false);
        _YargsInstance_usage.set(this, void 0);
        _YargsInstance_usageConfig.set(this, {});
        _YargsInstance_versionOpt.set(this, null);
        _YargsInstance_validation.set(this, void 0);
        __classPrivateFieldSet$1(this, _YargsInstance_shim, shim, "f");
        __classPrivateFieldSet$1(this, _YargsInstance_processArgs, processArgs, "f");
        __classPrivateFieldSet$1(this, _YargsInstance_cwd, cwd, "f");
        __classPrivateFieldSet$1(this, _YargsInstance_parentRequire, parentRequire, "f");
        __classPrivateFieldSet$1(this, _YargsInstance_globalMiddleware, new GlobalMiddleware(this), "f");
        this.$0 = this[kGetDollarZero]();
        this[kReset]();
        __classPrivateFieldSet$1(this, _YargsInstance_command, __classPrivateFieldGet$1(this, _YargsInstance_command, "f"), "f");
        __classPrivateFieldSet$1(this, _YargsInstance_usage, __classPrivateFieldGet$1(this, _YargsInstance_usage, "f"), "f");
        __classPrivateFieldSet$1(this, _YargsInstance_validation, __classPrivateFieldGet$1(this, _YargsInstance_validation, "f"), "f");
        __classPrivateFieldSet$1(this, _YargsInstance_options, __classPrivateFieldGet$1(this, _YargsInstance_options, "f"), "f");
        __classPrivateFieldGet$1(this, _YargsInstance_options, "f").showHiddenOpt = __classPrivateFieldGet$1(this, _YargsInstance_defaultShowHiddenOpt, "f");
        __classPrivateFieldSet$1(this, _YargsInstance_logger, this[kCreateLogger](), "f");
        __classPrivateFieldGet$1(this, _YargsInstance_shim, "f").y18n.setLocale(DEFAULT_LOCALE);
    }
    addHelpOpt(opt, msg) {
        const defaultHelpOpt = 'help';
        argsert('[string|boolean] [string]', [opt, msg], arguments.length);
        if (__classPrivateFieldGet$1(this, _YargsInstance_helpOpt, "f")) {
            this[kDeleteFromParserHintObject](__classPrivateFieldGet$1(this, _YargsInstance_helpOpt, "f"));
            __classPrivateFieldSet$1(this, _YargsInstance_helpOpt, null, "f");
        }
        if (opt === false && msg === undefined)
            return this;
        __classPrivateFieldSet$1(this, _YargsInstance_helpOpt, typeof opt === 'string' ? opt : defaultHelpOpt, "f");
        this.boolean(__classPrivateFieldGet$1(this, _YargsInstance_helpOpt, "f"));
        this.describe(__classPrivateFieldGet$1(this, _YargsInstance_helpOpt, "f"), msg || __classPrivateFieldGet$1(this, _YargsInstance_usage, "f").deferY18nLookup('Show help'));
        return this;
    }
    help(opt, msg) {
        return this.addHelpOpt(opt, msg);
    }
    addShowHiddenOpt(opt, msg) {
        argsert('[string|boolean] [string]', [opt, msg], arguments.length);
        if (opt === false && msg === undefined)
            return this;
        const showHiddenOpt = typeof opt === 'string' ? opt : __classPrivateFieldGet$1(this, _YargsInstance_defaultShowHiddenOpt, "f");
        this.boolean(showHiddenOpt);
        this.describe(showHiddenOpt, msg || __classPrivateFieldGet$1(this, _YargsInstance_usage, "f").deferY18nLookup('Show hidden options'));
        __classPrivateFieldGet$1(this, _YargsInstance_options, "f").showHiddenOpt = showHiddenOpt;
        return this;
    }
    showHidden(opt, msg) {
        return this.addShowHiddenOpt(opt, msg);
    }
    alias(key, value) {
        argsert('<object|string|array> [string|array]', [key, value], arguments.length);
        this[kPopulateParserHintArrayDictionary](this.alias.bind(this), 'alias', key, value);
        return this;
    }
    array(keys) {
        argsert('<array|string>', [keys], arguments.length);
        this[kPopulateParserHintArray]('array', keys);
        this[kTrackManuallySetKeys](keys);
        return this;
    }
    boolean(keys) {
        argsert('<array|string>', [keys], arguments.length);
        this[kPopulateParserHintArray]('boolean', keys);
        this[kTrackManuallySetKeys](keys);
        return this;
    }
    check(f, global) {
        argsert('<function> [boolean]', [f, global], arguments.length);
        this.middleware((argv, _yargs) => {
            return maybeAsyncResult(() => {
                return f(argv, _yargs.getOptions());
            }, (result) => {
                if (!result) {
                    __classPrivateFieldGet$1(this, _YargsInstance_usage, "f").fail(__classPrivateFieldGet$1(this, _YargsInstance_shim, "f").y18n.__('Argument check failed: %s', f.toString()));
                }
                else if (typeof result === 'string' || result instanceof Error) {
                    __classPrivateFieldGet$1(this, _YargsInstance_usage, "f").fail(result.toString(), result);
                }
                return argv;
            }, (err) => {
                __classPrivateFieldGet$1(this, _YargsInstance_usage, "f").fail(err.message ? err.message : err.toString(), err);
                return argv;
            });
        }, false, global);
        return this;
    }
    choices(key, value) {
        argsert('<object|string|array> [string|array]', [key, value], arguments.length);
        this[kPopulateParserHintArrayDictionary](this.choices.bind(this), 'choices', key, value);
        return this;
    }
    coerce(keys, value) {
        argsert('<object|string|array> [function]', [keys, value], arguments.length);
        if (Array.isArray(keys)) {
            if (!value) {
                throw new YError('coerce callback must be provided');
            }
            for (const key of keys) {
                this.coerce(key, value);
            }
            return this;
        }
        else if (typeof keys === 'object') {
            for (const key of Object.keys(keys)) {
                this.coerce(key, keys[key]);
            }
            return this;
        }
        if (!value) {
            throw new YError('coerce callback must be provided');
        }
        const coerceKey = keys;
        __classPrivateFieldGet$1(this, _YargsInstance_options, "f").key[coerceKey] = true;
        __classPrivateFieldGet$1(this, _YargsInstance_globalMiddleware, "f").addCoerceMiddleware((argv, yargs) => {
            var _a;
            const coerceKeyAliases = (_a = yargs.getAliases()[coerceKey]) !== null && _a !== void 0 ? _a : [];
            const argvKeys = [coerceKey, ...coerceKeyAliases].filter(key => Object.prototype.hasOwnProperty.call(argv, key));
            if (argvKeys.length === 0) {
                return argv;
            }
            return maybeAsyncResult(() => {
                return value(argv[argvKeys[0]]);
            }, (result) => {
                argvKeys.forEach(key => {
                    argv[key] = result;
                });
                return argv;
            }, (err) => {
                throw new YError(err.message);
            });
        }, coerceKey);
        return this;
    }
    conflicts(key1, key2) {
        argsert('<string|object> [string|array]', [key1, key2], arguments.length);
        __classPrivateFieldGet$1(this, _YargsInstance_validation, "f").conflicts(key1, key2);
        return this;
    }
    config(key = 'config', msg, parseFn) {
        argsert('[object|string] [string|function] [function]', [key, msg, parseFn], arguments.length);
        if (typeof key === 'object' && !Array.isArray(key)) {
            key = applyExtends(key, __classPrivateFieldGet$1(this, _YargsInstance_cwd, "f"), this[kGetParserConfiguration]()['deep-merge-config'] || false, __classPrivateFieldGet$1(this, _YargsInstance_shim, "f"));
            __classPrivateFieldGet$1(this, _YargsInstance_options, "f").configObjects = (__classPrivateFieldGet$1(this, _YargsInstance_options, "f").configObjects || []).concat(key);
            return this;
        }
        if (typeof msg === 'function') {
            parseFn = msg;
            msg = undefined;
        }
        this.describe(key, msg || __classPrivateFieldGet$1(this, _YargsInstance_usage, "f").deferY18nLookup('Path to JSON config file'));
        (Array.isArray(key) ? key : [key]).forEach(k => {
            __classPrivateFieldGet$1(this, _YargsInstance_options, "f").config[k] = parseFn || true;
        });
        return this;
    }
    completion(cmd, desc, fn) {
        argsert('[string] [string|boolean|function] [function]', [cmd, desc, fn], arguments.length);
        if (typeof desc === 'function') {
            fn = desc;
            desc = undefined;
        }
        __classPrivateFieldSet$1(this, _YargsInstance_completionCommand, cmd || __classPrivateFieldGet$1(this, _YargsInstance_completionCommand, "f") || 'completion', "f");
        if (!desc && desc !== false) {
            desc = 'generate completion script';
        }
        this.command(__classPrivateFieldGet$1(this, _YargsInstance_completionCommand, "f"), desc);
        if (fn)
            __classPrivateFieldGet$1(this, _YargsInstance_completion, "f").registerFunction(fn);
        return this;
    }
    command(cmd, description, builder, handler, middlewares, deprecated) {
        argsert('<string|array|object> [string|boolean] [function|object] [function] [array] [boolean|string]', [cmd, description, builder, handler, middlewares, deprecated], arguments.length);
        __classPrivateFieldGet$1(this, _YargsInstance_command, "f").addHandler(cmd, description, builder, handler, middlewares, deprecated);
        return this;
    }
    commands(cmd, description, builder, handler, middlewares, deprecated) {
        return this.command(cmd, description, builder, handler, middlewares, deprecated);
    }
    commandDir(dir, opts) {
        argsert('<string> [object]', [dir, opts], arguments.length);
        const req = __classPrivateFieldGet$1(this, _YargsInstance_parentRequire, "f") || __classPrivateFieldGet$1(this, _YargsInstance_shim, "f").require;
        __classPrivateFieldGet$1(this, _YargsInstance_command, "f").addDirectory(dir, req, __classPrivateFieldGet$1(this, _YargsInstance_shim, "f").getCallerFile(), opts);
        return this;
    }
    count(keys) {
        argsert('<array|string>', [keys], arguments.length);
        this[kPopulateParserHintArray]('count', keys);
        this[kTrackManuallySetKeys](keys);
        return this;
    }
    default(key, value, defaultDescription) {
        argsert('<object|string|array> [*] [string]', [key, value, defaultDescription], arguments.length);
        if (defaultDescription) {
            assertSingleKey(key, __classPrivateFieldGet$1(this, _YargsInstance_shim, "f"));
            __classPrivateFieldGet$1(this, _YargsInstance_options, "f").defaultDescription[key] = defaultDescription;
        }
        if (typeof value === 'function') {
            assertSingleKey(key, __classPrivateFieldGet$1(this, _YargsInstance_shim, "f"));
            if (!__classPrivateFieldGet$1(this, _YargsInstance_options, "f").defaultDescription[key])
                __classPrivateFieldGet$1(this, _YargsInstance_options, "f").defaultDescription[key] =
                    __classPrivateFieldGet$1(this, _YargsInstance_usage, "f").functionDescription(value);
            value = value.call();
        }
        this[kPopulateParserHintSingleValueDictionary](this.default.bind(this), 'default', key, value);
        return this;
    }
    defaults(key, value, defaultDescription) {
        return this.default(key, value, defaultDescription);
    }
    demandCommand(min = 1, max, minMsg, maxMsg) {
        argsert('[number] [number|string] [string|null|undefined] [string|null|undefined]', [min, max, minMsg, maxMsg], arguments.length);
        if (typeof max !== 'number') {
            minMsg = max;
            max = Infinity;
        }
        this.global('_', false);
        __classPrivateFieldGet$1(this, _YargsInstance_options, "f").demandedCommands._ = {
            min,
            max,
            minMsg,
            maxMsg,
        };
        return this;
    }
    demand(keys, max, msg) {
        if (Array.isArray(max)) {
            max.forEach(key => {
                assertNotStrictEqual(msg, true, __classPrivateFieldGet$1(this, _YargsInstance_shim, "f"));
                this.demandOption(key, msg);
            });
            max = Infinity;
        }
        else if (typeof max !== 'number') {
            msg = max;
            max = Infinity;
        }
        if (typeof keys === 'number') {
            assertNotStrictEqual(msg, true, __classPrivateFieldGet$1(this, _YargsInstance_shim, "f"));
            this.demandCommand(keys, max, msg, msg);
        }
        else if (Array.isArray(keys)) {
            keys.forEach(key => {
                assertNotStrictEqual(msg, true, __classPrivateFieldGet$1(this, _YargsInstance_shim, "f"));
                this.demandOption(key, msg);
            });
        }
        else {
            if (typeof msg === 'string') {
                this.demandOption(keys, msg);
            }
            else if (msg === true || typeof msg === 'undefined') {
                this.demandOption(keys);
            }
        }
        return this;
    }
    demandOption(keys, msg) {
        argsert('<object|string|array> [string]', [keys, msg], arguments.length);
        this[kPopulateParserHintSingleValueDictionary](this.demandOption.bind(this), 'demandedOptions', keys, msg);
        return this;
    }
    deprecateOption(option, message) {
        argsert('<string> [string|boolean]', [option, message], arguments.length);
        __classPrivateFieldGet$1(this, _YargsInstance_options, "f").deprecatedOptions[option] = message;
        return this;
    }
    describe(keys, description) {
        argsert('<object|string|array> [string]', [keys, description], arguments.length);
        this[kSetKey](keys, true);
        __classPrivateFieldGet$1(this, _YargsInstance_usage, "f").describe(keys, description);
        return this;
    }
    detectLocale(detect) {
        argsert('<boolean>', [detect], arguments.length);
        __classPrivateFieldSet$1(this, _YargsInstance_detectLocale, detect, "f");
        return this;
    }
    env(prefix) {
        argsert('[string|boolean]', [prefix], arguments.length);
        if (prefix === false)
            delete __classPrivateFieldGet$1(this, _YargsInstance_options, "f").envPrefix;
        else
            __classPrivateFieldGet$1(this, _YargsInstance_options, "f").envPrefix = prefix || '';
        return this;
    }
    epilogue(msg) {
        argsert('<string>', [msg], arguments.length);
        __classPrivateFieldGet$1(this, _YargsInstance_usage, "f").epilog(msg);
        return this;
    }
    epilog(msg) {
        return this.epilogue(msg);
    }
    example(cmd, description) {
        argsert('<string|array> [string]', [cmd, description], arguments.length);
        if (Array.isArray(cmd)) {
            cmd.forEach(exampleParams => this.example(...exampleParams));
        }
        else {
            __classPrivateFieldGet$1(this, _YargsInstance_usage, "f").example(cmd, description);
        }
        return this;
    }
    exit(code, err) {
        __classPrivateFieldSet$1(this, _YargsInstance_hasOutput, true, "f");
        __classPrivateFieldSet$1(this, _YargsInstance_exitError, err, "f");
        if (__classPrivateFieldGet$1(this, _YargsInstance_exitProcess, "f"))
            __classPrivateFieldGet$1(this, _YargsInstance_shim, "f").process.exit(code);
    }
    exitProcess(enabled = true) {
        argsert('[boolean]', [enabled], arguments.length);
        __classPrivateFieldSet$1(this, _YargsInstance_exitProcess, enabled, "f");
        return this;
    }
    fail(f) {
        argsert('<function|boolean>', [f], arguments.length);
        if (typeof f === 'boolean' && f !== false) {
            throw new YError("Invalid first argument. Expected function or boolean 'false'");
        }
        __classPrivateFieldGet$1(this, _YargsInstance_usage, "f").failFn(f);
        return this;
    }
    getAliases() {
        return this.parsed ? this.parsed.aliases : {};
    }
    async getCompletion(args, done) {
        argsert('<array> [function]', [args, done], arguments.length);
        if (!done) {
            return new Promise((resolve, reject) => {
                __classPrivateFieldGet$1(this, _YargsInstance_completion, "f").getCompletion(args, (err, completions) => {
                    if (err)
                        reject(err);
                    else
                        resolve(completions);
                });
            });
        }
        else {
            return __classPrivateFieldGet$1(this, _YargsInstance_completion, "f").getCompletion(args, done);
        }
    }
    getDemandedOptions() {
        argsert([], 0);
        return __classPrivateFieldGet$1(this, _YargsInstance_options, "f").demandedOptions;
    }
    getDemandedCommands() {
        argsert([], 0);
        return __classPrivateFieldGet$1(this, _YargsInstance_options, "f").demandedCommands;
    }
    getDeprecatedOptions() {
        argsert([], 0);
        return __classPrivateFieldGet$1(this, _YargsInstance_options, "f").deprecatedOptions;
    }
    getDetectLocale() {
        return __classPrivateFieldGet$1(this, _YargsInstance_detectLocale, "f");
    }
    getExitProcess() {
        return __classPrivateFieldGet$1(this, _YargsInstance_exitProcess, "f");
    }
    getGroups() {
        return Object.assign({}, __classPrivateFieldGet$1(this, _YargsInstance_groups, "f"), __classPrivateFieldGet$1(this, _YargsInstance_preservedGroups, "f"));
    }
    getHelp() {
        __classPrivateFieldSet$1(this, _YargsInstance_hasOutput, true, "f");
        if (!__classPrivateFieldGet$1(this, _YargsInstance_usage, "f").hasCachedHelpMessage()) {
            if (!this.parsed) {
                const parse = this[kRunYargsParserAndExecuteCommands](__classPrivateFieldGet$1(this, _YargsInstance_processArgs, "f"), undefined, undefined, 0, true);
                if (isPromise$1(parse)) {
                    return parse.then(() => {
                        return __classPrivateFieldGet$1(this, _YargsInstance_usage, "f").help();
                    });
                }
            }
            const builderResponse = __classPrivateFieldGet$1(this, _YargsInstance_command, "f").runDefaultBuilderOn(this);
            if (isPromise$1(builderResponse)) {
                return builderResponse.then(() => {
                    return __classPrivateFieldGet$1(this, _YargsInstance_usage, "f").help();
                });
            }
        }
        return Promise.resolve(__classPrivateFieldGet$1(this, _YargsInstance_usage, "f").help());
    }
    getOptions() {
        return __classPrivateFieldGet$1(this, _YargsInstance_options, "f");
    }
    getStrict() {
        return __classPrivateFieldGet$1(this, _YargsInstance_strict, "f");
    }
    getStrictCommands() {
        return __classPrivateFieldGet$1(this, _YargsInstance_strictCommands, "f");
    }
    getStrictOptions() {
        return __classPrivateFieldGet$1(this, _YargsInstance_strictOptions, "f");
    }
    global(globals, global) {
        argsert('<string|array> [boolean]', [globals, global], arguments.length);
        globals = [].concat(globals);
        if (global !== false) {
            __classPrivateFieldGet$1(this, _YargsInstance_options, "f").local = __classPrivateFieldGet$1(this, _YargsInstance_options, "f").local.filter(l => globals.indexOf(l) === -1);
        }
        else {
            globals.forEach(g => {
                if (!__classPrivateFieldGet$1(this, _YargsInstance_options, "f").local.includes(g))
                    __classPrivateFieldGet$1(this, _YargsInstance_options, "f").local.push(g);
            });
        }
        return this;
    }
    group(opts, groupName) {
        argsert('<string|array> <string>', [opts, groupName], arguments.length);
        const existing = __classPrivateFieldGet$1(this, _YargsInstance_preservedGroups, "f")[groupName] || __classPrivateFieldGet$1(this, _YargsInstance_groups, "f")[groupName];
        if (__classPrivateFieldGet$1(this, _YargsInstance_preservedGroups, "f")[groupName]) {
            delete __classPrivateFieldGet$1(this, _YargsInstance_preservedGroups, "f")[groupName];
        }
        const seen = {};
        __classPrivateFieldGet$1(this, _YargsInstance_groups, "f")[groupName] = (existing || []).concat(opts).filter(key => {
            if (seen[key])
                return false;
            return (seen[key] = true);
        });
        return this;
    }
    hide(key) {
        argsert('<string>', [key], arguments.length);
        __classPrivateFieldGet$1(this, _YargsInstance_options, "f").hiddenOptions.push(key);
        return this;
    }
    implies(key, value) {
        argsert('<string|object> [number|string|array]', [key, value], arguments.length);
        __classPrivateFieldGet$1(this, _YargsInstance_validation, "f").implies(key, value);
        return this;
    }
    locale(locale) {
        argsert('[string]', [locale], arguments.length);
        if (locale === undefined) {
            this[kGuessLocale]();
            return __classPrivateFieldGet$1(this, _YargsInstance_shim, "f").y18n.getLocale();
        }
        __classPrivateFieldSet$1(this, _YargsInstance_detectLocale, false, "f");
        __classPrivateFieldGet$1(this, _YargsInstance_shim, "f").y18n.setLocale(locale);
        return this;
    }
    middleware(callback, applyBeforeValidation, global) {
        return __classPrivateFieldGet$1(this, _YargsInstance_globalMiddleware, "f").addMiddleware(callback, !!applyBeforeValidation, global);
    }
    nargs(key, value) {
        argsert('<string|object|array> [number]', [key, value], arguments.length);
        this[kPopulateParserHintSingleValueDictionary](this.nargs.bind(this), 'narg', key, value);
        return this;
    }
    normalize(keys) {
        argsert('<array|string>', [keys], arguments.length);
        this[kPopulateParserHintArray]('normalize', keys);
        return this;
    }
    number(keys) {
        argsert('<array|string>', [keys], arguments.length);
        this[kPopulateParserHintArray]('number', keys);
        this[kTrackManuallySetKeys](keys);
        return this;
    }
    option(key, opt) {
        argsert('<string|object> [object]', [key, opt], arguments.length);
        if (typeof key === 'object') {
            Object.keys(key).forEach(k => {
                this.options(k, key[k]);
            });
        }
        else {
            if (typeof opt !== 'object') {
                opt = {};
            }
            this[kTrackManuallySetKeys](key);
            if (__classPrivateFieldGet$1(this, _YargsInstance_versionOpt, "f") && (key === 'version' || (opt === null || opt === void 0 ? void 0 : opt.alias) === 'version')) {
                this[kEmitWarning]([
                    '"version" is a reserved word.',
                    'Please do one of the following:',
                    '- Disable version with `yargs.version(false)` if using "version" as an option',
                    '- Use the built-in `yargs.version` method instead (if applicable)',
                    '- Use a different option key',
                    'https://yargs.js.org/docs/#api-reference-version',
                ].join('\n'), undefined, 'versionWarning');
            }
            __classPrivateFieldGet$1(this, _YargsInstance_options, "f").key[key] = true;
            if (opt.alias)
                this.alias(key, opt.alias);
            const deprecate = opt.deprecate || opt.deprecated;
            if (deprecate) {
                this.deprecateOption(key, deprecate);
            }
            const demand = opt.demand || opt.required || opt.require;
            if (demand) {
                this.demand(key, demand);
            }
            if (opt.demandOption) {
                this.demandOption(key, typeof opt.demandOption === 'string' ? opt.demandOption : undefined);
            }
            if (opt.conflicts) {
                this.conflicts(key, opt.conflicts);
            }
            if ('default' in opt) {
                this.default(key, opt.default);
            }
            if (opt.implies !== undefined) {
                this.implies(key, opt.implies);
            }
            if (opt.nargs !== undefined) {
                this.nargs(key, opt.nargs);
            }
            if (opt.config) {
                this.config(key, opt.configParser);
            }
            if (opt.normalize) {
                this.normalize(key);
            }
            if (opt.choices) {
                this.choices(key, opt.choices);
            }
            if (opt.coerce) {
                this.coerce(key, opt.coerce);
            }
            if (opt.group) {
                this.group(key, opt.group);
            }
            if (opt.boolean || opt.type === 'boolean') {
                this.boolean(key);
                if (opt.alias)
                    this.boolean(opt.alias);
            }
            if (opt.array || opt.type === 'array') {
                this.array(key);
                if (opt.alias)
                    this.array(opt.alias);
            }
            if (opt.number || opt.type === 'number') {
                this.number(key);
                if (opt.alias)
                    this.number(opt.alias);
            }
            if (opt.string || opt.type === 'string') {
                this.string(key);
                if (opt.alias)
                    this.string(opt.alias);
            }
            if (opt.count || opt.type === 'count') {
                this.count(key);
            }
            if (typeof opt.global === 'boolean') {
                this.global(key, opt.global);
            }
            if (opt.defaultDescription) {
                __classPrivateFieldGet$1(this, _YargsInstance_options, "f").defaultDescription[key] = opt.defaultDescription;
            }
            if (opt.skipValidation) {
                this.skipValidation(key);
            }
            const desc = opt.describe || opt.description || opt.desc;
            const descriptions = __classPrivateFieldGet$1(this, _YargsInstance_usage, "f").getDescriptions();
            if (!Object.prototype.hasOwnProperty.call(descriptions, key) ||
                typeof desc === 'string') {
                this.describe(key, desc);
            }
            if (opt.hidden) {
                this.hide(key);
            }
            if (opt.requiresArg) {
                this.requiresArg(key);
            }
        }
        return this;
    }
    options(key, opt) {
        return this.option(key, opt);
    }
    parse(args, shortCircuit, _parseFn) {
        argsert('[string|array] [function|boolean|object] [function]', [args, shortCircuit, _parseFn], arguments.length);
        this[kFreeze]();
        if (typeof args === 'undefined') {
            args = __classPrivateFieldGet$1(this, _YargsInstance_processArgs, "f");
        }
        if (typeof shortCircuit === 'object') {
            __classPrivateFieldSet$1(this, _YargsInstance_parseContext, shortCircuit, "f");
            shortCircuit = _parseFn;
        }
        if (typeof shortCircuit === 'function') {
            __classPrivateFieldSet$1(this, _YargsInstance_parseFn, shortCircuit, "f");
            shortCircuit = false;
        }
        if (!shortCircuit)
            __classPrivateFieldSet$1(this, _YargsInstance_processArgs, args, "f");
        if (__classPrivateFieldGet$1(this, _YargsInstance_parseFn, "f"))
            __classPrivateFieldSet$1(this, _YargsInstance_exitProcess, false, "f");
        const parsed = this[kRunYargsParserAndExecuteCommands](args, !!shortCircuit);
        const tmpParsed = this.parsed;
        __classPrivateFieldGet$1(this, _YargsInstance_completion, "f").setParsed(this.parsed);
        if (isPromise$1(parsed)) {
            return parsed
                .then(argv => {
                if (__classPrivateFieldGet$1(this, _YargsInstance_parseFn, "f"))
                    __classPrivateFieldGet$1(this, _YargsInstance_parseFn, "f").call(this, __classPrivateFieldGet$1(this, _YargsInstance_exitError, "f"), argv, __classPrivateFieldGet$1(this, _YargsInstance_output, "f"));
                return argv;
            })
                .catch(err => {
                if (__classPrivateFieldGet$1(this, _YargsInstance_parseFn, "f")) {
                    __classPrivateFieldGet$1(this, _YargsInstance_parseFn, "f")(err, this.parsed.argv, __classPrivateFieldGet$1(this, _YargsInstance_output, "f"));
                }
                throw err;
            })
                .finally(() => {
                this[kUnfreeze]();
                this.parsed = tmpParsed;
            });
        }
        else {
            if (__classPrivateFieldGet$1(this, _YargsInstance_parseFn, "f"))
                __classPrivateFieldGet$1(this, _YargsInstance_parseFn, "f").call(this, __classPrivateFieldGet$1(this, _YargsInstance_exitError, "f"), parsed, __classPrivateFieldGet$1(this, _YargsInstance_output, "f"));
            this[kUnfreeze]();
            this.parsed = tmpParsed;
        }
        return parsed;
    }
    parseAsync(args, shortCircuit, _parseFn) {
        const maybePromise = this.parse(args, shortCircuit, _parseFn);
        return !isPromise$1(maybePromise)
            ? Promise.resolve(maybePromise)
            : maybePromise;
    }
    parseSync(args, shortCircuit, _parseFn) {
        const maybePromise = this.parse(args, shortCircuit, _parseFn);
        if (isPromise$1(maybePromise)) {
            throw new YError('.parseSync() must not be used with asynchronous builders, handlers, or middleware');
        }
        return maybePromise;
    }
    parserConfiguration(config) {
        argsert('<object>', [config], arguments.length);
        __classPrivateFieldSet$1(this, _YargsInstance_parserConfig, config, "f");
        return this;
    }
    pkgConf(key, rootPath) {
        argsert('<string> [string]', [key, rootPath], arguments.length);
        let conf = null;
        const obj = this[kPkgUp](rootPath || __classPrivateFieldGet$1(this, _YargsInstance_cwd, "f"));
        if (obj[key] && typeof obj[key] === 'object') {
            conf = applyExtends(obj[key], rootPath || __classPrivateFieldGet$1(this, _YargsInstance_cwd, "f"), this[kGetParserConfiguration]()['deep-merge-config'] || false, __classPrivateFieldGet$1(this, _YargsInstance_shim, "f"));
            __classPrivateFieldGet$1(this, _YargsInstance_options, "f").configObjects = (__classPrivateFieldGet$1(this, _YargsInstance_options, "f").configObjects || []).concat(conf);
        }
        return this;
    }
    positional(key, opts) {
        argsert('<string> <object>', [key, opts], arguments.length);
        const supportedOpts = [
            'default',
            'defaultDescription',
            'implies',
            'normalize',
            'choices',
            'conflicts',
            'coerce',
            'type',
            'describe',
            'desc',
            'description',
            'alias',
        ];
        opts = objFilter(opts, (k, v) => {
            if (k === 'type' && !['string', 'number', 'boolean'].includes(v))
                return false;
            return supportedOpts.includes(k);
        });
        const fullCommand = __classPrivateFieldGet$1(this, _YargsInstance_context, "f").fullCommands[__classPrivateFieldGet$1(this, _YargsInstance_context, "f").fullCommands.length - 1];
        const parseOptions = fullCommand
            ? __classPrivateFieldGet$1(this, _YargsInstance_command, "f").cmdToParseOptions(fullCommand)
            : {
                array: [],
                alias: {},
                default: {},
                demand: {},
            };
        objectKeys(parseOptions).forEach(pk => {
            const parseOption = parseOptions[pk];
            if (Array.isArray(parseOption)) {
                if (parseOption.indexOf(key) !== -1)
                    opts[pk] = true;
            }
            else {
                if (parseOption[key] && !(pk in opts))
                    opts[pk] = parseOption[key];
            }
        });
        this.group(key, __classPrivateFieldGet$1(this, _YargsInstance_usage, "f").getPositionalGroupName());
        return this.option(key, opts);
    }
    recommendCommands(recommend = true) {
        argsert('[boolean]', [recommend], arguments.length);
        __classPrivateFieldSet$1(this, _YargsInstance_recommendCommands, recommend, "f");
        return this;
    }
    required(keys, max, msg) {
        return this.demand(keys, max, msg);
    }
    require(keys, max, msg) {
        return this.demand(keys, max, msg);
    }
    requiresArg(keys) {
        argsert('<array|string|object> [number]', [keys], arguments.length);
        if (typeof keys === 'string' && __classPrivateFieldGet$1(this, _YargsInstance_options, "f").narg[keys]) {
            return this;
        }
        else {
            this[kPopulateParserHintSingleValueDictionary](this.requiresArg.bind(this), 'narg', keys, NaN);
        }
        return this;
    }
    showCompletionScript($0, cmd) {
        argsert('[string] [string]', [$0, cmd], arguments.length);
        $0 = $0 || this.$0;
        __classPrivateFieldGet$1(this, _YargsInstance_logger, "f").log(__classPrivateFieldGet$1(this, _YargsInstance_completion, "f").generateCompletionScript($0, cmd || __classPrivateFieldGet$1(this, _YargsInstance_completionCommand, "f") || 'completion'));
        return this;
    }
    showHelp(level) {
        argsert('[string|function]', [level], arguments.length);
        __classPrivateFieldSet$1(this, _YargsInstance_hasOutput, true, "f");
        if (!__classPrivateFieldGet$1(this, _YargsInstance_usage, "f").hasCachedHelpMessage()) {
            if (!this.parsed) {
                const parse = this[kRunYargsParserAndExecuteCommands](__classPrivateFieldGet$1(this, _YargsInstance_processArgs, "f"), undefined, undefined, 0, true);
                if (isPromise$1(parse)) {
                    parse.then(() => {
                        __classPrivateFieldGet$1(this, _YargsInstance_usage, "f").showHelp(level);
                    });
                    return this;
                }
            }
            const builderResponse = __classPrivateFieldGet$1(this, _YargsInstance_command, "f").runDefaultBuilderOn(this);
            if (isPromise$1(builderResponse)) {
                builderResponse.then(() => {
                    __classPrivateFieldGet$1(this, _YargsInstance_usage, "f").showHelp(level);
                });
                return this;
            }
        }
        __classPrivateFieldGet$1(this, _YargsInstance_usage, "f").showHelp(level);
        return this;
    }
    scriptName(scriptName) {
        this.customScriptName = true;
        this.$0 = scriptName;
        return this;
    }
    showHelpOnFail(enabled, message) {
        argsert('[boolean|string] [string]', [enabled, message], arguments.length);
        __classPrivateFieldGet$1(this, _YargsInstance_usage, "f").showHelpOnFail(enabled, message);
        return this;
    }
    showVersion(level) {
        argsert('[string|function]', [level], arguments.length);
        __classPrivateFieldGet$1(this, _YargsInstance_usage, "f").showVersion(level);
        return this;
    }
    skipValidation(keys) {
        argsert('<array|string>', [keys], arguments.length);
        this[kPopulateParserHintArray]('skipValidation', keys);
        return this;
    }
    strict(enabled) {
        argsert('[boolean]', [enabled], arguments.length);
        __classPrivateFieldSet$1(this, _YargsInstance_strict, enabled !== false, "f");
        return this;
    }
    strictCommands(enabled) {
        argsert('[boolean]', [enabled], arguments.length);
        __classPrivateFieldSet$1(this, _YargsInstance_strictCommands, enabled !== false, "f");
        return this;
    }
    strictOptions(enabled) {
        argsert('[boolean]', [enabled], arguments.length);
        __classPrivateFieldSet$1(this, _YargsInstance_strictOptions, enabled !== false, "f");
        return this;
    }
    string(keys) {
        argsert('<array|string>', [keys], arguments.length);
        this[kPopulateParserHintArray]('string', keys);
        this[kTrackManuallySetKeys](keys);
        return this;
    }
    terminalWidth() {
        argsert([], 0);
        return __classPrivateFieldGet$1(this, _YargsInstance_shim, "f").process.stdColumns;
    }
    updateLocale(obj) {
        return this.updateStrings(obj);
    }
    updateStrings(obj) {
        argsert('<object>', [obj], arguments.length);
        __classPrivateFieldSet$1(this, _YargsInstance_detectLocale, false, "f");
        __classPrivateFieldGet$1(this, _YargsInstance_shim, "f").y18n.updateLocale(obj);
        return this;
    }
    usage(msg, description, builder, handler) {
        argsert('<string|null|undefined> [string|boolean] [function|object] [function]', [msg, description, builder, handler], arguments.length);
        if (description !== undefined) {
            assertNotStrictEqual(msg, null, __classPrivateFieldGet$1(this, _YargsInstance_shim, "f"));
            if ((msg || '').match(/^\$0( |$)/)) {
                return this.command(msg, description, builder, handler);
            }
            else {
                throw new YError('.usage() description must start with $0 if being used as alias for .command()');
            }
        }
        else {
            __classPrivateFieldGet$1(this, _YargsInstance_usage, "f").usage(msg);
            return this;
        }
    }
    usageConfiguration(config) {
        argsert('<object>', [config], arguments.length);
        __classPrivateFieldSet$1(this, _YargsInstance_usageConfig, config, "f");
        return this;
    }
    version(opt, msg, ver) {
        const defaultVersionOpt = 'version';
        argsert('[boolean|string] [string] [string]', [opt, msg, ver], arguments.length);
        if (__classPrivateFieldGet$1(this, _YargsInstance_versionOpt, "f")) {
            this[kDeleteFromParserHintObject](__classPrivateFieldGet$1(this, _YargsInstance_versionOpt, "f"));
            __classPrivateFieldGet$1(this, _YargsInstance_usage, "f").version(undefined);
            __classPrivateFieldSet$1(this, _YargsInstance_versionOpt, null, "f");
        }
        if (arguments.length === 0) {
            ver = this[kGuessVersion]();
            opt = defaultVersionOpt;
        }
        else if (arguments.length === 1) {
            if (opt === false) {
                return this;
            }
            ver = opt;
            opt = defaultVersionOpt;
        }
        else if (arguments.length === 2) {
            ver = msg;
            msg = undefined;
        }
        __classPrivateFieldSet$1(this, _YargsInstance_versionOpt, typeof opt === 'string' ? opt : defaultVersionOpt, "f");
        msg = msg || __classPrivateFieldGet$1(this, _YargsInstance_usage, "f").deferY18nLookup('Show version number');
        __classPrivateFieldGet$1(this, _YargsInstance_usage, "f").version(ver || undefined);
        this.boolean(__classPrivateFieldGet$1(this, _YargsInstance_versionOpt, "f"));
        this.describe(__classPrivateFieldGet$1(this, _YargsInstance_versionOpt, "f"), msg);
        return this;
    }
    wrap(cols) {
        argsert('<number|null|undefined>', [cols], arguments.length);
        __classPrivateFieldGet$1(this, _YargsInstance_usage, "f").wrap(cols);
        return this;
    }
    [(_YargsInstance_command = new WeakMap(), _YargsInstance_cwd = new WeakMap(), _YargsInstance_context = new WeakMap(), _YargsInstance_completion = new WeakMap(), _YargsInstance_completionCommand = new WeakMap(), _YargsInstance_defaultShowHiddenOpt = new WeakMap(), _YargsInstance_exitError = new WeakMap(), _YargsInstance_detectLocale = new WeakMap(), _YargsInstance_emittedWarnings = new WeakMap(), _YargsInstance_exitProcess = new WeakMap(), _YargsInstance_frozens = new WeakMap(), _YargsInstance_globalMiddleware = new WeakMap(), _YargsInstance_groups = new WeakMap(), _YargsInstance_hasOutput = new WeakMap(), _YargsInstance_helpOpt = new WeakMap(), _YargsInstance_isGlobalContext = new WeakMap(), _YargsInstance_logger = new WeakMap(), _YargsInstance_output = new WeakMap(), _YargsInstance_options = new WeakMap(), _YargsInstance_parentRequire = new WeakMap(), _YargsInstance_parserConfig = new WeakMap(), _YargsInstance_parseFn = new WeakMap(), _YargsInstance_parseContext = new WeakMap(), _YargsInstance_pkgs = new WeakMap(), _YargsInstance_preservedGroups = new WeakMap(), _YargsInstance_processArgs = new WeakMap(), _YargsInstance_recommendCommands = new WeakMap(), _YargsInstance_shim = new WeakMap(), _YargsInstance_strict = new WeakMap(), _YargsInstance_strictCommands = new WeakMap(), _YargsInstance_strictOptions = new WeakMap(), _YargsInstance_usage = new WeakMap(), _YargsInstance_usageConfig = new WeakMap(), _YargsInstance_versionOpt = new WeakMap(), _YargsInstance_validation = new WeakMap(), kCopyDoubleDash)](argv) {
        if (!argv._ || !argv['--'])
            return argv;
        argv._.push.apply(argv._, argv['--']);
        try {
            delete argv['--'];
        }
        catch (_err) { }
        return argv;
    }
    [kCreateLogger]() {
        return {
            log: (...args) => {
                if (!this[kHasParseCallback]())
                    console.log(...args);
                __classPrivateFieldSet$1(this, _YargsInstance_hasOutput, true, "f");
                if (__classPrivateFieldGet$1(this, _YargsInstance_output, "f").length)
                    __classPrivateFieldSet$1(this, _YargsInstance_output, __classPrivateFieldGet$1(this, _YargsInstance_output, "f") + '\n', "f");
                __classPrivateFieldSet$1(this, _YargsInstance_output, __classPrivateFieldGet$1(this, _YargsInstance_output, "f") + args.join(' '), "f");
            },
            error: (...args) => {
                if (!this[kHasParseCallback]())
                    console.error(...args);
                __classPrivateFieldSet$1(this, _YargsInstance_hasOutput, true, "f");
                if (__classPrivateFieldGet$1(this, _YargsInstance_output, "f").length)
                    __classPrivateFieldSet$1(this, _YargsInstance_output, __classPrivateFieldGet$1(this, _YargsInstance_output, "f") + '\n', "f");
                __classPrivateFieldSet$1(this, _YargsInstance_output, __classPrivateFieldGet$1(this, _YargsInstance_output, "f") + args.join(' '), "f");
            },
        };
    }
    [kDeleteFromParserHintObject](optionKey) {
        objectKeys(__classPrivateFieldGet$1(this, _YargsInstance_options, "f")).forEach((hintKey) => {
            if (((key) => key === 'configObjects')(hintKey))
                return;
            const hint = __classPrivateFieldGet$1(this, _YargsInstance_options, "f")[hintKey];
            if (Array.isArray(hint)) {
                if (hint.includes(optionKey))
                    hint.splice(hint.indexOf(optionKey), 1);
            }
            else if (typeof hint === 'object') {
                delete hint[optionKey];
            }
        });
        delete __classPrivateFieldGet$1(this, _YargsInstance_usage, "f").getDescriptions()[optionKey];
    }
    [kEmitWarning](warning, type, deduplicationId) {
        if (!__classPrivateFieldGet$1(this, _YargsInstance_emittedWarnings, "f")[deduplicationId]) {
            __classPrivateFieldGet$1(this, _YargsInstance_shim, "f").process.emitWarning(warning, type);
            __classPrivateFieldGet$1(this, _YargsInstance_emittedWarnings, "f")[deduplicationId] = true;
        }
    }
    [kFreeze]() {
        __classPrivateFieldGet$1(this, _YargsInstance_frozens, "f").push({
            options: __classPrivateFieldGet$1(this, _YargsInstance_options, "f"),
            configObjects: __classPrivateFieldGet$1(this, _YargsInstance_options, "f").configObjects.slice(0),
            exitProcess: __classPrivateFieldGet$1(this, _YargsInstance_exitProcess, "f"),
            groups: __classPrivateFieldGet$1(this, _YargsInstance_groups, "f"),
            strict: __classPrivateFieldGet$1(this, _YargsInstance_strict, "f"),
            strictCommands: __classPrivateFieldGet$1(this, _YargsInstance_strictCommands, "f"),
            strictOptions: __classPrivateFieldGet$1(this, _YargsInstance_strictOptions, "f"),
            completionCommand: __classPrivateFieldGet$1(this, _YargsInstance_completionCommand, "f"),
            output: __classPrivateFieldGet$1(this, _YargsInstance_output, "f"),
            exitError: __classPrivateFieldGet$1(this, _YargsInstance_exitError, "f"),
            hasOutput: __classPrivateFieldGet$1(this, _YargsInstance_hasOutput, "f"),
            parsed: this.parsed,
            parseFn: __classPrivateFieldGet$1(this, _YargsInstance_parseFn, "f"),
            parseContext: __classPrivateFieldGet$1(this, _YargsInstance_parseContext, "f"),
        });
        __classPrivateFieldGet$1(this, _YargsInstance_usage, "f").freeze();
        __classPrivateFieldGet$1(this, _YargsInstance_validation, "f").freeze();
        __classPrivateFieldGet$1(this, _YargsInstance_command, "f").freeze();
        __classPrivateFieldGet$1(this, _YargsInstance_globalMiddleware, "f").freeze();
    }
    [kGetDollarZero]() {
        let $0 = '';
        let default$0;
        if (/\b(node|iojs|electron)(\.exe)?$/.test(__classPrivateFieldGet$1(this, _YargsInstance_shim, "f").process.argv()[0])) {
            default$0 = __classPrivateFieldGet$1(this, _YargsInstance_shim, "f").process.argv().slice(1, 2);
        }
        else {
            default$0 = __classPrivateFieldGet$1(this, _YargsInstance_shim, "f").process.argv().slice(0, 1);
        }
        $0 = default$0
            .map(x => {
            const b = this[kRebase](__classPrivateFieldGet$1(this, _YargsInstance_cwd, "f"), x);
            return x.match(/^(\/|([a-zA-Z]:)?\\)/) && b.length < x.length ? b : x;
        })
            .join(' ')
            .trim();
        if (__classPrivateFieldGet$1(this, _YargsInstance_shim, "f").getEnv('_') &&
            __classPrivateFieldGet$1(this, _YargsInstance_shim, "f").getProcessArgvBin() === __classPrivateFieldGet$1(this, _YargsInstance_shim, "f").getEnv('_')) {
            $0 = __classPrivateFieldGet$1(this, _YargsInstance_shim, "f")
                .getEnv('_')
                .replace(`${__classPrivateFieldGet$1(this, _YargsInstance_shim, "f").path.dirname(__classPrivateFieldGet$1(this, _YargsInstance_shim, "f").process.execPath())}/`, '');
        }
        return $0;
    }
    [kGetParserConfiguration]() {
        return __classPrivateFieldGet$1(this, _YargsInstance_parserConfig, "f");
    }
    [kGetUsageConfiguration]() {
        return __classPrivateFieldGet$1(this, _YargsInstance_usageConfig, "f");
    }
    [kGuessLocale]() {
        if (!__classPrivateFieldGet$1(this, _YargsInstance_detectLocale, "f"))
            return;
        const locale = __classPrivateFieldGet$1(this, _YargsInstance_shim, "f").getEnv('LC_ALL') ||
            __classPrivateFieldGet$1(this, _YargsInstance_shim, "f").getEnv('LC_MESSAGES') ||
            __classPrivateFieldGet$1(this, _YargsInstance_shim, "f").getEnv('LANG') ||
            __classPrivateFieldGet$1(this, _YargsInstance_shim, "f").getEnv('LANGUAGE') ||
            'en_US';
        this.locale(locale.replace(/[.:].*/, ''));
    }
    [kGuessVersion]() {
        const obj = this[kPkgUp]();
        return obj.version || 'unknown';
    }
    [kParsePositionalNumbers](argv) {
        const args = argv['--'] ? argv['--'] : argv._;
        for (let i = 0, arg; (arg = args[i]) !== undefined; i++) {
            if (__classPrivateFieldGet$1(this, _YargsInstance_shim, "f").Parser.looksLikeNumber(arg) &&
                Number.isSafeInteger(Math.floor(parseFloat(`${arg}`)))) {
                args[i] = Number(arg);
            }
        }
        return argv;
    }
    [kPkgUp](rootPath) {
        const npath = rootPath || '*';
        if (__classPrivateFieldGet$1(this, _YargsInstance_pkgs, "f")[npath])
            return __classPrivateFieldGet$1(this, _YargsInstance_pkgs, "f")[npath];
        let obj = {};
        try {
            let startDir = rootPath || __classPrivateFieldGet$1(this, _YargsInstance_shim, "f").mainFilename;
            if (__classPrivateFieldGet$1(this, _YargsInstance_shim, "f").path.extname(startDir)) {
                startDir = __classPrivateFieldGet$1(this, _YargsInstance_shim, "f").path.dirname(startDir);
            }
            const pkgJsonPath = __classPrivateFieldGet$1(this, _YargsInstance_shim, "f").findUp(startDir, (dir, names) => {
                if (names.includes('package.json')) {
                    return 'package.json';
                }
                else {
                    return undefined;
                }
            });
            assertNotStrictEqual(pkgJsonPath, undefined, __classPrivateFieldGet$1(this, _YargsInstance_shim, "f"));
            obj = JSON.parse(__classPrivateFieldGet$1(this, _YargsInstance_shim, "f").readFileSync(pkgJsonPath, 'utf8'));
        }
        catch (_noop) { }
        __classPrivateFieldGet$1(this, _YargsInstance_pkgs, "f")[npath] = obj || {};
        return __classPrivateFieldGet$1(this, _YargsInstance_pkgs, "f")[npath];
    }
    [kPopulateParserHintArray](type, keys) {
        keys = [].concat(keys);
        keys.forEach(key => {
            key = this[kSanitizeKey](key);
            __classPrivateFieldGet$1(this, _YargsInstance_options, "f")[type].push(key);
        });
    }
    [kPopulateParserHintSingleValueDictionary](builder, type, key, value) {
        this[kPopulateParserHintDictionary](builder, type, key, value, (type, key, value) => {
            __classPrivateFieldGet$1(this, _YargsInstance_options, "f")[type][key] = value;
        });
    }
    [kPopulateParserHintArrayDictionary](builder, type, key, value) {
        this[kPopulateParserHintDictionary](builder, type, key, value, (type, key, value) => {
            __classPrivateFieldGet$1(this, _YargsInstance_options, "f")[type][key] = (__classPrivateFieldGet$1(this, _YargsInstance_options, "f")[type][key] || []).concat(value);
        });
    }
    [kPopulateParserHintDictionary](builder, type, key, value, singleKeyHandler) {
        if (Array.isArray(key)) {
            key.forEach(k => {
                builder(k, value);
            });
        }
        else if (((key) => typeof key === 'object')(key)) {
            for (const k of objectKeys(key)) {
                builder(k, key[k]);
            }
        }
        else {
            singleKeyHandler(type, this[kSanitizeKey](key), value);
        }
    }
    [kSanitizeKey](key) {
        if (key === '__proto__')
            return '___proto___';
        return key;
    }
    [kSetKey](key, set) {
        this[kPopulateParserHintSingleValueDictionary](this[kSetKey].bind(this), 'key', key, set);
        return this;
    }
    [kUnfreeze]() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        const frozen = __classPrivateFieldGet$1(this, _YargsInstance_frozens, "f").pop();
        assertNotStrictEqual(frozen, undefined, __classPrivateFieldGet$1(this, _YargsInstance_shim, "f"));
        let configObjects;
        (_a = this, _b = this, _c = this, _d = this, _e = this, _f = this, _g = this, _h = this, _j = this, _k = this, _l = this, _m = this, {
            options: ({ set value(_o) { __classPrivateFieldSet$1(_a, _YargsInstance_options, _o, "f"); } }).value,
            configObjects,
            exitProcess: ({ set value(_o) { __classPrivateFieldSet$1(_b, _YargsInstance_exitProcess, _o, "f"); } }).value,
            groups: ({ set value(_o) { __classPrivateFieldSet$1(_c, _YargsInstance_groups, _o, "f"); } }).value,
            output: ({ set value(_o) { __classPrivateFieldSet$1(_d, _YargsInstance_output, _o, "f"); } }).value,
            exitError: ({ set value(_o) { __classPrivateFieldSet$1(_e, _YargsInstance_exitError, _o, "f"); } }).value,
            hasOutput: ({ set value(_o) { __classPrivateFieldSet$1(_f, _YargsInstance_hasOutput, _o, "f"); } }).value,
            parsed: this.parsed,
            strict: ({ set value(_o) { __classPrivateFieldSet$1(_g, _YargsInstance_strict, _o, "f"); } }).value,
            strictCommands: ({ set value(_o) { __classPrivateFieldSet$1(_h, _YargsInstance_strictCommands, _o, "f"); } }).value,
            strictOptions: ({ set value(_o) { __classPrivateFieldSet$1(_j, _YargsInstance_strictOptions, _o, "f"); } }).value,
            completionCommand: ({ set value(_o) { __classPrivateFieldSet$1(_k, _YargsInstance_completionCommand, _o, "f"); } }).value,
            parseFn: ({ set value(_o) { __classPrivateFieldSet$1(_l, _YargsInstance_parseFn, _o, "f"); } }).value,
            parseContext: ({ set value(_o) { __classPrivateFieldSet$1(_m, _YargsInstance_parseContext, _o, "f"); } }).value,
        } = frozen);
        __classPrivateFieldGet$1(this, _YargsInstance_options, "f").configObjects = configObjects;
        __classPrivateFieldGet$1(this, _YargsInstance_usage, "f").unfreeze();
        __classPrivateFieldGet$1(this, _YargsInstance_validation, "f").unfreeze();
        __classPrivateFieldGet$1(this, _YargsInstance_command, "f").unfreeze();
        __classPrivateFieldGet$1(this, _YargsInstance_globalMiddleware, "f").unfreeze();
    }
    [kValidateAsync](validation, argv) {
        return maybeAsyncResult(argv, result => {
            validation(result);
            return result;
        });
    }
    getInternalMethods() {
        return {
            getCommandInstance: this[kGetCommandInstance].bind(this),
            getContext: this[kGetContext].bind(this),
            getHasOutput: this[kGetHasOutput].bind(this),
            getLoggerInstance: this[kGetLoggerInstance].bind(this),
            getParseContext: this[kGetParseContext].bind(this),
            getParserConfiguration: this[kGetParserConfiguration].bind(this),
            getUsageConfiguration: this[kGetUsageConfiguration].bind(this),
            getUsageInstance: this[kGetUsageInstance].bind(this),
            getValidationInstance: this[kGetValidationInstance].bind(this),
            hasParseCallback: this[kHasParseCallback].bind(this),
            isGlobalContext: this[kIsGlobalContext].bind(this),
            postProcess: this[kPostProcess].bind(this),
            reset: this[kReset].bind(this),
            runValidation: this[kRunValidation].bind(this),
            runYargsParserAndExecuteCommands: this[kRunYargsParserAndExecuteCommands].bind(this),
            setHasOutput: this[kSetHasOutput].bind(this),
        };
    }
    [kGetCommandInstance]() {
        return __classPrivateFieldGet$1(this, _YargsInstance_command, "f");
    }
    [kGetContext]() {
        return __classPrivateFieldGet$1(this, _YargsInstance_context, "f");
    }
    [kGetHasOutput]() {
        return __classPrivateFieldGet$1(this, _YargsInstance_hasOutput, "f");
    }
    [kGetLoggerInstance]() {
        return __classPrivateFieldGet$1(this, _YargsInstance_logger, "f");
    }
    [kGetParseContext]() {
        return __classPrivateFieldGet$1(this, _YargsInstance_parseContext, "f") || {};
    }
    [kGetUsageInstance]() {
        return __classPrivateFieldGet$1(this, _YargsInstance_usage, "f");
    }
    [kGetValidationInstance]() {
        return __classPrivateFieldGet$1(this, _YargsInstance_validation, "f");
    }
    [kHasParseCallback]() {
        return !!__classPrivateFieldGet$1(this, _YargsInstance_parseFn, "f");
    }
    [kIsGlobalContext]() {
        return __classPrivateFieldGet$1(this, _YargsInstance_isGlobalContext, "f");
    }
    [kPostProcess](argv, populateDoubleDash, calledFromCommand, runGlobalMiddleware) {
        if (calledFromCommand)
            return argv;
        if (isPromise$1(argv))
            return argv;
        if (!populateDoubleDash) {
            argv = this[kCopyDoubleDash](argv);
        }
        const parsePositionalNumbers = this[kGetParserConfiguration]()['parse-positional-numbers'] ||
            this[kGetParserConfiguration]()['parse-positional-numbers'] === undefined;
        if (parsePositionalNumbers) {
            argv = this[kParsePositionalNumbers](argv);
        }
        if (runGlobalMiddleware) {
            argv = applyMiddleware(argv, this, __classPrivateFieldGet$1(this, _YargsInstance_globalMiddleware, "f").getMiddleware(), false);
        }
        return argv;
    }
    [kReset](aliases = {}) {
        __classPrivateFieldSet$1(this, _YargsInstance_options, __classPrivateFieldGet$1(this, _YargsInstance_options, "f") || {}, "f");
        const tmpOptions = {};
        tmpOptions.local = __classPrivateFieldGet$1(this, _YargsInstance_options, "f").local || [];
        tmpOptions.configObjects = __classPrivateFieldGet$1(this, _YargsInstance_options, "f").configObjects || [];
        const localLookup = {};
        tmpOptions.local.forEach(l => {
            localLookup[l] = true;
            (aliases[l] || []).forEach(a => {
                localLookup[a] = true;
            });
        });
        Object.assign(__classPrivateFieldGet$1(this, _YargsInstance_preservedGroups, "f"), Object.keys(__classPrivateFieldGet$1(this, _YargsInstance_groups, "f")).reduce((acc, groupName) => {
            const keys = __classPrivateFieldGet$1(this, _YargsInstance_groups, "f")[groupName].filter(key => !(key in localLookup));
            if (keys.length > 0) {
                acc[groupName] = keys;
            }
            return acc;
        }, {}));
        __classPrivateFieldSet$1(this, _YargsInstance_groups, {}, "f");
        const arrayOptions = [
            'array',
            'boolean',
            'string',
            'skipValidation',
            'count',
            'normalize',
            'number',
            'hiddenOptions',
        ];
        const objectOptions = [
            'narg',
            'key',
            'alias',
            'default',
            'defaultDescription',
            'config',
            'choices',
            'demandedOptions',
            'demandedCommands',
            'deprecatedOptions',
        ];
        arrayOptions.forEach(k => {
            tmpOptions[k] = (__classPrivateFieldGet$1(this, _YargsInstance_options, "f")[k] || []).filter((k) => !localLookup[k]);
        });
        objectOptions.forEach((k) => {
            tmpOptions[k] = objFilter(__classPrivateFieldGet$1(this, _YargsInstance_options, "f")[k], k => !localLookup[k]);
        });
        tmpOptions.envPrefix = __classPrivateFieldGet$1(this, _YargsInstance_options, "f").envPrefix;
        __classPrivateFieldSet$1(this, _YargsInstance_options, tmpOptions, "f");
        __classPrivateFieldSet$1(this, _YargsInstance_usage, __classPrivateFieldGet$1(this, _YargsInstance_usage, "f")
            ? __classPrivateFieldGet$1(this, _YargsInstance_usage, "f").reset(localLookup)
            : usage(this, __classPrivateFieldGet$1(this, _YargsInstance_shim, "f")), "f");
        __classPrivateFieldSet$1(this, _YargsInstance_validation, __classPrivateFieldGet$1(this, _YargsInstance_validation, "f")
            ? __classPrivateFieldGet$1(this, _YargsInstance_validation, "f").reset(localLookup)
            : validation$1(this, __classPrivateFieldGet$1(this, _YargsInstance_usage, "f"), __classPrivateFieldGet$1(this, _YargsInstance_shim, "f")), "f");
        __classPrivateFieldSet$1(this, _YargsInstance_command, __classPrivateFieldGet$1(this, _YargsInstance_command, "f")
            ? __classPrivateFieldGet$1(this, _YargsInstance_command, "f").reset()
            : command(__classPrivateFieldGet$1(this, _YargsInstance_usage, "f"), __classPrivateFieldGet$1(this, _YargsInstance_validation, "f"), __classPrivateFieldGet$1(this, _YargsInstance_globalMiddleware, "f"), __classPrivateFieldGet$1(this, _YargsInstance_shim, "f")), "f");
        if (!__classPrivateFieldGet$1(this, _YargsInstance_completion, "f"))
            __classPrivateFieldSet$1(this, _YargsInstance_completion, completion(this, __classPrivateFieldGet$1(this, _YargsInstance_usage, "f"), __classPrivateFieldGet$1(this, _YargsInstance_command, "f"), __classPrivateFieldGet$1(this, _YargsInstance_shim, "f")), "f");
        __classPrivateFieldGet$1(this, _YargsInstance_globalMiddleware, "f").reset();
        __classPrivateFieldSet$1(this, _YargsInstance_completionCommand, null, "f");
        __classPrivateFieldSet$1(this, _YargsInstance_output, '', "f");
        __classPrivateFieldSet$1(this, _YargsInstance_exitError, null, "f");
        __classPrivateFieldSet$1(this, _YargsInstance_hasOutput, false, "f");
        this.parsed = false;
        return this;
    }
    [kRebase](base, dir) {
        return __classPrivateFieldGet$1(this, _YargsInstance_shim, "f").path.relative(base, dir);
    }
    [kRunYargsParserAndExecuteCommands](args, shortCircuit, calledFromCommand, commandIndex = 0, helpOnly = false) {
        var _a, _b, _c, _d;
        let skipValidation = !!calledFromCommand || helpOnly;
        args = args || __classPrivateFieldGet$1(this, _YargsInstance_processArgs, "f");
        __classPrivateFieldGet$1(this, _YargsInstance_options, "f").__ = __classPrivateFieldGet$1(this, _YargsInstance_shim, "f").y18n.__;
        __classPrivateFieldGet$1(this, _YargsInstance_options, "f").configuration = this[kGetParserConfiguration]();
        const populateDoubleDash = !!__classPrivateFieldGet$1(this, _YargsInstance_options, "f").configuration['populate--'];
        const config = Object.assign({}, __classPrivateFieldGet$1(this, _YargsInstance_options, "f").configuration, {
            'populate--': true,
        });
        const parsed = __classPrivateFieldGet$1(this, _YargsInstance_shim, "f").Parser.detailed(args, Object.assign({}, __classPrivateFieldGet$1(this, _YargsInstance_options, "f"), {
            configuration: { 'parse-positional-numbers': false, ...config },
        }));
        const argv = Object.assign(parsed.argv, __classPrivateFieldGet$1(this, _YargsInstance_parseContext, "f"));
        let argvPromise = undefined;
        const aliases = parsed.aliases;
        let helpOptSet = false;
        let versionOptSet = false;
        Object.keys(argv).forEach(key => {
            if (key === __classPrivateFieldGet$1(this, _YargsInstance_helpOpt, "f") && argv[key]) {
                helpOptSet = true;
            }
            else if (key === __classPrivateFieldGet$1(this, _YargsInstance_versionOpt, "f") && argv[key]) {
                versionOptSet = true;
            }
        });
        argv.$0 = this.$0;
        this.parsed = parsed;
        if (commandIndex === 0) {
            __classPrivateFieldGet$1(this, _YargsInstance_usage, "f").clearCachedHelpMessage();
        }
        try {
            this[kGuessLocale]();
            if (shortCircuit) {
                return this[kPostProcess](argv, populateDoubleDash, !!calledFromCommand, false);
            }
            if (__classPrivateFieldGet$1(this, _YargsInstance_helpOpt, "f")) {
                const helpCmds = [__classPrivateFieldGet$1(this, _YargsInstance_helpOpt, "f")]
                    .concat(aliases[__classPrivateFieldGet$1(this, _YargsInstance_helpOpt, "f")] || [])
                    .filter(k => k.length > 1);
                if (helpCmds.includes('' + argv._[argv._.length - 1])) {
                    argv._.pop();
                    helpOptSet = true;
                }
            }
            __classPrivateFieldSet$1(this, _YargsInstance_isGlobalContext, false, "f");
            const handlerKeys = __classPrivateFieldGet$1(this, _YargsInstance_command, "f").getCommands();
            const requestCompletions = ((_a = __classPrivateFieldGet$1(this, _YargsInstance_completion, "f")) === null || _a === void 0 ? void 0 : _a.completionKey)
                ? [
                    (_b = __classPrivateFieldGet$1(this, _YargsInstance_completion, "f")) === null || _b === void 0 ? void 0 : _b.completionKey,
                    ...((_d = this.getAliases()[(_c = __classPrivateFieldGet$1(this, _YargsInstance_completion, "f")) === null || _c === void 0 ? void 0 : _c.completionKey]) !== null && _d !== void 0 ? _d : []),
                ].some((key) => Object.prototype.hasOwnProperty.call(argv, key))
                : false;
            const skipRecommendation = helpOptSet || requestCompletions || helpOnly;
            if (argv._.length) {
                if (handlerKeys.length) {
                    let firstUnknownCommand;
                    for (let i = commandIndex || 0, cmd; argv._[i] !== undefined; i++) {
                        cmd = String(argv._[i]);
                        if (handlerKeys.includes(cmd) && cmd !== __classPrivateFieldGet$1(this, _YargsInstance_completionCommand, "f")) {
                            const innerArgv = __classPrivateFieldGet$1(this, _YargsInstance_command, "f").runCommand(cmd, this, parsed, i + 1, helpOnly, helpOptSet || versionOptSet || helpOnly);
                            return this[kPostProcess](innerArgv, populateDoubleDash, !!calledFromCommand, false);
                        }
                        else if (!firstUnknownCommand &&
                            cmd !== __classPrivateFieldGet$1(this, _YargsInstance_completionCommand, "f")) {
                            firstUnknownCommand = cmd;
                            break;
                        }
                    }
                    if (!__classPrivateFieldGet$1(this, _YargsInstance_command, "f").hasDefaultCommand() &&
                        __classPrivateFieldGet$1(this, _YargsInstance_recommendCommands, "f") &&
                        firstUnknownCommand &&
                        !skipRecommendation) {
                        __classPrivateFieldGet$1(this, _YargsInstance_validation, "f").recommendCommands(firstUnknownCommand, handlerKeys);
                    }
                }
                if (__classPrivateFieldGet$1(this, _YargsInstance_completionCommand, "f") &&
                    argv._.includes(__classPrivateFieldGet$1(this, _YargsInstance_completionCommand, "f")) &&
                    !requestCompletions) {
                    if (__classPrivateFieldGet$1(this, _YargsInstance_exitProcess, "f"))
                        setBlocking(true);
                    this.showCompletionScript();
                    this.exit(0);
                }
            }
            if (__classPrivateFieldGet$1(this, _YargsInstance_command, "f").hasDefaultCommand() && !skipRecommendation) {
                const innerArgv = __classPrivateFieldGet$1(this, _YargsInstance_command, "f").runCommand(null, this, parsed, 0, helpOnly, helpOptSet || versionOptSet || helpOnly);
                return this[kPostProcess](innerArgv, populateDoubleDash, !!calledFromCommand, false);
            }
            if (requestCompletions) {
                if (__classPrivateFieldGet$1(this, _YargsInstance_exitProcess, "f"))
                    setBlocking(true);
                args = [].concat(args);
                const completionArgs = args.slice(args.indexOf(`--${__classPrivateFieldGet$1(this, _YargsInstance_completion, "f").completionKey}`) + 1);
                __classPrivateFieldGet$1(this, _YargsInstance_completion, "f").getCompletion(completionArgs, (err, completions) => {
                    if (err)
                        throw new YError(err.message);
                    (completions || []).forEach(completion => {
                        __classPrivateFieldGet$1(this, _YargsInstance_logger, "f").log(completion);
                    });
                    this.exit(0);
                });
                return this[kPostProcess](argv, !populateDoubleDash, !!calledFromCommand, false);
            }
            if (!__classPrivateFieldGet$1(this, _YargsInstance_hasOutput, "f")) {
                if (helpOptSet) {
                    if (__classPrivateFieldGet$1(this, _YargsInstance_exitProcess, "f"))
                        setBlocking(true);
                    skipValidation = true;
                    this.showHelp(message => {
                        __classPrivateFieldGet$1(this, _YargsInstance_logger, "f").log(message);
                        this.exit(0);
                    });
                }
                else if (versionOptSet) {
                    if (__classPrivateFieldGet$1(this, _YargsInstance_exitProcess, "f"))
                        setBlocking(true);
                    skipValidation = true;
                    __classPrivateFieldGet$1(this, _YargsInstance_usage, "f").showVersion('log');
                    this.exit(0);
                }
            }
            if (!skipValidation && __classPrivateFieldGet$1(this, _YargsInstance_options, "f").skipValidation.length > 0) {
                skipValidation = Object.keys(argv).some(key => __classPrivateFieldGet$1(this, _YargsInstance_options, "f").skipValidation.indexOf(key) >= 0 && argv[key] === true);
            }
            if (!skipValidation) {
                if (parsed.error)
                    throw new YError(parsed.error.message);
                if (!requestCompletions) {
                    const validation = this[kRunValidation](aliases, {}, parsed.error);
                    if (!calledFromCommand) {
                        argvPromise = applyMiddleware(argv, this, __classPrivateFieldGet$1(this, _YargsInstance_globalMiddleware, "f").getMiddleware(), true);
                    }
                    argvPromise = this[kValidateAsync](validation, argvPromise !== null && argvPromise !== void 0 ? argvPromise : argv);
                    if (isPromise$1(argvPromise) && !calledFromCommand) {
                        argvPromise = argvPromise.then(() => {
                            return applyMiddleware(argv, this, __classPrivateFieldGet$1(this, _YargsInstance_globalMiddleware, "f").getMiddleware(), false);
                        });
                    }
                }
            }
        }
        catch (err) {
            if (err instanceof YError)
                __classPrivateFieldGet$1(this, _YargsInstance_usage, "f").fail(err.message, err);
            else
                throw err;
        }
        return this[kPostProcess](argvPromise !== null && argvPromise !== void 0 ? argvPromise : argv, populateDoubleDash, !!calledFromCommand, true);
    }
    [kRunValidation](aliases, positionalMap, parseErrors, isDefaultCommand) {
        const demandedOptions = { ...this.getDemandedOptions() };
        return (argv) => {
            if (parseErrors)
                throw new YError(parseErrors.message);
            __classPrivateFieldGet$1(this, _YargsInstance_validation, "f").nonOptionCount(argv);
            __classPrivateFieldGet$1(this, _YargsInstance_validation, "f").requiredArguments(argv, demandedOptions);
            let failedStrictCommands = false;
            if (__classPrivateFieldGet$1(this, _YargsInstance_strictCommands, "f")) {
                failedStrictCommands = __classPrivateFieldGet$1(this, _YargsInstance_validation, "f").unknownCommands(argv);
            }
            if (__classPrivateFieldGet$1(this, _YargsInstance_strict, "f") && !failedStrictCommands) {
                __classPrivateFieldGet$1(this, _YargsInstance_validation, "f").unknownArguments(argv, aliases, positionalMap, !!isDefaultCommand);
            }
            else if (__classPrivateFieldGet$1(this, _YargsInstance_strictOptions, "f")) {
                __classPrivateFieldGet$1(this, _YargsInstance_validation, "f").unknownArguments(argv, aliases, {}, false, false);
            }
            __classPrivateFieldGet$1(this, _YargsInstance_validation, "f").limitedChoices(argv);
            __classPrivateFieldGet$1(this, _YargsInstance_validation, "f").implications(argv);
            __classPrivateFieldGet$1(this, _YargsInstance_validation, "f").conflicting(argv);
        };
    }
    [kSetHasOutput]() {
        __classPrivateFieldSet$1(this, _YargsInstance_hasOutput, true, "f");
    }
    [kTrackManuallySetKeys](keys) {
        if (typeof keys === 'string') {
            __classPrivateFieldGet$1(this, _YargsInstance_options, "f").key[keys] = true;
        }
        else {
            for (const k of keys) {
                __classPrivateFieldGet$1(this, _YargsInstance_options, "f").key[k] = true;
            }
        }
    }
}
function isYargsInstance(y) {
    return !!y && typeof y.getInternalMethods === 'function';
}

const Yargs = YargsFactory(shim$1);

var src = {exports: {}};

var browser = {exports: {}};

var ms;
var hasRequiredMs;

function requireMs () {
	if (hasRequiredMs) return ms;
	hasRequiredMs = 1;
	var s = 1000;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var w = d * 7;
	var y = d * 365.25;
	ms = function (val, options) {
	  options = options || {};
	  var type = typeof val;
	  if (type === 'string' && val.length > 0) {
	    return parse(val);
	  } else if (type === 'number' && isFinite(val)) {
	    return options.long ? fmtLong(val) : fmtShort(val);
	  }
	  throw new Error(
	    'val is not a non-empty string or a valid number. val=' +
	      JSON.stringify(val)
	  );
	};
	function parse(str) {
	  str = String(str);
	  if (str.length > 100) {
	    return;
	  }
	  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
	    str
	  );
	  if (!match) {
	    return;
	  }
	  var n = parseFloat(match[1]);
	  var type = (match[2] || 'ms').toLowerCase();
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'yrs':
	    case 'yr':
	    case 'y':
	      return n * y;
	    case 'weeks':
	    case 'week':
	    case 'w':
	      return n * w;
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d;
	    case 'hours':
	    case 'hour':
	    case 'hrs':
	    case 'hr':
	    case 'h':
	      return n * h;
	    case 'minutes':
	    case 'minute':
	    case 'mins':
	    case 'min':
	    case 'm':
	      return n * m;
	    case 'seconds':
	    case 'second':
	    case 'secs':
	    case 'sec':
	    case 's':
	      return n * s;
	    case 'milliseconds':
	    case 'millisecond':
	    case 'msecs':
	    case 'msec':
	    case 'ms':
	      return n;
	    default:
	      return undefined;
	  }
	}
	function fmtShort(ms) {
	  var msAbs = Math.abs(ms);
	  if (msAbs >= d) {
	    return Math.round(ms / d) + 'd';
	  }
	  if (msAbs >= h) {
	    return Math.round(ms / h) + 'h';
	  }
	  if (msAbs >= m) {
	    return Math.round(ms / m) + 'm';
	  }
	  if (msAbs >= s) {
	    return Math.round(ms / s) + 's';
	  }
	  return ms + 'ms';
	}
	function fmtLong(ms) {
	  var msAbs = Math.abs(ms);
	  if (msAbs >= d) {
	    return plural(ms, msAbs, d, 'day');
	  }
	  if (msAbs >= h) {
	    return plural(ms, msAbs, h, 'hour');
	  }
	  if (msAbs >= m) {
	    return plural(ms, msAbs, m, 'minute');
	  }
	  if (msAbs >= s) {
	    return plural(ms, msAbs, s, 'second');
	  }
	  return ms + ' ms';
	}
	function plural(ms, msAbs, n, name) {
	  var isPlural = msAbs >= n * 1.5;
	  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
	}
	return ms;
}

var common$2;
var hasRequiredCommon$2;

function requireCommon$2 () {
	if (hasRequiredCommon$2) return common$2;
	hasRequiredCommon$2 = 1;
	function setup(env) {
		createDebug.debug = createDebug;
		createDebug.default = createDebug;
		createDebug.coerce = coerce;
		createDebug.disable = disable;
		createDebug.enable = enable;
		createDebug.enabled = enabled;
		createDebug.humanize = requireMs();
		createDebug.destroy = destroy;
		Object.keys(env).forEach(key => {
			createDebug[key] = env[key];
		});
		createDebug.names = [];
		createDebug.skips = [];
		createDebug.formatters = {};
		function selectColor(namespace) {
			let hash = 0;
			for (let i = 0; i < namespace.length; i++) {
				hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
				hash |= 0;
			}
			return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
		}
		createDebug.selectColor = selectColor;
		function createDebug(namespace) {
			let prevTime;
			let enableOverride = null;
			let namespacesCache;
			let enabledCache;
			function debug(...args) {
				if (!debug.enabled) {
					return;
				}
				const self = debug;
				const curr = Number(new Date());
				const ms = curr - (prevTime || curr);
				self.diff = ms;
				self.prev = prevTime;
				self.curr = curr;
				prevTime = curr;
				args[0] = createDebug.coerce(args[0]);
				if (typeof args[0] !== 'string') {
					args.unshift('%O');
				}
				let index = 0;
				args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
					if (match === '%%') {
						return '%';
					}
					index++;
					const formatter = createDebug.formatters[format];
					if (typeof formatter === 'function') {
						const val = args[index];
						match = formatter.call(self, val);
						args.splice(index, 1);
						index--;
					}
					return match;
				});
				createDebug.formatArgs.call(self, args);
				const logFn = self.log || createDebug.log;
				logFn.apply(self, args);
			}
			debug.namespace = namespace;
			debug.useColors = createDebug.useColors();
			debug.color = createDebug.selectColor(namespace);
			debug.extend = extend;
			debug.destroy = createDebug.destroy;
			Object.defineProperty(debug, 'enabled', {
				enumerable: true,
				configurable: false,
				get: () => {
					if (enableOverride !== null) {
						return enableOverride;
					}
					if (namespacesCache !== createDebug.namespaces) {
						namespacesCache = createDebug.namespaces;
						enabledCache = createDebug.enabled(namespace);
					}
					return enabledCache;
				},
				set: v => {
					enableOverride = v;
				}
			});
			if (typeof createDebug.init === 'function') {
				createDebug.init(debug);
			}
			return debug;
		}
		function extend(namespace, delimiter) {
			const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
			newDebug.log = this.log;
			return newDebug;
		}
		function enable(namespaces) {
			createDebug.save(namespaces);
			createDebug.namespaces = namespaces;
			createDebug.names = [];
			createDebug.skips = [];
			const split = (typeof namespaces === 'string' ? namespaces : '')
				.trim()
				.replace(/\s+/g, ',')
				.split(',')
				.filter(Boolean);
			for (const ns of split) {
				if (ns[0] === '-') {
					createDebug.skips.push(ns.slice(1));
				} else {
					createDebug.names.push(ns);
				}
			}
		}
		function matchesTemplate(search, template) {
			let searchIndex = 0;
			let templateIndex = 0;
			let starIndex = -1;
			let matchIndex = 0;
			while (searchIndex < search.length) {
				if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === '*')) {
					if (template[templateIndex] === '*') {
						starIndex = templateIndex;
						matchIndex = searchIndex;
						templateIndex++;
					} else {
						searchIndex++;
						templateIndex++;
					}
				} else if (starIndex !== -1) {
					templateIndex = starIndex + 1;
					matchIndex++;
					searchIndex = matchIndex;
				} else {
					return false;
				}
			}
			while (templateIndex < template.length && template[templateIndex] === '*') {
				templateIndex++;
			}
			return templateIndex === template.length;
		}
		function disable() {
			const namespaces = [
				...createDebug.names,
				...createDebug.skips.map(namespace => '-' + namespace)
			].join(',');
			createDebug.enable('');
			return namespaces;
		}
		function enabled(name) {
			for (const skip of createDebug.skips) {
				if (matchesTemplate(name, skip)) {
					return false;
				}
			}
			for (const ns of createDebug.names) {
				if (matchesTemplate(name, ns)) {
					return true;
				}
			}
			return false;
		}
		function coerce(val) {
			if (val instanceof Error) {
				return val.stack || val.message;
			}
			return val;
		}
		function destroy() {
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}
		createDebug.enable(createDebug.load());
		return createDebug;
	}
	common$2 = setup;
	return common$2;
}

var hasRequiredBrowser;

function requireBrowser () {
	if (hasRequiredBrowser) return browser.exports;
	hasRequiredBrowser = 1;
	(function (module, exports) {
		exports.formatArgs = formatArgs;
		exports.save = save;
		exports.load = load;
		exports.useColors = useColors;
		exports.storage = localstorage();
		exports.destroy = (() => {
			let warned = false;
			return () => {
				if (!warned) {
					warned = true;
					console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
				}
			};
		})();
		exports.colors = [
			'#0000CC',
			'#0000FF',
			'#0033CC',
			'#0033FF',
			'#0066CC',
			'#0066FF',
			'#0099CC',
			'#0099FF',
			'#00CC00',
			'#00CC33',
			'#00CC66',
			'#00CC99',
			'#00CCCC',
			'#00CCFF',
			'#3300CC',
			'#3300FF',
			'#3333CC',
			'#3333FF',
			'#3366CC',
			'#3366FF',
			'#3399CC',
			'#3399FF',
			'#33CC00',
			'#33CC33',
			'#33CC66',
			'#33CC99',
			'#33CCCC',
			'#33CCFF',
			'#6600CC',
			'#6600FF',
			'#6633CC',
			'#6633FF',
			'#66CC00',
			'#66CC33',
			'#9900CC',
			'#9900FF',
			'#9933CC',
			'#9933FF',
			'#99CC00',
			'#99CC33',
			'#CC0000',
			'#CC0033',
			'#CC0066',
			'#CC0099',
			'#CC00CC',
			'#CC00FF',
			'#CC3300',
			'#CC3333',
			'#CC3366',
			'#CC3399',
			'#CC33CC',
			'#CC33FF',
			'#CC6600',
			'#CC6633',
			'#CC9900',
			'#CC9933',
			'#CCCC00',
			'#CCCC33',
			'#FF0000',
			'#FF0033',
			'#FF0066',
			'#FF0099',
			'#FF00CC',
			'#FF00FF',
			'#FF3300',
			'#FF3333',
			'#FF3366',
			'#FF3399',
			'#FF33CC',
			'#FF33FF',
			'#FF6600',
			'#FF6633',
			'#FF9900',
			'#FF9933',
			'#FFCC00',
			'#FFCC33'
		];
		function useColors() {
			if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
				return true;
			}
			if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
				return false;
			}
			let m;
			return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
				(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
				(typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31) ||
				(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
		}
		function formatArgs(args) {
			args[0] = (this.useColors ? '%c' : '') +
				this.namespace +
				(this.useColors ? ' %c' : ' ') +
				args[0] +
				(this.useColors ? '%c ' : ' ') +
				'+' + module.exports.humanize(this.diff);
			if (!this.useColors) {
				return;
			}
			const c = 'color: ' + this.color;
			args.splice(1, 0, c, 'color: inherit');
			let index = 0;
			let lastC = 0;
			args[0].replace(/%[a-zA-Z%]/g, match => {
				if (match === '%%') {
					return;
				}
				index++;
				if (match === '%c') {
					lastC = index;
				}
			});
			args.splice(lastC, 0, c);
		}
		exports.log = console.debug || console.log || (() => {});
		function save(namespaces) {
			try {
				if (namespaces) {
					exports.storage.setItem('debug', namespaces);
				} else {
					exports.storage.removeItem('debug');
				}
			} catch (error) {
			}
		}
		function load() {
			let r;
			try {
				r = exports.storage.getItem('debug') || exports.storage.getItem('DEBUG') ;
			} catch (error) {
			}
			if (!r && typeof process !== 'undefined' && 'env' in process) {
				r = process.env.DEBUG;
			}
			return r;
		}
		function localstorage() {
			try {
				return localStorage;
			} catch (error) {
			}
		}
		module.exports = requireCommon$2()(exports);
		const {formatters} = module.exports;
		formatters.j = function (v) {
			try {
				return JSON.stringify(v);
			} catch (error) {
				return '[UnexpectedJSONParseError]: ' + error.message;
			}
		}; 
	} (browser, browser.exports));
	return browser.exports;
}

var node = {exports: {}};

var hasFlag;
var hasRequiredHasFlag;

function requireHasFlag () {
	if (hasRequiredHasFlag) return hasFlag;
	hasRequiredHasFlag = 1;
	hasFlag = (flag, argv = process.argv) => {
		const prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');
		const position = argv.indexOf(prefix + flag);
		const terminatorPosition = argv.indexOf('--');
		return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
	};
	return hasFlag;
}

var supportsColor_1;
var hasRequiredSupportsColor;

function requireSupportsColor () {
	if (hasRequiredSupportsColor) return supportsColor_1;
	hasRequiredSupportsColor = 1;
	const os = require$$0$1;
	const tty = require$$1;
	const hasFlag = requireHasFlag();
	const {env} = process;
	let forceColor;
	if (hasFlag('no-color') ||
		hasFlag('no-colors') ||
		hasFlag('color=false') ||
		hasFlag('color=never')) {
		forceColor = 0;
	} else if (hasFlag('color') ||
		hasFlag('colors') ||
		hasFlag('color=true') ||
		hasFlag('color=always')) {
		forceColor = 1;
	}
	if ('FORCE_COLOR' in env) {
		if (env.FORCE_COLOR === 'true') {
			forceColor = 1;
		} else if (env.FORCE_COLOR === 'false') {
			forceColor = 0;
		} else {
			forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
		}
	}
	function translateLevel(level) {
		if (level === 0) {
			return false;
		}
		return {
			level,
			hasBasic: true,
			has256: level >= 2,
			has16m: level >= 3
		};
	}
	function supportsColor(haveStream, streamIsTTY) {
		if (forceColor === 0) {
			return 0;
		}
		if (hasFlag('color=16m') ||
			hasFlag('color=full') ||
			hasFlag('color=truecolor')) {
			return 3;
		}
		if (hasFlag('color=256')) {
			return 2;
		}
		if (haveStream && !streamIsTTY && forceColor === undefined) {
			return 0;
		}
		const min = forceColor || 0;
		if (env.TERM === 'dumb') {
			return min;
		}
		if (process.platform === 'win32') {
			const osRelease = os.release().split('.');
			if (
				Number(osRelease[0]) >= 10 &&
				Number(osRelease[2]) >= 10586
			) {
				return Number(osRelease[2]) >= 14931 ? 3 : 2;
			}
			return 1;
		}
		if ('CI' in env) {
			if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI', 'GITHUB_ACTIONS', 'BUILDKITE'].some(sign => sign in env) || env.CI_NAME === 'codeship') {
				return 1;
			}
			return min;
		}
		if ('TEAMCITY_VERSION' in env) {
			return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
		}
		if (env.COLORTERM === 'truecolor') {
			return 3;
		}
		if ('TERM_PROGRAM' in env) {
			const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);
			switch (env.TERM_PROGRAM) {
				case 'iTerm.app':
					return version >= 3 ? 3 : 2;
				case 'Apple_Terminal':
					return 2;
			}
		}
		if (/-256(color)?$/i.test(env.TERM)) {
			return 2;
		}
		if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
			return 1;
		}
		if ('COLORTERM' in env) {
			return 1;
		}
		return min;
	}
	function getSupportLevel(stream) {
		const level = supportsColor(stream, stream && stream.isTTY);
		return translateLevel(level);
	}
	supportsColor_1 = {
		supportsColor: getSupportLevel,
		stdout: translateLevel(supportsColor(true, tty.isatty(1))),
		stderr: translateLevel(supportsColor(true, tty.isatty(2)))
	};
	return supportsColor_1;
}

var hasRequiredNode;

function requireNode () {
	if (hasRequiredNode) return node.exports;
	hasRequiredNode = 1;
	(function (module, exports) {
		const tty = require$$1;
		const util = require$$0$2;
		exports.init = init;
		exports.log = log;
		exports.formatArgs = formatArgs;
		exports.save = save;
		exports.load = load;
		exports.useColors = useColors;
		exports.destroy = util.deprecate(
			() => {},
			'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'
		);
		exports.colors = [6, 2, 3, 4, 5, 1];
		try {
			const supportsColor = requireSupportsColor();
			if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
				exports.colors = [
					20,
					21,
					26,
					27,
					32,
					33,
					38,
					39,
					40,
					41,
					42,
					43,
					44,
					45,
					56,
					57,
					62,
					63,
					68,
					69,
					74,
					75,
					76,
					77,
					78,
					79,
					80,
					81,
					92,
					93,
					98,
					99,
					112,
					113,
					128,
					129,
					134,
					135,
					148,
					149,
					160,
					161,
					162,
					163,
					164,
					165,
					166,
					167,
					168,
					169,
					170,
					171,
					172,
					173,
					178,
					179,
					184,
					185,
					196,
					197,
					198,
					199,
					200,
					201,
					202,
					203,
					204,
					205,
					206,
					207,
					208,
					209,
					214,
					215,
					220,
					221
				];
			}
		} catch (error) {
		}
		exports.inspectOpts = Object.keys(process.env).filter(key => {
			return /^debug_/i.test(key);
		}).reduce((obj, key) => {
			const prop = key
				.substring(6)
				.toLowerCase()
				.replace(/_([a-z])/g, (_, k) => {
					return k.toUpperCase();
				});
			let val = process.env[key];
			if (/^(yes|on|true|enabled)$/i.test(val)) {
				val = true;
			} else if (/^(no|off|false|disabled)$/i.test(val)) {
				val = false;
			} else if (val === 'null') {
				val = null;
			} else {
				val = Number(val);
			}
			obj[prop] = val;
			return obj;
		}, {});
		function useColors() {
			return 'colors' in exports.inspectOpts ?
				Boolean(exports.inspectOpts.colors) :
				tty.isatty(process.stderr.fd);
		}
		function formatArgs(args) {
			const {namespace: name, useColors} = this;
			if (useColors) {
				const c = this.color;
				const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
				const prefix = `  ${colorCode};1m${name} \u001B[0m`;
				args[0] = prefix + args[0].split('\n').join('\n' + prefix);
				args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
			} else {
				args[0] = getDate() + name + ' ' + args[0];
			}
		}
		function getDate() {
			if (exports.inspectOpts.hideDate) {
				return '';
			}
			return new Date().toISOString() + ' ';
		}
		function log(...args) {
			return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + '\n');
		}
		function save(namespaces) {
			if (namespaces) {
				process.env.DEBUG = namespaces;
			} else {
				delete process.env.DEBUG;
			}
		}
		function load() {
			return process.env.DEBUG;
		}
		function init(debug) {
			debug.inspectOpts = {};
			const keys = Object.keys(exports.inspectOpts);
			for (let i = 0; i < keys.length; i++) {
				debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
			}
		}
		module.exports = requireCommon$2()(exports);
		const {formatters} = module.exports;
		formatters.o = function (v) {
			this.inspectOpts.colors = this.useColors;
			return util.inspect(v, this.inspectOpts)
				.split('\n')
				.map(str => str.trim())
				.join(' ');
		};
		formatters.O = function (v) {
			this.inspectOpts.colors = this.useColors;
			return util.inspect(v, this.inspectOpts);
		}; 
	} (node, node.exports));
	return node.exports;
}

var hasRequiredSrc;

function requireSrc () {
	if (hasRequiredSrc) return src.exports;
	hasRequiredSrc = 1;
	if (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {
		src.exports = requireBrowser();
	} else {
		src.exports = requireNode();
	}
	return src.exports;
}

var srcExports = requireSrc();
var debug$2 = /*@__PURE__*/getDefaultExportFromCjs(srcExports);

var index = /*#__PURE__*/Object.freeze({
	__proto__: null,
	default: debug$2
});

var util$4;
(function (util) {
    util.assertEqual = (_) => { };
    function assertIs(_arg) { }
    util.assertIs = assertIs;
    function assertNever(_x) {
        throw new Error();
    }
    util.assertNever = assertNever;
    util.arrayToEnum = (items) => {
        const obj = {};
        for (const item of items) {
            obj[item] = item;
        }
        return obj;
    };
    util.getValidEnumValues = (obj) => {
        const validKeys = util.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
        const filtered = {};
        for (const k of validKeys) {
            filtered[k] = obj[k];
        }
        return util.objectValues(filtered);
    };
    util.objectValues = (obj) => {
        return util.objectKeys(obj).map(function (e) {
            return obj[e];
        });
    };
    util.objectKeys = typeof Object.keys === "function"
        ? (obj) => Object.keys(obj)
        : (object) => {
            const keys = [];
            for (const key in object) {
                if (Object.prototype.hasOwnProperty.call(object, key)) {
                    keys.push(key);
                }
            }
            return keys;
        };
    util.find = (arr, checker) => {
        for (const item of arr) {
            if (checker(item))
                return item;
        }
        return undefined;
    };
    util.isInteger = typeof Number.isInteger === "function"
        ? (val) => Number.isInteger(val)
        : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
    function joinValues(array, separator = " | ") {
        return array.map((val) => (typeof val === "string" ? `'${val}'` : val)).join(separator);
    }
    util.joinValues = joinValues;
    util.jsonStringifyReplacer = (_, value) => {
        if (typeof value === "bigint") {
            return value.toString();
        }
        return value;
    };
})(util$4 || (util$4 = {}));
var objectUtil;
(function (objectUtil) {
    objectUtil.mergeShapes = (first, second) => {
        return {
            ...first,
            ...second,
        };
    };
})(objectUtil || (objectUtil = {}));
const ZodParsedType = util$4.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set",
]);
const getParsedType = (data) => {
    const t = typeof data;
    switch (t) {
        case "undefined":
            return ZodParsedType.undefined;
        case "string":
            return ZodParsedType.string;
        case "number":
            return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
        case "boolean":
            return ZodParsedType.boolean;
        case "function":
            return ZodParsedType.function;
        case "bigint":
            return ZodParsedType.bigint;
        case "symbol":
            return ZodParsedType.symbol;
        case "object":
            if (Array.isArray(data)) {
                return ZodParsedType.array;
            }
            if (data === null) {
                return ZodParsedType.null;
            }
            if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
                return ZodParsedType.promise;
            }
            if (typeof Map !== "undefined" && data instanceof Map) {
                return ZodParsedType.map;
            }
            if (typeof Set !== "undefined" && data instanceof Set) {
                return ZodParsedType.set;
            }
            if (typeof Date !== "undefined" && data instanceof Date) {
                return ZodParsedType.date;
            }
            return ZodParsedType.object;
        default:
            return ZodParsedType.unknown;
    }
};

const ZodIssueCode = util$4.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite",
]);
const quotelessJson = (obj) => {
    const json = JSON.stringify(obj, null, 2);
    return json.replace(/"([^"]+)":/g, "$1:");
};
class ZodError extends Error {
    get errors() {
        return this.issues;
    }
    constructor(issues) {
        super();
        this.issues = [];
        this.addIssue = (sub) => {
            this.issues = [...this.issues, sub];
        };
        this.addIssues = (subs = []) => {
            this.issues = [...this.issues, ...subs];
        };
        const actualProto = new.target.prototype;
        if (Object.setPrototypeOf) {
            Object.setPrototypeOf(this, actualProto);
        }
        else {
            this.__proto__ = actualProto;
        }
        this.name = "ZodError";
        this.issues = issues;
    }
    format(_mapper) {
        const mapper = _mapper ||
            function (issue) {
                return issue.message;
            };
        const fieldErrors = { _errors: [] };
        const processError = (error) => {
            for (const issue of error.issues) {
                if (issue.code === "invalid_union") {
                    issue.unionErrors.map(processError);
                }
                else if (issue.code === "invalid_return_type") {
                    processError(issue.returnTypeError);
                }
                else if (issue.code === "invalid_arguments") {
                    processError(issue.argumentsError);
                }
                else if (issue.path.length === 0) {
                    fieldErrors._errors.push(mapper(issue));
                }
                else {
                    let curr = fieldErrors;
                    let i = 0;
                    while (i < issue.path.length) {
                        const el = issue.path[i];
                        const terminal = i === issue.path.length - 1;
                        if (!terminal) {
                            curr[el] = curr[el] || { _errors: [] };
                        }
                        else {
                            curr[el] = curr[el] || { _errors: [] };
                            curr[el]._errors.push(mapper(issue));
                        }
                        curr = curr[el];
                        i++;
                    }
                }
            }
        };
        processError(this);
        return fieldErrors;
    }
    static assert(value) {
        if (!(value instanceof ZodError)) {
            throw new Error(`Not a ZodError: ${value}`);
        }
    }
    toString() {
        return this.message;
    }
    get message() {
        return JSON.stringify(this.issues, util$4.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
        return this.issues.length === 0;
    }
    flatten(mapper = (issue) => issue.message) {
        const fieldErrors = {};
        const formErrors = [];
        for (const sub of this.issues) {
            if (sub.path.length > 0) {
                const firstEl = sub.path[0];
                fieldErrors[firstEl] = fieldErrors[firstEl] || [];
                fieldErrors[firstEl].push(mapper(sub));
            }
            else {
                formErrors.push(mapper(sub));
            }
        }
        return { formErrors, fieldErrors };
    }
    get formErrors() {
        return this.flatten();
    }
}
ZodError.create = (issues) => {
    const error = new ZodError(issues);
    return error;
};

const errorMap = (issue, _ctx) => {
    let message;
    switch (issue.code) {
        case ZodIssueCode.invalid_type:
            if (issue.received === ZodParsedType.undefined) {
                message = "Required";
            }
            else {
                message = `Expected ${issue.expected}, received ${issue.received}`;
            }
            break;
        case ZodIssueCode.invalid_literal:
            message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util$4.jsonStringifyReplacer)}`;
            break;
        case ZodIssueCode.unrecognized_keys:
            message = `Unrecognized key(s) in object: ${util$4.joinValues(issue.keys, ", ")}`;
            break;
        case ZodIssueCode.invalid_union:
            message = `Invalid input`;
            break;
        case ZodIssueCode.invalid_union_discriminator:
            message = `Invalid discriminator value. Expected ${util$4.joinValues(issue.options)}`;
            break;
        case ZodIssueCode.invalid_enum_value:
            message = `Invalid enum value. Expected ${util$4.joinValues(issue.options)}, received '${issue.received}'`;
            break;
        case ZodIssueCode.invalid_arguments:
            message = `Invalid function arguments`;
            break;
        case ZodIssueCode.invalid_return_type:
            message = `Invalid function return type`;
            break;
        case ZodIssueCode.invalid_date:
            message = `Invalid date`;
            break;
        case ZodIssueCode.invalid_string:
            if (typeof issue.validation === "object") {
                if ("includes" in issue.validation) {
                    message = `Invalid input: must include "${issue.validation.includes}"`;
                    if (typeof issue.validation.position === "number") {
                        message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
                    }
                }
                else if ("startsWith" in issue.validation) {
                    message = `Invalid input: must start with "${issue.validation.startsWith}"`;
                }
                else if ("endsWith" in issue.validation) {
                    message = `Invalid input: must end with "${issue.validation.endsWith}"`;
                }
                else {
                    util$4.assertNever(issue.validation);
                }
            }
            else if (issue.validation !== "regex") {
                message = `Invalid ${issue.validation}`;
            }
            else {
                message = "Invalid";
            }
            break;
        case ZodIssueCode.too_small:
            if (issue.type === "array")
                message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
            else if (issue.type === "string")
                message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
            else if (issue.type === "number")
                message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
            else if (issue.type === "bigint")
                message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
            else if (issue.type === "date")
                message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
            else
                message = "Invalid input";
            break;
        case ZodIssueCode.too_big:
            if (issue.type === "array")
                message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
            else if (issue.type === "string")
                message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
            else if (issue.type === "number")
                message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
            else if (issue.type === "bigint")
                message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
            else if (issue.type === "date")
                message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
            else
                message = "Invalid input";
            break;
        case ZodIssueCode.custom:
            message = `Invalid input`;
            break;
        case ZodIssueCode.invalid_intersection_types:
            message = `Intersection results could not be merged`;
            break;
        case ZodIssueCode.not_multiple_of:
            message = `Number must be a multiple of ${issue.multipleOf}`;
            break;
        case ZodIssueCode.not_finite:
            message = "Number must be finite";
            break;
        default:
            message = _ctx.defaultError;
            util$4.assertNever(issue);
    }
    return { message };
};

let overrideErrorMap = errorMap;
function setErrorMap(map) {
    overrideErrorMap = map;
}
function getErrorMap() {
    return overrideErrorMap;
}

const makeIssue = (params) => {
    const { data, path, errorMaps, issueData } = params;
    const fullPath = [...path, ...(issueData.path || [])];
    const fullIssue = {
        ...issueData,
        path: fullPath,
    };
    if (issueData.message !== undefined) {
        return {
            ...issueData,
            path: fullPath,
            message: issueData.message,
        };
    }
    let errorMessage = "";
    const maps = errorMaps
        .filter((m) => !!m)
        .slice()
        .reverse();
    for (const map of maps) {
        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
    }
    return {
        ...issueData,
        path: fullPath,
        message: errorMessage,
    };
};
const EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
    const overrideMap = getErrorMap();
    const issue = makeIssue({
        issueData: issueData,
        data: ctx.data,
        path: ctx.path,
        errorMaps: [
            ctx.common.contextualErrorMap,
            ctx.schemaErrorMap,
            overrideMap,
            overrideMap === errorMap ? undefined : errorMap,
        ].filter((x) => !!x),
    });
    ctx.common.issues.push(issue);
}
class ParseStatus {
    constructor() {
        this.value = "valid";
    }
    dirty() {
        if (this.value === "valid")
            this.value = "dirty";
    }
    abort() {
        if (this.value !== "aborted")
            this.value = "aborted";
    }
    static mergeArray(status, results) {
        const arrayValue = [];
        for (const s of results) {
            if (s.status === "aborted")
                return INVALID;
            if (s.status === "dirty")
                status.dirty();
            arrayValue.push(s.value);
        }
        return { status: status.value, value: arrayValue };
    }
    static async mergeObjectAsync(status, pairs) {
        const syncPairs = [];
        for (const pair of pairs) {
            const key = await pair.key;
            const value = await pair.value;
            syncPairs.push({
                key,
                value,
            });
        }
        return ParseStatus.mergeObjectSync(status, syncPairs);
    }
    static mergeObjectSync(status, pairs) {
        const finalObject = {};
        for (const pair of pairs) {
            const { key, value } = pair;
            if (key.status === "aborted")
                return INVALID;
            if (value.status === "aborted")
                return INVALID;
            if (key.status === "dirty")
                status.dirty();
            if (value.status === "dirty")
                status.dirty();
            if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
                finalObject[key.value] = value.value;
            }
        }
        return { status: status.value, value: finalObject };
    }
}
const INVALID = Object.freeze({
    status: "aborted",
});
const DIRTY = (value) => ({ status: "dirty", value });
const OK = (value) => ({ status: "valid", value });
const isAborted = (x) => x.status === "aborted";
const isDirty = (x) => x.status === "dirty";
const isValid = (x) => x.status === "valid";
const isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;

var errorUtil;
(function (errorUtil) {
    errorUtil.errToObj = (message) => typeof message === "string" ? { message } : message || {};
    errorUtil.toString = (message) => typeof message === "string" ? message : message?.message;
})(errorUtil || (errorUtil = {}));

class ParseInputLazyPath {
    constructor(parent, value, path, key) {
        this._cachedPath = [];
        this.parent = parent;
        this.data = value;
        this._path = path;
        this._key = key;
    }
    get path() {
        if (!this._cachedPath.length) {
            if (Array.isArray(this._key)) {
                this._cachedPath.push(...this._path, ...this._key);
            }
            else {
                this._cachedPath.push(...this._path, this._key);
            }
        }
        return this._cachedPath;
    }
}
const handleResult = (ctx, result) => {
    if (isValid(result)) {
        return { success: true, data: result.value };
    }
    else {
        if (!ctx.common.issues.length) {
            throw new Error("Validation failed but no issues detected.");
        }
        return {
            success: false,
            get error() {
                if (this._error)
                    return this._error;
                const error = new ZodError(ctx.common.issues);
                this._error = error;
                return this._error;
            },
        };
    }
};
function processCreateParams$1(params) {
    if (!params)
        return {};
    const { errorMap, invalid_type_error, required_error, description } = params;
    if (errorMap && (invalid_type_error || required_error)) {
        throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    }
    if (errorMap)
        return { errorMap: errorMap, description };
    const customMap = (iss, ctx) => {
        const { message } = params;
        if (iss.code === "invalid_enum_value") {
            return { message: message ?? ctx.defaultError };
        }
        if (typeof ctx.data === "undefined") {
            return { message: message ?? required_error ?? ctx.defaultError };
        }
        if (iss.code !== "invalid_type")
            return { message: ctx.defaultError };
        return { message: message ?? invalid_type_error ?? ctx.defaultError };
    };
    return { errorMap: customMap, description };
}
class ZodType {
    get description() {
        return this._def.description;
    }
    _getType(input) {
        return getParsedType(input.data);
    }
    _getOrReturnCtx(input, ctx) {
        return (ctx || {
            common: input.parent.common,
            data: input.data,
            parsedType: getParsedType(input.data),
            schemaErrorMap: this._def.errorMap,
            path: input.path,
            parent: input.parent,
        });
    }
    _processInputParams(input) {
        return {
            status: new ParseStatus(),
            ctx: {
                common: input.parent.common,
                data: input.data,
                parsedType: getParsedType(input.data),
                schemaErrorMap: this._def.errorMap,
                path: input.path,
                parent: input.parent,
            },
        };
    }
    _parseSync(input) {
        const result = this._parse(input);
        if (isAsync(result)) {
            throw new Error("Synchronous parse encountered promise.");
        }
        return result;
    }
    _parseAsync(input) {
        const result = this._parse(input);
        return Promise.resolve(result);
    }
    parse(data, params) {
        const result = this.safeParse(data, params);
        if (result.success)
            return result.data;
        throw result.error;
    }
    safeParse(data, params) {
        const ctx = {
            common: {
                issues: [],
                async: params?.async ?? false,
                contextualErrorMap: params?.errorMap,
            },
            path: params?.path || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: getParsedType(data),
        };
        const result = this._parseSync({ data, path: ctx.path, parent: ctx });
        return handleResult(ctx, result);
    }
    "~validate"(data) {
        const ctx = {
            common: {
                issues: [],
                async: !!this["~standard"].async,
            },
            path: [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: getParsedType(data),
        };
        if (!this["~standard"].async) {
            try {
                const result = this._parseSync({ data, path: [], parent: ctx });
                return isValid(result)
                    ? {
                        value: result.value,
                    }
                    : {
                        issues: ctx.common.issues,
                    };
            }
            catch (err) {
                if (err?.message?.toLowerCase()?.includes("encountered")) {
                    this["~standard"].async = true;
                }
                ctx.common = {
                    issues: [],
                    async: true,
                };
            }
        }
        return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result)
            ? {
                value: result.value,
            }
            : {
                issues: ctx.common.issues,
            });
    }
    async parseAsync(data, params) {
        const result = await this.safeParseAsync(data, params);
        if (result.success)
            return result.data;
        throw result.error;
    }
    async safeParseAsync(data, params) {
        const ctx = {
            common: {
                issues: [],
                contextualErrorMap: params?.errorMap,
                async: true,
            },
            path: params?.path || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: getParsedType(data),
        };
        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
        const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
        return handleResult(ctx, result);
    }
    refine(check, message) {
        const getIssueProperties = (val) => {
            if (typeof message === "string" || typeof message === "undefined") {
                return { message };
            }
            else if (typeof message === "function") {
                return message(val);
            }
            else {
                return message;
            }
        };
        return this._refinement((val, ctx) => {
            const result = check(val);
            const setError = () => ctx.addIssue({
                code: ZodIssueCode.custom,
                ...getIssueProperties(val),
            });
            if (typeof Promise !== "undefined" && result instanceof Promise) {
                return result.then((data) => {
                    if (!data) {
                        setError();
                        return false;
                    }
                    else {
                        return true;
                    }
                });
            }
            if (!result) {
                setError();
                return false;
            }
            else {
                return true;
            }
        });
    }
    refinement(check, refinementData) {
        return this._refinement((val, ctx) => {
            if (!check(val)) {
                ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
                return false;
            }
            else {
                return true;
            }
        });
    }
    _refinement(refinement) {
        return new ZodEffects({
            schema: this,
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            effect: { type: "refinement", refinement },
        });
    }
    superRefine(refinement) {
        return this._refinement(refinement);
    }
    constructor(def) {
        this.spa = this.safeParseAsync;
        this._def = def;
        this.parse = this.parse.bind(this);
        this.safeParse = this.safeParse.bind(this);
        this.parseAsync = this.parseAsync.bind(this);
        this.safeParseAsync = this.safeParseAsync.bind(this);
        this.spa = this.spa.bind(this);
        this.refine = this.refine.bind(this);
        this.refinement = this.refinement.bind(this);
        this.superRefine = this.superRefine.bind(this);
        this.optional = this.optional.bind(this);
        this.nullable = this.nullable.bind(this);
        this.nullish = this.nullish.bind(this);
        this.array = this.array.bind(this);
        this.promise = this.promise.bind(this);
        this.or = this.or.bind(this);
        this.and = this.and.bind(this);
        this.transform = this.transform.bind(this);
        this.brand = this.brand.bind(this);
        this.default = this.default.bind(this);
        this.catch = this.catch.bind(this);
        this.describe = this.describe.bind(this);
        this.pipe = this.pipe.bind(this);
        this.readonly = this.readonly.bind(this);
        this.isNullable = this.isNullable.bind(this);
        this.isOptional = this.isOptional.bind(this);
        this["~standard"] = {
            version: 1,
            vendor: "zod",
            validate: (data) => this["~validate"](data),
        };
    }
    optional() {
        return ZodOptional.create(this, this._def);
    }
    nullable() {
        return ZodNullable.create(this, this._def);
    }
    nullish() {
        return this.nullable().optional();
    }
    array() {
        return ZodArray.create(this);
    }
    promise() {
        return ZodPromise.create(this, this._def);
    }
    or(option) {
        return ZodUnion.create([this, option], this._def);
    }
    and(incoming) {
        return ZodIntersection.create(this, incoming, this._def);
    }
    transform(transform) {
        return new ZodEffects({
            ...processCreateParams$1(this._def),
            schema: this,
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            effect: { type: "transform", transform },
        });
    }
    default(def) {
        const defaultValueFunc = typeof def === "function" ? def : () => def;
        return new ZodDefault({
            ...processCreateParams$1(this._def),
            innerType: this,
            defaultValue: defaultValueFunc,
            typeName: ZodFirstPartyTypeKind.ZodDefault,
        });
    }
    brand() {
        return new ZodBranded({
            typeName: ZodFirstPartyTypeKind.ZodBranded,
            type: this,
            ...processCreateParams$1(this._def),
        });
    }
    catch(def) {
        const catchValueFunc = typeof def === "function" ? def : () => def;
        return new ZodCatch({
            ...processCreateParams$1(this._def),
            innerType: this,
            catchValue: catchValueFunc,
            typeName: ZodFirstPartyTypeKind.ZodCatch,
        });
    }
    describe(description) {
        const This = this.constructor;
        return new This({
            ...this._def,
            description,
        });
    }
    pipe(target) {
        return ZodPipeline.create(this, target);
    }
    readonly() {
        return ZodReadonly.create(this);
    }
    isOptional() {
        return this.safeParse(undefined).success;
    }
    isNullable() {
        return this.safeParse(null).success;
    }
}
const cuidRegex = /^c[^\s-]{8,}$/i;
const cuid2Regex = /^[0-9a-z]+$/;
const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const nanoidRegex = /^[a-z0-9_-]{21}$/i;
const jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
const durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex$1;
const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
const ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
const ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
const base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
const base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
const dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
const dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
    let secondsRegexSource = `[0-5]\\d`;
    if (args.precision) {
        secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
    }
    else if (args.precision == null) {
        secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
    }
    const secondsQuantifier = args.precision ? "+" : "?";
    return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex(args) {
    return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
    let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
    const opts = [];
    opts.push(args.local ? `Z?` : `Z`);
    if (args.offset)
        opts.push(`([+-]\\d{2}:?\\d{2})`);
    regex = `${regex}(${opts.join("|")})`;
    return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version) {
    if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
        return true;
    }
    if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
        return true;
    }
    return false;
}
function isValidJWT(jwt, alg) {
    if (!jwtRegex.test(jwt))
        return false;
    try {
        const [header] = jwt.split(".");
        if (!header)
            return false;
        const base64 = header
            .replace(/-/g, "+")
            .replace(/_/g, "/")
            .padEnd(header.length + ((4 - (header.length % 4)) % 4), "=");
        const decoded = JSON.parse(atob(base64));
        if (typeof decoded !== "object" || decoded === null)
            return false;
        if ("typ" in decoded && decoded?.typ !== "JWT")
            return false;
        if (!decoded.alg)
            return false;
        if (alg && decoded.alg !== alg)
            return false;
        return true;
    }
    catch {
        return false;
    }
}
function isValidCidr(ip, version) {
    if ((version === "v4" || !version) && ipv4CidrRegex.test(ip)) {
        return true;
    }
    if ((version === "v6" || !version) && ipv6CidrRegex.test(ip)) {
        return true;
    }
    return false;
}
class ZodString extends ZodType {
    _parse(input) {
        if (this._def.coerce) {
            input.data = String(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.string) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.string,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const status = new ParseStatus();
        let ctx = undefined;
        for (const check of this._def.checks) {
            if (check.kind === "min") {
                if (input.data.length < check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        minimum: check.value,
                        type: "string",
                        inclusive: true,
                        exact: false,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "max") {
                if (input.data.length > check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        maximum: check.value,
                        type: "string",
                        inclusive: true,
                        exact: false,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "length") {
                const tooBig = input.data.length > check.value;
                const tooSmall = input.data.length < check.value;
                if (tooBig || tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    if (tooBig) {
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_big,
                            maximum: check.value,
                            type: "string",
                            inclusive: true,
                            exact: true,
                            message: check.message,
                        });
                    }
                    else if (tooSmall) {
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_small,
                            minimum: check.value,
                            type: "string",
                            inclusive: true,
                            exact: true,
                            message: check.message,
                        });
                    }
                    status.dirty();
                }
            }
            else if (check.kind === "email") {
                if (!emailRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "email",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "emoji") {
                if (!emojiRegex$1) {
                    emojiRegex$1 = new RegExp(_emojiRegex, "u");
                }
                if (!emojiRegex$1.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "emoji",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "uuid") {
                if (!uuidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "uuid",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "nanoid") {
                if (!nanoidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "nanoid",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "cuid") {
                if (!cuidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "cuid",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "cuid2") {
                if (!cuid2Regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "cuid2",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "ulid") {
                if (!ulidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "ulid",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "url") {
                try {
                    new URL(input.data);
                }
                catch {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "url",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "regex") {
                check.regex.lastIndex = 0;
                const testResult = check.regex.test(input.data);
                if (!testResult) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "regex",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "trim") {
                input.data = input.data.trim();
            }
            else if (check.kind === "includes") {
                if (!input.data.includes(check.value, check.position)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: { includes: check.value, position: check.position },
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "toLowerCase") {
                input.data = input.data.toLowerCase();
            }
            else if (check.kind === "toUpperCase") {
                input.data = input.data.toUpperCase();
            }
            else if (check.kind === "startsWith") {
                if (!input.data.startsWith(check.value)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: { startsWith: check.value },
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "endsWith") {
                if (!input.data.endsWith(check.value)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: { endsWith: check.value },
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "datetime") {
                const regex = datetimeRegex(check);
                if (!regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: "datetime",
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "date") {
                const regex = dateRegex;
                if (!regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: "date",
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "time") {
                const regex = timeRegex(check);
                if (!regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: "time",
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "duration") {
                if (!durationRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "duration",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "ip") {
                if (!isValidIP(input.data, check.version)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "ip",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "jwt") {
                if (!isValidJWT(input.data, check.alg)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "jwt",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "cidr") {
                if (!isValidCidr(input.data, check.version)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "cidr",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "base64") {
                if (!base64Regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "base64",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "base64url") {
                if (!base64urlRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "base64url",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else {
                util$4.assertNever(check);
            }
        }
        return { status: status.value, value: input.data };
    }
    _regex(regex, validation, message) {
        return this.refinement((data) => regex.test(data), {
            validation,
            code: ZodIssueCode.invalid_string,
            ...errorUtil.errToObj(message),
        });
    }
    _addCheck(check) {
        return new ZodString({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    email(message) {
        return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
    }
    url(message) {
        return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
    }
    emoji(message) {
        return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
    }
    uuid(message) {
        return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
    }
    nanoid(message) {
        return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
    }
    cuid(message) {
        return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
    }
    cuid2(message) {
        return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
    }
    ulid(message) {
        return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
    }
    base64(message) {
        return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
    }
    base64url(message) {
        return this._addCheck({
            kind: "base64url",
            ...errorUtil.errToObj(message),
        });
    }
    jwt(options) {
        return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
    }
    ip(options) {
        return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
    }
    cidr(options) {
        return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
    }
    datetime(options) {
        if (typeof options === "string") {
            return this._addCheck({
                kind: "datetime",
                precision: null,
                offset: false,
                local: false,
                message: options,
            });
        }
        return this._addCheck({
            kind: "datetime",
            precision: typeof options?.precision === "undefined" ? null : options?.precision,
            offset: options?.offset ?? false,
            local: options?.local ?? false,
            ...errorUtil.errToObj(options?.message),
        });
    }
    date(message) {
        return this._addCheck({ kind: "date", message });
    }
    time(options) {
        if (typeof options === "string") {
            return this._addCheck({
                kind: "time",
                precision: null,
                message: options,
            });
        }
        return this._addCheck({
            kind: "time",
            precision: typeof options?.precision === "undefined" ? null : options?.precision,
            ...errorUtil.errToObj(options?.message),
        });
    }
    duration(message) {
        return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
    }
    regex(regex, message) {
        return this._addCheck({
            kind: "regex",
            regex: regex,
            ...errorUtil.errToObj(message),
        });
    }
    includes(value, options) {
        return this._addCheck({
            kind: "includes",
            value: value,
            position: options?.position,
            ...errorUtil.errToObj(options?.message),
        });
    }
    startsWith(value, message) {
        return this._addCheck({
            kind: "startsWith",
            value: value,
            ...errorUtil.errToObj(message),
        });
    }
    endsWith(value, message) {
        return this._addCheck({
            kind: "endsWith",
            value: value,
            ...errorUtil.errToObj(message),
        });
    }
    min(minLength, message) {
        return this._addCheck({
            kind: "min",
            value: minLength,
            ...errorUtil.errToObj(message),
        });
    }
    max(maxLength, message) {
        return this._addCheck({
            kind: "max",
            value: maxLength,
            ...errorUtil.errToObj(message),
        });
    }
    length(len, message) {
        return this._addCheck({
            kind: "length",
            value: len,
            ...errorUtil.errToObj(message),
        });
    }
    nonempty(message) {
        return this.min(1, errorUtil.errToObj(message));
    }
    trim() {
        return new ZodString({
            ...this._def,
            checks: [...this._def.checks, { kind: "trim" }],
        });
    }
    toLowerCase() {
        return new ZodString({
            ...this._def,
            checks: [...this._def.checks, { kind: "toLowerCase" }],
        });
    }
    toUpperCase() {
        return new ZodString({
            ...this._def,
            checks: [...this._def.checks, { kind: "toUpperCase" }],
        });
    }
    get isDatetime() {
        return !!this._def.checks.find((ch) => ch.kind === "datetime");
    }
    get isDate() {
        return !!this._def.checks.find((ch) => ch.kind === "date");
    }
    get isTime() {
        return !!this._def.checks.find((ch) => ch.kind === "time");
    }
    get isDuration() {
        return !!this._def.checks.find((ch) => ch.kind === "duration");
    }
    get isEmail() {
        return !!this._def.checks.find((ch) => ch.kind === "email");
    }
    get isURL() {
        return !!this._def.checks.find((ch) => ch.kind === "url");
    }
    get isEmoji() {
        return !!this._def.checks.find((ch) => ch.kind === "emoji");
    }
    get isUUID() {
        return !!this._def.checks.find((ch) => ch.kind === "uuid");
    }
    get isNANOID() {
        return !!this._def.checks.find((ch) => ch.kind === "nanoid");
    }
    get isCUID() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid");
    }
    get isCUID2() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid2");
    }
    get isULID() {
        return !!this._def.checks.find((ch) => ch.kind === "ulid");
    }
    get isIP() {
        return !!this._def.checks.find((ch) => ch.kind === "ip");
    }
    get isCIDR() {
        return !!this._def.checks.find((ch) => ch.kind === "cidr");
    }
    get isBase64() {
        return !!this._def.checks.find((ch) => ch.kind === "base64");
    }
    get isBase64url() {
        return !!this._def.checks.find((ch) => ch.kind === "base64url");
    }
    get minLength() {
        let min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
        }
        return min;
    }
    get maxLength() {
        let max = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return max;
    }
}
ZodString.create = (params) => {
    return new ZodString({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodString,
        coerce: params?.coerce ?? false,
        ...processCreateParams$1(params),
    });
};
function floatSafeRemainder(val, step) {
    const valDecCount = (val.toString().split(".")[1] || "").length;
    const stepDecCount = (step.toString().split(".")[1] || "").length;
    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
    const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
    const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
    return (valInt % stepInt) / 10 ** decCount;
}
class ZodNumber extends ZodType {
    constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
        this.step = this.multipleOf;
    }
    _parse(input) {
        if (this._def.coerce) {
            input.data = Number(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.number) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.number,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        let ctx = undefined;
        const status = new ParseStatus();
        for (const check of this._def.checks) {
            if (check.kind === "int") {
                if (!util$4.isInteger(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: "integer",
                        received: "float",
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "min") {
                const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
                if (tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        minimum: check.value,
                        type: "number",
                        inclusive: check.inclusive,
                        exact: false,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "max") {
                const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
                if (tooBig) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        maximum: check.value,
                        type: "number",
                        inclusive: check.inclusive,
                        exact: false,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "multipleOf") {
                if (floatSafeRemainder(input.data, check.value) !== 0) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.not_multiple_of,
                        multipleOf: check.value,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "finite") {
                if (!Number.isFinite(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.not_finite,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else {
                util$4.assertNever(check);
            }
        }
        return { status: status.value, value: input.data };
    }
    gte(value, message) {
        return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
        return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
        return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
        return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
        return new ZodNumber({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind,
                    value,
                    inclusive,
                    message: errorUtil.toString(message),
                },
            ],
        });
    }
    _addCheck(check) {
        return new ZodNumber({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    int(message) {
        return this._addCheck({
            kind: "int",
            message: errorUtil.toString(message),
        });
    }
    positive(message) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: false,
            message: errorUtil.toString(message),
        });
    }
    negative(message) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: false,
            message: errorUtil.toString(message),
        });
    }
    nonpositive(message) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: true,
            message: errorUtil.toString(message),
        });
    }
    nonnegative(message) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: true,
            message: errorUtil.toString(message),
        });
    }
    multipleOf(value, message) {
        return this._addCheck({
            kind: "multipleOf",
            value: value,
            message: errorUtil.toString(message),
        });
    }
    finite(message) {
        return this._addCheck({
            kind: "finite",
            message: errorUtil.toString(message),
        });
    }
    safe(message) {
        return this._addCheck({
            kind: "min",
            inclusive: true,
            value: Number.MIN_SAFE_INTEGER,
            message: errorUtil.toString(message),
        })._addCheck({
            kind: "max",
            inclusive: true,
            value: Number.MAX_SAFE_INTEGER,
            message: errorUtil.toString(message),
        });
    }
    get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
        }
        return min;
    }
    get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return max;
    }
    get isInt() {
        return !!this._def.checks.find((ch) => ch.kind === "int" || (ch.kind === "multipleOf" && util$4.isInteger(ch.value)));
    }
    get isFinite() {
        let max = null;
        let min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
                return true;
            }
            else if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
            else if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return Number.isFinite(min) && Number.isFinite(max);
    }
}
ZodNumber.create = (params) => {
    return new ZodNumber({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodNumber,
        coerce: params?.coerce || false,
        ...processCreateParams$1(params),
    });
};
class ZodBigInt extends ZodType {
    constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
    }
    _parse(input) {
        if (this._def.coerce) {
            try {
                input.data = BigInt(input.data);
            }
            catch {
                return this._getInvalidInput(input);
            }
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.bigint) {
            return this._getInvalidInput(input);
        }
        let ctx = undefined;
        const status = new ParseStatus();
        for (const check of this._def.checks) {
            if (check.kind === "min") {
                const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
                if (tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        type: "bigint",
                        minimum: check.value,
                        inclusive: check.inclusive,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "max") {
                const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
                if (tooBig) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        type: "bigint",
                        maximum: check.value,
                        inclusive: check.inclusive,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "multipleOf") {
                if (input.data % check.value !== BigInt(0)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.not_multiple_of,
                        multipleOf: check.value,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else {
                util$4.assertNever(check);
            }
        }
        return { status: status.value, value: input.data };
    }
    _getInvalidInput(input) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.bigint,
            received: ctx.parsedType,
        });
        return INVALID;
    }
    gte(value, message) {
        return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
        return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
        return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
        return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
        return new ZodBigInt({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind,
                    value,
                    inclusive,
                    message: errorUtil.toString(message),
                },
            ],
        });
    }
    _addCheck(check) {
        return new ZodBigInt({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    positive(message) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: false,
            message: errorUtil.toString(message),
        });
    }
    negative(message) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: false,
            message: errorUtil.toString(message),
        });
    }
    nonpositive(message) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: true,
            message: errorUtil.toString(message),
        });
    }
    nonnegative(message) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: true,
            message: errorUtil.toString(message),
        });
    }
    multipleOf(value, message) {
        return this._addCheck({
            kind: "multipleOf",
            value,
            message: errorUtil.toString(message),
        });
    }
    get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
        }
        return min;
    }
    get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return max;
    }
}
ZodBigInt.create = (params) => {
    return new ZodBigInt({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodBigInt,
        coerce: params?.coerce ?? false,
        ...processCreateParams$1(params),
    });
};
class ZodBoolean extends ZodType {
    _parse(input) {
        if (this._def.coerce) {
            input.data = Boolean(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.boolean) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.boolean,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodBoolean.create = (params) => {
    return new ZodBoolean({
        typeName: ZodFirstPartyTypeKind.ZodBoolean,
        coerce: params?.coerce || false,
        ...processCreateParams$1(params),
    });
};
class ZodDate extends ZodType {
    _parse(input) {
        if (this._def.coerce) {
            input.data = new Date(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.date) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.date,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        if (Number.isNaN(input.data.getTime())) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_date,
            });
            return INVALID;
        }
        const status = new ParseStatus();
        let ctx = undefined;
        for (const check of this._def.checks) {
            if (check.kind === "min") {
                if (input.data.getTime() < check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        message: check.message,
                        inclusive: true,
                        exact: false,
                        minimum: check.value,
                        type: "date",
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "max") {
                if (input.data.getTime() > check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        message: check.message,
                        inclusive: true,
                        exact: false,
                        maximum: check.value,
                        type: "date",
                    });
                    status.dirty();
                }
            }
            else {
                util$4.assertNever(check);
            }
        }
        return {
            status: status.value,
            value: new Date(input.data.getTime()),
        };
    }
    _addCheck(check) {
        return new ZodDate({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    min(minDate, message) {
        return this._addCheck({
            kind: "min",
            value: minDate.getTime(),
            message: errorUtil.toString(message),
        });
    }
    max(maxDate, message) {
        return this._addCheck({
            kind: "max",
            value: maxDate.getTime(),
            message: errorUtil.toString(message),
        });
    }
    get minDate() {
        let min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
        }
        return min != null ? new Date(min) : null;
    }
    get maxDate() {
        let max = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return max != null ? new Date(max) : null;
    }
}
ZodDate.create = (params) => {
    return new ZodDate({
        checks: [],
        coerce: params?.coerce || false,
        typeName: ZodFirstPartyTypeKind.ZodDate,
        ...processCreateParams$1(params),
    });
};
class ZodSymbol extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.symbol) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.symbol,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodSymbol.create = (params) => {
    return new ZodSymbol({
        typeName: ZodFirstPartyTypeKind.ZodSymbol,
        ...processCreateParams$1(params),
    });
};
class ZodUndefined extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.undefined,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodUndefined.create = (params) => {
    return new ZodUndefined({
        typeName: ZodFirstPartyTypeKind.ZodUndefined,
        ...processCreateParams$1(params),
    });
};
class ZodNull extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.null) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.null,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodNull.create = (params) => {
    return new ZodNull({
        typeName: ZodFirstPartyTypeKind.ZodNull,
        ...processCreateParams$1(params),
    });
};
class ZodAny extends ZodType {
    constructor() {
        super(...arguments);
        this._any = true;
    }
    _parse(input) {
        return OK(input.data);
    }
}
ZodAny.create = (params) => {
    return new ZodAny({
        typeName: ZodFirstPartyTypeKind.ZodAny,
        ...processCreateParams$1(params),
    });
};
class ZodUnknown extends ZodType {
    constructor() {
        super(...arguments);
        this._unknown = true;
    }
    _parse(input) {
        return OK(input.data);
    }
}
ZodUnknown.create = (params) => {
    return new ZodUnknown({
        typeName: ZodFirstPartyTypeKind.ZodUnknown,
        ...processCreateParams$1(params),
    });
};
class ZodNever extends ZodType {
    _parse(input) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.never,
            received: ctx.parsedType,
        });
        return INVALID;
    }
}
ZodNever.create = (params) => {
    return new ZodNever({
        typeName: ZodFirstPartyTypeKind.ZodNever,
        ...processCreateParams$1(params),
    });
};
class ZodVoid extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.void,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodVoid.create = (params) => {
    return new ZodVoid({
        typeName: ZodFirstPartyTypeKind.ZodVoid,
        ...processCreateParams$1(params),
    });
};
class ZodArray extends ZodType {
    _parse(input) {
        const { ctx, status } = this._processInputParams(input);
        const def = this._def;
        if (ctx.parsedType !== ZodParsedType.array) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.array,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        if (def.exactLength !== null) {
            const tooBig = ctx.data.length > def.exactLength.value;
            const tooSmall = ctx.data.length < def.exactLength.value;
            if (tooBig || tooSmall) {
                addIssueToContext(ctx, {
                    code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
                    minimum: (tooSmall ? def.exactLength.value : undefined),
                    maximum: (tooBig ? def.exactLength.value : undefined),
                    type: "array",
                    inclusive: true,
                    exact: true,
                    message: def.exactLength.message,
                });
                status.dirty();
            }
        }
        if (def.minLength !== null) {
            if (ctx.data.length < def.minLength.value) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_small,
                    minimum: def.minLength.value,
                    type: "array",
                    inclusive: true,
                    exact: false,
                    message: def.minLength.message,
                });
                status.dirty();
            }
        }
        if (def.maxLength !== null) {
            if (ctx.data.length > def.maxLength.value) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_big,
                    maximum: def.maxLength.value,
                    type: "array",
                    inclusive: true,
                    exact: false,
                    message: def.maxLength.message,
                });
                status.dirty();
            }
        }
        if (ctx.common.async) {
            return Promise.all([...ctx.data].map((item, i) => {
                return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
            })).then((result) => {
                return ParseStatus.mergeArray(status, result);
            });
        }
        const result = [...ctx.data].map((item, i) => {
            return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        });
        return ParseStatus.mergeArray(status, result);
    }
    get element() {
        return this._def.type;
    }
    min(minLength, message) {
        return new ZodArray({
            ...this._def,
            minLength: { value: minLength, message: errorUtil.toString(message) },
        });
    }
    max(maxLength, message) {
        return new ZodArray({
            ...this._def,
            maxLength: { value: maxLength, message: errorUtil.toString(message) },
        });
    }
    length(len, message) {
        return new ZodArray({
            ...this._def,
            exactLength: { value: len, message: errorUtil.toString(message) },
        });
    }
    nonempty(message) {
        return this.min(1, message);
    }
}
ZodArray.create = (schema, params) => {
    return new ZodArray({
        type: schema,
        minLength: null,
        maxLength: null,
        exactLength: null,
        typeName: ZodFirstPartyTypeKind.ZodArray,
        ...processCreateParams$1(params),
    });
};
function deepPartialify(schema) {
    if (schema instanceof ZodObject) {
        const newShape = {};
        for (const key in schema.shape) {
            const fieldSchema = schema.shape[key];
            newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
        }
        return new ZodObject({
            ...schema._def,
            shape: () => newShape,
        });
    }
    else if (schema instanceof ZodArray) {
        return new ZodArray({
            ...schema._def,
            type: deepPartialify(schema.element),
        });
    }
    else if (schema instanceof ZodOptional) {
        return ZodOptional.create(deepPartialify(schema.unwrap()));
    }
    else if (schema instanceof ZodNullable) {
        return ZodNullable.create(deepPartialify(schema.unwrap()));
    }
    else if (schema instanceof ZodTuple) {
        return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
    }
    else {
        return schema;
    }
}
class ZodObject extends ZodType {
    constructor() {
        super(...arguments);
        this._cached = null;
        this.nonstrict = this.passthrough;
        this.augment = this.extend;
    }
    _getCached() {
        if (this._cached !== null)
            return this._cached;
        const shape = this._def.shape();
        const keys = util$4.objectKeys(shape);
        this._cached = { shape, keys };
        return this._cached;
    }
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.object) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.object,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const { status, ctx } = this._processInputParams(input);
        const { shape, keys: shapeKeys } = this._getCached();
        const extraKeys = [];
        if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
            for (const key in ctx.data) {
                if (!shapeKeys.includes(key)) {
                    extraKeys.push(key);
                }
            }
        }
        const pairs = [];
        for (const key of shapeKeys) {
            const keyValidator = shape[key];
            const value = ctx.data[key];
            pairs.push({
                key: { status: "valid", value: key },
                value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
                alwaysSet: key in ctx.data,
            });
        }
        if (this._def.catchall instanceof ZodNever) {
            const unknownKeys = this._def.unknownKeys;
            if (unknownKeys === "passthrough") {
                for (const key of extraKeys) {
                    pairs.push({
                        key: { status: "valid", value: key },
                        value: { status: "valid", value: ctx.data[key] },
                    });
                }
            }
            else if (unknownKeys === "strict") {
                if (extraKeys.length > 0) {
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.unrecognized_keys,
                        keys: extraKeys,
                    });
                    status.dirty();
                }
            }
            else if (unknownKeys === "strip") ;
            else {
                throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
            }
        }
        else {
            const catchall = this._def.catchall;
            for (const key of extraKeys) {
                const value = ctx.data[key];
                pairs.push({
                    key: { status: "valid", value: key },
                    value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)
                    ),
                    alwaysSet: key in ctx.data,
                });
            }
        }
        if (ctx.common.async) {
            return Promise.resolve()
                .then(async () => {
                const syncPairs = [];
                for (const pair of pairs) {
                    const key = await pair.key;
                    const value = await pair.value;
                    syncPairs.push({
                        key,
                        value,
                        alwaysSet: pair.alwaysSet,
                    });
                }
                return syncPairs;
            })
                .then((syncPairs) => {
                return ParseStatus.mergeObjectSync(status, syncPairs);
            });
        }
        else {
            return ParseStatus.mergeObjectSync(status, pairs);
        }
    }
    get shape() {
        return this._def.shape();
    }
    strict(message) {
        errorUtil.errToObj;
        return new ZodObject({
            ...this._def,
            unknownKeys: "strict",
            ...(message !== undefined
                ? {
                    errorMap: (issue, ctx) => {
                        const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;
                        if (issue.code === "unrecognized_keys")
                            return {
                                message: errorUtil.errToObj(message).message ?? defaultError,
                            };
                        return {
                            message: defaultError,
                        };
                    },
                }
                : {}),
        });
    }
    strip() {
        return new ZodObject({
            ...this._def,
            unknownKeys: "strip",
        });
    }
    passthrough() {
        return new ZodObject({
            ...this._def,
            unknownKeys: "passthrough",
        });
    }
    extend(augmentation) {
        return new ZodObject({
            ...this._def,
            shape: () => ({
                ...this._def.shape(),
                ...augmentation,
            }),
        });
    }
    merge(merging) {
        const merged = new ZodObject({
            unknownKeys: merging._def.unknownKeys,
            catchall: merging._def.catchall,
            shape: () => ({
                ...this._def.shape(),
                ...merging._def.shape(),
            }),
            typeName: ZodFirstPartyTypeKind.ZodObject,
        });
        return merged;
    }
    setKey(key, schema) {
        return this.augment({ [key]: schema });
    }
    catchall(index) {
        return new ZodObject({
            ...this._def,
            catchall: index,
        });
    }
    pick(mask) {
        const shape = {};
        for (const key of util$4.objectKeys(mask)) {
            if (mask[key] && this.shape[key]) {
                shape[key] = this.shape[key];
            }
        }
        return new ZodObject({
            ...this._def,
            shape: () => shape,
        });
    }
    omit(mask) {
        const shape = {};
        for (const key of util$4.objectKeys(this.shape)) {
            if (!mask[key]) {
                shape[key] = this.shape[key];
            }
        }
        return new ZodObject({
            ...this._def,
            shape: () => shape,
        });
    }
    deepPartial() {
        return deepPartialify(this);
    }
    partial(mask) {
        const newShape = {};
        for (const key of util$4.objectKeys(this.shape)) {
            const fieldSchema = this.shape[key];
            if (mask && !mask[key]) {
                newShape[key] = fieldSchema;
            }
            else {
                newShape[key] = fieldSchema.optional();
            }
        }
        return new ZodObject({
            ...this._def,
            shape: () => newShape,
        });
    }
    required(mask) {
        const newShape = {};
        for (const key of util$4.objectKeys(this.shape)) {
            if (mask && !mask[key]) {
                newShape[key] = this.shape[key];
            }
            else {
                const fieldSchema = this.shape[key];
                let newField = fieldSchema;
                while (newField instanceof ZodOptional) {
                    newField = newField._def.innerType;
                }
                newShape[key] = newField;
            }
        }
        return new ZodObject({
            ...this._def,
            shape: () => newShape,
        });
    }
    keyof() {
        return createZodEnum(util$4.objectKeys(this.shape));
    }
}
ZodObject.create = (shape, params) => {
    return new ZodObject({
        shape: () => shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams$1(params),
    });
};
ZodObject.strictCreate = (shape, params) => {
    return new ZodObject({
        shape: () => shape,
        unknownKeys: "strict",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams$1(params),
    });
};
ZodObject.lazycreate = (shape, params) => {
    return new ZodObject({
        shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams$1(params),
    });
};
class ZodUnion extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const options = this._def.options;
        function handleResults(results) {
            for (const result of results) {
                if (result.result.status === "valid") {
                    return result.result;
                }
            }
            for (const result of results) {
                if (result.result.status === "dirty") {
                    ctx.common.issues.push(...result.ctx.common.issues);
                    return result.result;
                }
            }
            const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_union,
                unionErrors,
            });
            return INVALID;
        }
        if (ctx.common.async) {
            return Promise.all(options.map(async (option) => {
                const childCtx = {
                    ...ctx,
                    common: {
                        ...ctx.common,
                        issues: [],
                    },
                    parent: null,
                };
                return {
                    result: await option._parseAsync({
                        data: ctx.data,
                        path: ctx.path,
                        parent: childCtx,
                    }),
                    ctx: childCtx,
                };
            })).then(handleResults);
        }
        else {
            let dirty = undefined;
            const issues = [];
            for (const option of options) {
                const childCtx = {
                    ...ctx,
                    common: {
                        ...ctx.common,
                        issues: [],
                    },
                    parent: null,
                };
                const result = option._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: childCtx,
                });
                if (result.status === "valid") {
                    return result;
                }
                else if (result.status === "dirty" && !dirty) {
                    dirty = { result, ctx: childCtx };
                }
                if (childCtx.common.issues.length) {
                    issues.push(childCtx.common.issues);
                }
            }
            if (dirty) {
                ctx.common.issues.push(...dirty.ctx.common.issues);
                return dirty.result;
            }
            const unionErrors = issues.map((issues) => new ZodError(issues));
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_union,
                unionErrors,
            });
            return INVALID;
        }
    }
    get options() {
        return this._def.options;
    }
}
ZodUnion.create = (types, params) => {
    return new ZodUnion({
        options: types,
        typeName: ZodFirstPartyTypeKind.ZodUnion,
        ...processCreateParams$1(params),
    });
};
const getDiscriminator = (type) => {
    if (type instanceof ZodLazy) {
        return getDiscriminator(type.schema);
    }
    else if (type instanceof ZodEffects) {
        return getDiscriminator(type.innerType());
    }
    else if (type instanceof ZodLiteral) {
        return [type.value];
    }
    else if (type instanceof ZodEnum) {
        return type.options;
    }
    else if (type instanceof ZodNativeEnum) {
        return util$4.objectValues(type.enum);
    }
    else if (type instanceof ZodDefault) {
        return getDiscriminator(type._def.innerType);
    }
    else if (type instanceof ZodUndefined) {
        return [undefined];
    }
    else if (type instanceof ZodNull) {
        return [null];
    }
    else if (type instanceof ZodOptional) {
        return [undefined, ...getDiscriminator(type.unwrap())];
    }
    else if (type instanceof ZodNullable) {
        return [null, ...getDiscriminator(type.unwrap())];
    }
    else if (type instanceof ZodBranded) {
        return getDiscriminator(type.unwrap());
    }
    else if (type instanceof ZodReadonly) {
        return getDiscriminator(type.unwrap());
    }
    else if (type instanceof ZodCatch) {
        return getDiscriminator(type._def.innerType);
    }
    else {
        return [];
    }
};
class ZodDiscriminatedUnion extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.object,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const discriminator = this.discriminator;
        const discriminatorValue = ctx.data[discriminator];
        const option = this.optionsMap.get(discriminatorValue);
        if (!option) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_union_discriminator,
                options: Array.from(this.optionsMap.keys()),
                path: [discriminator],
            });
            return INVALID;
        }
        if (ctx.common.async) {
            return option._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            });
        }
        else {
            return option._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            });
        }
    }
    get discriminator() {
        return this._def.discriminator;
    }
    get options() {
        return this._def.options;
    }
    get optionsMap() {
        return this._def.optionsMap;
    }
    static create(discriminator, options, params) {
        const optionsMap = new Map();
        for (const type of options) {
            const discriminatorValues = getDiscriminator(type.shape[discriminator]);
            if (!discriminatorValues.length) {
                throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
            }
            for (const value of discriminatorValues) {
                if (optionsMap.has(value)) {
                    throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
                }
                optionsMap.set(value, type);
            }
        }
        return new ZodDiscriminatedUnion({
            typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
            discriminator,
            options,
            optionsMap,
            ...processCreateParams$1(params),
        });
    }
}
function mergeValues(a, b) {
    const aType = getParsedType(a);
    const bType = getParsedType(b);
    if (a === b) {
        return { valid: true, data: a };
    }
    else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
        const bKeys = util$4.objectKeys(b);
        const sharedKeys = util$4.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
        const newObj = { ...a, ...b };
        for (const key of sharedKeys) {
            const sharedValue = mergeValues(a[key], b[key]);
            if (!sharedValue.valid) {
                return { valid: false };
            }
            newObj[key] = sharedValue.data;
        }
        return { valid: true, data: newObj };
    }
    else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
        if (a.length !== b.length) {
            return { valid: false };
        }
        const newArray = [];
        for (let index = 0; index < a.length; index++) {
            const itemA = a[index];
            const itemB = b[index];
            const sharedValue = mergeValues(itemA, itemB);
            if (!sharedValue.valid) {
                return { valid: false };
            }
            newArray.push(sharedValue.data);
        }
        return { valid: true, data: newArray };
    }
    else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
        return { valid: true, data: a };
    }
    else {
        return { valid: false };
    }
}
class ZodIntersection extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const handleParsed = (parsedLeft, parsedRight) => {
            if (isAborted(parsedLeft) || isAborted(parsedRight)) {
                return INVALID;
            }
            const merged = mergeValues(parsedLeft.value, parsedRight.value);
            if (!merged.valid) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_intersection_types,
                });
                return INVALID;
            }
            if (isDirty(parsedLeft) || isDirty(parsedRight)) {
                status.dirty();
            }
            return { status: status.value, value: merged.data };
        };
        if (ctx.common.async) {
            return Promise.all([
                this._def.left._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                }),
                this._def.right._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                }),
            ]).then(([left, right]) => handleParsed(left, right));
        }
        else {
            return handleParsed(this._def.left._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            }), this._def.right._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            }));
        }
    }
}
ZodIntersection.create = (left, right, params) => {
    return new ZodIntersection({
        left: left,
        right: right,
        typeName: ZodFirstPartyTypeKind.ZodIntersection,
        ...processCreateParams$1(params),
    });
};
class ZodTuple extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.array) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.array,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        if (ctx.data.length < this._def.items.length) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: this._def.items.length,
                inclusive: true,
                exact: false,
                type: "array",
            });
            return INVALID;
        }
        const rest = this._def.rest;
        if (!rest && ctx.data.length > this._def.items.length) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: this._def.items.length,
                inclusive: true,
                exact: false,
                type: "array",
            });
            status.dirty();
        }
        const items = [...ctx.data]
            .map((item, itemIndex) => {
            const schema = this._def.items[itemIndex] || this._def.rest;
            if (!schema)
                return null;
            return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
        })
            .filter((x) => !!x);
        if (ctx.common.async) {
            return Promise.all(items).then((results) => {
                return ParseStatus.mergeArray(status, results);
            });
        }
        else {
            return ParseStatus.mergeArray(status, items);
        }
    }
    get items() {
        return this._def.items;
    }
    rest(rest) {
        return new ZodTuple({
            ...this._def,
            rest,
        });
    }
}
ZodTuple.create = (schemas, params) => {
    if (!Array.isArray(schemas)) {
        throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    }
    return new ZodTuple({
        items: schemas,
        typeName: ZodFirstPartyTypeKind.ZodTuple,
        rest: null,
        ...processCreateParams$1(params),
    });
};
class ZodRecord extends ZodType {
    get keySchema() {
        return this._def.keyType;
    }
    get valueSchema() {
        return this._def.valueType;
    }
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.object,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const pairs = [];
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        for (const key in ctx.data) {
            pairs.push({
                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
                value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
                alwaysSet: key in ctx.data,
            });
        }
        if (ctx.common.async) {
            return ParseStatus.mergeObjectAsync(status, pairs);
        }
        else {
            return ParseStatus.mergeObjectSync(status, pairs);
        }
    }
    get element() {
        return this._def.valueType;
    }
    static create(first, second, third) {
        if (second instanceof ZodType) {
            return new ZodRecord({
                keyType: first,
                valueType: second,
                typeName: ZodFirstPartyTypeKind.ZodRecord,
                ...processCreateParams$1(third),
            });
        }
        return new ZodRecord({
            keyType: ZodString.create(),
            valueType: first,
            typeName: ZodFirstPartyTypeKind.ZodRecord,
            ...processCreateParams$1(second),
        });
    }
}
class ZodMap extends ZodType {
    get keySchema() {
        return this._def.keyType;
    }
    get valueSchema() {
        return this._def.valueType;
    }
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.map) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.map,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        const pairs = [...ctx.data.entries()].map(([key, value], index) => {
            return {
                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
                value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"])),
            };
        });
        if (ctx.common.async) {
            const finalMap = new Map();
            return Promise.resolve().then(async () => {
                for (const pair of pairs) {
                    const key = await pair.key;
                    const value = await pair.value;
                    if (key.status === "aborted" || value.status === "aborted") {
                        return INVALID;
                    }
                    if (key.status === "dirty" || value.status === "dirty") {
                        status.dirty();
                    }
                    finalMap.set(key.value, value.value);
                }
                return { status: status.value, value: finalMap };
            });
        }
        else {
            const finalMap = new Map();
            for (const pair of pairs) {
                const key = pair.key;
                const value = pair.value;
                if (key.status === "aborted" || value.status === "aborted") {
                    return INVALID;
                }
                if (key.status === "dirty" || value.status === "dirty") {
                    status.dirty();
                }
                finalMap.set(key.value, value.value);
            }
            return { status: status.value, value: finalMap };
        }
    }
}
ZodMap.create = (keyType, valueType, params) => {
    return new ZodMap({
        valueType,
        keyType,
        typeName: ZodFirstPartyTypeKind.ZodMap,
        ...processCreateParams$1(params),
    });
};
class ZodSet extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.set) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.set,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const def = this._def;
        if (def.minSize !== null) {
            if (ctx.data.size < def.minSize.value) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_small,
                    minimum: def.minSize.value,
                    type: "set",
                    inclusive: true,
                    exact: false,
                    message: def.minSize.message,
                });
                status.dirty();
            }
        }
        if (def.maxSize !== null) {
            if (ctx.data.size > def.maxSize.value) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_big,
                    maximum: def.maxSize.value,
                    type: "set",
                    inclusive: true,
                    exact: false,
                    message: def.maxSize.message,
                });
                status.dirty();
            }
        }
        const valueType = this._def.valueType;
        function finalizeSet(elements) {
            const parsedSet = new Set();
            for (const element of elements) {
                if (element.status === "aborted")
                    return INVALID;
                if (element.status === "dirty")
                    status.dirty();
                parsedSet.add(element.value);
            }
            return { status: status.value, value: parsedSet };
        }
        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
        if (ctx.common.async) {
            return Promise.all(elements).then((elements) => finalizeSet(elements));
        }
        else {
            return finalizeSet(elements);
        }
    }
    min(minSize, message) {
        return new ZodSet({
            ...this._def,
            minSize: { value: minSize, message: errorUtil.toString(message) },
        });
    }
    max(maxSize, message) {
        return new ZodSet({
            ...this._def,
            maxSize: { value: maxSize, message: errorUtil.toString(message) },
        });
    }
    size(size, message) {
        return this.min(size, message).max(size, message);
    }
    nonempty(message) {
        return this.min(1, message);
    }
}
ZodSet.create = (valueType, params) => {
    return new ZodSet({
        valueType,
        minSize: null,
        maxSize: null,
        typeName: ZodFirstPartyTypeKind.ZodSet,
        ...processCreateParams$1(params),
    });
};
class ZodFunction extends ZodType {
    constructor() {
        super(...arguments);
        this.validate = this.implement;
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.function) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.function,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        function makeArgsIssue(args, error) {
            return makeIssue({
                data: args,
                path: ctx.path,
                errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), errorMap].filter((x) => !!x),
                issueData: {
                    code: ZodIssueCode.invalid_arguments,
                    argumentsError: error,
                },
            });
        }
        function makeReturnsIssue(returns, error) {
            return makeIssue({
                data: returns,
                path: ctx.path,
                errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), errorMap].filter((x) => !!x),
                issueData: {
                    code: ZodIssueCode.invalid_return_type,
                    returnTypeError: error,
                },
            });
        }
        const params = { errorMap: ctx.common.contextualErrorMap };
        const fn = ctx.data;
        if (this._def.returns instanceof ZodPromise) {
            const me = this;
            return OK(async function (...args) {
                const error = new ZodError([]);
                const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
                    error.addIssue(makeArgsIssue(args, e));
                    throw error;
                });
                const result = await Reflect.apply(fn, this, parsedArgs);
                const parsedReturns = await me._def.returns._def.type
                    .parseAsync(result, params)
                    .catch((e) => {
                    error.addIssue(makeReturnsIssue(result, e));
                    throw error;
                });
                return parsedReturns;
            });
        }
        else {
            const me = this;
            return OK(function (...args) {
                const parsedArgs = me._def.args.safeParse(args, params);
                if (!parsedArgs.success) {
                    throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
                }
                const result = Reflect.apply(fn, this, parsedArgs.data);
                const parsedReturns = me._def.returns.safeParse(result, params);
                if (!parsedReturns.success) {
                    throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
                }
                return parsedReturns.data;
            });
        }
    }
    parameters() {
        return this._def.args;
    }
    returnType() {
        return this._def.returns;
    }
    args(...items) {
        return new ZodFunction({
            ...this._def,
            args: ZodTuple.create(items).rest(ZodUnknown.create()),
        });
    }
    returns(returnType) {
        return new ZodFunction({
            ...this._def,
            returns: returnType,
        });
    }
    implement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
    }
    strictImplement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
    }
    static create(args, returns, params) {
        return new ZodFunction({
            args: (args ? args : ZodTuple.create([]).rest(ZodUnknown.create())),
            returns: returns || ZodUnknown.create(),
            typeName: ZodFirstPartyTypeKind.ZodFunction,
            ...processCreateParams$1(params),
        });
    }
}
class ZodLazy extends ZodType {
    get schema() {
        return this._def.getter();
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const lazySchema = this._def.getter();
        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
    }
}
ZodLazy.create = (getter, params) => {
    return new ZodLazy({
        getter: getter,
        typeName: ZodFirstPartyTypeKind.ZodLazy,
        ...processCreateParams$1(params),
    });
};
class ZodLiteral extends ZodType {
    _parse(input) {
        if (input.data !== this._def.value) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                received: ctx.data,
                code: ZodIssueCode.invalid_literal,
                expected: this._def.value,
            });
            return INVALID;
        }
        return { status: "valid", value: input.data };
    }
    get value() {
        return this._def.value;
    }
}
ZodLiteral.create = (value, params) => {
    return new ZodLiteral({
        value: value,
        typeName: ZodFirstPartyTypeKind.ZodLiteral,
        ...processCreateParams$1(params),
    });
};
function createZodEnum(values, params) {
    return new ZodEnum({
        values,
        typeName: ZodFirstPartyTypeKind.ZodEnum,
        ...processCreateParams$1(params),
    });
}
class ZodEnum extends ZodType {
    _parse(input) {
        if (typeof input.data !== "string") {
            const ctx = this._getOrReturnCtx(input);
            const expectedValues = this._def.values;
            addIssueToContext(ctx, {
                expected: util$4.joinValues(expectedValues),
                received: ctx.parsedType,
                code: ZodIssueCode.invalid_type,
            });
            return INVALID;
        }
        if (!this._cache) {
            this._cache = new Set(this._def.values);
        }
        if (!this._cache.has(input.data)) {
            const ctx = this._getOrReturnCtx(input);
            const expectedValues = this._def.values;
            addIssueToContext(ctx, {
                received: ctx.data,
                code: ZodIssueCode.invalid_enum_value,
                options: expectedValues,
            });
            return INVALID;
        }
        return OK(input.data);
    }
    get options() {
        return this._def.values;
    }
    get enum() {
        const enumValues = {};
        for (const val of this._def.values) {
            enumValues[val] = val;
        }
        return enumValues;
    }
    get Values() {
        const enumValues = {};
        for (const val of this._def.values) {
            enumValues[val] = val;
        }
        return enumValues;
    }
    get Enum() {
        const enumValues = {};
        for (const val of this._def.values) {
            enumValues[val] = val;
        }
        return enumValues;
    }
    extract(values, newDef = this._def) {
        return ZodEnum.create(values, {
            ...this._def,
            ...newDef,
        });
    }
    exclude(values, newDef = this._def) {
        return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
            ...this._def,
            ...newDef,
        });
    }
}
ZodEnum.create = createZodEnum;
class ZodNativeEnum extends ZodType {
    _parse(input) {
        const nativeEnumValues = util$4.getValidEnumValues(this._def.values);
        const ctx = this._getOrReturnCtx(input);
        if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
            const expectedValues = util$4.objectValues(nativeEnumValues);
            addIssueToContext(ctx, {
                expected: util$4.joinValues(expectedValues),
                received: ctx.parsedType,
                code: ZodIssueCode.invalid_type,
            });
            return INVALID;
        }
        if (!this._cache) {
            this._cache = new Set(util$4.getValidEnumValues(this._def.values));
        }
        if (!this._cache.has(input.data)) {
            const expectedValues = util$4.objectValues(nativeEnumValues);
            addIssueToContext(ctx, {
                received: ctx.data,
                code: ZodIssueCode.invalid_enum_value,
                options: expectedValues,
            });
            return INVALID;
        }
        return OK(input.data);
    }
    get enum() {
        return this._def.values;
    }
}
ZodNativeEnum.create = (values, params) => {
    return new ZodNativeEnum({
        values: values,
        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
        ...processCreateParams$1(params),
    });
};
class ZodPromise extends ZodType {
    unwrap() {
        return this._def.type;
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.promise,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
        return OK(promisified.then((data) => {
            return this._def.type.parseAsync(data, {
                path: ctx.path,
                errorMap: ctx.common.contextualErrorMap,
            });
        }));
    }
}
ZodPromise.create = (schema, params) => {
    return new ZodPromise({
        type: schema,
        typeName: ZodFirstPartyTypeKind.ZodPromise,
        ...processCreateParams$1(params),
    });
};
class ZodEffects extends ZodType {
    innerType() {
        return this._def.schema;
    }
    sourceType() {
        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects
            ? this._def.schema.sourceType()
            : this._def.schema;
    }
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const effect = this._def.effect || null;
        const checkCtx = {
            addIssue: (arg) => {
                addIssueToContext(ctx, arg);
                if (arg.fatal) {
                    status.abort();
                }
                else {
                    status.dirty();
                }
            },
            get path() {
                return ctx.path;
            },
        };
        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
        if (effect.type === "preprocess") {
            const processed = effect.transform(ctx.data, checkCtx);
            if (ctx.common.async) {
                return Promise.resolve(processed).then(async (processed) => {
                    if (status.value === "aborted")
                        return INVALID;
                    const result = await this._def.schema._parseAsync({
                        data: processed,
                        path: ctx.path,
                        parent: ctx,
                    });
                    if (result.status === "aborted")
                        return INVALID;
                    if (result.status === "dirty")
                        return DIRTY(result.value);
                    if (status.value === "dirty")
                        return DIRTY(result.value);
                    return result;
                });
            }
            else {
                if (status.value === "aborted")
                    return INVALID;
                const result = this._def.schema._parseSync({
                    data: processed,
                    path: ctx.path,
                    parent: ctx,
                });
                if (result.status === "aborted")
                    return INVALID;
                if (result.status === "dirty")
                    return DIRTY(result.value);
                if (status.value === "dirty")
                    return DIRTY(result.value);
                return result;
            }
        }
        if (effect.type === "refinement") {
            const executeRefinement = (acc) => {
                const result = effect.refinement(acc, checkCtx);
                if (ctx.common.async) {
                    return Promise.resolve(result);
                }
                if (result instanceof Promise) {
                    throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
                }
                return acc;
            };
            if (ctx.common.async === false) {
                const inner = this._def.schema._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                });
                if (inner.status === "aborted")
                    return INVALID;
                if (inner.status === "dirty")
                    status.dirty();
                executeRefinement(inner.value);
                return { status: status.value, value: inner.value };
            }
            else {
                return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
                    if (inner.status === "aborted")
                        return INVALID;
                    if (inner.status === "dirty")
                        status.dirty();
                    return executeRefinement(inner.value).then(() => {
                        return { status: status.value, value: inner.value };
                    });
                });
            }
        }
        if (effect.type === "transform") {
            if (ctx.common.async === false) {
                const base = this._def.schema._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                });
                if (!isValid(base))
                    return INVALID;
                const result = effect.transform(base.value, checkCtx);
                if (result instanceof Promise) {
                    throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
                }
                return { status: status.value, value: result };
            }
            else {
                return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
                    if (!isValid(base))
                        return INVALID;
                    return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
                        status: status.value,
                        value: result,
                    }));
                });
            }
        }
        util$4.assertNever(effect);
    }
}
ZodEffects.create = (schema, effect, params) => {
    return new ZodEffects({
        schema,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect,
        ...processCreateParams$1(params),
    });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
    return new ZodEffects({
        schema,
        effect: { type: "preprocess", transform: preprocess },
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        ...processCreateParams$1(params),
    });
};
class ZodOptional extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.undefined) {
            return OK(undefined);
        }
        return this._def.innerType._parse(input);
    }
    unwrap() {
        return this._def.innerType;
    }
}
ZodOptional.create = (type, params) => {
    return new ZodOptional({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodOptional,
        ...processCreateParams$1(params),
    });
};
class ZodNullable extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.null) {
            return OK(null);
        }
        return this._def.innerType._parse(input);
    }
    unwrap() {
        return this._def.innerType;
    }
}
ZodNullable.create = (type, params) => {
    return new ZodNullable({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodNullable,
        ...processCreateParams$1(params),
    });
};
class ZodDefault extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        let data = ctx.data;
        if (ctx.parsedType === ZodParsedType.undefined) {
            data = this._def.defaultValue();
        }
        return this._def.innerType._parse({
            data,
            path: ctx.path,
            parent: ctx,
        });
    }
    removeDefault() {
        return this._def.innerType;
    }
}
ZodDefault.create = (type, params) => {
    return new ZodDefault({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodDefault,
        defaultValue: typeof params.default === "function" ? params.default : () => params.default,
        ...processCreateParams$1(params),
    });
};
class ZodCatch extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const newCtx = {
            ...ctx,
            common: {
                ...ctx.common,
                issues: [],
            },
        };
        const result = this._def.innerType._parse({
            data: newCtx.data,
            path: newCtx.path,
            parent: {
                ...newCtx,
            },
        });
        if (isAsync(result)) {
            return result.then((result) => {
                return {
                    status: "valid",
                    value: result.status === "valid"
                        ? result.value
                        : this._def.catchValue({
                            get error() {
                                return new ZodError(newCtx.common.issues);
                            },
                            input: newCtx.data,
                        }),
                };
            });
        }
        else {
            return {
                status: "valid",
                value: result.status === "valid"
                    ? result.value
                    : this._def.catchValue({
                        get error() {
                            return new ZodError(newCtx.common.issues);
                        },
                        input: newCtx.data,
                    }),
            };
        }
    }
    removeCatch() {
        return this._def.innerType;
    }
}
ZodCatch.create = (type, params) => {
    return new ZodCatch({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodCatch,
        catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
        ...processCreateParams$1(params),
    });
};
class ZodNaN extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.nan) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.nan,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return { status: "valid", value: input.data };
    }
}
ZodNaN.create = (params) => {
    return new ZodNaN({
        typeName: ZodFirstPartyTypeKind.ZodNaN,
        ...processCreateParams$1(params),
    });
};
const BRAND = Symbol("zod_brand");
class ZodBranded extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const data = ctx.data;
        return this._def.type._parse({
            data,
            path: ctx.path,
            parent: ctx,
        });
    }
    unwrap() {
        return this._def.type;
    }
}
class ZodPipeline extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.common.async) {
            const handleAsync = async () => {
                const inResult = await this._def.in._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                });
                if (inResult.status === "aborted")
                    return INVALID;
                if (inResult.status === "dirty") {
                    status.dirty();
                    return DIRTY(inResult.value);
                }
                else {
                    return this._def.out._parseAsync({
                        data: inResult.value,
                        path: ctx.path,
                        parent: ctx,
                    });
                }
            };
            return handleAsync();
        }
        else {
            const inResult = this._def.in._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            });
            if (inResult.status === "aborted")
                return INVALID;
            if (inResult.status === "dirty") {
                status.dirty();
                return {
                    status: "dirty",
                    value: inResult.value,
                };
            }
            else {
                return this._def.out._parseSync({
                    data: inResult.value,
                    path: ctx.path,
                    parent: ctx,
                });
            }
        }
    }
    static create(a, b) {
        return new ZodPipeline({
            in: a,
            out: b,
            typeName: ZodFirstPartyTypeKind.ZodPipeline,
        });
    }
}
class ZodReadonly extends ZodType {
    _parse(input) {
        const result = this._def.innerType._parse(input);
        const freeze = (data) => {
            if (isValid(data)) {
                data.value = Object.freeze(data.value);
            }
            return data;
        };
        return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
    }
    unwrap() {
        return this._def.innerType;
    }
}
ZodReadonly.create = (type, params) => {
    return new ZodReadonly({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodReadonly,
        ...processCreateParams$1(params),
    });
};
function cleanParams(params, data) {
    const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
    const p2 = typeof p === "string" ? { message: p } : p;
    return p2;
}
function custom$1(check, _params = {},
fatal) {
    if (check)
        return ZodAny.create().superRefine((data, ctx) => {
            const r = check(data);
            if (r instanceof Promise) {
                return r.then((r) => {
                    if (!r) {
                        const params = cleanParams(_params, data);
                        const _fatal = params.fatal ?? fatal ?? true;
                        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
                    }
                });
            }
            if (!r) {
                const params = cleanParams(_params, data);
                const _fatal = params.fatal ?? fatal ?? true;
                ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
            }
            return;
        });
    return ZodAny.create();
}
const late = {
    object: ZodObject.lazycreate,
};
var ZodFirstPartyTypeKind;
(function (ZodFirstPartyTypeKind) {
    ZodFirstPartyTypeKind["ZodString"] = "ZodString";
    ZodFirstPartyTypeKind["ZodNumber"] = "ZodNumber";
    ZodFirstPartyTypeKind["ZodNaN"] = "ZodNaN";
    ZodFirstPartyTypeKind["ZodBigInt"] = "ZodBigInt";
    ZodFirstPartyTypeKind["ZodBoolean"] = "ZodBoolean";
    ZodFirstPartyTypeKind["ZodDate"] = "ZodDate";
    ZodFirstPartyTypeKind["ZodSymbol"] = "ZodSymbol";
    ZodFirstPartyTypeKind["ZodUndefined"] = "ZodUndefined";
    ZodFirstPartyTypeKind["ZodNull"] = "ZodNull";
    ZodFirstPartyTypeKind["ZodAny"] = "ZodAny";
    ZodFirstPartyTypeKind["ZodUnknown"] = "ZodUnknown";
    ZodFirstPartyTypeKind["ZodNever"] = "ZodNever";
    ZodFirstPartyTypeKind["ZodVoid"] = "ZodVoid";
    ZodFirstPartyTypeKind["ZodArray"] = "ZodArray";
    ZodFirstPartyTypeKind["ZodObject"] = "ZodObject";
    ZodFirstPartyTypeKind["ZodUnion"] = "ZodUnion";
    ZodFirstPartyTypeKind["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
    ZodFirstPartyTypeKind["ZodIntersection"] = "ZodIntersection";
    ZodFirstPartyTypeKind["ZodTuple"] = "ZodTuple";
    ZodFirstPartyTypeKind["ZodRecord"] = "ZodRecord";
    ZodFirstPartyTypeKind["ZodMap"] = "ZodMap";
    ZodFirstPartyTypeKind["ZodSet"] = "ZodSet";
    ZodFirstPartyTypeKind["ZodFunction"] = "ZodFunction";
    ZodFirstPartyTypeKind["ZodLazy"] = "ZodLazy";
    ZodFirstPartyTypeKind["ZodLiteral"] = "ZodLiteral";
    ZodFirstPartyTypeKind["ZodEnum"] = "ZodEnum";
    ZodFirstPartyTypeKind["ZodEffects"] = "ZodEffects";
    ZodFirstPartyTypeKind["ZodNativeEnum"] = "ZodNativeEnum";
    ZodFirstPartyTypeKind["ZodOptional"] = "ZodOptional";
    ZodFirstPartyTypeKind["ZodNullable"] = "ZodNullable";
    ZodFirstPartyTypeKind["ZodDefault"] = "ZodDefault";
    ZodFirstPartyTypeKind["ZodCatch"] = "ZodCatch";
    ZodFirstPartyTypeKind["ZodPromise"] = "ZodPromise";
    ZodFirstPartyTypeKind["ZodBranded"] = "ZodBranded";
    ZodFirstPartyTypeKind["ZodPipeline"] = "ZodPipeline";
    ZodFirstPartyTypeKind["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
const instanceOfType = (
cls, params = {
    message: `Input not instance of ${cls.name}`,
}) => custom$1((data) => data instanceof cls, params);
const stringType = ZodString.create;
const numberType = ZodNumber.create;
const nanType = ZodNaN.create;
const bigIntType = ZodBigInt.create;
const booleanType = ZodBoolean.create;
const dateType = ZodDate.create;
const symbolType = ZodSymbol.create;
const undefinedType = ZodUndefined.create;
const nullType = ZodNull.create;
const anyType = ZodAny.create;
const unknownType = ZodUnknown.create;
const neverType = ZodNever.create;
const voidType = ZodVoid.create;
const arrayType = ZodArray.create;
const objectType = ZodObject.create;
const strictObjectType = ZodObject.strictCreate;
const unionType = ZodUnion.create;
const discriminatedUnionType = ZodDiscriminatedUnion.create;
const intersectionType = ZodIntersection.create;
const tupleType = ZodTuple.create;
const recordType = ZodRecord.create;
const mapType = ZodMap.create;
const setType = ZodSet.create;
const functionType = ZodFunction.create;
const lazyType = ZodLazy.create;
const literalType = ZodLiteral.create;
const enumType = ZodEnum.create;
const nativeEnumType = ZodNativeEnum.create;
const promiseType = ZodPromise.create;
const effectsType = ZodEffects.create;
const optionalType = ZodOptional.create;
const nullableType = ZodNullable.create;
const preprocessType = ZodEffects.createWithPreprocess;
const pipelineType = ZodPipeline.create;
const ostring = () => stringType().optional();
const onumber = () => numberType().optional();
const oboolean = () => booleanType().optional();
const coerce = {
    string: ((arg) => ZodString.create({ ...arg, coerce: true })),
    number: ((arg) => ZodNumber.create({ ...arg, coerce: true })),
    boolean: ((arg) => ZodBoolean.create({
        ...arg,
        coerce: true,
    })),
    bigint: ((arg) => ZodBigInt.create({ ...arg, coerce: true })),
    date: ((arg) => ZodDate.create({ ...arg, coerce: true })),
};
const NEVER$1 = INVALID;

var z = /*#__PURE__*/Object.freeze({
	__proto__: null,
	BRAND: BRAND,
	DIRTY: DIRTY,
	EMPTY_PATH: EMPTY_PATH,
	INVALID: INVALID,
	NEVER: NEVER$1,
	OK: OK,
	ParseStatus: ParseStatus,
	Schema: ZodType,
	ZodAny: ZodAny,
	ZodArray: ZodArray,
	ZodBigInt: ZodBigInt,
	ZodBoolean: ZodBoolean,
	ZodBranded: ZodBranded,
	ZodCatch: ZodCatch,
	ZodDate: ZodDate,
	ZodDefault: ZodDefault,
	ZodDiscriminatedUnion: ZodDiscriminatedUnion,
	ZodEffects: ZodEffects,
	ZodEnum: ZodEnum,
	ZodError: ZodError,
	get ZodFirstPartyTypeKind () { return ZodFirstPartyTypeKind; },
	ZodFunction: ZodFunction,
	ZodIntersection: ZodIntersection,
	ZodIssueCode: ZodIssueCode,
	ZodLazy: ZodLazy,
	ZodLiteral: ZodLiteral,
	ZodMap: ZodMap,
	ZodNaN: ZodNaN,
	ZodNativeEnum: ZodNativeEnum,
	ZodNever: ZodNever,
	ZodNull: ZodNull,
	ZodNullable: ZodNullable,
	ZodNumber: ZodNumber,
	ZodObject: ZodObject,
	ZodOptional: ZodOptional,
	ZodParsedType: ZodParsedType,
	ZodPipeline: ZodPipeline,
	ZodPromise: ZodPromise,
	ZodReadonly: ZodReadonly,
	ZodRecord: ZodRecord,
	ZodSchema: ZodType,
	ZodSet: ZodSet,
	ZodString: ZodString,
	ZodSymbol: ZodSymbol,
	ZodTransformer: ZodEffects,
	ZodTuple: ZodTuple,
	ZodType: ZodType,
	ZodUndefined: ZodUndefined,
	ZodUnion: ZodUnion,
	ZodUnknown: ZodUnknown,
	ZodVoid: ZodVoid,
	addIssueToContext: addIssueToContext,
	any: anyType,
	array: arrayType,
	bigint: bigIntType,
	boolean: booleanType,
	coerce: coerce,
	custom: custom$1,
	date: dateType,
	datetimeRegex: datetimeRegex,
	defaultErrorMap: errorMap,
	discriminatedUnion: discriminatedUnionType,
	effect: effectsType,
	enum: enumType,
	function: functionType,
	getErrorMap: getErrorMap,
	getParsedType: getParsedType,
	instanceof: instanceOfType,
	intersection: intersectionType,
	isAborted: isAborted,
	isAsync: isAsync,
	isDirty: isDirty,
	isValid: isValid,
	late: late,
	lazy: lazyType,
	literal: literalType,
	makeIssue: makeIssue,
	map: mapType,
	nan: nanType,
	nativeEnum: nativeEnumType,
	never: neverType,
	null: nullType,
	nullable: nullableType,
	number: numberType,
	object: objectType,
	get objectUtil () { return objectUtil; },
	oboolean: oboolean,
	onumber: onumber,
	optional: optionalType,
	ostring: ostring,
	pipeline: pipelineType,
	preprocess: preprocessType,
	promise: promiseType,
	quotelessJson: quotelessJson,
	record: recordType,
	set: setType,
	setErrorMap: setErrorMap,
	strictObject: strictObjectType,
	string: stringType,
	symbol: symbolType,
	transformer: effectsType,
	tuple: tupleType,
	undefined: undefinedType,
	union: unionType,
	unknown: unknownType,
	get util () { return util$4; },
	void: voidType
});

const LATEST_PROTOCOL_VERSION = '2025-06-18';
const SUPPORTED_PROTOCOL_VERSIONS = [LATEST_PROTOCOL_VERSION, '2025-03-26', '2024-11-05', '2024-10-07'];
const JSONRPC_VERSION = '2.0';
const ProgressTokenSchema = unionType([stringType(), numberType().int()]);
const CursorSchema = stringType();
const RequestMetaSchema = objectType({
    progressToken: optionalType(ProgressTokenSchema)
})
    .passthrough();
const BaseRequestParamsSchema = objectType({
    _meta: optionalType(RequestMetaSchema)
})
    .passthrough();
const RequestSchema = objectType({
    method: stringType(),
    params: optionalType(BaseRequestParamsSchema)
});
const BaseNotificationParamsSchema = objectType({
    _meta: optionalType(objectType({}).passthrough())
})
    .passthrough();
const NotificationSchema = objectType({
    method: stringType(),
    params: optionalType(BaseNotificationParamsSchema)
});
const ResultSchema = objectType({
    _meta: optionalType(objectType({}).passthrough())
})
    .passthrough();
const RequestIdSchema = unionType([stringType(), numberType().int()]);
const JSONRPCRequestSchema = objectType({
    jsonrpc: literalType(JSONRPC_VERSION),
    id: RequestIdSchema
})
    .merge(RequestSchema)
    .strict();
const isJSONRPCRequest = (value) => JSONRPCRequestSchema.safeParse(value).success;
const JSONRPCNotificationSchema = objectType({
    jsonrpc: literalType(JSONRPC_VERSION)
})
    .merge(NotificationSchema)
    .strict();
const isJSONRPCNotification = (value) => JSONRPCNotificationSchema.safeParse(value).success;
const JSONRPCResponseSchema = objectType({
    jsonrpc: literalType(JSONRPC_VERSION),
    id: RequestIdSchema,
    result: ResultSchema
})
    .strict();
const isJSONRPCResponse = (value) => JSONRPCResponseSchema.safeParse(value).success;
var ErrorCode;
(function (ErrorCode) {
    ErrorCode[ErrorCode["ConnectionClosed"] = -32e3] = "ConnectionClosed";
    ErrorCode[ErrorCode["RequestTimeout"] = -32001] = "RequestTimeout";
    ErrorCode[ErrorCode["ParseError"] = -32700] = "ParseError";
    ErrorCode[ErrorCode["InvalidRequest"] = -32600] = "InvalidRequest";
    ErrorCode[ErrorCode["MethodNotFound"] = -32601] = "MethodNotFound";
    ErrorCode[ErrorCode["InvalidParams"] = -32602] = "InvalidParams";
    ErrorCode[ErrorCode["InternalError"] = -32603] = "InternalError";
})(ErrorCode || (ErrorCode = {}));
const JSONRPCErrorSchema = objectType({
    jsonrpc: literalType(JSONRPC_VERSION),
    id: RequestIdSchema,
    error: objectType({
        code: numberType().int(),
        message: stringType(),
        data: optionalType(unknownType())
    })
})
    .strict();
const isJSONRPCError = (value) => JSONRPCErrorSchema.safeParse(value).success;
const JSONRPCMessageSchema = unionType([JSONRPCRequestSchema, JSONRPCNotificationSchema, JSONRPCResponseSchema, JSONRPCErrorSchema]);
const EmptyResultSchema = ResultSchema.strict();
const CancelledNotificationSchema = NotificationSchema.extend({
    method: literalType('notifications/cancelled'),
    params: BaseNotificationParamsSchema.extend({
        requestId: RequestIdSchema,
        reason: stringType().optional()
    })
});
const IconSchema = objectType({
    src: stringType(),
    mimeType: optionalType(stringType()),
    sizes: optionalType(arrayType(stringType()))
})
    .passthrough();
const IconsSchema = objectType({
    icons: arrayType(IconSchema).optional()
})
    .passthrough();
const BaseMetadataSchema = objectType({
    name: stringType(),
    title: optionalType(stringType())
})
    .passthrough();
const ImplementationSchema = BaseMetadataSchema.extend({
    version: stringType(),
    websiteUrl: optionalType(stringType())
}).merge(IconsSchema);
const ClientCapabilitiesSchema = objectType({
    experimental: optionalType(objectType({}).passthrough()),
    sampling: optionalType(objectType({}).passthrough()),
    elicitation: optionalType(objectType({}).passthrough()),
    roots: optionalType(objectType({
        listChanged: optionalType(booleanType())
    })
        .passthrough())
})
    .passthrough();
const InitializeRequestSchema = RequestSchema.extend({
    method: literalType('initialize'),
    params: BaseRequestParamsSchema.extend({
        protocolVersion: stringType(),
        capabilities: ClientCapabilitiesSchema,
        clientInfo: ImplementationSchema
    })
});
const ServerCapabilitiesSchema = objectType({
    experimental: optionalType(objectType({}).passthrough()),
    logging: optionalType(objectType({}).passthrough()),
    completions: optionalType(objectType({}).passthrough()),
    prompts: optionalType(objectType({
        listChanged: optionalType(booleanType())
    })
        .passthrough()),
    resources: optionalType(objectType({
        subscribe: optionalType(booleanType()),
        listChanged: optionalType(booleanType())
    })
        .passthrough()),
    tools: optionalType(objectType({
        listChanged: optionalType(booleanType())
    })
        .passthrough())
})
    .passthrough();
const InitializeResultSchema = ResultSchema.extend({
    protocolVersion: stringType(),
    capabilities: ServerCapabilitiesSchema,
    serverInfo: ImplementationSchema,
    instructions: optionalType(stringType())
});
const InitializedNotificationSchema = NotificationSchema.extend({
    method: literalType('notifications/initialized')
});
const PingRequestSchema = RequestSchema.extend({
    method: literalType('ping')
});
const ProgressSchema = objectType({
    progress: numberType(),
    total: optionalType(numberType()),
    message: optionalType(stringType())
})
    .passthrough();
const ProgressNotificationSchema = NotificationSchema.extend({
    method: literalType('notifications/progress'),
    params: BaseNotificationParamsSchema.merge(ProgressSchema).extend({
        progressToken: ProgressTokenSchema
    })
});
const PaginatedRequestSchema = RequestSchema.extend({
    params: BaseRequestParamsSchema.extend({
        cursor: optionalType(CursorSchema)
    }).optional()
});
const PaginatedResultSchema = ResultSchema.extend({
    nextCursor: optionalType(CursorSchema)
});
const ResourceContentsSchema = objectType({
    uri: stringType(),
    mimeType: optionalType(stringType()),
    _meta: optionalType(objectType({}).passthrough())
})
    .passthrough();
const TextResourceContentsSchema = ResourceContentsSchema.extend({
    text: stringType()
});
const Base64Schema = stringType().refine(val => {
    try {
        atob(val);
        return true;
    }
    catch (_a) {
        return false;
    }
}, { message: 'Invalid Base64 string' });
const BlobResourceContentsSchema = ResourceContentsSchema.extend({
    blob: Base64Schema
});
const ResourceSchema = BaseMetadataSchema.extend({
    uri: stringType(),
    description: optionalType(stringType()),
    mimeType: optionalType(stringType()),
    _meta: optionalType(objectType({}).passthrough())
}).merge(IconsSchema);
const ResourceTemplateSchema = BaseMetadataSchema.extend({
    uriTemplate: stringType(),
    description: optionalType(stringType()),
    mimeType: optionalType(stringType()),
    _meta: optionalType(objectType({}).passthrough())
}).merge(IconsSchema);
const ListResourcesRequestSchema = PaginatedRequestSchema.extend({
    method: literalType('resources/list')
});
const ListResourcesResultSchema = PaginatedResultSchema.extend({
    resources: arrayType(ResourceSchema)
});
const ListResourceTemplatesRequestSchema = PaginatedRequestSchema.extend({
    method: literalType('resources/templates/list')
});
const ListResourceTemplatesResultSchema = PaginatedResultSchema.extend({
    resourceTemplates: arrayType(ResourceTemplateSchema)
});
const ReadResourceRequestSchema = RequestSchema.extend({
    method: literalType('resources/read'),
    params: BaseRequestParamsSchema.extend({
        uri: stringType()
    })
});
const ReadResourceResultSchema = ResultSchema.extend({
    contents: arrayType(unionType([TextResourceContentsSchema, BlobResourceContentsSchema]))
});
const ResourceListChangedNotificationSchema = NotificationSchema.extend({
    method: literalType('notifications/resources/list_changed')
});
const SubscribeRequestSchema = RequestSchema.extend({
    method: literalType('resources/subscribe'),
    params: BaseRequestParamsSchema.extend({
        uri: stringType()
    })
});
const UnsubscribeRequestSchema = RequestSchema.extend({
    method: literalType('resources/unsubscribe'),
    params: BaseRequestParamsSchema.extend({
        uri: stringType()
    })
});
const ResourceUpdatedNotificationSchema = NotificationSchema.extend({
    method: literalType('notifications/resources/updated'),
    params: BaseNotificationParamsSchema.extend({
        uri: stringType()
    })
});
const PromptArgumentSchema = objectType({
    name: stringType(),
    description: optionalType(stringType()),
    required: optionalType(booleanType())
})
    .passthrough();
const PromptSchema = BaseMetadataSchema.extend({
    description: optionalType(stringType()),
    arguments: optionalType(arrayType(PromptArgumentSchema)),
    _meta: optionalType(objectType({}).passthrough())
}).merge(IconsSchema);
const ListPromptsRequestSchema = PaginatedRequestSchema.extend({
    method: literalType('prompts/list')
});
const ListPromptsResultSchema = PaginatedResultSchema.extend({
    prompts: arrayType(PromptSchema)
});
const GetPromptRequestSchema = RequestSchema.extend({
    method: literalType('prompts/get'),
    params: BaseRequestParamsSchema.extend({
        name: stringType(),
        arguments: optionalType(recordType(stringType()))
    })
});
const TextContentSchema = objectType({
    type: literalType('text'),
    text: stringType(),
    _meta: optionalType(objectType({}).passthrough())
})
    .passthrough();
const ImageContentSchema = objectType({
    type: literalType('image'),
    data: Base64Schema,
    mimeType: stringType(),
    _meta: optionalType(objectType({}).passthrough())
})
    .passthrough();
const AudioContentSchema = objectType({
    type: literalType('audio'),
    data: Base64Schema,
    mimeType: stringType(),
    _meta: optionalType(objectType({}).passthrough())
})
    .passthrough();
const EmbeddedResourceSchema = objectType({
    type: literalType('resource'),
    resource: unionType([TextResourceContentsSchema, BlobResourceContentsSchema]),
    _meta: optionalType(objectType({}).passthrough())
})
    .passthrough();
const ResourceLinkSchema = ResourceSchema.extend({
    type: literalType('resource_link')
});
const ContentBlockSchema = unionType([
    TextContentSchema,
    ImageContentSchema,
    AudioContentSchema,
    ResourceLinkSchema,
    EmbeddedResourceSchema
]);
const PromptMessageSchema = objectType({
    role: enumType(['user', 'assistant']),
    content: ContentBlockSchema
})
    .passthrough();
const GetPromptResultSchema = ResultSchema.extend({
    description: optionalType(stringType()),
    messages: arrayType(PromptMessageSchema)
});
const PromptListChangedNotificationSchema = NotificationSchema.extend({
    method: literalType('notifications/prompts/list_changed')
});
const ToolAnnotationsSchema = objectType({
    title: optionalType(stringType()),
    readOnlyHint: optionalType(booleanType()),
    destructiveHint: optionalType(booleanType()),
    idempotentHint: optionalType(booleanType()),
    openWorldHint: optionalType(booleanType())
})
    .passthrough();
const ToolSchema = BaseMetadataSchema.extend({
    description: optionalType(stringType()),
    inputSchema: objectType({
        type: literalType('object'),
        properties: optionalType(objectType({}).passthrough()),
        required: optionalType(arrayType(stringType()))
    })
        .passthrough(),
    outputSchema: optionalType(objectType({
        type: literalType('object'),
        properties: optionalType(objectType({}).passthrough()),
        required: optionalType(arrayType(stringType()))
    })
        .passthrough()),
    annotations: optionalType(ToolAnnotationsSchema),
    _meta: optionalType(objectType({}).passthrough())
}).merge(IconsSchema);
const ListToolsRequestSchema = PaginatedRequestSchema.extend({
    method: literalType('tools/list')
});
const ListToolsResultSchema = PaginatedResultSchema.extend({
    tools: arrayType(ToolSchema)
});
const CallToolResultSchema = ResultSchema.extend({
    content: arrayType(ContentBlockSchema).default([]),
    structuredContent: objectType({}).passthrough().optional(),
    isError: optionalType(booleanType())
});
CallToolResultSchema.or(ResultSchema.extend({
    toolResult: unknownType()
}));
const CallToolRequestSchema = RequestSchema.extend({
    method: literalType('tools/call'),
    params: BaseRequestParamsSchema.extend({
        name: stringType(),
        arguments: optionalType(recordType(unknownType()))
    })
});
const ToolListChangedNotificationSchema = NotificationSchema.extend({
    method: literalType('notifications/tools/list_changed')
});
const LoggingLevelSchema = enumType(['debug', 'info', 'notice', 'warning', 'error', 'critical', 'alert', 'emergency']);
const SetLevelRequestSchema = RequestSchema.extend({
    method: literalType('logging/setLevel'),
    params: BaseRequestParamsSchema.extend({
        level: LoggingLevelSchema
    })
});
const LoggingMessageNotificationSchema = NotificationSchema.extend({
    method: literalType('notifications/message'),
    params: BaseNotificationParamsSchema.extend({
        level: LoggingLevelSchema,
        logger: optionalType(stringType()),
        data: unknownType()
    })
});
const ModelHintSchema = objectType({
    name: stringType().optional()
})
    .passthrough();
const ModelPreferencesSchema = objectType({
    hints: optionalType(arrayType(ModelHintSchema)),
    costPriority: optionalType(numberType().min(0).max(1)),
    speedPriority: optionalType(numberType().min(0).max(1)),
    intelligencePriority: optionalType(numberType().min(0).max(1))
})
    .passthrough();
const SamplingMessageSchema = objectType({
    role: enumType(['user', 'assistant']),
    content: unionType([TextContentSchema, ImageContentSchema, AudioContentSchema])
})
    .passthrough();
const CreateMessageRequestSchema = RequestSchema.extend({
    method: literalType('sampling/createMessage'),
    params: BaseRequestParamsSchema.extend({
        messages: arrayType(SamplingMessageSchema),
        systemPrompt: optionalType(stringType()),
        includeContext: optionalType(enumType(['none', 'thisServer', 'allServers'])),
        temperature: optionalType(numberType()),
        maxTokens: numberType().int(),
        stopSequences: optionalType(arrayType(stringType())),
        metadata: optionalType(objectType({}).passthrough()),
        modelPreferences: optionalType(ModelPreferencesSchema)
    })
});
const CreateMessageResultSchema = ResultSchema.extend({
    model: stringType(),
    stopReason: optionalType(enumType(['endTurn', 'stopSequence', 'maxTokens']).or(stringType())),
    role: enumType(['user', 'assistant']),
    content: discriminatedUnionType('type', [TextContentSchema, ImageContentSchema, AudioContentSchema])
});
const BooleanSchemaSchema = objectType({
    type: literalType('boolean'),
    title: optionalType(stringType()),
    description: optionalType(stringType()),
    default: optionalType(booleanType())
})
    .passthrough();
const StringSchemaSchema = objectType({
    type: literalType('string'),
    title: optionalType(stringType()),
    description: optionalType(stringType()),
    minLength: optionalType(numberType()),
    maxLength: optionalType(numberType()),
    format: optionalType(enumType(['email', 'uri', 'date', 'date-time']))
})
    .passthrough();
const NumberSchemaSchema = objectType({
    type: enumType(['number', 'integer']),
    title: optionalType(stringType()),
    description: optionalType(stringType()),
    minimum: optionalType(numberType()),
    maximum: optionalType(numberType())
})
    .passthrough();
const EnumSchemaSchema = objectType({
    type: literalType('string'),
    title: optionalType(stringType()),
    description: optionalType(stringType()),
    enum: arrayType(stringType()),
    enumNames: optionalType(arrayType(stringType()))
})
    .passthrough();
const PrimitiveSchemaDefinitionSchema = unionType([BooleanSchemaSchema, StringSchemaSchema, NumberSchemaSchema, EnumSchemaSchema]);
const ElicitRequestSchema = RequestSchema.extend({
    method: literalType('elicitation/create'),
    params: BaseRequestParamsSchema.extend({
        message: stringType(),
        requestedSchema: objectType({
            type: literalType('object'),
            properties: recordType(stringType(), PrimitiveSchemaDefinitionSchema),
            required: optionalType(arrayType(stringType()))
        })
            .passthrough()
    })
});
const ElicitResultSchema = ResultSchema.extend({
    action: enumType(['accept', 'decline', 'cancel']),
    content: optionalType(recordType(stringType(), unknownType()))
});
const ResourceTemplateReferenceSchema = objectType({
    type: literalType('ref/resource'),
    uri: stringType()
})
    .passthrough();
const PromptReferenceSchema = objectType({
    type: literalType('ref/prompt'),
    name: stringType()
})
    .passthrough();
const CompleteRequestSchema = RequestSchema.extend({
    method: literalType('completion/complete'),
    params: BaseRequestParamsSchema.extend({
        ref: unionType([PromptReferenceSchema, ResourceTemplateReferenceSchema]),
        argument: objectType({
            name: stringType(),
            value: stringType()
        })
            .passthrough(),
        context: optionalType(objectType({
            arguments: optionalType(recordType(stringType(), stringType()))
        }))
    })
});
const CompleteResultSchema = ResultSchema.extend({
    completion: objectType({
        values: arrayType(stringType()).max(100),
        total: optionalType(numberType().int()),
        hasMore: optionalType(booleanType())
    })
        .passthrough()
});
const RootSchema = objectType({
    uri: stringType().startsWith('file://'),
    name: optionalType(stringType()),
    _meta: optionalType(objectType({}).passthrough())
})
    .passthrough();
const ListRootsRequestSchema = RequestSchema.extend({
    method: literalType('roots/list')
});
const ListRootsResultSchema = ResultSchema.extend({
    roots: arrayType(RootSchema)
});
const RootsListChangedNotificationSchema = NotificationSchema.extend({
    method: literalType('notifications/roots/list_changed')
});
unionType([
    PingRequestSchema,
    InitializeRequestSchema,
    CompleteRequestSchema,
    SetLevelRequestSchema,
    GetPromptRequestSchema,
    ListPromptsRequestSchema,
    ListResourcesRequestSchema,
    ListResourceTemplatesRequestSchema,
    ReadResourceRequestSchema,
    SubscribeRequestSchema,
    UnsubscribeRequestSchema,
    CallToolRequestSchema,
    ListToolsRequestSchema
]);
unionType([
    CancelledNotificationSchema,
    ProgressNotificationSchema,
    InitializedNotificationSchema,
    RootsListChangedNotificationSchema
]);
unionType([EmptyResultSchema, CreateMessageResultSchema, ElicitResultSchema, ListRootsResultSchema]);
unionType([PingRequestSchema, CreateMessageRequestSchema, ElicitRequestSchema, ListRootsRequestSchema]);
unionType([
    CancelledNotificationSchema,
    ProgressNotificationSchema,
    LoggingMessageNotificationSchema,
    ResourceUpdatedNotificationSchema,
    ResourceListChangedNotificationSchema,
    ToolListChangedNotificationSchema,
    PromptListChangedNotificationSchema
]);
unionType([
    EmptyResultSchema,
    InitializeResultSchema,
    CompleteResultSchema,
    GetPromptResultSchema,
    ListPromptsResultSchema,
    ListResourcesResultSchema,
    ListResourceTemplatesResultSchema,
    ReadResourceResultSchema,
    CallToolResultSchema,
    ListToolsResultSchema
]);
class McpError extends Error {
    constructor(code, message, data) {
        super(`MCP error ${code}: ${message}`);
        this.code = code;
        this.data = data;
        this.name = 'McpError';
    }
}

const DEFAULT_REQUEST_TIMEOUT_MSEC = 60000;
class Protocol {
    constructor(_options) {
        this._options = _options;
        this._requestMessageId = 0;
        this._requestHandlers = new Map();
        this._requestHandlerAbortControllers = new Map();
        this._notificationHandlers = new Map();
        this._responseHandlers = new Map();
        this._progressHandlers = new Map();
        this._timeoutInfo = new Map();
        this._pendingDebouncedNotifications = new Set();
        this.setNotificationHandler(CancelledNotificationSchema, notification => {
            const controller = this._requestHandlerAbortControllers.get(notification.params.requestId);
            controller === null || controller === void 0 ? void 0 : controller.abort(notification.params.reason);
        });
        this.setNotificationHandler(ProgressNotificationSchema, notification => {
            this._onprogress(notification);
        });
        this.setRequestHandler(PingRequestSchema,
        _request => ({}));
    }
    _setupTimeout(messageId, timeout, maxTotalTimeout, onTimeout, resetTimeoutOnProgress = false) {
        this._timeoutInfo.set(messageId, {
            timeoutId: setTimeout(onTimeout, timeout),
            startTime: Date.now(),
            timeout,
            maxTotalTimeout,
            resetTimeoutOnProgress,
            onTimeout
        });
    }
    _resetTimeout(messageId) {
        const info = this._timeoutInfo.get(messageId);
        if (!info)
            return false;
        const totalElapsed = Date.now() - info.startTime;
        if (info.maxTotalTimeout && totalElapsed >= info.maxTotalTimeout) {
            this._timeoutInfo.delete(messageId);
            throw new McpError(ErrorCode.RequestTimeout, 'Maximum total timeout exceeded', {
                maxTotalTimeout: info.maxTotalTimeout,
                totalElapsed
            });
        }
        clearTimeout(info.timeoutId);
        info.timeoutId = setTimeout(info.onTimeout, info.timeout);
        return true;
    }
    _cleanupTimeout(messageId) {
        const info = this._timeoutInfo.get(messageId);
        if (info) {
            clearTimeout(info.timeoutId);
            this._timeoutInfo.delete(messageId);
        }
    }
    async connect(transport) {
        var _a, _b, _c;
        this._transport = transport;
        const _onclose = (_a = this.transport) === null || _a === void 0 ? void 0 : _a.onclose;
        this._transport.onclose = () => {
            _onclose === null || _onclose === void 0 ? void 0 : _onclose();
            this._onclose();
        };
        const _onerror = (_b = this.transport) === null || _b === void 0 ? void 0 : _b.onerror;
        this._transport.onerror = (error) => {
            _onerror === null || _onerror === void 0 ? void 0 : _onerror(error);
            this._onerror(error);
        };
        const _onmessage = (_c = this._transport) === null || _c === void 0 ? void 0 : _c.onmessage;
        this._transport.onmessage = (message, extra) => {
            _onmessage === null || _onmessage === void 0 ? void 0 : _onmessage(message, extra);
            if (isJSONRPCResponse(message) || isJSONRPCError(message)) {
                this._onresponse(message);
            }
            else if (isJSONRPCRequest(message)) {
                this._onrequest(message, extra);
            }
            else if (isJSONRPCNotification(message)) {
                this._onnotification(message);
            }
            else {
                this._onerror(new Error(`Unknown message type: ${JSON.stringify(message)}`));
            }
        };
        await this._transport.start();
    }
    _onclose() {
        var _a;
        const responseHandlers = this._responseHandlers;
        this._responseHandlers = new Map();
        this._progressHandlers.clear();
        this._pendingDebouncedNotifications.clear();
        this._transport = undefined;
        (_a = this.onclose) === null || _a === void 0 ? void 0 : _a.call(this);
        const error = new McpError(ErrorCode.ConnectionClosed, 'Connection closed');
        for (const handler of responseHandlers.values()) {
            handler(error);
        }
    }
    _onerror(error) {
        var _a;
        (_a = this.onerror) === null || _a === void 0 ? void 0 : _a.call(this, error);
    }
    _onnotification(notification) {
        var _a;
        const handler = (_a = this._notificationHandlers.get(notification.method)) !== null && _a !== void 0 ? _a : this.fallbackNotificationHandler;
        if (handler === undefined) {
            return;
        }
        Promise.resolve()
            .then(() => handler(notification))
            .catch(error => this._onerror(new Error(`Uncaught error in notification handler: ${error}`)));
    }
    _onrequest(request, extra) {
        var _a, _b;
        const handler = (_a = this._requestHandlers.get(request.method)) !== null && _a !== void 0 ? _a : this.fallbackRequestHandler;
        const capturedTransport = this._transport;
        if (handler === undefined) {
            capturedTransport === null || capturedTransport === void 0 ? void 0 : capturedTransport.send({
                jsonrpc: '2.0',
                id: request.id,
                error: {
                    code: ErrorCode.MethodNotFound,
                    message: 'Method not found'
                }
            }).catch(error => this._onerror(new Error(`Failed to send an error response: ${error}`)));
            return;
        }
        const abortController = new AbortController();
        this._requestHandlerAbortControllers.set(request.id, abortController);
        const fullExtra = {
            signal: abortController.signal,
            sessionId: capturedTransport === null || capturedTransport === void 0 ? void 0 : capturedTransport.sessionId,
            _meta: (_b = request.params) === null || _b === void 0 ? void 0 : _b._meta,
            sendNotification: notification => this.notification(notification, { relatedRequestId: request.id }),
            sendRequest: (r, resultSchema, options) => this.request(r, resultSchema, { ...options, relatedRequestId: request.id }),
            authInfo: extra === null || extra === void 0 ? void 0 : extra.authInfo,
            requestId: request.id,
            requestInfo: extra === null || extra === void 0 ? void 0 : extra.requestInfo
        };
        Promise.resolve()
            .then(() => handler(request, fullExtra))
            .then(result => {
            if (abortController.signal.aborted) {
                return;
            }
            return capturedTransport === null || capturedTransport === void 0 ? void 0 : capturedTransport.send({
                result,
                jsonrpc: '2.0',
                id: request.id
            });
        }, error => {
            var _a;
            if (abortController.signal.aborted) {
                return;
            }
            return capturedTransport === null || capturedTransport === void 0 ? void 0 : capturedTransport.send({
                jsonrpc: '2.0',
                id: request.id,
                error: {
                    code: Number.isSafeInteger(error['code']) ? error['code'] : ErrorCode.InternalError,
                    message: (_a = error.message) !== null && _a !== void 0 ? _a : 'Internal error'
                }
            });
        })
            .catch(error => this._onerror(new Error(`Failed to send response: ${error}`)))
            .finally(() => {
            this._requestHandlerAbortControllers.delete(request.id);
        });
    }
    _onprogress(notification) {
        const { progressToken, ...params } = notification.params;
        const messageId = Number(progressToken);
        const handler = this._progressHandlers.get(messageId);
        if (!handler) {
            this._onerror(new Error(`Received a progress notification for an unknown token: ${JSON.stringify(notification)}`));
            return;
        }
        const responseHandler = this._responseHandlers.get(messageId);
        const timeoutInfo = this._timeoutInfo.get(messageId);
        if (timeoutInfo && responseHandler && timeoutInfo.resetTimeoutOnProgress) {
            try {
                this._resetTimeout(messageId);
            }
            catch (error) {
                responseHandler(error);
                return;
            }
        }
        handler(params);
    }
    _onresponse(response) {
        const messageId = Number(response.id);
        const handler = this._responseHandlers.get(messageId);
        if (handler === undefined) {
            this._onerror(new Error(`Received a response for an unknown message ID: ${JSON.stringify(response)}`));
            return;
        }
        this._responseHandlers.delete(messageId);
        this._progressHandlers.delete(messageId);
        this._cleanupTimeout(messageId);
        if (isJSONRPCResponse(response)) {
            handler(response);
        }
        else {
            const error = new McpError(response.error.code, response.error.message, response.error.data);
            handler(error);
        }
    }
    get transport() {
        return this._transport;
    }
    async close() {
        var _a;
        await ((_a = this._transport) === null || _a === void 0 ? void 0 : _a.close());
    }
    request(request, resultSchema, options) {
        const { relatedRequestId, resumptionToken, onresumptiontoken } = options !== null && options !== void 0 ? options : {};
        return new Promise((resolve, reject) => {
            var _a, _b, _c, _d, _e, _f;
            if (!this._transport) {
                reject(new Error('Not connected'));
                return;
            }
            if (((_a = this._options) === null || _a === void 0 ? void 0 : _a.enforceStrictCapabilities) === true) {
                this.assertCapabilityForMethod(request.method);
            }
            (_b = options === null || options === void 0 ? void 0 : options.signal) === null || _b === void 0 ? void 0 : _b.throwIfAborted();
            const messageId = this._requestMessageId++;
            const jsonrpcRequest = {
                ...request,
                jsonrpc: '2.0',
                id: messageId
            };
            if (options === null || options === void 0 ? void 0 : options.onprogress) {
                this._progressHandlers.set(messageId, options.onprogress);
                jsonrpcRequest.params = {
                    ...request.params,
                    _meta: {
                        ...(((_c = request.params) === null || _c === void 0 ? void 0 : _c._meta) || {}),
                        progressToken: messageId
                    }
                };
            }
            const cancel = (reason) => {
                var _a;
                this._responseHandlers.delete(messageId);
                this._progressHandlers.delete(messageId);
                this._cleanupTimeout(messageId);
                (_a = this._transport) === null || _a === void 0 ? void 0 : _a.send({
                    jsonrpc: '2.0',
                    method: 'notifications/cancelled',
                    params: {
                        requestId: messageId,
                        reason: String(reason)
                    }
                }, { relatedRequestId, resumptionToken, onresumptiontoken }).catch(error => this._onerror(new Error(`Failed to send cancellation: ${error}`)));
                reject(reason);
            };
            this._responseHandlers.set(messageId, response => {
                var _a;
                if ((_a = options === null || options === void 0 ? void 0 : options.signal) === null || _a === void 0 ? void 0 : _a.aborted) {
                    return;
                }
                if (response instanceof Error) {
                    return reject(response);
                }
                try {
                    const result = resultSchema.parse(response.result);
                    resolve(result);
                }
                catch (error) {
                    reject(error);
                }
            });
            (_d = options === null || options === void 0 ? void 0 : options.signal) === null || _d === void 0 ? void 0 : _d.addEventListener('abort', () => {
                var _a;
                cancel((_a = options === null || options === void 0 ? void 0 : options.signal) === null || _a === void 0 ? void 0 : _a.reason);
            });
            const timeout = (_e = options === null || options === void 0 ? void 0 : options.timeout) !== null && _e !== void 0 ? _e : DEFAULT_REQUEST_TIMEOUT_MSEC;
            const timeoutHandler = () => cancel(new McpError(ErrorCode.RequestTimeout, 'Request timed out', { timeout }));
            this._setupTimeout(messageId, timeout, options === null || options === void 0 ? void 0 : options.maxTotalTimeout, timeoutHandler, (_f = options === null || options === void 0 ? void 0 : options.resetTimeoutOnProgress) !== null && _f !== void 0 ? _f : false);
            this._transport.send(jsonrpcRequest, { relatedRequestId, resumptionToken, onresumptiontoken }).catch(error => {
                this._cleanupTimeout(messageId);
                reject(error);
            });
        });
    }
    async notification(notification, options) {
        var _a, _b;
        if (!this._transport) {
            throw new Error('Not connected');
        }
        this.assertNotificationCapability(notification.method);
        const debouncedMethods = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.debouncedNotificationMethods) !== null && _b !== void 0 ? _b : [];
        const canDebounce = debouncedMethods.includes(notification.method) && !notification.params && !(options === null || options === void 0 ? void 0 : options.relatedRequestId);
        if (canDebounce) {
            if (this._pendingDebouncedNotifications.has(notification.method)) {
                return;
            }
            this._pendingDebouncedNotifications.add(notification.method);
            Promise.resolve().then(() => {
                var _a;
                this._pendingDebouncedNotifications.delete(notification.method);
                if (!this._transport) {
                    return;
                }
                const jsonrpcNotification = {
                    ...notification,
                    jsonrpc: '2.0'
                };
                (_a = this._transport) === null || _a === void 0 ? void 0 : _a.send(jsonrpcNotification, options).catch(error => this._onerror(error));
            });
            return;
        }
        const jsonrpcNotification = {
            ...notification,
            jsonrpc: '2.0'
        };
        await this._transport.send(jsonrpcNotification, options);
    }
    setRequestHandler(requestSchema, handler) {
        const method = requestSchema.shape.method.value;
        this.assertRequestHandlerCapability(method);
        this._requestHandlers.set(method, (request, extra) => {
            return Promise.resolve(handler(requestSchema.parse(request), extra));
        });
    }
    removeRequestHandler(method) {
        this._requestHandlers.delete(method);
    }
    assertCanSetRequestHandler(method) {
        if (this._requestHandlers.has(method)) {
            throw new Error(`A request handler for ${method} already exists, which would be overridden`);
        }
    }
    setNotificationHandler(notificationSchema, handler) {
        this._notificationHandlers.set(notificationSchema.shape.method.value, notification => Promise.resolve(handler(notificationSchema.parse(notification))));
    }
    removeNotificationHandler(method) {
        this._notificationHandlers.delete(method);
    }
}
function mergeCapabilities(base, additional) {
    return Object.entries(additional).reduce((acc, [key, value]) => {
        if (value && typeof value === 'object') {
            acc[key] = acc[key] ? { ...acc[key], ...value } : value;
        }
        else {
            acc[key] = value;
        }
        return acc;
    }, { ...base });
}

var uri_all$1 = {exports: {}};

var uri_all = uri_all$1.exports;

var hasRequiredUri_all;

function requireUri_all () {
	if (hasRequiredUri_all) return uri_all$1.exports;
	hasRequiredUri_all = 1;
	(function (module, exports) {
		(function (global, factory) {
			factory(exports) ;
		}(uri_all, (function (exports) {		function merge() {
		    for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {
		        sets[_key] = arguments[_key];
		    }
		    if (sets.length > 1) {
		        sets[0] = sets[0].slice(0, -1);
		        var xl = sets.length - 1;
		        for (var x = 1; x < xl; ++x) {
		            sets[x] = sets[x].slice(1, -1);
		        }
		        sets[xl] = sets[xl].slice(1);
		        return sets.join('');
		    } else {
		        return sets[0];
		    }
		}
		function subexp(str) {
		    return "(?:" + str + ")";
		}
		function typeOf(o) {
		    return o === undefined ? "undefined" : o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
		}
		function toUpperCase(str) {
		    return str.toUpperCase();
		}
		function toArray(obj) {
		    return obj !== undefined && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];
		}
		function assign(target, source) {
		    var obj = target;
		    if (source) {
		        for (var key in source) {
		            obj[key] = source[key];
		        }
		    }
		    return obj;
		}
		function buildExps(isIRI) {
		    var ALPHA$$ = "[A-Za-z]",
		        DIGIT$$ = "[0-9]",
		        HEXDIG$$ = merge(DIGIT$$, "[A-Fa-f]"),
		    PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$)),
		    GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]",
		        SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]",
		        RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$),
		        UCSCHAR$$ = isIRI ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]",
		    IPRIVATE$$ = isIRI ? "[\\uE000-\\uF8FF]" : "[]",
		    UNRESERVED$$ = merge(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$);
		        subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*");
		        subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:]")) + "*");
		        var DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$),
		    IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$),
		        H16$ = subexp(HEXDIG$$ + "{1,4}"),
		        LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$),
		        IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$),
		    IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$),
		    IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$),
		    IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$),
		    IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$),
		    IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$),
		    IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$),
		    IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$),
		    IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"),
		    IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join("|")),
		        ZONEID$ = subexp(subexp(UNRESERVED$$ + "|" + PCT_ENCODED$) + "+");
		    subexp("[vV]" + HEXDIG$$ + "+\\." + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:]") + "+");
		        subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$)) + "*");
		        var PCHAR$ = subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@]"));
		        subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\@]")) + "+");
		        subexp(subexp(PCHAR$ + "|" + merge("[\\/\\?]", IPRIVATE$$)) + "*");
		    return {
		        NOT_SCHEME: new RegExp(merge("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
		        NOT_USERINFO: new RegExp(merge("[^\\%\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
		        NOT_HOST: new RegExp(merge("[^\\%\\[\\]\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
		        NOT_PATH: new RegExp(merge("[^\\%\\/\\:\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
		        NOT_PATH_NOSCHEME: new RegExp(merge("[^\\%\\/\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
		        NOT_QUERY: new RegExp(merge("[^\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
		        NOT_FRAGMENT: new RegExp(merge("[^\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
		        ESCAPE: new RegExp(merge("[^]", UNRESERVED$$, SUB_DELIMS$$), "g"),
		        UNRESERVED: new RegExp(UNRESERVED$$, "g"),
		        OTHER_CHARS: new RegExp(merge("[^\\%]", UNRESERVED$$, RESERVED$$), "g"),
		        PCT_ENCODED: new RegExp(PCT_ENCODED$, "g"),
		        IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
		        IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$ + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$")
		    };
		}
		var URI_PROTOCOL = buildExps(false);
		var IRI_PROTOCOL = buildExps(true);
		var slicedToArray = function () {
		  function sliceIterator(arr, i) {
		    var _arr = [];
		    var _n = true;
		    var _d = false;
		    var _e = undefined;
		    try {
		      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
		        _arr.push(_s.value);
		        if (i && _arr.length === i) break;
		      }
		    } catch (err) {
		      _d = true;
		      _e = err;
		    } finally {
		      try {
		        if (!_n && _i["return"]) _i["return"]();
		      } finally {
		        if (_d) throw _e;
		      }
		    }
		    return _arr;
		  }
		  return function (arr, i) {
		    if (Array.isArray(arr)) {
		      return arr;
		    } else if (Symbol.iterator in Object(arr)) {
		      return sliceIterator(arr, i);
		    } else {
		      throw new TypeError("Invalid attempt to destructure non-iterable instance");
		    }
		  };
		}();
		var toConsumableArray = function (arr) {
		  if (Array.isArray(arr)) {
		    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
		    return arr2;
		  } else {
		    return Array.from(arr);
		  }
		};
		var maxInt = 2147483647;
		var base = 36;
		var tMin = 1;
		var tMax = 26;
		var skew = 38;
		var damp = 700;
		var initialBias = 72;
		var initialN = 128;
		var delimiter = '-';
		var regexPunycode = /^xn--/;
		var regexNonASCII = /[^\0-\x7E]/;
		var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
		var errors = {
			'overflow': 'Overflow: input needs wider integers to process',
			'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
			'invalid-input': 'Invalid input'
		};
		var baseMinusTMin = base - tMin;
		var floor = Math.floor;
		var stringFromCharCode = String.fromCharCode;
		function error$1(type) {
			throw new RangeError(errors[type]);
		}
		function map(array, fn) {
			var result = [];
			var length = array.length;
			while (length--) {
				result[length] = fn(array[length]);
			}
			return result;
		}
		function mapDomain(string, fn) {
			var parts = string.split('@');
			var result = '';
			if (parts.length > 1) {
				result = parts[0] + '@';
				string = parts[1];
			}
			string = string.replace(regexSeparators, '\x2E');
			var labels = string.split('.');
			var encoded = map(labels, fn).join('.');
			return result + encoded;
		}
		function ucs2decode(string) {
			var output = [];
			var counter = 0;
			var length = string.length;
			while (counter < length) {
				var value = string.charCodeAt(counter++);
				if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
					var extra = string.charCodeAt(counter++);
					if ((extra & 0xFC00) == 0xDC00) {
						output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
					} else {
						output.push(value);
						counter--;
					}
				} else {
					output.push(value);
				}
			}
			return output;
		}
		var ucs2encode = function ucs2encode(array) {
			return String.fromCodePoint.apply(String, toConsumableArray(array));
		};
		var basicToDigit = function basicToDigit(codePoint) {
			if (codePoint - 0x30 < 0x0A) {
				return codePoint - 0x16;
			}
			if (codePoint - 0x41 < 0x1A) {
				return codePoint - 0x41;
			}
			if (codePoint - 0x61 < 0x1A) {
				return codePoint - 0x61;
			}
			return base;
		};
		var digitToBasic = function digitToBasic(digit, flag) {
			return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
		};
		var adapt = function adapt(delta, numPoints, firstTime) {
			var k = 0;
			delta = firstTime ? floor(delta / damp) : delta >> 1;
			delta += floor(delta / numPoints);
			for (; delta > baseMinusTMin * tMax >> 1; k += base) {
				delta = floor(delta / baseMinusTMin);
			}
			return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
		};
		var decode = function decode(input) {
			var output = [];
			var inputLength = input.length;
			var i = 0;
			var n = initialN;
			var bias = initialBias;
			var basic = input.lastIndexOf(delimiter);
			if (basic < 0) {
				basic = 0;
			}
			for (var j = 0; j < basic; ++j) {
				if (input.charCodeAt(j) >= 0x80) {
					error$1('not-basic');
				}
				output.push(input.charCodeAt(j));
			}
			for (var index = basic > 0 ? basic + 1 : 0; index < inputLength;) {
				var oldi = i;
				for (var w = 1, k = base;; k += base) {
					if (index >= inputLength) {
						error$1('invalid-input');
					}
					var digit = basicToDigit(input.charCodeAt(index++));
					if (digit >= base || digit > floor((maxInt - i) / w)) {
						error$1('overflow');
					}
					i += digit * w;
					var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
					if (digit < t) {
						break;
					}
					var baseMinusT = base - t;
					if (w > floor(maxInt / baseMinusT)) {
						error$1('overflow');
					}
					w *= baseMinusT;
				}
				var out = output.length + 1;
				bias = adapt(i - oldi, out, oldi == 0);
				if (floor(i / out) > maxInt - n) {
					error$1('overflow');
				}
				n += floor(i / out);
				i %= out;
				output.splice(i++, 0, n);
			}
			return String.fromCodePoint.apply(String, output);
		};
		var encode = function encode(input) {
			var output = [];
			input = ucs2decode(input);
			var inputLength = input.length;
			var n = initialN;
			var delta = 0;
			var bias = initialBias;
			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;
			try {
				for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					var _currentValue2 = _step.value;
					if (_currentValue2 < 0x80) {
						output.push(stringFromCharCode(_currentValue2));
					}
				}
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator.return) {
						_iterator.return();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}
			var basicLength = output.length;
			var handledCPCount = basicLength;
			if (basicLength) {
				output.push(delimiter);
			}
			while (handledCPCount < inputLength) {
				var m = maxInt;
				var _iteratorNormalCompletion2 = true;
				var _didIteratorError2 = false;
				var _iteratorError2 = undefined;
				try {
					for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
						var currentValue = _step2.value;
						if (currentValue >= n && currentValue < m) {
							m = currentValue;
						}
					}
				} catch (err) {
					_didIteratorError2 = true;
					_iteratorError2 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion2 && _iterator2.return) {
							_iterator2.return();
						}
					} finally {
						if (_didIteratorError2) {
							throw _iteratorError2;
						}
					}
				}
				var handledCPCountPlusOne = handledCPCount + 1;
				if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
					error$1('overflow');
				}
				delta += (m - n) * handledCPCountPlusOne;
				n = m;
				var _iteratorNormalCompletion3 = true;
				var _didIteratorError3 = false;
				var _iteratorError3 = undefined;
				try {
					for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
						var _currentValue = _step3.value;
						if (_currentValue < n && ++delta > maxInt) {
							error$1('overflow');
						}
						if (_currentValue == n) {
							var q = delta;
							for (var k = base;; k += base) {
								var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
								if (q < t) {
									break;
								}
								var qMinusT = q - t;
								var baseMinusT = base - t;
								output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
								q = floor(qMinusT / baseMinusT);
							}
							output.push(stringFromCharCode(digitToBasic(q, 0)));
							bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
							delta = 0;
							++handledCPCount;
						}
					}
				} catch (err) {
					_didIteratorError3 = true;
					_iteratorError3 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion3 && _iterator3.return) {
							_iterator3.return();
						}
					} finally {
						if (_didIteratorError3) {
							throw _iteratorError3;
						}
					}
				}
				++delta;
				++n;
			}
			return output.join('');
		};
		var toUnicode = function toUnicode(input) {
			return mapDomain(input, function (string) {
				return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
			});
		};
		var toASCII = function toASCII(input) {
			return mapDomain(input, function (string) {
				return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
			});
		};
		var punycode = {
			'version': '2.1.0',
			'ucs2': {
				'decode': ucs2decode,
				'encode': ucs2encode
			},
			'decode': decode,
			'encode': encode,
			'toASCII': toASCII,
			'toUnicode': toUnicode
		};
		/**
		 * Copyright 2011 Gary Court. All rights reserved.
		 *
		 * Redistribution and use in source and binary forms, with or without modification, are
		 * permitted provided that the following conditions are met:
		 *
		 *    1. Redistributions of source code must retain the above copyright notice, this list of
		 *       conditions and the following disclaimer.
		 *
		 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
		 *       of conditions and the following disclaimer in the documentation and/or other materials
		 *       provided with the distribution.
		 *
		 * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED
		 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
		 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR
		 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
		 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
		 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
		 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
		 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
		 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
		 *
		 * The views and conclusions contained in the software and documentation are those of the
		 * authors and should not be interpreted as representing official policies, either expressed
		 * or implied, of Gary Court.
		 */
		var SCHEMES = {};
		function pctEncChar(chr) {
		    var c = chr.charCodeAt(0);
		    var e = void 0;
		    if (c < 16) e = "%0" + c.toString(16).toUpperCase();else if (c < 128) e = "%" + c.toString(16).toUpperCase();else if (c < 2048) e = "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();else e = "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
		    return e;
		}
		function pctDecChars(str) {
		    var newStr = "";
		    var i = 0;
		    var il = str.length;
		    while (i < il) {
		        var c = parseInt(str.substr(i + 1, 2), 16);
		        if (c < 128) {
		            newStr += String.fromCharCode(c);
		            i += 3;
		        } else if (c >= 194 && c < 224) {
		            if (il - i >= 6) {
		                var c2 = parseInt(str.substr(i + 4, 2), 16);
		                newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);
		            } else {
		                newStr += str.substr(i, 6);
		            }
		            i += 6;
		        } else if (c >= 224) {
		            if (il - i >= 9) {
		                var _c = parseInt(str.substr(i + 4, 2), 16);
		                var c3 = parseInt(str.substr(i + 7, 2), 16);
		                newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);
		            } else {
		                newStr += str.substr(i, 9);
		            }
		            i += 9;
		        } else {
		            newStr += str.substr(i, 3);
		            i += 3;
		        }
		    }
		    return newStr;
		}
		function _normalizeComponentEncoding(components, protocol) {
		    function decodeUnreserved(str) {
		        var decStr = pctDecChars(str);
		        return !decStr.match(protocol.UNRESERVED) ? str : decStr;
		    }
		    if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, "");
		    if (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
		    if (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
		    if (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
		    if (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
		    if (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
		    return components;
		}
		function _stripLeadingZeros(str) {
		    return str.replace(/^0*(.*)/, "$1") || "0";
		}
		function _normalizeIPv4(host, protocol) {
		    var matches = host.match(protocol.IPV4ADDRESS) || [];
		    var _matches = slicedToArray(matches, 2),
		        address = _matches[1];
		    if (address) {
		        return address.split(".").map(_stripLeadingZeros).join(".");
		    } else {
		        return host;
		    }
		}
		function _normalizeIPv6(host, protocol) {
		    var matches = host.match(protocol.IPV6ADDRESS) || [];
		    var _matches2 = slicedToArray(matches, 3),
		        address = _matches2[1],
		        zone = _matches2[2];
		    if (address) {
		        var _address$toLowerCase$ = address.toLowerCase().split('::').reverse(),
		            _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2),
		            last = _address$toLowerCase$2[0],
		            first = _address$toLowerCase$2[1];
		        var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
		        var lastFields = last.split(":").map(_stripLeadingZeros);
		        var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
		        var fieldCount = isLastFieldIPv4Address ? 7 : 8;
		        var lastFieldsStart = lastFields.length - fieldCount;
		        var fields = Array(fieldCount);
		        for (var x = 0; x < fieldCount; ++x) {
		            fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || '';
		        }
		        if (isLastFieldIPv4Address) {
		            fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
		        }
		        var allZeroFields = fields.reduce(function (acc, field, index) {
		            if (!field || field === "0") {
		                var lastLongest = acc[acc.length - 1];
		                if (lastLongest && lastLongest.index + lastLongest.length === index) {
		                    lastLongest.length++;
		                } else {
		                    acc.push({ index: index, length: 1 });
		                }
		            }
		            return acc;
		        }, []);
		        var longestZeroFields = allZeroFields.sort(function (a, b) {
		            return b.length - a.length;
		        })[0];
		        var newHost = void 0;
		        if (longestZeroFields && longestZeroFields.length > 1) {
		            var newFirst = fields.slice(0, longestZeroFields.index);
		            var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
		            newHost = newFirst.join(":") + "::" + newLast.join(":");
		        } else {
		            newHost = fields.join(":");
		        }
		        if (zone) {
		            newHost += "%" + zone;
		        }
		        return newHost;
		    } else {
		        return host;
		    }
		}
		var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
		var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === undefined;
		function parse(uriString) {
		    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
		    var components = {};
		    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
		    if (options.reference === "suffix") uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
		    var matches = uriString.match(URI_PARSE);
		    if (matches) {
		        if (NO_MATCH_IS_UNDEFINED) {
		            components.scheme = matches[1];
		            components.userinfo = matches[3];
		            components.host = matches[4];
		            components.port = parseInt(matches[5], 10);
		            components.path = matches[6] || "";
		            components.query = matches[7];
		            components.fragment = matches[8];
		            if (isNaN(components.port)) {
		                components.port = matches[5];
		            }
		        } else {
		            components.scheme = matches[1] || undefined;
		            components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : undefined;
		            components.host = uriString.indexOf("//") !== -1 ? matches[4] : undefined;
		            components.port = parseInt(matches[5], 10);
		            components.path = matches[6] || "";
		            components.query = uriString.indexOf("?") !== -1 ? matches[7] : undefined;
		            components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : undefined;
		            if (isNaN(components.port)) {
		                components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : undefined;
		            }
		        }
		        if (components.host) {
		            components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
		        }
		        if (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {
		            components.reference = "same-document";
		        } else if (components.scheme === undefined) {
		            components.reference = "relative";
		        } else if (components.fragment === undefined) {
		            components.reference = "absolute";
		        } else {
		            components.reference = "uri";
		        }
		        if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
		            components.error = components.error || "URI is not a " + options.reference + " reference.";
		        }
		        var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
		        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
		            if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {
		                try {
		                    components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
		                } catch (e) {
		                    components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
		                }
		            }
		            _normalizeComponentEncoding(components, URI_PROTOCOL);
		        } else {
		            _normalizeComponentEncoding(components, protocol);
		        }
		        if (schemeHandler && schemeHandler.parse) {
		            schemeHandler.parse(components, options);
		        }
		    } else {
		        components.error = components.error || "URI can not be parsed.";
		    }
		    return components;
		}
		function _recomposeAuthority(components, options) {
		    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
		    var uriTokens = [];
		    if (components.userinfo !== undefined) {
		        uriTokens.push(components.userinfo);
		        uriTokens.push("@");
		    }
		    if (components.host !== undefined) {
		        uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function (_, $1, $2) {
		            return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
		        }));
		    }
		    if (typeof components.port === "number" || typeof components.port === "string") {
		        uriTokens.push(":");
		        uriTokens.push(String(components.port));
		    }
		    return uriTokens.length ? uriTokens.join("") : undefined;
		}
		var RDS1 = /^\.\.?\//;
		var RDS2 = /^\/\.(\/|$)/;
		var RDS3 = /^\/\.\.(\/|$)/;
		var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
		function removeDotSegments(input) {
		    var output = [];
		    while (input.length) {
		        if (input.match(RDS1)) {
		            input = input.replace(RDS1, "");
		        } else if (input.match(RDS2)) {
		            input = input.replace(RDS2, "/");
		        } else if (input.match(RDS3)) {
		            input = input.replace(RDS3, "/");
		            output.pop();
		        } else if (input === "." || input === "..") {
		            input = "";
		        } else {
		            var im = input.match(RDS5);
		            if (im) {
		                var s = im[0];
		                input = input.slice(s.length);
		                output.push(s);
		            } else {
		                throw new Error("Unexpected dot segment condition");
		            }
		        }
		    }
		    return output.join("");
		}
		function serialize(components) {
		    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
		    var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
		    var uriTokens = [];
		    var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
		    if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);
		    if (components.host) {
		        if (protocol.IPV6ADDRESS.test(components.host)) ;
		        else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {
		                try {
		                    components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
		                } catch (e) {
		                    components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
		                }
		            }
		    }
		    _normalizeComponentEncoding(components, protocol);
		    if (options.reference !== "suffix" && components.scheme) {
		        uriTokens.push(components.scheme);
		        uriTokens.push(":");
		    }
		    var authority = _recomposeAuthority(components, options);
		    if (authority !== undefined) {
		        if (options.reference !== "suffix") {
		            uriTokens.push("//");
		        }
		        uriTokens.push(authority);
		        if (components.path && components.path.charAt(0) !== "/") {
		            uriTokens.push("/");
		        }
		    }
		    if (components.path !== undefined) {
		        var s = components.path;
		        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
		            s = removeDotSegments(s);
		        }
		        if (authority === undefined) {
		            s = s.replace(/^\/\//, "/%2F");
		        }
		        uriTokens.push(s);
		    }
		    if (components.query !== undefined) {
		        uriTokens.push("?");
		        uriTokens.push(components.query);
		    }
		    if (components.fragment !== undefined) {
		        uriTokens.push("#");
		        uriTokens.push(components.fragment);
		    }
		    return uriTokens.join("");
		}
		function resolveComponents(base, relative) {
		    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
		    var skipNormalization = arguments[3];
		    var target = {};
		    if (!skipNormalization) {
		        base = parse(serialize(base, options), options);
		        relative = parse(serialize(relative, options), options);
		    }
		    options = options || {};
		    if (!options.tolerant && relative.scheme) {
		        target.scheme = relative.scheme;
		        target.userinfo = relative.userinfo;
		        target.host = relative.host;
		        target.port = relative.port;
		        target.path = removeDotSegments(relative.path || "");
		        target.query = relative.query;
		    } else {
		        if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {
		            target.userinfo = relative.userinfo;
		            target.host = relative.host;
		            target.port = relative.port;
		            target.path = removeDotSegments(relative.path || "");
		            target.query = relative.query;
		        } else {
		            if (!relative.path) {
		                target.path = base.path;
		                if (relative.query !== undefined) {
		                    target.query = relative.query;
		                } else {
		                    target.query = base.query;
		                }
		            } else {
		                if (relative.path.charAt(0) === "/") {
		                    target.path = removeDotSegments(relative.path);
		                } else {
		                    if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {
		                        target.path = "/" + relative.path;
		                    } else if (!base.path) {
		                        target.path = relative.path;
		                    } else {
		                        target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
		                    }
		                    target.path = removeDotSegments(target.path);
		                }
		                target.query = relative.query;
		            }
		            target.userinfo = base.userinfo;
		            target.host = base.host;
		            target.port = base.port;
		        }
		        target.scheme = base.scheme;
		    }
		    target.fragment = relative.fragment;
		    return target;
		}
		function resolve(baseURI, relativeURI, options) {
		    var schemelessOptions = assign({ scheme: 'null' }, options);
		    return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
		}
		function normalize(uri, options) {
		    if (typeof uri === "string") {
		        uri = serialize(parse(uri, options), options);
		    } else if (typeOf(uri) === "object") {
		        uri = parse(serialize(uri, options), options);
		    }
		    return uri;
		}
		function equal(uriA, uriB, options) {
		    if (typeof uriA === "string") {
		        uriA = serialize(parse(uriA, options), options);
		    } else if (typeOf(uriA) === "object") {
		        uriA = serialize(uriA, options);
		    }
		    if (typeof uriB === "string") {
		        uriB = serialize(parse(uriB, options), options);
		    } else if (typeOf(uriB) === "object") {
		        uriB = serialize(uriB, options);
		    }
		    return uriA === uriB;
		}
		function escapeComponent(str, options) {
		    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
		}
		function unescapeComponent(str, options) {
		    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
		}
		var handler = {
		    scheme: "http",
		    domainHost: true,
		    parse: function parse(components, options) {
		        if (!components.host) {
		            components.error = components.error || "HTTP URIs must have a host.";
		        }
		        return components;
		    },
		    serialize: function serialize(components, options) {
		        var secure = String(components.scheme).toLowerCase() === "https";
		        if (components.port === (secure ? 443 : 80) || components.port === "") {
		            components.port = undefined;
		        }
		        if (!components.path) {
		            components.path = "/";
		        }
		        return components;
		    }
		};
		var handler$1 = {
		    scheme: "https",
		    domainHost: handler.domainHost,
		    parse: handler.parse,
		    serialize: handler.serialize
		};
		function isSecure(wsComponents) {
		    return typeof wsComponents.secure === 'boolean' ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
		}
		var handler$2 = {
		    scheme: "ws",
		    domainHost: true,
		    parse: function parse(components, options) {
		        var wsComponents = components;
		        wsComponents.secure = isSecure(wsComponents);
		        wsComponents.resourceName = (wsComponents.path || '/') + (wsComponents.query ? '?' + wsComponents.query : '');
		        wsComponents.path = undefined;
		        wsComponents.query = undefined;
		        return wsComponents;
		    },
		    serialize: function serialize(wsComponents, options) {
		        if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
		            wsComponents.port = undefined;
		        }
		        if (typeof wsComponents.secure === 'boolean') {
		            wsComponents.scheme = wsComponents.secure ? 'wss' : 'ws';
		            wsComponents.secure = undefined;
		        }
		        if (wsComponents.resourceName) {
		            var _wsComponents$resourc = wsComponents.resourceName.split('?'),
		                _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2),
		                path = _wsComponents$resourc2[0],
		                query = _wsComponents$resourc2[1];
		            wsComponents.path = path && path !== '/' ? path : undefined;
		            wsComponents.query = query;
		            wsComponents.resourceName = undefined;
		        }
		        wsComponents.fragment = undefined;
		        return wsComponents;
		    }
		};
		var handler$3 = {
		    scheme: "wss",
		    domainHost: handler$2.domainHost,
		    parse: handler$2.parse,
		    serialize: handler$2.serialize
		};
		var O = {};
		var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~" + ("\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF" ) + "]";
		var HEXDIG$$ = "[0-9A-Fa-f]";
		var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$));
		var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
		var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
		var VCHAR$$ = merge(QTEXT$$, "[\\\"\\\\]");
		var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
		var UNRESERVED = new RegExp(UNRESERVED$$, "g");
		var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
		var NOT_LOCAL_PART = new RegExp(merge("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$), "g");
		var NOT_HFNAME = new RegExp(merge("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
		var NOT_HFVALUE = NOT_HFNAME;
		function decodeUnreserved(str) {
		    var decStr = pctDecChars(str);
		    return !decStr.match(UNRESERVED) ? str : decStr;
		}
		var handler$4 = {
		    scheme: "mailto",
		    parse: function parse$$1(components, options) {
		        var mailtoComponents = components;
		        var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
		        mailtoComponents.path = undefined;
		        if (mailtoComponents.query) {
		            var unknownHeaders = false;
		            var headers = {};
		            var hfields = mailtoComponents.query.split("&");
		            for (var x = 0, xl = hfields.length; x < xl; ++x) {
		                var hfield = hfields[x].split("=");
		                switch (hfield[0]) {
		                    case "to":
		                        var toAddrs = hfield[1].split(",");
		                        for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
		                            to.push(toAddrs[_x]);
		                        }
		                        break;
		                    case "subject":
		                        mailtoComponents.subject = unescapeComponent(hfield[1], options);
		                        break;
		                    case "body":
		                        mailtoComponents.body = unescapeComponent(hfield[1], options);
		                        break;
		                    default:
		                        unknownHeaders = true;
		                        headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
		                        break;
		                }
		            }
		            if (unknownHeaders) mailtoComponents.headers = headers;
		        }
		        mailtoComponents.query = undefined;
		        for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
		            var addr = to[_x2].split("@");
		            addr[0] = unescapeComponent(addr[0]);
		            if (!options.unicodeSupport) {
		                try {
		                    addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
		                } catch (e) {
		                    mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
		                }
		            } else {
		                addr[1] = unescapeComponent(addr[1], options).toLowerCase();
		            }
		            to[_x2] = addr.join("@");
		        }
		        return mailtoComponents;
		    },
		    serialize: function serialize$$1(mailtoComponents, options) {
		        var components = mailtoComponents;
		        var to = toArray(mailtoComponents.to);
		        if (to) {
		            for (var x = 0, xl = to.length; x < xl; ++x) {
		                var toAddr = String(to[x]);
		                var atIdx = toAddr.lastIndexOf("@");
		                var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
		                var domain = toAddr.slice(atIdx + 1);
		                try {
		                    domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);
		                } catch (e) {
		                    components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
		                }
		                to[x] = localPart + "@" + domain;
		            }
		            components.path = to.join(",");
		        }
		        var headers = mailtoComponents.headers = mailtoComponents.headers || {};
		        if (mailtoComponents.subject) headers["subject"] = mailtoComponents.subject;
		        if (mailtoComponents.body) headers["body"] = mailtoComponents.body;
		        var fields = [];
		        for (var name in headers) {
		            if (headers[name] !== O[name]) {
		                fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
		            }
		        }
		        if (fields.length) {
		            components.query = fields.join("&");
		        }
		        return components;
		    }
		};
		var URN_PARSE = /^([^\:]+)\:(.*)/;
		var handler$5 = {
		    scheme: "urn",
		    parse: function parse$$1(components, options) {
		        var matches = components.path && components.path.match(URN_PARSE);
		        var urnComponents = components;
		        if (matches) {
		            var scheme = options.scheme || urnComponents.scheme || "urn";
		            var nid = matches[1].toLowerCase();
		            var nss = matches[2];
		            var urnScheme = scheme + ":" + (options.nid || nid);
		            var schemeHandler = SCHEMES[urnScheme];
		            urnComponents.nid = nid;
		            urnComponents.nss = nss;
		            urnComponents.path = undefined;
		            if (schemeHandler) {
		                urnComponents = schemeHandler.parse(urnComponents, options);
		            }
		        } else {
		            urnComponents.error = urnComponents.error || "URN can not be parsed.";
		        }
		        return urnComponents;
		    },
		    serialize: function serialize$$1(urnComponents, options) {
		        var scheme = options.scheme || urnComponents.scheme || "urn";
		        var nid = urnComponents.nid;
		        var urnScheme = scheme + ":" + (options.nid || nid);
		        var schemeHandler = SCHEMES[urnScheme];
		        if (schemeHandler) {
		            urnComponents = schemeHandler.serialize(urnComponents, options);
		        }
		        var uriComponents = urnComponents;
		        var nss = urnComponents.nss;
		        uriComponents.path = (nid || options.nid) + ":" + nss;
		        return uriComponents;
		    }
		};
		var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
		var handler$6 = {
		    scheme: "urn:uuid",
		    parse: function parse(urnComponents, options) {
		        var uuidComponents = urnComponents;
		        uuidComponents.uuid = uuidComponents.nss;
		        uuidComponents.nss = undefined;
		        if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {
		            uuidComponents.error = uuidComponents.error || "UUID is not valid.";
		        }
		        return uuidComponents;
		    },
		    serialize: function serialize(uuidComponents, options) {
		        var urnComponents = uuidComponents;
		        urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
		        return urnComponents;
		    }
		};
		SCHEMES[handler.scheme] = handler;
		SCHEMES[handler$1.scheme] = handler$1;
		SCHEMES[handler$2.scheme] = handler$2;
		SCHEMES[handler$3.scheme] = handler$3;
		SCHEMES[handler$4.scheme] = handler$4;
		SCHEMES[handler$5.scheme] = handler$5;
		SCHEMES[handler$6.scheme] = handler$6;
		exports.SCHEMES = SCHEMES;
		exports.pctEncChar = pctEncChar;
		exports.pctDecChars = pctDecChars;
		exports.parse = parse;
		exports.removeDotSegments = removeDotSegments;
		exports.serialize = serialize;
		exports.resolveComponents = resolveComponents;
		exports.resolve = resolve;
		exports.normalize = normalize;
		exports.equal = equal;
		exports.escapeComponent = escapeComponent;
		exports.unescapeComponent = unescapeComponent;
		Object.defineProperty(exports, '__esModule', { value: true });
		}))); 
	} (uri_all$1, uri_all$1.exports));
	return uri_all$1.exports;
}

var fastDeepEqual;
var hasRequiredFastDeepEqual;

function requireFastDeepEqual () {
	if (hasRequiredFastDeepEqual) return fastDeepEqual;
	hasRequiredFastDeepEqual = 1;
	fastDeepEqual = function equal(a, b) {
	  if (a === b) return true;
	  if (a && b && typeof a == 'object' && typeof b == 'object') {
	    if (a.constructor !== b.constructor) return false;
	    var length, i, keys;
	    if (Array.isArray(a)) {
	      length = a.length;
	      if (length != b.length) return false;
	      for (i = length; i-- !== 0;)
	        if (!equal(a[i], b[i])) return false;
	      return true;
	    }
	    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
	    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
	    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
	    keys = Object.keys(a);
	    length = keys.length;
	    if (length !== Object.keys(b).length) return false;
	    for (i = length; i-- !== 0;)
	      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
	    for (i = length; i-- !== 0;) {
	      var key = keys[i];
	      if (!equal(a[key], b[key])) return false;
	    }
	    return true;
	  }
	  return a!==a && b!==b;
	};
	return fastDeepEqual;
}

var ucs2length;
var hasRequiredUcs2length;

function requireUcs2length () {
	if (hasRequiredUcs2length) return ucs2length;
	hasRequiredUcs2length = 1;
	ucs2length = function ucs2length(str) {
	  var length = 0
	    , len = str.length
	    , pos = 0
	    , value;
	  while (pos < len) {
	    length++;
	    value = str.charCodeAt(pos++);
	    if (value >= 0xD800 && value <= 0xDBFF && pos < len) {
	      value = str.charCodeAt(pos);
	      if ((value & 0xFC00) == 0xDC00) pos++;
	    }
	  }
	  return length;
	};
	return ucs2length;
}

var util$3;
var hasRequiredUtil$3;

function requireUtil$3 () {
	if (hasRequiredUtil$3) return util$3;
	hasRequiredUtil$3 = 1;
	util$3 = {
	  copy: copy,
	  checkDataType: checkDataType,
	  checkDataTypes: checkDataTypes,
	  coerceToTypes: coerceToTypes,
	  toHash: toHash,
	  getProperty: getProperty,
	  escapeQuotes: escapeQuotes,
	  equal: requireFastDeepEqual(),
	  ucs2length: requireUcs2length(),
	  varOccurences: varOccurences,
	  varReplace: varReplace,
	  schemaHasRules: schemaHasRules,
	  schemaHasRulesExcept: schemaHasRulesExcept,
	  schemaUnknownRules: schemaUnknownRules,
	  toQuotedString: toQuotedString,
	  getPathExpr: getPathExpr,
	  getPath: getPath,
	  getData: getData,
	  unescapeFragment: unescapeFragment,
	  unescapeJsonPointer: unescapeJsonPointer,
	  escapeFragment: escapeFragment,
	  escapeJsonPointer: escapeJsonPointer
	};
	function copy(o, to) {
	  to = to || {};
	  for (var key in o) to[key] = o[key];
	  return to;
	}
	function checkDataType(dataType, data, strictNumbers, negate) {
	  var EQUAL = negate ? ' !== ' : ' === '
	    , AND = negate ? ' || ' : ' && '
	    , OK = negate ? '!' : ''
	    , NOT = negate ? '' : '!';
	  switch (dataType) {
	    case 'null': return data + EQUAL + 'null';
	    case 'array': return OK + 'Array.isArray(' + data + ')';
	    case 'object': return '(' + OK + data + AND +
	                          'typeof ' + data + EQUAL + '"object"' + AND +
	                          NOT + 'Array.isArray(' + data + '))';
	    case 'integer': return '(typeof ' + data + EQUAL + '"number"' + AND +
	                           NOT + '(' + data + ' % 1)' +
	                           AND + data + EQUAL + data +
	                           (strictNumbers ? (AND + OK + 'isFinite(' + data + ')') : '') + ')';
	    case 'number': return '(typeof ' + data + EQUAL + '"' + dataType + '"' +
	                          (strictNumbers ? (AND + OK + 'isFinite(' + data + ')') : '') + ')';
	    default: return 'typeof ' + data + EQUAL + '"' + dataType + '"';
	  }
	}
	function checkDataTypes(dataTypes, data, strictNumbers) {
	  switch (dataTypes.length) {
	    case 1: return checkDataType(dataTypes[0], data, strictNumbers, true);
	    default:
	      var code = '';
	      var types = toHash(dataTypes);
	      if (types.array && types.object) {
	        code = types.null ? '(': '(!' + data + ' || ';
	        code += 'typeof ' + data + ' !== "object")';
	        delete types.null;
	        delete types.array;
	        delete types.object;
	      }
	      if (types.number) delete types.integer;
	      for (var t in types)
	        code += (code ? ' && ' : '' ) + checkDataType(t, data, strictNumbers, true);
	      return code;
	  }
	}
	var COERCE_TO_TYPES = toHash([ 'string', 'number', 'integer', 'boolean', 'null' ]);
	function coerceToTypes(optionCoerceTypes, dataTypes) {
	  if (Array.isArray(dataTypes)) {
	    var types = [];
	    for (var i=0; i<dataTypes.length; i++) {
	      var t = dataTypes[i];
	      if (COERCE_TO_TYPES[t]) types[types.length] = t;
	      else if (optionCoerceTypes === 'array' && t === 'array') types[types.length] = t;
	    }
	    if (types.length) return types;
	  } else if (COERCE_TO_TYPES[dataTypes]) {
	    return [dataTypes];
	  } else if (optionCoerceTypes === 'array' && dataTypes === 'array') {
	    return ['array'];
	  }
	}
	function toHash(arr) {
	  var hash = {};
	  for (var i=0; i<arr.length; i++) hash[arr[i]] = true;
	  return hash;
	}
	var IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
	var SINGLE_QUOTE = /'|\\/g;
	function getProperty(key) {
	  return typeof key == 'number'
	          ? '[' + key + ']'
	          : IDENTIFIER.test(key)
	            ? '.' + key
	            : "['" + escapeQuotes(key) + "']";
	}
	function escapeQuotes(str) {
	  return str.replace(SINGLE_QUOTE, '\\$&')
	            .replace(/\n/g, '\\n')
	            .replace(/\r/g, '\\r')
	            .replace(/\f/g, '\\f')
	            .replace(/\t/g, '\\t');
	}
	function varOccurences(str, dataVar) {
	  dataVar += '[^0-9]';
	  var matches = str.match(new RegExp(dataVar, 'g'));
	  return matches ? matches.length : 0;
	}
	function varReplace(str, dataVar, expr) {
	  dataVar += '([^0-9])';
	  expr = expr.replace(/\$/g, '$$$$');
	  return str.replace(new RegExp(dataVar, 'g'), expr + '$1');
	}
	function schemaHasRules(schema, rules) {
	  if (typeof schema == 'boolean') return !schema;
	  for (var key in schema) if (rules[key]) return true;
	}
	function schemaHasRulesExcept(schema, rules, exceptKeyword) {
	  if (typeof schema == 'boolean') return !schema && exceptKeyword != 'not';
	  for (var key in schema) if (key != exceptKeyword && rules[key]) return true;
	}
	function schemaUnknownRules(schema, rules) {
	  if (typeof schema == 'boolean') return;
	  for (var key in schema) if (!rules[key]) return key;
	}
	function toQuotedString(str) {
	  return '\'' + escapeQuotes(str) + '\'';
	}
	function getPathExpr(currentPath, expr, jsonPointers, isNumber) {
	  var path = jsonPointers
	              ? '\'/\' + ' + expr + (isNumber ? '' : '.replace(/~/g, \'~0\').replace(/\\//g, \'~1\')')
	              : (isNumber ? '\'[\' + ' + expr + ' + \']\'' : '\'[\\\'\' + ' + expr + ' + \'\\\']\'');
	  return joinPaths(currentPath, path);
	}
	function getPath(currentPath, prop, jsonPointers) {
	  var path = jsonPointers
	              ? toQuotedString('/' + escapeJsonPointer(prop))
	              : toQuotedString(getProperty(prop));
	  return joinPaths(currentPath, path);
	}
	var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
	var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
	function getData($data, lvl, paths) {
	  var up, jsonPointer, data, matches;
	  if ($data === '') return 'rootData';
	  if ($data[0] == '/') {
	    if (!JSON_POINTER.test($data)) throw new Error('Invalid JSON-pointer: ' + $data);
	    jsonPointer = $data;
	    data = 'rootData';
	  } else {
	    matches = $data.match(RELATIVE_JSON_POINTER);
	    if (!matches) throw new Error('Invalid JSON-pointer: ' + $data);
	    up = +matches[1];
	    jsonPointer = matches[2];
	    if (jsonPointer == '#') {
	      if (up >= lvl) throw new Error('Cannot access property/index ' + up + ' levels up, current level is ' + lvl);
	      return paths[lvl - up];
	    }
	    if (up > lvl) throw new Error('Cannot access data ' + up + ' levels up, current level is ' + lvl);
	    data = 'data' + ((lvl - up) || '');
	    if (!jsonPointer) return data;
	  }
	  var expr = data;
	  var segments = jsonPointer.split('/');
	  for (var i=0; i<segments.length; i++) {
	    var segment = segments[i];
	    if (segment) {
	      data += getProperty(unescapeJsonPointer(segment));
	      expr += ' && ' + data;
	    }
	  }
	  return expr;
	}
	function joinPaths (a, b) {
	  if (a == '""') return b;
	  return (a + ' + ' + b).replace(/([^\\])' \+ '/g, '$1');
	}
	function unescapeFragment(str) {
	  return unescapeJsonPointer(decodeURIComponent(str));
	}
	function escapeFragment(str) {
	  return encodeURIComponent(escapeJsonPointer(str));
	}
	function escapeJsonPointer(str) {
	  return str.replace(/~/g, '~0').replace(/\//g, '~1');
	}
	function unescapeJsonPointer(str) {
	  return str.replace(/~1/g, '/').replace(/~0/g, '~');
	}
	return util$3;
}

var schema_obj;
var hasRequiredSchema_obj;

function requireSchema_obj () {
	if (hasRequiredSchema_obj) return schema_obj;
	hasRequiredSchema_obj = 1;
	var util = requireUtil$3();
	schema_obj = SchemaObject;
	function SchemaObject(obj) {
	  util.copy(obj, this);
	}
	return schema_obj;
}

var jsonSchemaTraverse = {exports: {}};

var hasRequiredJsonSchemaTraverse;

function requireJsonSchemaTraverse () {
	if (hasRequiredJsonSchemaTraverse) return jsonSchemaTraverse.exports;
	hasRequiredJsonSchemaTraverse = 1;
	var traverse = jsonSchemaTraverse.exports = function (schema, opts, cb) {
	  if (typeof opts == 'function') {
	    cb = opts;
	    opts = {};
	  }
	  cb = opts.cb || cb;
	  var pre = (typeof cb == 'function') ? cb : cb.pre || function() {};
	  var post = cb.post || function() {};
	  _traverse(opts, pre, post, schema, '', schema);
	};
	traverse.keywords = {
	  additionalItems: true,
	  items: true,
	  contains: true,
	  additionalProperties: true,
	  propertyNames: true,
	  not: true
	};
	traverse.arrayKeywords = {
	  items: true,
	  allOf: true,
	  anyOf: true,
	  oneOf: true
	};
	traverse.propsKeywords = {
	  definitions: true,
	  properties: true,
	  patternProperties: true,
	  dependencies: true
	};
	traverse.skipKeywords = {
	  default: true,
	  enum: true,
	  const: true,
	  required: true,
	  maximum: true,
	  minimum: true,
	  exclusiveMaximum: true,
	  exclusiveMinimum: true,
	  multipleOf: true,
	  maxLength: true,
	  minLength: true,
	  pattern: true,
	  format: true,
	  maxItems: true,
	  minItems: true,
	  uniqueItems: true,
	  maxProperties: true,
	  minProperties: true
	};
	function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
	  if (schema && typeof schema == 'object' && !Array.isArray(schema)) {
	    pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
	    for (var key in schema) {
	      var sch = schema[key];
	      if (Array.isArray(sch)) {
	        if (key in traverse.arrayKeywords) {
	          for (var i=0; i<sch.length; i++)
	            _traverse(opts, pre, post, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);
	        }
	      } else if (key in traverse.propsKeywords) {
	        if (sch && typeof sch == 'object') {
	          for (var prop in sch)
	            _traverse(opts, pre, post, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
	        }
	      } else if (key in traverse.keywords || (opts.allKeys && !(key in traverse.skipKeywords))) {
	        _traverse(opts, pre, post, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);
	      }
	    }
	    post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
	  }
	}
	function escapeJsonPtr(str) {
	  return str.replace(/~/g, '~0').replace(/\//g, '~1');
	}
	return jsonSchemaTraverse.exports;
}

var resolve_1;
var hasRequiredResolve;

function requireResolve () {
	if (hasRequiredResolve) return resolve_1;
	hasRequiredResolve = 1;
	var URI = requireUri_all()
	  , equal = requireFastDeepEqual()
	  , util = requireUtil$3()
	  , SchemaObject = requireSchema_obj()
	  , traverse = requireJsonSchemaTraverse();
	resolve_1 = resolve;
	resolve.normalizeId = normalizeId;
	resolve.fullPath = getFullPath;
	resolve.url = resolveUrl;
	resolve.ids = resolveIds;
	resolve.inlineRef = inlineRef;
	resolve.schema = resolveSchema;
	function resolve(compile, root, ref) {
	  var refVal = this._refs[ref];
	  if (typeof refVal == 'string') {
	    if (this._refs[refVal]) refVal = this._refs[refVal];
	    else return resolve.call(this, compile, root, refVal);
	  }
	  refVal = refVal || this._schemas[ref];
	  if (refVal instanceof SchemaObject) {
	    return inlineRef(refVal.schema, this._opts.inlineRefs)
	            ? refVal.schema
	            : refVal.validate || this._compile(refVal);
	  }
	  var res = resolveSchema.call(this, root, ref);
	  var schema, v, baseId;
	  if (res) {
	    schema = res.schema;
	    root = res.root;
	    baseId = res.baseId;
	  }
	  if (schema instanceof SchemaObject) {
	    v = schema.validate || compile.call(this, schema.schema, root, undefined, baseId);
	  } else if (schema !== undefined) {
	    v = inlineRef(schema, this._opts.inlineRefs)
	        ? schema
	        : compile.call(this, schema, root, undefined, baseId);
	  }
	  return v;
	}
	function resolveSchema(root, ref) {
	  var p = URI.parse(ref)
	    , refPath = _getFullPath(p)
	    , baseId = getFullPath(this._getId(root.schema));
	  if (Object.keys(root.schema).length === 0 || refPath !== baseId) {
	    var id = normalizeId(refPath);
	    var refVal = this._refs[id];
	    if (typeof refVal == 'string') {
	      return resolveRecursive.call(this, root, refVal, p);
	    } else if (refVal instanceof SchemaObject) {
	      if (!refVal.validate) this._compile(refVal);
	      root = refVal;
	    } else {
	      refVal = this._schemas[id];
	      if (refVal instanceof SchemaObject) {
	        if (!refVal.validate) this._compile(refVal);
	        if (id == normalizeId(ref))
	          return { schema: refVal, root: root, baseId: baseId };
	        root = refVal;
	      } else {
	        return;
	      }
	    }
	    if (!root.schema) return;
	    baseId = getFullPath(this._getId(root.schema));
	  }
	  return getJsonPointer.call(this, p, baseId, root.schema, root);
	}
	function resolveRecursive(root, ref, parsedRef) {
	  var res = resolveSchema.call(this, root, ref);
	  if (res) {
	    var schema = res.schema;
	    var baseId = res.baseId;
	    root = res.root;
	    var id = this._getId(schema);
	    if (id) baseId = resolveUrl(baseId, id);
	    return getJsonPointer.call(this, parsedRef, baseId, schema, root);
	  }
	}
	var PREVENT_SCOPE_CHANGE = util.toHash(['properties', 'patternProperties', 'enum', 'dependencies', 'definitions']);
	function getJsonPointer(parsedRef, baseId, schema, root) {
	  parsedRef.fragment = parsedRef.fragment || '';
	  if (parsedRef.fragment.slice(0,1) != '/') return;
	  var parts = parsedRef.fragment.split('/');
	  for (var i = 1; i < parts.length; i++) {
	    var part = parts[i];
	    if (part) {
	      part = util.unescapeFragment(part);
	      schema = schema[part];
	      if (schema === undefined) break;
	      var id;
	      if (!PREVENT_SCOPE_CHANGE[part]) {
	        id = this._getId(schema);
	        if (id) baseId = resolveUrl(baseId, id);
	        if (schema.$ref) {
	          var $ref = resolveUrl(baseId, schema.$ref);
	          var res = resolveSchema.call(this, root, $ref);
	          if (res) {
	            schema = res.schema;
	            root = res.root;
	            baseId = res.baseId;
	          }
	        }
	      }
	    }
	  }
	  if (schema !== undefined && schema !== root.schema)
	    return { schema: schema, root: root, baseId: baseId };
	}
	var SIMPLE_INLINED = util.toHash([
	  'type', 'format', 'pattern',
	  'maxLength', 'minLength',
	  'maxProperties', 'minProperties',
	  'maxItems', 'minItems',
	  'maximum', 'minimum',
	  'uniqueItems', 'multipleOf',
	  'required', 'enum'
	]);
	function inlineRef(schema, limit) {
	  if (limit === false) return false;
	  if (limit === undefined || limit === true) return checkNoRef(schema);
	  else if (limit) return countKeys(schema) <= limit;
	}
	function checkNoRef(schema) {
	  var item;
	  if (Array.isArray(schema)) {
	    for (var i=0; i<schema.length; i++) {
	      item = schema[i];
	      if (typeof item == 'object' && !checkNoRef(item)) return false;
	    }
	  } else {
	    for (var key in schema) {
	      if (key == '$ref') return false;
	      item = schema[key];
	      if (typeof item == 'object' && !checkNoRef(item)) return false;
	    }
	  }
	  return true;
	}
	function countKeys(schema) {
	  var count = 0, item;
	  if (Array.isArray(schema)) {
	    for (var i=0; i<schema.length; i++) {
	      item = schema[i];
	      if (typeof item == 'object') count += countKeys(item);
	      if (count == Infinity) return Infinity;
	    }
	  } else {
	    for (var key in schema) {
	      if (key == '$ref') return Infinity;
	      if (SIMPLE_INLINED[key]) {
	        count++;
	      } else {
	        item = schema[key];
	        if (typeof item == 'object') count += countKeys(item) + 1;
	        if (count == Infinity) return Infinity;
	      }
	    }
	  }
	  return count;
	}
	function getFullPath(id, normalize) {
	  if (normalize !== false) id = normalizeId(id);
	  var p = URI.parse(id);
	  return _getFullPath(p);
	}
	function _getFullPath(p) {
	  return URI.serialize(p).split('#')[0] + '#';
	}
	var TRAILING_SLASH_HASH = /#\/?$/;
	function normalizeId(id) {
	  return id ? id.replace(TRAILING_SLASH_HASH, '') : '';
	}
	function resolveUrl(baseId, id) {
	  id = normalizeId(id);
	  return URI.resolve(baseId, id);
	}
	function resolveIds(schema) {
	  var schemaId = normalizeId(this._getId(schema));
	  var baseIds = {'': schemaId};
	  var fullPaths = {'': getFullPath(schemaId, false)};
	  var localRefs = {};
	  var self = this;
	  traverse(schema, {allKeys: true}, function(sch, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
	    if (jsonPtr === '') return;
	    var id = self._getId(sch);
	    var baseId = baseIds[parentJsonPtr];
	    var fullPath = fullPaths[parentJsonPtr] + '/' + parentKeyword;
	    if (keyIndex !== undefined)
	      fullPath += '/' + (typeof keyIndex == 'number' ? keyIndex : util.escapeFragment(keyIndex));
	    if (typeof id == 'string') {
	      id = baseId = normalizeId(baseId ? URI.resolve(baseId, id) : id);
	      var refVal = self._refs[id];
	      if (typeof refVal == 'string') refVal = self._refs[refVal];
	      if (refVal && refVal.schema) {
	        if (!equal(sch, refVal.schema))
	          throw new Error('id "' + id + '" resolves to more than one schema');
	      } else if (id != normalizeId(fullPath)) {
	        if (id[0] == '#') {
	          if (localRefs[id] && !equal(sch, localRefs[id]))
	            throw new Error('id "' + id + '" resolves to more than one schema');
	          localRefs[id] = sch;
	        } else {
	          self._refs[id] = fullPath;
	        }
	      }
	    }
	    baseIds[jsonPtr] = baseId;
	    fullPaths[jsonPtr] = fullPath;
	  });
	  return localRefs;
	}
	return resolve_1;
}

var error_classes;
var hasRequiredError_classes;

function requireError_classes () {
	if (hasRequiredError_classes) return error_classes;
	hasRequiredError_classes = 1;
	var resolve = requireResolve();
	error_classes = {
	  Validation: errorSubclass(ValidationError),
	  MissingRef: errorSubclass(MissingRefError)
	};
	function ValidationError(errors) {
	  this.message = 'validation failed';
	  this.errors = errors;
	  this.ajv = this.validation = true;
	}
	MissingRefError.message = function (baseId, ref) {
	  return 'can\'t resolve reference ' + ref + ' from id ' + baseId;
	};
	function MissingRefError(baseId, ref, message) {
	  this.message = message || MissingRefError.message(baseId, ref);
	  this.missingRef = resolve.url(baseId, ref);
	  this.missingSchema = resolve.normalizeId(resolve.fullPath(this.missingRef));
	}
	function errorSubclass(Subclass) {
	  Subclass.prototype = Object.create(Error.prototype);
	  Subclass.prototype.constructor = Subclass;
	  return Subclass;
	}
	return error_classes;
}

var fastJsonStableStringify;
var hasRequiredFastJsonStableStringify;

function requireFastJsonStableStringify () {
	if (hasRequiredFastJsonStableStringify) return fastJsonStableStringify;
	hasRequiredFastJsonStableStringify = 1;
	fastJsonStableStringify = function (data, opts) {
	    if (!opts) opts = {};
	    if (typeof opts === 'function') opts = { cmp: opts };
	    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;
	    var cmp = opts.cmp && (function (f) {
	        return function (node) {
	            return function (a, b) {
	                var aobj = { key: a, value: node[a] };
	                var bobj = { key: b, value: node[b] };
	                return f(aobj, bobj);
	            };
	        };
	    })(opts.cmp);
	    var seen = [];
	    return (function stringify (node) {
	        if (node && node.toJSON && typeof node.toJSON === 'function') {
	            node = node.toJSON();
	        }
	        if (node === undefined) return;
	        if (typeof node == 'number') return isFinite(node) ? '' + node : 'null';
	        if (typeof node !== 'object') return JSON.stringify(node);
	        var i, out;
	        if (Array.isArray(node)) {
	            out = '[';
	            for (i = 0; i < node.length; i++) {
	                if (i) out += ',';
	                out += stringify(node[i]) || 'null';
	            }
	            return out + ']';
	        }
	        if (node === null) return 'null';
	        if (seen.indexOf(node) !== -1) {
	            if (cycles) return JSON.stringify('__cycle__');
	            throw new TypeError('Converting circular structure to JSON');
	        }
	        var seenIndex = seen.push(node) - 1;
	        var keys = Object.keys(node).sort(cmp && cmp(node));
	        out = '';
	        for (i = 0; i < keys.length; i++) {
	            var key = keys[i];
	            var value = stringify(node[key]);
	            if (!value) continue;
	            if (out) out += ',';
	            out += JSON.stringify(key) + ':' + value;
	        }
	        seen.splice(seenIndex, 1);
	        return '{' + out + '}';
	    })(data);
	};
	return fastJsonStableStringify;
}

var validate;
var hasRequiredValidate;

function requireValidate () {
	if (hasRequiredValidate) return validate;
	hasRequiredValidate = 1;
	validate = function generate_validate(it, $keyword, $ruleType) {
	  var out = '';
	  var $async = it.schema.$async === true,
	    $refKeywords = it.util.schemaHasRulesExcept(it.schema, it.RULES.all, '$ref'),
	    $id = it.self._getId(it.schema);
	  if (it.opts.strictKeywords) {
	    var $unknownKwd = it.util.schemaUnknownRules(it.schema, it.RULES.keywords);
	    if ($unknownKwd) {
	      var $keywordsMsg = 'unknown keyword: ' + $unknownKwd;
	      if (it.opts.strictKeywords === 'log') it.logger.warn($keywordsMsg);
	      else throw new Error($keywordsMsg);
	    }
	  }
	  if (it.isTop) {
	    out += ' var validate = ';
	    if ($async) {
	      it.async = true;
	      out += 'async ';
	    }
	    out += 'function(data, dataPath, parentData, parentDataProperty, rootData) { \'use strict\'; ';
	    if ($id && (it.opts.sourceCode || it.opts.processCode)) {
	      out += ' ' + ('/\*# sourceURL=' + $id + ' */') + ' ';
	    }
	  }
	  if (typeof it.schema == 'boolean' || !($refKeywords || it.schema.$ref)) {
	    var $keyword = 'false schema';
	    var $lvl = it.level;
	    var $dataLvl = it.dataLevel;
	    var $schema = it.schema[$keyword];
	    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
	    var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
	    var $breakOnError = !it.opts.allErrors;
	    var $errorKeyword;
	    var $data = 'data' + ($dataLvl || '');
	    var $valid = 'valid' + $lvl;
	    if (it.schema === false) {
	      if (it.isTop) {
	        $breakOnError = true;
	      } else {
	        out += ' var ' + ($valid) + ' = false; ';
	      }
	      var $$outStack = $$outStack || [];
	      $$outStack.push(out);
	      out = '';
	      if (it.createErrors !== false) {
	        out += ' { keyword: \'' + ($errorKeyword || 'false schema') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
	        if (it.opts.messages !== false) {
	          out += ' , message: \'boolean schema is false\' ';
	        }
	        if (it.opts.verbose) {
	          out += ' , schema: false , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
	        }
	        out += ' } ';
	      } else {
	        out += ' {} ';
	      }
	      var __err = out;
	      out = $$outStack.pop();
	      if (!it.compositeRule && $breakOnError) {
	        if (it.async) {
	          out += ' throw new ValidationError([' + (__err) + ']); ';
	        } else {
	          out += ' validate.errors = [' + (__err) + ']; return false; ';
	        }
	      } else {
	        out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
	      }
	    } else {
	      if (it.isTop) {
	        if ($async) {
	          out += ' return data; ';
	        } else {
	          out += ' validate.errors = null; return true; ';
	        }
	      } else {
	        out += ' var ' + ($valid) + ' = true; ';
	      }
	    }
	    if (it.isTop) {
	      out += ' }; return validate; ';
	    }
	    return out;
	  }
	  if (it.isTop) {
	    var $top = it.isTop,
	      $lvl = it.level = 0,
	      $dataLvl = it.dataLevel = 0,
	      $data = 'data';
	    it.rootId = it.resolve.fullPath(it.self._getId(it.root.schema));
	    it.baseId = it.baseId || it.rootId;
	    delete it.isTop;
	    it.dataPathArr = [""];
	    if (it.schema.default !== undefined && it.opts.useDefaults && it.opts.strictDefaults) {
	      var $defaultMsg = 'default is ignored in the schema root';
	      if (it.opts.strictDefaults === 'log') it.logger.warn($defaultMsg);
	      else throw new Error($defaultMsg);
	    }
	    out += ' var vErrors = null; ';
	    out += ' var errors = 0;     ';
	    out += ' if (rootData === undefined) rootData = data; ';
	  } else {
	    var $lvl = it.level,
	      $dataLvl = it.dataLevel,
	      $data = 'data' + ($dataLvl || '');
	    if ($id) it.baseId = it.resolve.url(it.baseId, $id);
	    if ($async && !it.async) throw new Error('async schema in sync schema');
	    out += ' var errs_' + ($lvl) + ' = errors;';
	  }
	  var $valid = 'valid' + $lvl,
	    $breakOnError = !it.opts.allErrors,
	    $closingBraces1 = '',
	    $closingBraces2 = '';
	  var $errorKeyword;
	  var $typeSchema = it.schema.type,
	    $typeIsArray = Array.isArray($typeSchema);
	  if ($typeSchema && it.opts.nullable && it.schema.nullable === true) {
	    if ($typeIsArray) {
	      if ($typeSchema.indexOf('null') == -1) $typeSchema = $typeSchema.concat('null');
	    } else if ($typeSchema != 'null') {
	      $typeSchema = [$typeSchema, 'null'];
	      $typeIsArray = true;
	    }
	  }
	  if ($typeIsArray && $typeSchema.length == 1) {
	    $typeSchema = $typeSchema[0];
	    $typeIsArray = false;
	  }
	  if (it.schema.$ref && $refKeywords) {
	    if (it.opts.extendRefs == 'fail') {
	      throw new Error('$ref: validation keywords used in schema at path "' + it.errSchemaPath + '" (see option extendRefs)');
	    } else if (it.opts.extendRefs !== true) {
	      $refKeywords = false;
	      it.logger.warn('$ref: keywords ignored in schema at path "' + it.errSchemaPath + '"');
	    }
	  }
	  if (it.schema.$comment && it.opts.$comment) {
	    out += ' ' + (it.RULES.all.$comment.code(it, '$comment'));
	  }
	  if ($typeSchema) {
	    if (it.opts.coerceTypes) {
	      var $coerceToTypes = it.util.coerceToTypes(it.opts.coerceTypes, $typeSchema);
	    }
	    var $rulesGroup = it.RULES.types[$typeSchema];
	    if ($coerceToTypes || $typeIsArray || $rulesGroup === true || ($rulesGroup && !$shouldUseGroup($rulesGroup))) {
	      var $schemaPath = it.schemaPath + '.type',
	        $errSchemaPath = it.errSchemaPath + '/type';
	      var $schemaPath = it.schemaPath + '.type',
	        $errSchemaPath = it.errSchemaPath + '/type',
	        $method = $typeIsArray ? 'checkDataTypes' : 'checkDataType';
	      out += ' if (' + (it.util[$method]($typeSchema, $data, it.opts.strictNumbers, true)) + ') { ';
	      if ($coerceToTypes) {
	        var $dataType = 'dataType' + $lvl,
	          $coerced = 'coerced' + $lvl;
	        out += ' var ' + ($dataType) + ' = typeof ' + ($data) + '; var ' + ($coerced) + ' = undefined; ';
	        if (it.opts.coerceTypes == 'array') {
	          out += ' if (' + ($dataType) + ' == \'object\' && Array.isArray(' + ($data) + ') && ' + ($data) + '.length == 1) { ' + ($data) + ' = ' + ($data) + '[0]; ' + ($dataType) + ' = typeof ' + ($data) + '; if (' + (it.util.checkDataType(it.schema.type, $data, it.opts.strictNumbers)) + ') ' + ($coerced) + ' = ' + ($data) + '; } ';
	        }
	        out += ' if (' + ($coerced) + ' !== undefined) ; ';
	        var arr1 = $coerceToTypes;
	        if (arr1) {
	          var $type, $i = -1,
	            l1 = arr1.length - 1;
	          while ($i < l1) {
	            $type = arr1[$i += 1];
	            if ($type == 'string') {
	              out += ' else if (' + ($dataType) + ' == \'number\' || ' + ($dataType) + ' == \'boolean\') ' + ($coerced) + ' = \'\' + ' + ($data) + '; else if (' + ($data) + ' === null) ' + ($coerced) + ' = \'\'; ';
	            } else if ($type == 'number' || $type == 'integer') {
	              out += ' else if (' + ($dataType) + ' == \'boolean\' || ' + ($data) + ' === null || (' + ($dataType) + ' == \'string\' && ' + ($data) + ' && ' + ($data) + ' == +' + ($data) + ' ';
	              if ($type == 'integer') {
	                out += ' && !(' + ($data) + ' % 1)';
	              }
	              out += ')) ' + ($coerced) + ' = +' + ($data) + '; ';
	            } else if ($type == 'boolean') {
	              out += ' else if (' + ($data) + ' === \'false\' || ' + ($data) + ' === 0 || ' + ($data) + ' === null) ' + ($coerced) + ' = false; else if (' + ($data) + ' === \'true\' || ' + ($data) + ' === 1) ' + ($coerced) + ' = true; ';
	            } else if ($type == 'null') {
	              out += ' else if (' + ($data) + ' === \'\' || ' + ($data) + ' === 0 || ' + ($data) + ' === false) ' + ($coerced) + ' = null; ';
	            } else if (it.opts.coerceTypes == 'array' && $type == 'array') {
	              out += ' else if (' + ($dataType) + ' == \'string\' || ' + ($dataType) + ' == \'number\' || ' + ($dataType) + ' == \'boolean\' || ' + ($data) + ' == null) ' + ($coerced) + ' = [' + ($data) + ']; ';
	            }
	          }
	        }
	        out += ' else {   ';
	        var $$outStack = $$outStack || [];
	        $$outStack.push(out);
	        out = '';
	        if (it.createErrors !== false) {
	          out += ' { keyword: \'' + ($errorKeyword || 'type') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { type: \'';
	          if ($typeIsArray) {
	            out += '' + ($typeSchema.join(","));
	          } else {
	            out += '' + ($typeSchema);
	          }
	          out += '\' } ';
	          if (it.opts.messages !== false) {
	            out += ' , message: \'should be ';
	            if ($typeIsArray) {
	              out += '' + ($typeSchema.join(","));
	            } else {
	              out += '' + ($typeSchema);
	            }
	            out += '\' ';
	          }
	          if (it.opts.verbose) {
	            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
	          }
	          out += ' } ';
	        } else {
	          out += ' {} ';
	        }
	        var __err = out;
	        out = $$outStack.pop();
	        if (!it.compositeRule && $breakOnError) {
	          if (it.async) {
	            out += ' throw new ValidationError([' + (__err) + ']); ';
	          } else {
	            out += ' validate.errors = [' + (__err) + ']; return false; ';
	          }
	        } else {
	          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
	        }
	        out += ' } if (' + ($coerced) + ' !== undefined) {  ';
	        var $parentData = $dataLvl ? 'data' + (($dataLvl - 1) || '') : 'parentData',
	          $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';
	        out += ' ' + ($data) + ' = ' + ($coerced) + '; ';
	        if (!$dataLvl) {
	          out += 'if (' + ($parentData) + ' !== undefined)';
	        }
	        out += ' ' + ($parentData) + '[' + ($parentDataProperty) + '] = ' + ($coerced) + '; } ';
	      } else {
	        var $$outStack = $$outStack || [];
	        $$outStack.push(out);
	        out = '';
	        if (it.createErrors !== false) {
	          out += ' { keyword: \'' + ($errorKeyword || 'type') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { type: \'';
	          if ($typeIsArray) {
	            out += '' + ($typeSchema.join(","));
	          } else {
	            out += '' + ($typeSchema);
	          }
	          out += '\' } ';
	          if (it.opts.messages !== false) {
	            out += ' , message: \'should be ';
	            if ($typeIsArray) {
	              out += '' + ($typeSchema.join(","));
	            } else {
	              out += '' + ($typeSchema);
	            }
	            out += '\' ';
	          }
	          if (it.opts.verbose) {
	            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
	          }
	          out += ' } ';
	        } else {
	          out += ' {} ';
	        }
	        var __err = out;
	        out = $$outStack.pop();
	        if (!it.compositeRule && $breakOnError) {
	          if (it.async) {
	            out += ' throw new ValidationError([' + (__err) + ']); ';
	          } else {
	            out += ' validate.errors = [' + (__err) + ']; return false; ';
	          }
	        } else {
	          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
	        }
	      }
	      out += ' } ';
	    }
	  }
	  if (it.schema.$ref && !$refKeywords) {
	    out += ' ' + (it.RULES.all.$ref.code(it, '$ref')) + ' ';
	    if ($breakOnError) {
	      out += ' } if (errors === ';
	      if ($top) {
	        out += '0';
	      } else {
	        out += 'errs_' + ($lvl);
	      }
	      out += ') { ';
	      $closingBraces2 += '}';
	    }
	  } else {
	    var arr2 = it.RULES;
	    if (arr2) {
	      var $rulesGroup, i2 = -1,
	        l2 = arr2.length - 1;
	      while (i2 < l2) {
	        $rulesGroup = arr2[i2 += 1];
	        if ($shouldUseGroup($rulesGroup)) {
	          if ($rulesGroup.type) {
	            out += ' if (' + (it.util.checkDataType($rulesGroup.type, $data, it.opts.strictNumbers)) + ') { ';
	          }
	          if (it.opts.useDefaults) {
	            if ($rulesGroup.type == 'object' && it.schema.properties) {
	              var $schema = it.schema.properties,
	                $schemaKeys = Object.keys($schema);
	              var arr3 = $schemaKeys;
	              if (arr3) {
	                var $propertyKey, i3 = -1,
	                  l3 = arr3.length - 1;
	                while (i3 < l3) {
	                  $propertyKey = arr3[i3 += 1];
	                  var $sch = $schema[$propertyKey];
	                  if ($sch.default !== undefined) {
	                    var $passData = $data + it.util.getProperty($propertyKey);
	                    if (it.compositeRule) {
	                      if (it.opts.strictDefaults) {
	                        var $defaultMsg = 'default is ignored for: ' + $passData;
	                        if (it.opts.strictDefaults === 'log') it.logger.warn($defaultMsg);
	                        else throw new Error($defaultMsg);
	                      }
	                    } else {
	                      out += ' if (' + ($passData) + ' === undefined ';
	                      if (it.opts.useDefaults == 'empty') {
	                        out += ' || ' + ($passData) + ' === null || ' + ($passData) + ' === \'\' ';
	                      }
	                      out += ' ) ' + ($passData) + ' = ';
	                      if (it.opts.useDefaults == 'shared') {
	                        out += ' ' + (it.useDefault($sch.default)) + ' ';
	                      } else {
	                        out += ' ' + (JSON.stringify($sch.default)) + ' ';
	                      }
	                      out += '; ';
	                    }
	                  }
	                }
	              }
	            } else if ($rulesGroup.type == 'array' && Array.isArray(it.schema.items)) {
	              var arr4 = it.schema.items;
	              if (arr4) {
	                var $sch, $i = -1,
	                  l4 = arr4.length - 1;
	                while ($i < l4) {
	                  $sch = arr4[$i += 1];
	                  if ($sch.default !== undefined) {
	                    var $passData = $data + '[' + $i + ']';
	                    if (it.compositeRule) {
	                      if (it.opts.strictDefaults) {
	                        var $defaultMsg = 'default is ignored for: ' + $passData;
	                        if (it.opts.strictDefaults === 'log') it.logger.warn($defaultMsg);
	                        else throw new Error($defaultMsg);
	                      }
	                    } else {
	                      out += ' if (' + ($passData) + ' === undefined ';
	                      if (it.opts.useDefaults == 'empty') {
	                        out += ' || ' + ($passData) + ' === null || ' + ($passData) + ' === \'\' ';
	                      }
	                      out += ' ) ' + ($passData) + ' = ';
	                      if (it.opts.useDefaults == 'shared') {
	                        out += ' ' + (it.useDefault($sch.default)) + ' ';
	                      } else {
	                        out += ' ' + (JSON.stringify($sch.default)) + ' ';
	                      }
	                      out += '; ';
	                    }
	                  }
	                }
	              }
	            }
	          }
	          var arr5 = $rulesGroup.rules;
	          if (arr5) {
	            var $rule, i5 = -1,
	              l5 = arr5.length - 1;
	            while (i5 < l5) {
	              $rule = arr5[i5 += 1];
	              if ($shouldUseRule($rule)) {
	                var $code = $rule.code(it, $rule.keyword, $rulesGroup.type);
	                if ($code) {
	                  out += ' ' + ($code) + ' ';
	                  if ($breakOnError) {
	                    $closingBraces1 += '}';
	                  }
	                }
	              }
	            }
	          }
	          if ($breakOnError) {
	            out += ' ' + ($closingBraces1) + ' ';
	            $closingBraces1 = '';
	          }
	          if ($rulesGroup.type) {
	            out += ' } ';
	            if ($typeSchema && $typeSchema === $rulesGroup.type && !$coerceToTypes) {
	              out += ' else { ';
	              var $schemaPath = it.schemaPath + '.type',
	                $errSchemaPath = it.errSchemaPath + '/type';
	              var $$outStack = $$outStack || [];
	              $$outStack.push(out);
	              out = '';
	              if (it.createErrors !== false) {
	                out += ' { keyword: \'' + ($errorKeyword || 'type') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { type: \'';
	                if ($typeIsArray) {
	                  out += '' + ($typeSchema.join(","));
	                } else {
	                  out += '' + ($typeSchema);
	                }
	                out += '\' } ';
	                if (it.opts.messages !== false) {
	                  out += ' , message: \'should be ';
	                  if ($typeIsArray) {
	                    out += '' + ($typeSchema.join(","));
	                  } else {
	                    out += '' + ($typeSchema);
	                  }
	                  out += '\' ';
	                }
	                if (it.opts.verbose) {
	                  out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
	                }
	                out += ' } ';
	              } else {
	                out += ' {} ';
	              }
	              var __err = out;
	              out = $$outStack.pop();
	              if (!it.compositeRule && $breakOnError) {
	                if (it.async) {
	                  out += ' throw new ValidationError([' + (__err) + ']); ';
	                } else {
	                  out += ' validate.errors = [' + (__err) + ']; return false; ';
	                }
	              } else {
	                out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
	              }
	              out += ' } ';
	            }
	          }
	          if ($breakOnError) {
	            out += ' if (errors === ';
	            if ($top) {
	              out += '0';
	            } else {
	              out += 'errs_' + ($lvl);
	            }
	            out += ') { ';
	            $closingBraces2 += '}';
	          }
	        }
	      }
	    }
	  }
	  if ($breakOnError) {
	    out += ' ' + ($closingBraces2) + ' ';
	  }
	  if ($top) {
	    if ($async) {
	      out += ' if (errors === 0) return data;           ';
	      out += ' else throw new ValidationError(vErrors); ';
	    } else {
	      out += ' validate.errors = vErrors; ';
	      out += ' return errors === 0;       ';
	    }
	    out += ' }; return validate;';
	  } else {
	    out += ' var ' + ($valid) + ' = errors === errs_' + ($lvl) + ';';
	  }
	  function $shouldUseGroup($rulesGroup) {
	    var rules = $rulesGroup.rules;
	    for (var i = 0; i < rules.length; i++)
	      if ($shouldUseRule(rules[i])) return true;
	  }
	  function $shouldUseRule($rule) {
	    return it.schema[$rule.keyword] !== undefined || ($rule.implements && $ruleImplementsSomeKeyword($rule));
	  }
	  function $ruleImplementsSomeKeyword($rule) {
	    var impl = $rule.implements;
	    for (var i = 0; i < impl.length; i++)
	      if (it.schema[impl[i]] !== undefined) return true;
	  }
	  return out;
	};
	return validate;
}

var compile_1;
var hasRequiredCompile$1;

function requireCompile$1 () {
	if (hasRequiredCompile$1) return compile_1;
	hasRequiredCompile$1 = 1;
	var resolve = requireResolve()
	  , util = requireUtil$3()
	  , errorClasses = requireError_classes()
	  , stableStringify = requireFastJsonStableStringify();
	var validateGenerator = requireValidate();
	var ucs2length = util.ucs2length;
	var equal = requireFastDeepEqual();
	var ValidationError = errorClasses.Validation;
	compile_1 = compile;
	function compile(schema, root, localRefs, baseId) {
	  var self = this
	    , opts = this._opts
	    , refVal = [ undefined ]
	    , refs = {}
	    , patterns = []
	    , patternsHash = {}
	    , defaults = []
	    , defaultsHash = {}
	    , customRules = [];
	  root = root || { schema: schema, refVal: refVal, refs: refs };
	  var c = checkCompiling.call(this, schema, root, baseId);
	  var compilation = this._compilations[c.index];
	  if (c.compiling) return (compilation.callValidate = callValidate);
	  var formats = this._formats;
	  var RULES = this.RULES;
	  try {
	    var v = localCompile(schema, root, localRefs, baseId);
	    compilation.validate = v;
	    var cv = compilation.callValidate;
	    if (cv) {
	      cv.schema = v.schema;
	      cv.errors = null;
	      cv.refs = v.refs;
	      cv.refVal = v.refVal;
	      cv.root = v.root;
	      cv.$async = v.$async;
	      if (opts.sourceCode) cv.source = v.source;
	    }
	    return v;
	  } finally {
	    endCompiling.call(this, schema, root, baseId);
	  }
	  function callValidate() {
	    var validate = compilation.validate;
	    var result = validate.apply(this, arguments);
	    callValidate.errors = validate.errors;
	    return result;
	  }
	  function localCompile(_schema, _root, localRefs, baseId) {
	    var isRoot = !_root || (_root && _root.schema == _schema);
	    if (_root.schema != root.schema)
	      return compile.call(self, _schema, _root, localRefs, baseId);
	    var $async = _schema.$async === true;
	    var sourceCode = validateGenerator({
	      isTop: true,
	      schema: _schema,
	      isRoot: isRoot,
	      baseId: baseId,
	      root: _root,
	      schemaPath: '',
	      errSchemaPath: '#',
	      errorPath: '""',
	      MissingRefError: errorClasses.MissingRef,
	      RULES: RULES,
	      validate: validateGenerator,
	      util: util,
	      resolve: resolve,
	      resolveRef: resolveRef,
	      usePattern: usePattern,
	      useDefault: useDefault,
	      useCustomRule: useCustomRule,
	      opts: opts,
	      formats: formats,
	      logger: self.logger,
	      self: self
	    });
	    sourceCode = vars(refVal, refValCode) + vars(patterns, patternCode)
	                   + vars(defaults, defaultCode) + vars(customRules, customRuleCode)
	                   + sourceCode;
	    if (opts.processCode) sourceCode = opts.processCode(sourceCode, _schema);
	    var validate;
	    try {
	      var makeValidate = new Function(
	        'self',
	        'RULES',
	        'formats',
	        'root',
	        'refVal',
	        'defaults',
	        'customRules',
	        'equal',
	        'ucs2length',
	        'ValidationError',
	        sourceCode
	      );
	      validate = makeValidate(
	        self,
	        RULES,
	        formats,
	        root,
	        refVal,
	        defaults,
	        customRules,
	        equal,
	        ucs2length,
	        ValidationError
	      );
	      refVal[0] = validate;
	    } catch(e) {
	      self.logger.error('Error compiling schema, function code:', sourceCode);
	      throw e;
	    }
	    validate.schema = _schema;
	    validate.errors = null;
	    validate.refs = refs;
	    validate.refVal = refVal;
	    validate.root = isRoot ? validate : _root;
	    if ($async) validate.$async = true;
	    if (opts.sourceCode === true) {
	      validate.source = {
	        code: sourceCode,
	        patterns: patterns,
	        defaults: defaults
	      };
	    }
	    return validate;
	  }
	  function resolveRef(baseId, ref, isRoot) {
	    ref = resolve.url(baseId, ref);
	    var refIndex = refs[ref];
	    var _refVal, refCode;
	    if (refIndex !== undefined) {
	      _refVal = refVal[refIndex];
	      refCode = 'refVal[' + refIndex + ']';
	      return resolvedRef(_refVal, refCode);
	    }
	    if (!isRoot && root.refs) {
	      var rootRefId = root.refs[ref];
	      if (rootRefId !== undefined) {
	        _refVal = root.refVal[rootRefId];
	        refCode = addLocalRef(ref, _refVal);
	        return resolvedRef(_refVal, refCode);
	      }
	    }
	    refCode = addLocalRef(ref);
	    var v = resolve.call(self, localCompile, root, ref);
	    if (v === undefined) {
	      var localSchema = localRefs && localRefs[ref];
	      if (localSchema) {
	        v = resolve.inlineRef(localSchema, opts.inlineRefs)
	            ? localSchema
	            : compile.call(self, localSchema, root, localRefs, baseId);
	      }
	    }
	    if (v === undefined) {
	      removeLocalRef(ref);
	    } else {
	      replaceLocalRef(ref, v);
	      return resolvedRef(v, refCode);
	    }
	  }
	  function addLocalRef(ref, v) {
	    var refId = refVal.length;
	    refVal[refId] = v;
	    refs[ref] = refId;
	    return 'refVal' + refId;
	  }
	  function removeLocalRef(ref) {
	    delete refs[ref];
	  }
	  function replaceLocalRef(ref, v) {
	    var refId = refs[ref];
	    refVal[refId] = v;
	  }
	  function resolvedRef(refVal, code) {
	    return typeof refVal == 'object' || typeof refVal == 'boolean'
	            ? { code: code, schema: refVal, inline: true }
	            : { code: code, $async: refVal && !!refVal.$async };
	  }
	  function usePattern(regexStr) {
	    var index = patternsHash[regexStr];
	    if (index === undefined) {
	      index = patternsHash[regexStr] = patterns.length;
	      patterns[index] = regexStr;
	    }
	    return 'pattern' + index;
	  }
	  function useDefault(value) {
	    switch (typeof value) {
	      case 'boolean':
	      case 'number':
	        return '' + value;
	      case 'string':
	        return util.toQuotedString(value);
	      case 'object':
	        if (value === null) return 'null';
	        var valueStr = stableStringify(value);
	        var index = defaultsHash[valueStr];
	        if (index === undefined) {
	          index = defaultsHash[valueStr] = defaults.length;
	          defaults[index] = value;
	        }
	        return 'default' + index;
	    }
	  }
	  function useCustomRule(rule, schema, parentSchema, it) {
	    if (self._opts.validateSchema !== false) {
	      var deps = rule.definition.dependencies;
	      if (deps && !deps.every(function(keyword) {
	        return Object.prototype.hasOwnProperty.call(parentSchema, keyword);
	      }))
	        throw new Error('parent schema must have all required keywords: ' + deps.join(','));
	      var validateSchema = rule.definition.validateSchema;
	      if (validateSchema) {
	        var valid = validateSchema(schema);
	        if (!valid) {
	          var message = 'keyword schema is invalid: ' + self.errorsText(validateSchema.errors);
	          if (self._opts.validateSchema == 'log') self.logger.error(message);
	          else throw new Error(message);
	        }
	      }
	    }
	    var compile = rule.definition.compile
	      , inline = rule.definition.inline
	      , macro = rule.definition.macro;
	    var validate;
	    if (compile) {
	      validate = compile.call(self, schema, parentSchema, it);
	    } else if (macro) {
	      validate = macro.call(self, schema, parentSchema, it);
	      if (opts.validateSchema !== false) self.validateSchema(validate, true);
	    } else if (inline) {
	      validate = inline.call(self, it, rule.keyword, schema, parentSchema);
	    } else {
	      validate = rule.definition.validate;
	      if (!validate) return;
	    }
	    if (validate === undefined)
	      throw new Error('custom keyword "' + rule.keyword + '"failed to compile');
	    var index = customRules.length;
	    customRules[index] = validate;
	    return {
	      code: 'customRule' + index,
	      validate: validate
	    };
	  }
	}
	function checkCompiling(schema, root, baseId) {
	  var index = compIndex.call(this, schema, root, baseId);
	  if (index >= 0) return { index: index, compiling: true };
	  index = this._compilations.length;
	  this._compilations[index] = {
	    schema: schema,
	    root: root,
	    baseId: baseId
	  };
	  return { index: index, compiling: false };
	}
	function endCompiling(schema, root, baseId) {
	  var i = compIndex.call(this, schema, root, baseId);
	  if (i >= 0) this._compilations.splice(i, 1);
	}
	function compIndex(schema, root, baseId) {
	  for (var i=0; i<this._compilations.length; i++) {
	    var c = this._compilations[i];
	    if (c.schema == schema && c.root == root && c.baseId == baseId) return i;
	  }
	  return -1;
	}
	function patternCode(i, patterns) {
	  return 'var pattern' + i + ' = new RegExp(' + util.toQuotedString(patterns[i]) + ');';
	}
	function defaultCode(i) {
	  return 'var default' + i + ' = defaults[' + i + '];';
	}
	function refValCode(i, refVal) {
	  return refVal[i] === undefined ? '' : 'var refVal' + i + ' = refVal[' + i + '];';
	}
	function customRuleCode(i) {
	  return 'var customRule' + i + ' = customRules[' + i + '];';
	}
	function vars(arr, statement) {
	  if (!arr.length) return '';
	  var code = '';
	  for (var i=0; i<arr.length; i++)
	    code += statement(i, arr);
	  return code;
	}
	return compile_1;
}

var cache = {exports: {}};

var hasRequiredCache;

function requireCache () {
	if (hasRequiredCache) return cache.exports;
	hasRequiredCache = 1;
	var Cache = cache.exports = function Cache() {
	  this._cache = {};
	};
	Cache.prototype.put = function Cache_put(key, value) {
	  this._cache[key] = value;
	};
	Cache.prototype.get = function Cache_get(key) {
	  return this._cache[key];
	};
	Cache.prototype.del = function Cache_del(key) {
	  delete this._cache[key];
	};
	Cache.prototype.clear = function Cache_clear() {
	  this._cache = {};
	};
	return cache.exports;
}

var formats_1;
var hasRequiredFormats;

function requireFormats () {
	if (hasRequiredFormats) return formats_1;
	hasRequiredFormats = 1;
	var util = requireUtil$3();
	var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
	var DAYS = [0,31,28,31,30,31,30,31,31,30,31,30,31];
	var TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
	var HOSTNAME = /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i;
	var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
	var URIREF = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
	var URITEMPLATE = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i;
	var URL = /^(?:(?:http[s\u017F]?|ftp):\/\/)(?:(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+(?::(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?@)?(?:(?!10(?:\.[0-9]{1,3}){3})(?!127(?:\.[0-9]{1,3}){3})(?!169\.254(?:\.[0-9]{1,3}){2})(?!192\.168(?:\.[0-9]{1,3}){2})(?!172\.(?:1[6-9]|2[0-9]|3[01])(?:\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)(?:\.(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)*(?:\.(?:(?:[a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\/(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?$/i;
	var UUID = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;
	var JSON_POINTER = /^(?:\/(?:[^~/]|~0|~1)*)*$/;
	var JSON_POINTER_URI_FRAGMENT = /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;
	var RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/;
	formats_1 = formats;
	function formats(mode) {
	  mode = mode == 'full' ? 'full' : 'fast';
	  return util.copy(formats[mode]);
	}
	formats.fast = {
	  date: /^\d\d\d\d-[0-1]\d-[0-3]\d$/,
	  time: /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i,
	  'date-time': /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i,
	  uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
	  'uri-reference': /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
	  'uri-template': URITEMPLATE,
	  url: URL,
	  email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
	  hostname: HOSTNAME,
	  ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
	  ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
	  regex: regex,
	  uuid: UUID,
	  'json-pointer': JSON_POINTER,
	  'json-pointer-uri-fragment': JSON_POINTER_URI_FRAGMENT,
	  'relative-json-pointer': RELATIVE_JSON_POINTER
	};
	formats.full = {
	  date: date,
	  time: time,
	  'date-time': date_time,
	  uri: uri,
	  'uri-reference': URIREF,
	  'uri-template': URITEMPLATE,
	  url: URL,
	  email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
	  hostname: HOSTNAME,
	  ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
	  ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
	  regex: regex,
	  uuid: UUID,
	  'json-pointer': JSON_POINTER,
	  'json-pointer-uri-fragment': JSON_POINTER_URI_FRAGMENT,
	  'relative-json-pointer': RELATIVE_JSON_POINTER
	};
	function isLeapYear(year) {
	  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
	}
	function date(str) {
	  var matches = str.match(DATE);
	  if (!matches) return false;
	  var year = +matches[1];
	  var month = +matches[2];
	  var day = +matches[3];
	  return month >= 1 && month <= 12 && day >= 1 &&
	          day <= (month == 2 && isLeapYear(year) ? 29 : DAYS[month]);
	}
	function time(str, full) {
	  var matches = str.match(TIME);
	  if (!matches) return false;
	  var hour = matches[1];
	  var minute = matches[2];
	  var second = matches[3];
	  var timeZone = matches[5];
	  return ((hour <= 23 && minute <= 59 && second <= 59) ||
	          (hour == 23 && minute == 59 && second == 60)) &&
	         (!full || timeZone);
	}
	var DATE_TIME_SEPARATOR = /t|\s/i;
	function date_time(str) {
	  var dateTime = str.split(DATE_TIME_SEPARATOR);
	  return dateTime.length == 2 && date(dateTime[0]) && time(dateTime[1], true);
	}
	var NOT_URI_FRAGMENT = /\/|:/;
	function uri(str) {
	  return NOT_URI_FRAGMENT.test(str) && URI.test(str);
	}
	var Z_ANCHOR = /[^\\]\\Z/;
	function regex(str) {
	  if (Z_ANCHOR.test(str)) return false;
	  try {
	    new RegExp(str);
	    return true;
	  } catch(e) {
	    return false;
	  }
	}
	return formats_1;
}

var ref;
var hasRequiredRef;

function requireRef () {
	if (hasRequiredRef) return ref;
	hasRequiredRef = 1;
	ref = function generate_ref(it, $keyword, $ruleType) {
	  var out = ' ';
	  var $lvl = it.level;
	  var $dataLvl = it.dataLevel;
	  var $schema = it.schema[$keyword];
	  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
	  var $breakOnError = !it.opts.allErrors;
	  var $data = 'data' + ($dataLvl || '');
	  var $valid = 'valid' + $lvl;
	  var $async, $refCode;
	  if ($schema == '#' || $schema == '#/') {
	    if (it.isRoot) {
	      $async = it.async;
	      $refCode = 'validate';
	    } else {
	      $async = it.root.schema.$async === true;
	      $refCode = 'root.refVal[0]';
	    }
	  } else {
	    var $refVal = it.resolveRef(it.baseId, $schema, it.isRoot);
	    if ($refVal === undefined) {
	      var $message = it.MissingRefError.message(it.baseId, $schema);
	      if (it.opts.missingRefs == 'fail') {
	        it.logger.error($message);
	        var $$outStack = $$outStack || [];
	        $$outStack.push(out);
	        out = '';
	        if (it.createErrors !== false) {
	          out += ' { keyword: \'' + ('$ref') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { ref: \'' + (it.util.escapeQuotes($schema)) + '\' } ';
	          if (it.opts.messages !== false) {
	            out += ' , message: \'can\\\'t resolve reference ' + (it.util.escapeQuotes($schema)) + '\' ';
	          }
	          if (it.opts.verbose) {
	            out += ' , schema: ' + (it.util.toQuotedString($schema)) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
	          }
	          out += ' } ';
	        } else {
	          out += ' {} ';
	        }
	        var __err = out;
	        out = $$outStack.pop();
	        if (!it.compositeRule && $breakOnError) {
	          if (it.async) {
	            out += ' throw new ValidationError([' + (__err) + ']); ';
	          } else {
	            out += ' validate.errors = [' + (__err) + ']; return false; ';
	          }
	        } else {
	          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
	        }
	        if ($breakOnError) {
	          out += ' if (false) { ';
	        }
	      } else if (it.opts.missingRefs == 'ignore') {
	        it.logger.warn($message);
	        if ($breakOnError) {
	          out += ' if (true) { ';
	        }
	      } else {
	        throw new it.MissingRefError(it.baseId, $schema, $message);
	      }
	    } else if ($refVal.inline) {
	      var $it = it.util.copy(it);
	      $it.level++;
	      var $nextValid = 'valid' + $it.level;
	      $it.schema = $refVal.schema;
	      $it.schemaPath = '';
	      $it.errSchemaPath = $schema;
	      var $code = it.validate($it).replace(/validate\.schema/g, $refVal.code);
	      out += ' ' + ($code) + ' ';
	      if ($breakOnError) {
	        out += ' if (' + ($nextValid) + ') { ';
	      }
	    } else {
	      $async = $refVal.$async === true || (it.async && $refVal.$async !== false);
	      $refCode = $refVal.code;
	    }
	  }
	  if ($refCode) {
	    var $$outStack = $$outStack || [];
	    $$outStack.push(out);
	    out = '';
	    if (it.opts.passContext) {
	      out += ' ' + ($refCode) + '.call(this, ';
	    } else {
	      out += ' ' + ($refCode) + '( ';
	    }
	    out += ' ' + ($data) + ', (dataPath || \'\')';
	    if (it.errorPath != '""') {
	      out += ' + ' + (it.errorPath);
	    }
	    var $parentData = $dataLvl ? 'data' + (($dataLvl - 1) || '') : 'parentData',
	      $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';
	    out += ' , ' + ($parentData) + ' , ' + ($parentDataProperty) + ', rootData)  ';
	    var __callValidate = out;
	    out = $$outStack.pop();
	    if ($async) {
	      if (!it.async) throw new Error('async schema referenced by sync schema');
	      if ($breakOnError) {
	        out += ' var ' + ($valid) + '; ';
	      }
	      out += ' try { await ' + (__callValidate) + '; ';
	      if ($breakOnError) {
	        out += ' ' + ($valid) + ' = true; ';
	      }
	      out += ' } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; ';
	      if ($breakOnError) {
	        out += ' ' + ($valid) + ' = false; ';
	      }
	      out += ' } ';
	      if ($breakOnError) {
	        out += ' if (' + ($valid) + ') { ';
	      }
	    } else {
	      out += ' if (!' + (__callValidate) + ') { if (vErrors === null) vErrors = ' + ($refCode) + '.errors; else vErrors = vErrors.concat(' + ($refCode) + '.errors); errors = vErrors.length; } ';
	      if ($breakOnError) {
	        out += ' else { ';
	      }
	    }
	  }
	  return out;
	};
	return ref;
}

var allOf;
var hasRequiredAllOf;

function requireAllOf () {
	if (hasRequiredAllOf) return allOf;
	hasRequiredAllOf = 1;
	allOf = function generate_allOf(it, $keyword, $ruleType) {
	  var out = ' ';
	  var $schema = it.schema[$keyword];
	  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
	  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
	  var $breakOnError = !it.opts.allErrors;
	  var $it = it.util.copy(it);
	  var $closingBraces = '';
	  $it.level++;
	  var $nextValid = 'valid' + $it.level;
	  var $currentBaseId = $it.baseId,
	    $allSchemasEmpty = true;
	  var arr1 = $schema;
	  if (arr1) {
	    var $sch, $i = -1,
	      l1 = arr1.length - 1;
	    while ($i < l1) {
	      $sch = arr1[$i += 1];
	      if ((it.opts.strictKeywords ? (typeof $sch == 'object' && Object.keys($sch).length > 0) || $sch === false : it.util.schemaHasRules($sch, it.RULES.all))) {
	        $allSchemasEmpty = false;
	        $it.schema = $sch;
	        $it.schemaPath = $schemaPath + '[' + $i + ']';
	        $it.errSchemaPath = $errSchemaPath + '/' + $i;
	        out += '  ' + (it.validate($it)) + ' ';
	        $it.baseId = $currentBaseId;
	        if ($breakOnError) {
	          out += ' if (' + ($nextValid) + ') { ';
	          $closingBraces += '}';
	        }
	      }
	    }
	  }
	  if ($breakOnError) {
	    if ($allSchemasEmpty) {
	      out += ' if (true) { ';
	    } else {
	      out += ' ' + ($closingBraces.slice(0, -1)) + ' ';
	    }
	  }
	  return out;
	};
	return allOf;
}

var anyOf;
var hasRequiredAnyOf;

function requireAnyOf () {
	if (hasRequiredAnyOf) return anyOf;
	hasRequiredAnyOf = 1;
	anyOf = function generate_anyOf(it, $keyword, $ruleType) {
	  var out = ' ';
	  var $lvl = it.level;
	  var $dataLvl = it.dataLevel;
	  var $schema = it.schema[$keyword];
	  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
	  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
	  var $breakOnError = !it.opts.allErrors;
	  var $data = 'data' + ($dataLvl || '');
	  var $valid = 'valid' + $lvl;
	  var $errs = 'errs__' + $lvl;
	  var $it = it.util.copy(it);
	  var $closingBraces = '';
	  $it.level++;
	  var $nextValid = 'valid' + $it.level;
	  var $noEmptySchema = $schema.every(function($sch) {
	    return (it.opts.strictKeywords ? (typeof $sch == 'object' && Object.keys($sch).length > 0) || $sch === false : it.util.schemaHasRules($sch, it.RULES.all));
	  });
	  if ($noEmptySchema) {
	    var $currentBaseId = $it.baseId;
	    out += ' var ' + ($errs) + ' = errors; var ' + ($valid) + ' = false;  ';
	    var $wasComposite = it.compositeRule;
	    it.compositeRule = $it.compositeRule = true;
	    var arr1 = $schema;
	    if (arr1) {
	      var $sch, $i = -1,
	        l1 = arr1.length - 1;
	      while ($i < l1) {
	        $sch = arr1[$i += 1];
	        $it.schema = $sch;
	        $it.schemaPath = $schemaPath + '[' + $i + ']';
	        $it.errSchemaPath = $errSchemaPath + '/' + $i;
	        out += '  ' + (it.validate($it)) + ' ';
	        $it.baseId = $currentBaseId;
	        out += ' ' + ($valid) + ' = ' + ($valid) + ' || ' + ($nextValid) + '; if (!' + ($valid) + ') { ';
	        $closingBraces += '}';
	      }
	    }
	    it.compositeRule = $it.compositeRule = $wasComposite;
	    out += ' ' + ($closingBraces) + ' if (!' + ($valid) + ') {   var err =   ';
	    if (it.createErrors !== false) {
	      out += ' { keyword: \'' + ('anyOf') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
	      if (it.opts.messages !== false) {
	        out += ' , message: \'should match some schema in anyOf\' ';
	      }
	      if (it.opts.verbose) {
	        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
	      }
	      out += ' } ';
	    } else {
	      out += ' {} ';
	    }
	    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
	    if (!it.compositeRule && $breakOnError) {
	      if (it.async) {
	        out += ' throw new ValidationError(vErrors); ';
	      } else {
	        out += ' validate.errors = vErrors; return false; ';
	      }
	    }
	    out += ' } else {  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; } ';
	    if (it.opts.allErrors) {
	      out += ' } ';
	    }
	  } else {
	    if ($breakOnError) {
	      out += ' if (true) { ';
	    }
	  }
	  return out;
	};
	return anyOf;
}

var comment;
var hasRequiredComment;

function requireComment () {
	if (hasRequiredComment) return comment;
	hasRequiredComment = 1;
	comment = function generate_comment(it, $keyword, $ruleType) {
	  var out = ' ';
	  var $schema = it.schema[$keyword];
	  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
	  !it.opts.allErrors;
	  var $comment = it.util.toQuotedString($schema);
	  if (it.opts.$comment === true) {
	    out += ' console.log(' + ($comment) + ');';
	  } else if (typeof it.opts.$comment == 'function') {
	    out += ' self._opts.$comment(' + ($comment) + ', ' + (it.util.toQuotedString($errSchemaPath)) + ', validate.root.schema);';
	  }
	  return out;
	};
	return comment;
}

var _const;
var hasRequired_const;

function require_const () {
	if (hasRequired_const) return _const;
	hasRequired_const = 1;
	_const = function generate_const(it, $keyword, $ruleType) {
	  var out = ' ';
	  var $lvl = it.level;
	  var $dataLvl = it.dataLevel;
	  var $schema = it.schema[$keyword];
	  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
	  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
	  var $breakOnError = !it.opts.allErrors;
	  var $data = 'data' + ($dataLvl || '');
	  var $valid = 'valid' + $lvl;
	  var $isData = it.opts.$data && $schema && $schema.$data;
	  if ($isData) {
	    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
	  }
	  if (!$isData) {
	    out += ' var schema' + ($lvl) + ' = validate.schema' + ($schemaPath) + ';';
	  }
	  out += 'var ' + ($valid) + ' = equal(' + ($data) + ', schema' + ($lvl) + '); if (!' + ($valid) + ') {   ';
	  var $$outStack = $$outStack || [];
	  $$outStack.push(out);
	  out = '';
	  if (it.createErrors !== false) {
	    out += ' { keyword: \'' + ('const') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { allowedValue: schema' + ($lvl) + ' } ';
	    if (it.opts.messages !== false) {
	      out += ' , message: \'should be equal to constant\' ';
	    }
	    if (it.opts.verbose) {
	      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
	    }
	    out += ' } ';
	  } else {
	    out += ' {} ';
	  }
	  var __err = out;
	  out = $$outStack.pop();
	  if (!it.compositeRule && $breakOnError) {
	    if (it.async) {
	      out += ' throw new ValidationError([' + (__err) + ']); ';
	    } else {
	      out += ' validate.errors = [' + (__err) + ']; return false; ';
	    }
	  } else {
	    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
	  }
	  out += ' }';
	  if ($breakOnError) {
	    out += ' else { ';
	  }
	  return out;
	};
	return _const;
}

var contains;
var hasRequiredContains;

function requireContains () {
	if (hasRequiredContains) return contains;
	hasRequiredContains = 1;
	contains = function generate_contains(it, $keyword, $ruleType) {
	  var out = ' ';
	  var $lvl = it.level;
	  var $dataLvl = it.dataLevel;
	  var $schema = it.schema[$keyword];
	  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
	  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
	  var $breakOnError = !it.opts.allErrors;
	  var $data = 'data' + ($dataLvl || '');
	  var $valid = 'valid' + $lvl;
	  var $errs = 'errs__' + $lvl;
	  var $it = it.util.copy(it);
	  var $closingBraces = '';
	  $it.level++;
	  var $nextValid = 'valid' + $it.level;
	  var $idx = 'i' + $lvl,
	    $dataNxt = $it.dataLevel = it.dataLevel + 1,
	    $nextData = 'data' + $dataNxt,
	    $currentBaseId = it.baseId,
	    $nonEmptySchema = (it.opts.strictKeywords ? (typeof $schema == 'object' && Object.keys($schema).length > 0) || $schema === false : it.util.schemaHasRules($schema, it.RULES.all));
	  out += 'var ' + ($errs) + ' = errors;var ' + ($valid) + ';';
	  if ($nonEmptySchema) {
	    var $wasComposite = it.compositeRule;
	    it.compositeRule = $it.compositeRule = true;
	    $it.schema = $schema;
	    $it.schemaPath = $schemaPath;
	    $it.errSchemaPath = $errSchemaPath;
	    out += ' var ' + ($nextValid) + ' = false; for (var ' + ($idx) + ' = 0; ' + ($idx) + ' < ' + ($data) + '.length; ' + ($idx) + '++) { ';
	    $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
	    var $passData = $data + '[' + $idx + ']';
	    $it.dataPathArr[$dataNxt] = $idx;
	    var $code = it.validate($it);
	    $it.baseId = $currentBaseId;
	    if (it.util.varOccurences($code, $nextData) < 2) {
	      out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
	    } else {
	      out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
	    }
	    out += ' if (' + ($nextValid) + ') break; }  ';
	    it.compositeRule = $it.compositeRule = $wasComposite;
	    out += ' ' + ($closingBraces) + ' if (!' + ($nextValid) + ') {';
	  } else {
	    out += ' if (' + ($data) + '.length == 0) {';
	  }
	  var $$outStack = $$outStack || [];
	  $$outStack.push(out);
	  out = '';
	  if (it.createErrors !== false) {
	    out += ' { keyword: \'' + ('contains') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
	    if (it.opts.messages !== false) {
	      out += ' , message: \'should contain a valid item\' ';
	    }
	    if (it.opts.verbose) {
	      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
	    }
	    out += ' } ';
	  } else {
	    out += ' {} ';
	  }
	  var __err = out;
	  out = $$outStack.pop();
	  if (!it.compositeRule && $breakOnError) {
	    if (it.async) {
	      out += ' throw new ValidationError([' + (__err) + ']); ';
	    } else {
	      out += ' validate.errors = [' + (__err) + ']; return false; ';
	    }
	  } else {
	    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
	  }
	  out += ' } else { ';
	  if ($nonEmptySchema) {
	    out += '  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; } ';
	  }
	  if (it.opts.allErrors) {
	    out += ' } ';
	  }
	  return out;
	};
	return contains;
}

var dependencies;
var hasRequiredDependencies;

function requireDependencies () {
	if (hasRequiredDependencies) return dependencies;
	hasRequiredDependencies = 1;
	dependencies = function generate_dependencies(it, $keyword, $ruleType) {
	  var out = ' ';
	  var $lvl = it.level;
	  var $dataLvl = it.dataLevel;
	  var $schema = it.schema[$keyword];
	  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
	  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
	  var $breakOnError = !it.opts.allErrors;
	  var $data = 'data' + ($dataLvl || '');
	  var $errs = 'errs__' + $lvl;
	  var $it = it.util.copy(it);
	  var $closingBraces = '';
	  $it.level++;
	  var $nextValid = 'valid' + $it.level;
	  var $schemaDeps = {},
	    $propertyDeps = {},
	    $ownProperties = it.opts.ownProperties;
	  for ($property in $schema) {
	    if ($property == '__proto__') continue;
	    var $sch = $schema[$property];
	    var $deps = Array.isArray($sch) ? $propertyDeps : $schemaDeps;
	    $deps[$property] = $sch;
	  }
	  out += 'var ' + ($errs) + ' = errors;';
	  var $currentErrorPath = it.errorPath;
	  out += 'var missing' + ($lvl) + ';';
	  for (var $property in $propertyDeps) {
	    $deps = $propertyDeps[$property];
	    if ($deps.length) {
	      out += ' if ( ' + ($data) + (it.util.getProperty($property)) + ' !== undefined ';
	      if ($ownProperties) {
	        out += ' && Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($property)) + '\') ';
	      }
	      if ($breakOnError) {
	        out += ' && ( ';
	        var arr1 = $deps;
	        if (arr1) {
	          var $propertyKey, $i = -1,
	            l1 = arr1.length - 1;
	          while ($i < l1) {
	            $propertyKey = arr1[$i += 1];
	            if ($i) {
	              out += ' || ';
	            }
	            var $prop = it.util.getProperty($propertyKey),
	              $useData = $data + $prop;
	            out += ' ( ( ' + ($useData) + ' === undefined ';
	            if ($ownProperties) {
	              out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
	            }
	            out += ') && (missing' + ($lvl) + ' = ' + (it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop)) + ') ) ';
	          }
	        }
	        out += ')) {  ';
	        var $propertyPath = 'missing' + $lvl,
	          $missingProperty = '\' + ' + $propertyPath + ' + \'';
	        if (it.opts._errorDataPathProperty) {
	          it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + ' + ' + $propertyPath;
	        }
	        var $$outStack = $$outStack || [];
	        $$outStack.push(out);
	        out = '';
	        if (it.createErrors !== false) {
	          out += ' { keyword: \'' + ('dependencies') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { property: \'' + (it.util.escapeQuotes($property)) + '\', missingProperty: \'' + ($missingProperty) + '\', depsCount: ' + ($deps.length) + ', deps: \'' + (it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", "))) + '\' } ';
	          if (it.opts.messages !== false) {
	            out += ' , message: \'should have ';
	            if ($deps.length == 1) {
	              out += 'property ' + (it.util.escapeQuotes($deps[0]));
	            } else {
	              out += 'properties ' + (it.util.escapeQuotes($deps.join(", ")));
	            }
	            out += ' when property ' + (it.util.escapeQuotes($property)) + ' is present\' ';
	          }
	          if (it.opts.verbose) {
	            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
	          }
	          out += ' } ';
	        } else {
	          out += ' {} ';
	        }
	        var __err = out;
	        out = $$outStack.pop();
	        if (!it.compositeRule && $breakOnError) {
	          if (it.async) {
	            out += ' throw new ValidationError([' + (__err) + ']); ';
	          } else {
	            out += ' validate.errors = [' + (__err) + ']; return false; ';
	          }
	        } else {
	          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
	        }
	      } else {
	        out += ' ) { ';
	        var arr2 = $deps;
	        if (arr2) {
	          var $propertyKey, i2 = -1,
	            l2 = arr2.length - 1;
	          while (i2 < l2) {
	            $propertyKey = arr2[i2 += 1];
	            var $prop = it.util.getProperty($propertyKey),
	              $missingProperty = it.util.escapeQuotes($propertyKey),
	              $useData = $data + $prop;
	            if (it.opts._errorDataPathProperty) {
	              it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
	            }
	            out += ' if ( ' + ($useData) + ' === undefined ';
	            if ($ownProperties) {
	              out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
	            }
	            out += ') {  var err =   ';
	            if (it.createErrors !== false) {
	              out += ' { keyword: \'' + ('dependencies') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { property: \'' + (it.util.escapeQuotes($property)) + '\', missingProperty: \'' + ($missingProperty) + '\', depsCount: ' + ($deps.length) + ', deps: \'' + (it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", "))) + '\' } ';
	              if (it.opts.messages !== false) {
	                out += ' , message: \'should have ';
	                if ($deps.length == 1) {
	                  out += 'property ' + (it.util.escapeQuotes($deps[0]));
	                } else {
	                  out += 'properties ' + (it.util.escapeQuotes($deps.join(", ")));
	                }
	                out += ' when property ' + (it.util.escapeQuotes($property)) + ' is present\' ';
	              }
	              if (it.opts.verbose) {
	                out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
	              }
	              out += ' } ';
	            } else {
	              out += ' {} ';
	            }
	            out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ';
	          }
	        }
	      }
	      out += ' }   ';
	      if ($breakOnError) {
	        $closingBraces += '}';
	        out += ' else { ';
	      }
	    }
	  }
	  it.errorPath = $currentErrorPath;
	  var $currentBaseId = $it.baseId;
	  for (var $property in $schemaDeps) {
	    var $sch = $schemaDeps[$property];
	    if ((it.opts.strictKeywords ? (typeof $sch == 'object' && Object.keys($sch).length > 0) || $sch === false : it.util.schemaHasRules($sch, it.RULES.all))) {
	      out += ' ' + ($nextValid) + ' = true; if ( ' + ($data) + (it.util.getProperty($property)) + ' !== undefined ';
	      if ($ownProperties) {
	        out += ' && Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($property)) + '\') ';
	      }
	      out += ') { ';
	      $it.schema = $sch;
	      $it.schemaPath = $schemaPath + it.util.getProperty($property);
	      $it.errSchemaPath = $errSchemaPath + '/' + it.util.escapeFragment($property);
	      out += '  ' + (it.validate($it)) + ' ';
	      $it.baseId = $currentBaseId;
	      out += ' }  ';
	      if ($breakOnError) {
	        out += ' if (' + ($nextValid) + ') { ';
	        $closingBraces += '}';
	      }
	    }
	  }
	  if ($breakOnError) {
	    out += '   ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';
	  }
	  return out;
	};
	return dependencies;
}

var _enum;
var hasRequired_enum;

function require_enum () {
	if (hasRequired_enum) return _enum;
	hasRequired_enum = 1;
	_enum = function generate_enum(it, $keyword, $ruleType) {
	  var out = ' ';
	  var $lvl = it.level;
	  var $dataLvl = it.dataLevel;
	  var $schema = it.schema[$keyword];
	  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
	  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
	  var $breakOnError = !it.opts.allErrors;
	  var $data = 'data' + ($dataLvl || '');
	  var $valid = 'valid' + $lvl;
	  var $isData = it.opts.$data && $schema && $schema.$data;
	  if ($isData) {
	    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
	  }
	  var $i = 'i' + $lvl,
	    $vSchema = 'schema' + $lvl;
	  if (!$isData) {
	    out += ' var ' + ($vSchema) + ' = validate.schema' + ($schemaPath) + ';';
	  }
	  out += 'var ' + ($valid) + ';';
	  if ($isData) {
	    out += ' if (schema' + ($lvl) + ' === undefined) ' + ($valid) + ' = true; else if (!Array.isArray(schema' + ($lvl) + ')) ' + ($valid) + ' = false; else {';
	  }
	  out += '' + ($valid) + ' = false;for (var ' + ($i) + '=0; ' + ($i) + '<' + ($vSchema) + '.length; ' + ($i) + '++) if (equal(' + ($data) + ', ' + ($vSchema) + '[' + ($i) + '])) { ' + ($valid) + ' = true; break; }';
	  if ($isData) {
	    out += '  }  ';
	  }
	  out += ' if (!' + ($valid) + ') {   ';
	  var $$outStack = $$outStack || [];
	  $$outStack.push(out);
	  out = '';
	  if (it.createErrors !== false) {
	    out += ' { keyword: \'' + ('enum') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { allowedValues: schema' + ($lvl) + ' } ';
	    if (it.opts.messages !== false) {
	      out += ' , message: \'should be equal to one of the allowed values\' ';
	    }
	    if (it.opts.verbose) {
	      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
	    }
	    out += ' } ';
	  } else {
	    out += ' {} ';
	  }
	  var __err = out;
	  out = $$outStack.pop();
	  if (!it.compositeRule && $breakOnError) {
	    if (it.async) {
	      out += ' throw new ValidationError([' + (__err) + ']); ';
	    } else {
	      out += ' validate.errors = [' + (__err) + ']; return false; ';
	    }
	  } else {
	    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
	  }
	  out += ' }';
	  if ($breakOnError) {
	    out += ' else { ';
	  }
	  return out;
	};
	return _enum;
}

var format;
var hasRequiredFormat;

function requireFormat () {
	if (hasRequiredFormat) return format;
	hasRequiredFormat = 1;
	format = function generate_format(it, $keyword, $ruleType) {
	  var out = ' ';
	  var $lvl = it.level;
	  var $dataLvl = it.dataLevel;
	  var $schema = it.schema[$keyword];
	  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
	  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
	  var $breakOnError = !it.opts.allErrors;
	  var $data = 'data' + ($dataLvl || '');
	  if (it.opts.format === false) {
	    if ($breakOnError) {
	      out += ' if (true) { ';
	    }
	    return out;
	  }
	  var $isData = it.opts.$data && $schema && $schema.$data,
	    $schemaValue;
	  if ($isData) {
	    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
	    $schemaValue = 'schema' + $lvl;
	  } else {
	    $schemaValue = $schema;
	  }
	  var $unknownFormats = it.opts.unknownFormats,
	    $allowUnknown = Array.isArray($unknownFormats);
	  if ($isData) {
	    var $format = 'format' + $lvl,
	      $isObject = 'isObject' + $lvl,
	      $formatType = 'formatType' + $lvl;
	    out += ' var ' + ($format) + ' = formats[' + ($schemaValue) + ']; var ' + ($isObject) + ' = typeof ' + ($format) + ' == \'object\' && !(' + ($format) + ' instanceof RegExp) && ' + ($format) + '.validate; var ' + ($formatType) + ' = ' + ($isObject) + ' && ' + ($format) + '.type || \'string\'; if (' + ($isObject) + ') { ';
	    if (it.async) {
	      out += ' var async' + ($lvl) + ' = ' + ($format) + '.async; ';
	    }
	    out += ' ' + ($format) + ' = ' + ($format) + '.validate; } if (  ';
	    if ($isData) {
	      out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'string\') || ';
	    }
	    out += ' (';
	    if ($unknownFormats != 'ignore') {
	      out += ' (' + ($schemaValue) + ' && !' + ($format) + ' ';
	      if ($allowUnknown) {
	        out += ' && self._opts.unknownFormats.indexOf(' + ($schemaValue) + ') == -1 ';
	      }
	      out += ') || ';
	    }
	    out += ' (' + ($format) + ' && ' + ($formatType) + ' == \'' + ($ruleType) + '\' && !(typeof ' + ($format) + ' == \'function\' ? ';
	    if (it.async) {
	      out += ' (async' + ($lvl) + ' ? await ' + ($format) + '(' + ($data) + ') : ' + ($format) + '(' + ($data) + ')) ';
	    } else {
	      out += ' ' + ($format) + '(' + ($data) + ') ';
	    }
	    out += ' : ' + ($format) + '.test(' + ($data) + '))))) {';
	  } else {
	    var $format = it.formats[$schema];
	    if (!$format) {
	      if ($unknownFormats == 'ignore') {
	        it.logger.warn('unknown format "' + $schema + '" ignored in schema at path "' + it.errSchemaPath + '"');
	        if ($breakOnError) {
	          out += ' if (true) { ';
	        }
	        return out;
	      } else if ($allowUnknown && $unknownFormats.indexOf($schema) >= 0) {
	        if ($breakOnError) {
	          out += ' if (true) { ';
	        }
	        return out;
	      } else {
	        throw new Error('unknown format "' + $schema + '" is used in schema at path "' + it.errSchemaPath + '"');
	      }
	    }
	    var $isObject = typeof $format == 'object' && !($format instanceof RegExp) && $format.validate;
	    var $formatType = $isObject && $format.type || 'string';
	    if ($isObject) {
	      var $async = $format.async === true;
	      $format = $format.validate;
	    }
	    if ($formatType != $ruleType) {
	      if ($breakOnError) {
	        out += ' if (true) { ';
	      }
	      return out;
	    }
	    if ($async) {
	      if (!it.async) throw new Error('async format in sync schema');
	      var $formatRef = 'formats' + it.util.getProperty($schema) + '.validate';
	      out += ' if (!(await ' + ($formatRef) + '(' + ($data) + '))) { ';
	    } else {
	      out += ' if (! ';
	      var $formatRef = 'formats' + it.util.getProperty($schema);
	      if ($isObject) $formatRef += '.validate';
	      if (typeof $format == 'function') {
	        out += ' ' + ($formatRef) + '(' + ($data) + ') ';
	      } else {
	        out += ' ' + ($formatRef) + '.test(' + ($data) + ') ';
	      }
	      out += ') { ';
	    }
	  }
	  var $$outStack = $$outStack || [];
	  $$outStack.push(out);
	  out = '';
	  if (it.createErrors !== false) {
	    out += ' { keyword: \'' + ('format') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { format:  ';
	    if ($isData) {
	      out += '' + ($schemaValue);
	    } else {
	      out += '' + (it.util.toQuotedString($schema));
	    }
	    out += '  } ';
	    if (it.opts.messages !== false) {
	      out += ' , message: \'should match format "';
	      if ($isData) {
	        out += '\' + ' + ($schemaValue) + ' + \'';
	      } else {
	        out += '' + (it.util.escapeQuotes($schema));
	      }
	      out += '"\' ';
	    }
	    if (it.opts.verbose) {
	      out += ' , schema:  ';
	      if ($isData) {
	        out += 'validate.schema' + ($schemaPath);
	      } else {
	        out += '' + (it.util.toQuotedString($schema));
	      }
	      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
	    }
	    out += ' } ';
	  } else {
	    out += ' {} ';
	  }
	  var __err = out;
	  out = $$outStack.pop();
	  if (!it.compositeRule && $breakOnError) {
	    if (it.async) {
	      out += ' throw new ValidationError([' + (__err) + ']); ';
	    } else {
	      out += ' validate.errors = [' + (__err) + ']; return false; ';
	    }
	  } else {
	    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
	  }
	  out += ' } ';
	  if ($breakOnError) {
	    out += ' else { ';
	  }
	  return out;
	};
	return format;
}

var _if;
var hasRequired_if;

function require_if () {
	if (hasRequired_if) return _if;
	hasRequired_if = 1;
	_if = function generate_if(it, $keyword, $ruleType) {
	  var out = ' ';
	  var $lvl = it.level;
	  var $dataLvl = it.dataLevel;
	  var $schema = it.schema[$keyword];
	  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
	  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
	  var $breakOnError = !it.opts.allErrors;
	  var $data = 'data' + ($dataLvl || '');
	  var $valid = 'valid' + $lvl;
	  var $errs = 'errs__' + $lvl;
	  var $it = it.util.copy(it);
	  $it.level++;
	  var $nextValid = 'valid' + $it.level;
	  var $thenSch = it.schema['then'],
	    $elseSch = it.schema['else'],
	    $thenPresent = $thenSch !== undefined && (it.opts.strictKeywords ? (typeof $thenSch == 'object' && Object.keys($thenSch).length > 0) || $thenSch === false : it.util.schemaHasRules($thenSch, it.RULES.all)),
	    $elsePresent = $elseSch !== undefined && (it.opts.strictKeywords ? (typeof $elseSch == 'object' && Object.keys($elseSch).length > 0) || $elseSch === false : it.util.schemaHasRules($elseSch, it.RULES.all)),
	    $currentBaseId = $it.baseId;
	  if ($thenPresent || $elsePresent) {
	    var $ifClause;
	    $it.createErrors = false;
	    $it.schema = $schema;
	    $it.schemaPath = $schemaPath;
	    $it.errSchemaPath = $errSchemaPath;
	    out += ' var ' + ($errs) + ' = errors; var ' + ($valid) + ' = true;  ';
	    var $wasComposite = it.compositeRule;
	    it.compositeRule = $it.compositeRule = true;
	    out += '  ' + (it.validate($it)) + ' ';
	    $it.baseId = $currentBaseId;
	    $it.createErrors = true;
	    out += '  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; }  ';
	    it.compositeRule = $it.compositeRule = $wasComposite;
	    if ($thenPresent) {
	      out += ' if (' + ($nextValid) + ') {  ';
	      $it.schema = it.schema['then'];
	      $it.schemaPath = it.schemaPath + '.then';
	      $it.errSchemaPath = it.errSchemaPath + '/then';
	      out += '  ' + (it.validate($it)) + ' ';
	      $it.baseId = $currentBaseId;
	      out += ' ' + ($valid) + ' = ' + ($nextValid) + '; ';
	      if ($thenPresent && $elsePresent) {
	        $ifClause = 'ifClause' + $lvl;
	        out += ' var ' + ($ifClause) + ' = \'then\'; ';
	      } else {
	        $ifClause = '\'then\'';
	      }
	      out += ' } ';
	      if ($elsePresent) {
	        out += ' else { ';
	      }
	    } else {
	      out += ' if (!' + ($nextValid) + ') { ';
	    }
	    if ($elsePresent) {
	      $it.schema = it.schema['else'];
	      $it.schemaPath = it.schemaPath + '.else';
	      $it.errSchemaPath = it.errSchemaPath + '/else';
	      out += '  ' + (it.validate($it)) + ' ';
	      $it.baseId = $currentBaseId;
	      out += ' ' + ($valid) + ' = ' + ($nextValid) + '; ';
	      if ($thenPresent && $elsePresent) {
	        $ifClause = 'ifClause' + $lvl;
	        out += ' var ' + ($ifClause) + ' = \'else\'; ';
	      } else {
	        $ifClause = '\'else\'';
	      }
	      out += ' } ';
	    }
	    out += ' if (!' + ($valid) + ') {   var err =   ';
	    if (it.createErrors !== false) {
	      out += ' { keyword: \'' + ('if') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { failingKeyword: ' + ($ifClause) + ' } ';
	      if (it.opts.messages !== false) {
	        out += ' , message: \'should match "\' + ' + ($ifClause) + ' + \'" schema\' ';
	      }
	      if (it.opts.verbose) {
	        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
	      }
	      out += ' } ';
	    } else {
	      out += ' {} ';
	    }
	    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
	    if (!it.compositeRule && $breakOnError) {
	      if (it.async) {
	        out += ' throw new ValidationError(vErrors); ';
	      } else {
	        out += ' validate.errors = vErrors; return false; ';
	      }
	    }
	    out += ' }   ';
	    if ($breakOnError) {
	      out += ' else { ';
	    }
	  } else {
	    if ($breakOnError) {
	      out += ' if (true) { ';
	    }
	  }
	  return out;
	};
	return _if;
}

var items;
var hasRequiredItems;

function requireItems () {
	if (hasRequiredItems) return items;
	hasRequiredItems = 1;
	items = function generate_items(it, $keyword, $ruleType) {
	  var out = ' ';
	  var $lvl = it.level;
	  var $dataLvl = it.dataLevel;
	  var $schema = it.schema[$keyword];
	  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
	  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
	  var $breakOnError = !it.opts.allErrors;
	  var $data = 'data' + ($dataLvl || '');
	  var $valid = 'valid' + $lvl;
	  var $errs = 'errs__' + $lvl;
	  var $it = it.util.copy(it);
	  var $closingBraces = '';
	  $it.level++;
	  var $nextValid = 'valid' + $it.level;
	  var $idx = 'i' + $lvl,
	    $dataNxt = $it.dataLevel = it.dataLevel + 1,
	    $nextData = 'data' + $dataNxt,
	    $currentBaseId = it.baseId;
	  out += 'var ' + ($errs) + ' = errors;var ' + ($valid) + ';';
	  if (Array.isArray($schema)) {
	    var $additionalItems = it.schema.additionalItems;
	    if ($additionalItems === false) {
	      out += ' ' + ($valid) + ' = ' + ($data) + '.length <= ' + ($schema.length) + '; ';
	      var $currErrSchemaPath = $errSchemaPath;
	      $errSchemaPath = it.errSchemaPath + '/additionalItems';
	      out += '  if (!' + ($valid) + ') {   ';
	      var $$outStack = $$outStack || [];
	      $$outStack.push(out);
	      out = '';
	      if (it.createErrors !== false) {
	        out += ' { keyword: \'' + ('additionalItems') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schema.length) + ' } ';
	        if (it.opts.messages !== false) {
	          out += ' , message: \'should NOT have more than ' + ($schema.length) + ' items\' ';
	        }
	        if (it.opts.verbose) {
	          out += ' , schema: false , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
	        }
	        out += ' } ';
	      } else {
	        out += ' {} ';
	      }
	      var __err = out;
	      out = $$outStack.pop();
	      if (!it.compositeRule && $breakOnError) {
	        if (it.async) {
	          out += ' throw new ValidationError([' + (__err) + ']); ';
	        } else {
	          out += ' validate.errors = [' + (__err) + ']; return false; ';
	        }
	      } else {
	        out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
	      }
	      out += ' } ';
	      $errSchemaPath = $currErrSchemaPath;
	      if ($breakOnError) {
	        $closingBraces += '}';
	        out += ' else { ';
	      }
	    }
	    var arr1 = $schema;
	    if (arr1) {
	      var $sch, $i = -1,
	        l1 = arr1.length - 1;
	      while ($i < l1) {
	        $sch = arr1[$i += 1];
	        if ((it.opts.strictKeywords ? (typeof $sch == 'object' && Object.keys($sch).length > 0) || $sch === false : it.util.schemaHasRules($sch, it.RULES.all))) {
	          out += ' ' + ($nextValid) + ' = true; if (' + ($data) + '.length > ' + ($i) + ') { ';
	          var $passData = $data + '[' + $i + ']';
	          $it.schema = $sch;
	          $it.schemaPath = $schemaPath + '[' + $i + ']';
	          $it.errSchemaPath = $errSchemaPath + '/' + $i;
	          $it.errorPath = it.util.getPathExpr(it.errorPath, $i, it.opts.jsonPointers, true);
	          $it.dataPathArr[$dataNxt] = $i;
	          var $code = it.validate($it);
	          $it.baseId = $currentBaseId;
	          if (it.util.varOccurences($code, $nextData) < 2) {
	            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
	          } else {
	            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
	          }
	          out += ' }  ';
	          if ($breakOnError) {
	            out += ' if (' + ($nextValid) + ') { ';
	            $closingBraces += '}';
	          }
	        }
	      }
	    }
	    if (typeof $additionalItems == 'object' && (it.opts.strictKeywords ? (typeof $additionalItems == 'object' && Object.keys($additionalItems).length > 0) || $additionalItems === false : it.util.schemaHasRules($additionalItems, it.RULES.all))) {
	      $it.schema = $additionalItems;
	      $it.schemaPath = it.schemaPath + '.additionalItems';
	      $it.errSchemaPath = it.errSchemaPath + '/additionalItems';
	      out += ' ' + ($nextValid) + ' = true; if (' + ($data) + '.length > ' + ($schema.length) + ') {  for (var ' + ($idx) + ' = ' + ($schema.length) + '; ' + ($idx) + ' < ' + ($data) + '.length; ' + ($idx) + '++) { ';
	      $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
	      var $passData = $data + '[' + $idx + ']';
	      $it.dataPathArr[$dataNxt] = $idx;
	      var $code = it.validate($it);
	      $it.baseId = $currentBaseId;
	      if (it.util.varOccurences($code, $nextData) < 2) {
	        out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
	      } else {
	        out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
	      }
	      if ($breakOnError) {
	        out += ' if (!' + ($nextValid) + ') break; ';
	      }
	      out += ' } }  ';
	      if ($breakOnError) {
	        out += ' if (' + ($nextValid) + ') { ';
	        $closingBraces += '}';
	      }
	    }
	  } else if ((it.opts.strictKeywords ? (typeof $schema == 'object' && Object.keys($schema).length > 0) || $schema === false : it.util.schemaHasRules($schema, it.RULES.all))) {
	    $it.schema = $schema;
	    $it.schemaPath = $schemaPath;
	    $it.errSchemaPath = $errSchemaPath;
	    out += '  for (var ' + ($idx) + ' = ' + (0) + '; ' + ($idx) + ' < ' + ($data) + '.length; ' + ($idx) + '++) { ';
	    $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
	    var $passData = $data + '[' + $idx + ']';
	    $it.dataPathArr[$dataNxt] = $idx;
	    var $code = it.validate($it);
	    $it.baseId = $currentBaseId;
	    if (it.util.varOccurences($code, $nextData) < 2) {
	      out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
	    } else {
	      out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
	    }
	    if ($breakOnError) {
	      out += ' if (!' + ($nextValid) + ') break; ';
	    }
	    out += ' }';
	  }
	  if ($breakOnError) {
	    out += ' ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';
	  }
	  return out;
	};
	return items;
}

var _limit;
var hasRequired_limit;

function require_limit () {
	if (hasRequired_limit) return _limit;
	hasRequired_limit = 1;
	_limit = function generate__limit(it, $keyword, $ruleType) {
	  var out = ' ';
	  var $lvl = it.level;
	  var $dataLvl = it.dataLevel;
	  var $schema = it.schema[$keyword];
	  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
	  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
	  var $breakOnError = !it.opts.allErrors;
	  var $errorKeyword;
	  var $data = 'data' + ($dataLvl || '');
	  var $isData = it.opts.$data && $schema && $schema.$data,
	    $schemaValue;
	  if ($isData) {
	    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
	    $schemaValue = 'schema' + $lvl;
	  } else {
	    $schemaValue = $schema;
	  }
	  var $isMax = $keyword == 'maximum',
	    $exclusiveKeyword = $isMax ? 'exclusiveMaximum' : 'exclusiveMinimum',
	    $schemaExcl = it.schema[$exclusiveKeyword],
	    $isDataExcl = it.opts.$data && $schemaExcl && $schemaExcl.$data,
	    $op = $isMax ? '<' : '>',
	    $notOp = $isMax ? '>' : '<',
	    $errorKeyword = undefined;
	  if (!($isData || typeof $schema == 'number' || $schema === undefined)) {
	    throw new Error($keyword + ' must be number');
	  }
	  if (!($isDataExcl || $schemaExcl === undefined || typeof $schemaExcl == 'number' || typeof $schemaExcl == 'boolean')) {
	    throw new Error($exclusiveKeyword + ' must be number or boolean');
	  }
	  if ($isDataExcl) {
	    var $schemaValueExcl = it.util.getData($schemaExcl.$data, $dataLvl, it.dataPathArr),
	      $exclusive = 'exclusive' + $lvl,
	      $exclType = 'exclType' + $lvl,
	      $exclIsNumber = 'exclIsNumber' + $lvl,
	      $opExpr = 'op' + $lvl,
	      $opStr = '\' + ' + $opExpr + ' + \'';
	    out += ' var schemaExcl' + ($lvl) + ' = ' + ($schemaValueExcl) + '; ';
	    $schemaValueExcl = 'schemaExcl' + $lvl;
	    out += ' var ' + ($exclusive) + '; var ' + ($exclType) + ' = typeof ' + ($schemaValueExcl) + '; if (' + ($exclType) + ' != \'boolean\' && ' + ($exclType) + ' != \'undefined\' && ' + ($exclType) + ' != \'number\') { ';
	    var $errorKeyword = $exclusiveKeyword;
	    var $$outStack = $$outStack || [];
	    $$outStack.push(out);
	    out = '';
	    if (it.createErrors !== false) {
	      out += ' { keyword: \'' + ($errorKeyword || '_exclusiveLimit') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
	      if (it.opts.messages !== false) {
	        out += ' , message: \'' + ($exclusiveKeyword) + ' should be boolean\' ';
	      }
	      if (it.opts.verbose) {
	        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
	      }
	      out += ' } ';
	    } else {
	      out += ' {} ';
	    }
	    var __err = out;
	    out = $$outStack.pop();
	    if (!it.compositeRule && $breakOnError) {
	      if (it.async) {
	        out += ' throw new ValidationError([' + (__err) + ']); ';
	      } else {
	        out += ' validate.errors = [' + (__err) + ']; return false; ';
	      }
	    } else {
	      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
	    }
	    out += ' } else if ( ';
	    if ($isData) {
	      out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
	    }
	    out += ' ' + ($exclType) + ' == \'number\' ? ( (' + ($exclusive) + ' = ' + ($schemaValue) + ' === undefined || ' + ($schemaValueExcl) + ' ' + ($op) + '= ' + ($schemaValue) + ') ? ' + ($data) + ' ' + ($notOp) + '= ' + ($schemaValueExcl) + ' : ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' ) : ( (' + ($exclusive) + ' = ' + ($schemaValueExcl) + ' === true) ? ' + ($data) + ' ' + ($notOp) + '= ' + ($schemaValue) + ' : ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' ) || ' + ($data) + ' !== ' + ($data) + ') { var op' + ($lvl) + ' = ' + ($exclusive) + ' ? \'' + ($op) + '\' : \'' + ($op) + '=\'; ';
	    if ($schema === undefined) {
	      $errorKeyword = $exclusiveKeyword;
	      $errSchemaPath = it.errSchemaPath + '/' + $exclusiveKeyword;
	      $schemaValue = $schemaValueExcl;
	      $isData = $isDataExcl;
	    }
	  } else {
	    var $exclIsNumber = typeof $schemaExcl == 'number',
	      $opStr = $op;
	    if ($exclIsNumber && $isData) {
	      var $opExpr = '\'' + $opStr + '\'';
	      out += ' if ( ';
	      if ($isData) {
	        out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
	      }
	      out += ' ( ' + ($schemaValue) + ' === undefined || ' + ($schemaExcl) + ' ' + ($op) + '= ' + ($schemaValue) + ' ? ' + ($data) + ' ' + ($notOp) + '= ' + ($schemaExcl) + ' : ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' ) || ' + ($data) + ' !== ' + ($data) + ') { ';
	    } else {
	      if ($exclIsNumber && $schema === undefined) {
	        $exclusive = true;
	        $errorKeyword = $exclusiveKeyword;
	        $errSchemaPath = it.errSchemaPath + '/' + $exclusiveKeyword;
	        $schemaValue = $schemaExcl;
	        $notOp += '=';
	      } else {
	        if ($exclIsNumber) $schemaValue = Math[$isMax ? 'min' : 'max']($schemaExcl, $schema);
	        if ($schemaExcl === ($exclIsNumber ? $schemaValue : true)) {
	          $exclusive = true;
	          $errorKeyword = $exclusiveKeyword;
	          $errSchemaPath = it.errSchemaPath + '/' + $exclusiveKeyword;
	          $notOp += '=';
	        } else {
	          $exclusive = false;
	          $opStr += '=';
	        }
	      }
	      var $opExpr = '\'' + $opStr + '\'';
	      out += ' if ( ';
	      if ($isData) {
	        out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
	      }
	      out += ' ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' || ' + ($data) + ' !== ' + ($data) + ') { ';
	    }
	  }
	  $errorKeyword = $errorKeyword || $keyword;
	  var $$outStack = $$outStack || [];
	  $$outStack.push(out);
	  out = '';
	  if (it.createErrors !== false) {
	    out += ' { keyword: \'' + ($errorKeyword || '_limit') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { comparison: ' + ($opExpr) + ', limit: ' + ($schemaValue) + ', exclusive: ' + ($exclusive) + ' } ';
	    if (it.opts.messages !== false) {
	      out += ' , message: \'should be ' + ($opStr) + ' ';
	      if ($isData) {
	        out += '\' + ' + ($schemaValue);
	      } else {
	        out += '' + ($schemaValue) + '\'';
	      }
	    }
	    if (it.opts.verbose) {
	      out += ' , schema:  ';
	      if ($isData) {
	        out += 'validate.schema' + ($schemaPath);
	      } else {
	        out += '' + ($schema);
	      }
	      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
	    }
	    out += ' } ';
	  } else {
	    out += ' {} ';
	  }
	  var __err = out;
	  out = $$outStack.pop();
	  if (!it.compositeRule && $breakOnError) {
	    if (it.async) {
	      out += ' throw new ValidationError([' + (__err) + ']); ';
	    } else {
	      out += ' validate.errors = [' + (__err) + ']; return false; ';
	    }
	  } else {
	    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
	  }
	  out += ' } ';
	  if ($breakOnError) {
	    out += ' else { ';
	  }
	  return out;
	};
	return _limit;
}

var _limitItems;
var hasRequired_limitItems;

function require_limitItems () {
	if (hasRequired_limitItems) return _limitItems;
	hasRequired_limitItems = 1;
	_limitItems = function generate__limitItems(it, $keyword, $ruleType) {
	  var out = ' ';
	  var $lvl = it.level;
	  var $dataLvl = it.dataLevel;
	  var $schema = it.schema[$keyword];
	  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
	  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
	  var $breakOnError = !it.opts.allErrors;
	  var $errorKeyword;
	  var $data = 'data' + ($dataLvl || '');
	  var $isData = it.opts.$data && $schema && $schema.$data,
	    $schemaValue;
	  if ($isData) {
	    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
	    $schemaValue = 'schema' + $lvl;
	  } else {
	    $schemaValue = $schema;
	  }
	  if (!($isData || typeof $schema == 'number')) {
	    throw new Error($keyword + ' must be number');
	  }
	  var $op = $keyword == 'maxItems' ? '>' : '<';
	  out += 'if ( ';
	  if ($isData) {
	    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
	  }
	  out += ' ' + ($data) + '.length ' + ($op) + ' ' + ($schemaValue) + ') { ';
	  var $errorKeyword = $keyword;
	  var $$outStack = $$outStack || [];
	  $$outStack.push(out);
	  out = '';
	  if (it.createErrors !== false) {
	    out += ' { keyword: \'' + ($errorKeyword || '_limitItems') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schemaValue) + ' } ';
	    if (it.opts.messages !== false) {
	      out += ' , message: \'should NOT have ';
	      if ($keyword == 'maxItems') {
	        out += 'more';
	      } else {
	        out += 'fewer';
	      }
	      out += ' than ';
	      if ($isData) {
	        out += '\' + ' + ($schemaValue) + ' + \'';
	      } else {
	        out += '' + ($schema);
	      }
	      out += ' items\' ';
	    }
	    if (it.opts.verbose) {
	      out += ' , schema:  ';
	      if ($isData) {
	        out += 'validate.schema' + ($schemaPath);
	      } else {
	        out += '' + ($schema);
	      }
	      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
	    }
	    out += ' } ';
	  } else {
	    out += ' {} ';
	  }
	  var __err = out;
	  out = $$outStack.pop();
	  if (!it.compositeRule && $breakOnError) {
	    if (it.async) {
	      out += ' throw new ValidationError([' + (__err) + ']); ';
	    } else {
	      out += ' validate.errors = [' + (__err) + ']; return false; ';
	    }
	  } else {
	    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
	  }
	  out += '} ';
	  if ($breakOnError) {
	    out += ' else { ';
	  }
	  return out;
	};
	return _limitItems;
}

var _limitLength;
var hasRequired_limitLength;

function require_limitLength () {
	if (hasRequired_limitLength) return _limitLength;
	hasRequired_limitLength = 1;
	_limitLength = function generate__limitLength(it, $keyword, $ruleType) {
	  var out = ' ';
	  var $lvl = it.level;
	  var $dataLvl = it.dataLevel;
	  var $schema = it.schema[$keyword];
	  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
	  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
	  var $breakOnError = !it.opts.allErrors;
	  var $errorKeyword;
	  var $data = 'data' + ($dataLvl || '');
	  var $isData = it.opts.$data && $schema && $schema.$data,
	    $schemaValue;
	  if ($isData) {
	    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
	    $schemaValue = 'schema' + $lvl;
	  } else {
	    $schemaValue = $schema;
	  }
	  if (!($isData || typeof $schema == 'number')) {
	    throw new Error($keyword + ' must be number');
	  }
	  var $op = $keyword == 'maxLength' ? '>' : '<';
	  out += 'if ( ';
	  if ($isData) {
	    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
	  }
	  if (it.opts.unicode === false) {
	    out += ' ' + ($data) + '.length ';
	  } else {
	    out += ' ucs2length(' + ($data) + ') ';
	  }
	  out += ' ' + ($op) + ' ' + ($schemaValue) + ') { ';
	  var $errorKeyword = $keyword;
	  var $$outStack = $$outStack || [];
	  $$outStack.push(out);
	  out = '';
	  if (it.createErrors !== false) {
	    out += ' { keyword: \'' + ($errorKeyword || '_limitLength') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schemaValue) + ' } ';
	    if (it.opts.messages !== false) {
	      out += ' , message: \'should NOT be ';
	      if ($keyword == 'maxLength') {
	        out += 'longer';
	      } else {
	        out += 'shorter';
	      }
	      out += ' than ';
	      if ($isData) {
	        out += '\' + ' + ($schemaValue) + ' + \'';
	      } else {
	        out += '' + ($schema);
	      }
	      out += ' characters\' ';
	    }
	    if (it.opts.verbose) {
	      out += ' , schema:  ';
	      if ($isData) {
	        out += 'validate.schema' + ($schemaPath);
	      } else {
	        out += '' + ($schema);
	      }
	      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
	    }
	    out += ' } ';
	  } else {
	    out += ' {} ';
	  }
	  var __err = out;
	  out = $$outStack.pop();
	  if (!it.compositeRule && $breakOnError) {
	    if (it.async) {
	      out += ' throw new ValidationError([' + (__err) + ']); ';
	    } else {
	      out += ' validate.errors = [' + (__err) + ']; return false; ';
	    }
	  } else {
	    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
	  }
	  out += '} ';
	  if ($breakOnError) {
	    out += ' else { ';
	  }
	  return out;
	};
	return _limitLength;
}

var _limitProperties;
var hasRequired_limitProperties;

function require_limitProperties () {
	if (hasRequired_limitProperties) return _limitProperties;
	hasRequired_limitProperties = 1;
	_limitProperties = function generate__limitProperties(it, $keyword, $ruleType) {
	  var out = ' ';
	  var $lvl = it.level;
	  var $dataLvl = it.dataLevel;
	  var $schema = it.schema[$keyword];
	  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
	  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
	  var $breakOnError = !it.opts.allErrors;
	  var $errorKeyword;
	  var $data = 'data' + ($dataLvl || '');
	  var $isData = it.opts.$data && $schema && $schema.$data,
	    $schemaValue;
	  if ($isData) {
	    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
	    $schemaValue = 'schema' + $lvl;
	  } else {
	    $schemaValue = $schema;
	  }
	  if (!($isData || typeof $schema == 'number')) {
	    throw new Error($keyword + ' must be number');
	  }
	  var $op = $keyword == 'maxProperties' ? '>' : '<';
	  out += 'if ( ';
	  if ($isData) {
	    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
	  }
	  out += ' Object.keys(' + ($data) + ').length ' + ($op) + ' ' + ($schemaValue) + ') { ';
	  var $errorKeyword = $keyword;
	  var $$outStack = $$outStack || [];
	  $$outStack.push(out);
	  out = '';
	  if (it.createErrors !== false) {
	    out += ' { keyword: \'' + ($errorKeyword || '_limitProperties') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schemaValue) + ' } ';
	    if (it.opts.messages !== false) {
	      out += ' , message: \'should NOT have ';
	      if ($keyword == 'maxProperties') {
	        out += 'more';
	      } else {
	        out += 'fewer';
	      }
	      out += ' than ';
	      if ($isData) {
	        out += '\' + ' + ($schemaValue) + ' + \'';
	      } else {
	        out += '' + ($schema);
	      }
	      out += ' properties\' ';
	    }
	    if (it.opts.verbose) {
	      out += ' , schema:  ';
	      if ($isData) {
	        out += 'validate.schema' + ($schemaPath);
	      } else {
	        out += '' + ($schema);
	      }
	      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
	    }
	    out += ' } ';
	  } else {
	    out += ' {} ';
	  }
	  var __err = out;
	  out = $$outStack.pop();
	  if (!it.compositeRule && $breakOnError) {
	    if (it.async) {
	      out += ' throw new ValidationError([' + (__err) + ']); ';
	    } else {
	      out += ' validate.errors = [' + (__err) + ']; return false; ';
	    }
	  } else {
	    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
	  }
	  out += '} ';
	  if ($breakOnError) {
	    out += ' else { ';
	  }
	  return out;
	};
	return _limitProperties;
}

var multipleOf;
var hasRequiredMultipleOf;

function requireMultipleOf () {
	if (hasRequiredMultipleOf) return multipleOf;
	hasRequiredMultipleOf = 1;
	multipleOf = function generate_multipleOf(it, $keyword, $ruleType) {
	  var out = ' ';
	  var $lvl = it.level;
	  var $dataLvl = it.dataLevel;
	  var $schema = it.schema[$keyword];
	  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
	  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
	  var $breakOnError = !it.opts.allErrors;
	  var $data = 'data' + ($dataLvl || '');
	  var $isData = it.opts.$data && $schema && $schema.$data,
	    $schemaValue;
	  if ($isData) {
	    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
	    $schemaValue = 'schema' + $lvl;
	  } else {
	    $schemaValue = $schema;
	  }
	  if (!($isData || typeof $schema == 'number')) {
	    throw new Error($keyword + ' must be number');
	  }
	  out += 'var division' + ($lvl) + ';if (';
	  if ($isData) {
	    out += ' ' + ($schemaValue) + ' !== undefined && ( typeof ' + ($schemaValue) + ' != \'number\' || ';
	  }
	  out += ' (division' + ($lvl) + ' = ' + ($data) + ' / ' + ($schemaValue) + ', ';
	  if (it.opts.multipleOfPrecision) {
	    out += ' Math.abs(Math.round(division' + ($lvl) + ') - division' + ($lvl) + ') > 1e-' + (it.opts.multipleOfPrecision) + ' ';
	  } else {
	    out += ' division' + ($lvl) + ' !== parseInt(division' + ($lvl) + ') ';
	  }
	  out += ' ) ';
	  if ($isData) {
	    out += '  )  ';
	  }
	  out += ' ) {   ';
	  var $$outStack = $$outStack || [];
	  $$outStack.push(out);
	  out = '';
	  if (it.createErrors !== false) {
	    out += ' { keyword: \'' + ('multipleOf') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { multipleOf: ' + ($schemaValue) + ' } ';
	    if (it.opts.messages !== false) {
	      out += ' , message: \'should be multiple of ';
	      if ($isData) {
	        out += '\' + ' + ($schemaValue);
	      } else {
	        out += '' + ($schemaValue) + '\'';
	      }
	    }
	    if (it.opts.verbose) {
	      out += ' , schema:  ';
	      if ($isData) {
	        out += 'validate.schema' + ($schemaPath);
	      } else {
	        out += '' + ($schema);
	      }
	      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
	    }
	    out += ' } ';
	  } else {
	    out += ' {} ';
	  }
	  var __err = out;
	  out = $$outStack.pop();
	  if (!it.compositeRule && $breakOnError) {
	    if (it.async) {
	      out += ' throw new ValidationError([' + (__err) + ']); ';
	    } else {
	      out += ' validate.errors = [' + (__err) + ']; return false; ';
	    }
	  } else {
	    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
	  }
	  out += '} ';
	  if ($breakOnError) {
	    out += ' else { ';
	  }
	  return out;
	};
	return multipleOf;
}

var not;
var hasRequiredNot;

function requireNot () {
	if (hasRequiredNot) return not;
	hasRequiredNot = 1;
	not = function generate_not(it, $keyword, $ruleType) {
	  var out = ' ';
	  var $lvl = it.level;
	  var $dataLvl = it.dataLevel;
	  var $schema = it.schema[$keyword];
	  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
	  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
	  var $breakOnError = !it.opts.allErrors;
	  var $data = 'data' + ($dataLvl || '');
	  var $errs = 'errs__' + $lvl;
	  var $it = it.util.copy(it);
	  $it.level++;
	  var $nextValid = 'valid' + $it.level;
	  if ((it.opts.strictKeywords ? (typeof $schema == 'object' && Object.keys($schema).length > 0) || $schema === false : it.util.schemaHasRules($schema, it.RULES.all))) {
	    $it.schema = $schema;
	    $it.schemaPath = $schemaPath;
	    $it.errSchemaPath = $errSchemaPath;
	    out += ' var ' + ($errs) + ' = errors;  ';
	    var $wasComposite = it.compositeRule;
	    it.compositeRule = $it.compositeRule = true;
	    $it.createErrors = false;
	    var $allErrorsOption;
	    if ($it.opts.allErrors) {
	      $allErrorsOption = $it.opts.allErrors;
	      $it.opts.allErrors = false;
	    }
	    out += ' ' + (it.validate($it)) + ' ';
	    $it.createErrors = true;
	    if ($allErrorsOption) $it.opts.allErrors = $allErrorsOption;
	    it.compositeRule = $it.compositeRule = $wasComposite;
	    out += ' if (' + ($nextValid) + ') {   ';
	    var $$outStack = $$outStack || [];
	    $$outStack.push(out);
	    out = '';
	    if (it.createErrors !== false) {
	      out += ' { keyword: \'' + ('not') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
	      if (it.opts.messages !== false) {
	        out += ' , message: \'should NOT be valid\' ';
	      }
	      if (it.opts.verbose) {
	        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
	      }
	      out += ' } ';
	    } else {
	      out += ' {} ';
	    }
	    var __err = out;
	    out = $$outStack.pop();
	    if (!it.compositeRule && $breakOnError) {
	      if (it.async) {
	        out += ' throw new ValidationError([' + (__err) + ']); ';
	      } else {
	        out += ' validate.errors = [' + (__err) + ']; return false; ';
	      }
	    } else {
	      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
	    }
	    out += ' } else {  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; } ';
	    if (it.opts.allErrors) {
	      out += ' } ';
	    }
	  } else {
	    out += '  var err =   ';
	    if (it.createErrors !== false) {
	      out += ' { keyword: \'' + ('not') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
	      if (it.opts.messages !== false) {
	        out += ' , message: \'should NOT be valid\' ';
	      }
	      if (it.opts.verbose) {
	        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
	      }
	      out += ' } ';
	    } else {
	      out += ' {} ';
	    }
	    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
	    if ($breakOnError) {
	      out += ' if (false) { ';
	    }
	  }
	  return out;
	};
	return not;
}

var oneOf;
var hasRequiredOneOf;

function requireOneOf () {
	if (hasRequiredOneOf) return oneOf;
	hasRequiredOneOf = 1;
	oneOf = function generate_oneOf(it, $keyword, $ruleType) {
	  var out = ' ';
	  var $lvl = it.level;
	  var $dataLvl = it.dataLevel;
	  var $schema = it.schema[$keyword];
	  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
	  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
	  var $breakOnError = !it.opts.allErrors;
	  var $data = 'data' + ($dataLvl || '');
	  var $valid = 'valid' + $lvl;
	  var $errs = 'errs__' + $lvl;
	  var $it = it.util.copy(it);
	  var $closingBraces = '';
	  $it.level++;
	  var $nextValid = 'valid' + $it.level;
	  var $currentBaseId = $it.baseId,
	    $prevValid = 'prevValid' + $lvl,
	    $passingSchemas = 'passingSchemas' + $lvl;
	  out += 'var ' + ($errs) + ' = errors , ' + ($prevValid) + ' = false , ' + ($valid) + ' = false , ' + ($passingSchemas) + ' = null; ';
	  var $wasComposite = it.compositeRule;
	  it.compositeRule = $it.compositeRule = true;
	  var arr1 = $schema;
	  if (arr1) {
	    var $sch, $i = -1,
	      l1 = arr1.length - 1;
	    while ($i < l1) {
	      $sch = arr1[$i += 1];
	      if ((it.opts.strictKeywords ? (typeof $sch == 'object' && Object.keys($sch).length > 0) || $sch === false : it.util.schemaHasRules($sch, it.RULES.all))) {
	        $it.schema = $sch;
	        $it.schemaPath = $schemaPath + '[' + $i + ']';
	        $it.errSchemaPath = $errSchemaPath + '/' + $i;
	        out += '  ' + (it.validate($it)) + ' ';
	        $it.baseId = $currentBaseId;
	      } else {
	        out += ' var ' + ($nextValid) + ' = true; ';
	      }
	      if ($i) {
	        out += ' if (' + ($nextValid) + ' && ' + ($prevValid) + ') { ' + ($valid) + ' = false; ' + ($passingSchemas) + ' = [' + ($passingSchemas) + ', ' + ($i) + ']; } else { ';
	        $closingBraces += '}';
	      }
	      out += ' if (' + ($nextValid) + ') { ' + ($valid) + ' = ' + ($prevValid) + ' = true; ' + ($passingSchemas) + ' = ' + ($i) + '; }';
	    }
	  }
	  it.compositeRule = $it.compositeRule = $wasComposite;
	  out += '' + ($closingBraces) + 'if (!' + ($valid) + ') {   var err =   ';
	  if (it.createErrors !== false) {
	    out += ' { keyword: \'' + ('oneOf') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { passingSchemas: ' + ($passingSchemas) + ' } ';
	    if (it.opts.messages !== false) {
	      out += ' , message: \'should match exactly one schema in oneOf\' ';
	    }
	    if (it.opts.verbose) {
	      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
	    }
	    out += ' } ';
	  } else {
	    out += ' {} ';
	  }
	  out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
	  if (!it.compositeRule && $breakOnError) {
	    if (it.async) {
	      out += ' throw new ValidationError(vErrors); ';
	    } else {
	      out += ' validate.errors = vErrors; return false; ';
	    }
	  }
	  out += '} else {  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; }';
	  if (it.opts.allErrors) {
	    out += ' } ';
	  }
	  return out;
	};
	return oneOf;
}

var pattern;
var hasRequiredPattern;

function requirePattern () {
	if (hasRequiredPattern) return pattern;
	hasRequiredPattern = 1;
	pattern = function generate_pattern(it, $keyword, $ruleType) {
	  var out = ' ';
	  var $lvl = it.level;
	  var $dataLvl = it.dataLevel;
	  var $schema = it.schema[$keyword];
	  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
	  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
	  var $breakOnError = !it.opts.allErrors;
	  var $data = 'data' + ($dataLvl || '');
	  var $isData = it.opts.$data && $schema && $schema.$data,
	    $schemaValue;
	  if ($isData) {
	    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
	    $schemaValue = 'schema' + $lvl;
	  } else {
	    $schemaValue = $schema;
	  }
	  var $regexp = $isData ? '(new RegExp(' + $schemaValue + '))' : it.usePattern($schema);
	  out += 'if ( ';
	  if ($isData) {
	    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'string\') || ';
	  }
	  out += ' !' + ($regexp) + '.test(' + ($data) + ') ) {   ';
	  var $$outStack = $$outStack || [];
	  $$outStack.push(out);
	  out = '';
	  if (it.createErrors !== false) {
	    out += ' { keyword: \'' + ('pattern') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { pattern:  ';
	    if ($isData) {
	      out += '' + ($schemaValue);
	    } else {
	      out += '' + (it.util.toQuotedString($schema));
	    }
	    out += '  } ';
	    if (it.opts.messages !== false) {
	      out += ' , message: \'should match pattern "';
	      if ($isData) {
	        out += '\' + ' + ($schemaValue) + ' + \'';
	      } else {
	        out += '' + (it.util.escapeQuotes($schema));
	      }
	      out += '"\' ';
	    }
	    if (it.opts.verbose) {
	      out += ' , schema:  ';
	      if ($isData) {
	        out += 'validate.schema' + ($schemaPath);
	      } else {
	        out += '' + (it.util.toQuotedString($schema));
	      }
	      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
	    }
	    out += ' } ';
	  } else {
	    out += ' {} ';
	  }
	  var __err = out;
	  out = $$outStack.pop();
	  if (!it.compositeRule && $breakOnError) {
	    if (it.async) {
	      out += ' throw new ValidationError([' + (__err) + ']); ';
	    } else {
	      out += ' validate.errors = [' + (__err) + ']; return false; ';
	    }
	  } else {
	    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
	  }
	  out += '} ';
	  if ($breakOnError) {
	    out += ' else { ';
	  }
	  return out;
	};
	return pattern;
}

var properties$2;
var hasRequiredProperties;

function requireProperties () {
	if (hasRequiredProperties) return properties$2;
	hasRequiredProperties = 1;
	properties$2 = function generate_properties(it, $keyword, $ruleType) {
	  var out = ' ';
	  var $lvl = it.level;
	  var $dataLvl = it.dataLevel;
	  var $schema = it.schema[$keyword];
	  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
	  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
	  var $breakOnError = !it.opts.allErrors;
	  var $data = 'data' + ($dataLvl || '');
	  var $errs = 'errs__' + $lvl;
	  var $it = it.util.copy(it);
	  var $closingBraces = '';
	  $it.level++;
	  var $nextValid = 'valid' + $it.level;
	  var $key = 'key' + $lvl,
	    $idx = 'idx' + $lvl,
	    $dataNxt = $it.dataLevel = it.dataLevel + 1,
	    $nextData = 'data' + $dataNxt,
	    $dataProperties = 'dataProperties' + $lvl;
	  var $schemaKeys = Object.keys($schema || {}).filter(notProto),
	    $pProperties = it.schema.patternProperties || {},
	    $pPropertyKeys = Object.keys($pProperties).filter(notProto),
	    $aProperties = it.schema.additionalProperties,
	    $someProperties = $schemaKeys.length || $pPropertyKeys.length,
	    $noAdditional = $aProperties === false,
	    $additionalIsSchema = typeof $aProperties == 'object' && Object.keys($aProperties).length,
	    $removeAdditional = it.opts.removeAdditional,
	    $checkAdditional = $noAdditional || $additionalIsSchema || $removeAdditional,
	    $ownProperties = it.opts.ownProperties,
	    $currentBaseId = it.baseId;
	  var $required = it.schema.required;
	  if ($required && !(it.opts.$data && $required.$data) && $required.length < it.opts.loopRequired) {
	    var $requiredHash = it.util.toHash($required);
	  }
	  function notProto(p) {
	    return p !== '__proto__';
	  }
	  out += 'var ' + ($errs) + ' = errors;var ' + ($nextValid) + ' = true;';
	  if ($ownProperties) {
	    out += ' var ' + ($dataProperties) + ' = undefined;';
	  }
	  if ($checkAdditional) {
	    if ($ownProperties) {
	      out += ' ' + ($dataProperties) + ' = ' + ($dataProperties) + ' || Object.keys(' + ($data) + '); for (var ' + ($idx) + '=0; ' + ($idx) + '<' + ($dataProperties) + '.length; ' + ($idx) + '++) { var ' + ($key) + ' = ' + ($dataProperties) + '[' + ($idx) + ']; ';
	    } else {
	      out += ' for (var ' + ($key) + ' in ' + ($data) + ') { ';
	    }
	    if ($someProperties) {
	      out += ' var isAdditional' + ($lvl) + ' = !(false ';
	      if ($schemaKeys.length) {
	        if ($schemaKeys.length > 8) {
	          out += ' || validate.schema' + ($schemaPath) + '.hasOwnProperty(' + ($key) + ') ';
	        } else {
	          var arr1 = $schemaKeys;
	          if (arr1) {
	            var $propertyKey, i1 = -1,
	              l1 = arr1.length - 1;
	            while (i1 < l1) {
	              $propertyKey = arr1[i1 += 1];
	              out += ' || ' + ($key) + ' == ' + (it.util.toQuotedString($propertyKey)) + ' ';
	            }
	          }
	        }
	      }
	      if ($pPropertyKeys.length) {
	        var arr2 = $pPropertyKeys;
	        if (arr2) {
	          var $pProperty, $i = -1,
	            l2 = arr2.length - 1;
	          while ($i < l2) {
	            $pProperty = arr2[$i += 1];
	            out += ' || ' + (it.usePattern($pProperty)) + '.test(' + ($key) + ') ';
	          }
	        }
	      }
	      out += ' ); if (isAdditional' + ($lvl) + ') { ';
	    }
	    if ($removeAdditional == 'all') {
	      out += ' delete ' + ($data) + '[' + ($key) + ']; ';
	    } else {
	      var $currentErrorPath = it.errorPath;
	      var $additionalProperty = '\' + ' + $key + ' + \'';
	      if (it.opts._errorDataPathProperty) {
	        it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
	      }
	      if ($noAdditional) {
	        if ($removeAdditional) {
	          out += ' delete ' + ($data) + '[' + ($key) + ']; ';
	        } else {
	          out += ' ' + ($nextValid) + ' = false; ';
	          var $currErrSchemaPath = $errSchemaPath;
	          $errSchemaPath = it.errSchemaPath + '/additionalProperties';
	          var $$outStack = $$outStack || [];
	          $$outStack.push(out);
	          out = '';
	          if (it.createErrors !== false) {
	            out += ' { keyword: \'' + ('additionalProperties') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { additionalProperty: \'' + ($additionalProperty) + '\' } ';
	            if (it.opts.messages !== false) {
	              out += ' , message: \'';
	              if (it.opts._errorDataPathProperty) {
	                out += 'is an invalid additional property';
	              } else {
	                out += 'should NOT have additional properties';
	              }
	              out += '\' ';
	            }
	            if (it.opts.verbose) {
	              out += ' , schema: false , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
	            }
	            out += ' } ';
	          } else {
	            out += ' {} ';
	          }
	          var __err = out;
	          out = $$outStack.pop();
	          if (!it.compositeRule && $breakOnError) {
	            if (it.async) {
	              out += ' throw new ValidationError([' + (__err) + ']); ';
	            } else {
	              out += ' validate.errors = [' + (__err) + ']; return false; ';
	            }
	          } else {
	            out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
	          }
	          $errSchemaPath = $currErrSchemaPath;
	          if ($breakOnError) {
	            out += ' break; ';
	          }
	        }
	      } else if ($additionalIsSchema) {
	        if ($removeAdditional == 'failing') {
	          out += ' var ' + ($errs) + ' = errors;  ';
	          var $wasComposite = it.compositeRule;
	          it.compositeRule = $it.compositeRule = true;
	          $it.schema = $aProperties;
	          $it.schemaPath = it.schemaPath + '.additionalProperties';
	          $it.errSchemaPath = it.errSchemaPath + '/additionalProperties';
	          $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
	          var $passData = $data + '[' + $key + ']';
	          $it.dataPathArr[$dataNxt] = $key;
	          var $code = it.validate($it);
	          $it.baseId = $currentBaseId;
	          if (it.util.varOccurences($code, $nextData) < 2) {
	            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
	          } else {
	            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
	          }
	          out += ' if (!' + ($nextValid) + ') { errors = ' + ($errs) + '; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete ' + ($data) + '[' + ($key) + ']; }  ';
	          it.compositeRule = $it.compositeRule = $wasComposite;
	        } else {
	          $it.schema = $aProperties;
	          $it.schemaPath = it.schemaPath + '.additionalProperties';
	          $it.errSchemaPath = it.errSchemaPath + '/additionalProperties';
	          $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
	          var $passData = $data + '[' + $key + ']';
	          $it.dataPathArr[$dataNxt] = $key;
	          var $code = it.validate($it);
	          $it.baseId = $currentBaseId;
	          if (it.util.varOccurences($code, $nextData) < 2) {
	            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
	          } else {
	            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
	          }
	          if ($breakOnError) {
	            out += ' if (!' + ($nextValid) + ') break; ';
	          }
	        }
	      }
	      it.errorPath = $currentErrorPath;
	    }
	    if ($someProperties) {
	      out += ' } ';
	    }
	    out += ' }  ';
	    if ($breakOnError) {
	      out += ' if (' + ($nextValid) + ') { ';
	      $closingBraces += '}';
	    }
	  }
	  var $useDefaults = it.opts.useDefaults && !it.compositeRule;
	  if ($schemaKeys.length) {
	    var arr3 = $schemaKeys;
	    if (arr3) {
	      var $propertyKey, i3 = -1,
	        l3 = arr3.length - 1;
	      while (i3 < l3) {
	        $propertyKey = arr3[i3 += 1];
	        var $sch = $schema[$propertyKey];
	        if ((it.opts.strictKeywords ? (typeof $sch == 'object' && Object.keys($sch).length > 0) || $sch === false : it.util.schemaHasRules($sch, it.RULES.all))) {
	          var $prop = it.util.getProperty($propertyKey),
	            $passData = $data + $prop,
	            $hasDefault = $useDefaults && $sch.default !== undefined;
	          $it.schema = $sch;
	          $it.schemaPath = $schemaPath + $prop;
	          $it.errSchemaPath = $errSchemaPath + '/' + it.util.escapeFragment($propertyKey);
	          $it.errorPath = it.util.getPath(it.errorPath, $propertyKey, it.opts.jsonPointers);
	          $it.dataPathArr[$dataNxt] = it.util.toQuotedString($propertyKey);
	          var $code = it.validate($it);
	          $it.baseId = $currentBaseId;
	          if (it.util.varOccurences($code, $nextData) < 2) {
	            $code = it.util.varReplace($code, $nextData, $passData);
	            var $useData = $passData;
	          } else {
	            var $useData = $nextData;
	            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ';
	          }
	          if ($hasDefault) {
	            out += ' ' + ($code) + ' ';
	          } else {
	            if ($requiredHash && $requiredHash[$propertyKey]) {
	              out += ' if ( ' + ($useData) + ' === undefined ';
	              if ($ownProperties) {
	                out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
	              }
	              out += ') { ' + ($nextValid) + ' = false; ';
	              var $currentErrorPath = it.errorPath,
	                $currErrSchemaPath = $errSchemaPath,
	                $missingProperty = it.util.escapeQuotes($propertyKey);
	              if (it.opts._errorDataPathProperty) {
	                it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
	              }
	              $errSchemaPath = it.errSchemaPath + '/required';
	              var $$outStack = $$outStack || [];
	              $$outStack.push(out);
	              out = '';
	              if (it.createErrors !== false) {
	                out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
	                if (it.opts.messages !== false) {
	                  out += ' , message: \'';
	                  if (it.opts._errorDataPathProperty) {
	                    out += 'is a required property';
	                  } else {
	                    out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
	                  }
	                  out += '\' ';
	                }
	                if (it.opts.verbose) {
	                  out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
	                }
	                out += ' } ';
	              } else {
	                out += ' {} ';
	              }
	              var __err = out;
	              out = $$outStack.pop();
	              if (!it.compositeRule && $breakOnError) {
	                if (it.async) {
	                  out += ' throw new ValidationError([' + (__err) + ']); ';
	                } else {
	                  out += ' validate.errors = [' + (__err) + ']; return false; ';
	                }
	              } else {
	                out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
	              }
	              $errSchemaPath = $currErrSchemaPath;
	              it.errorPath = $currentErrorPath;
	              out += ' } else { ';
	            } else {
	              if ($breakOnError) {
	                out += ' if ( ' + ($useData) + ' === undefined ';
	                if ($ownProperties) {
	                  out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
	                }
	                out += ') { ' + ($nextValid) + ' = true; } else { ';
	              } else {
	                out += ' if (' + ($useData) + ' !== undefined ';
	                if ($ownProperties) {
	                  out += ' &&   Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
	                }
	                out += ' ) { ';
	              }
	            }
	            out += ' ' + ($code) + ' } ';
	          }
	        }
	        if ($breakOnError) {
	          out += ' if (' + ($nextValid) + ') { ';
	          $closingBraces += '}';
	        }
	      }
	    }
	  }
	  if ($pPropertyKeys.length) {
	    var arr4 = $pPropertyKeys;
	    if (arr4) {
	      var $pProperty, i4 = -1,
	        l4 = arr4.length - 1;
	      while (i4 < l4) {
	        $pProperty = arr4[i4 += 1];
	        var $sch = $pProperties[$pProperty];
	        if ((it.opts.strictKeywords ? (typeof $sch == 'object' && Object.keys($sch).length > 0) || $sch === false : it.util.schemaHasRules($sch, it.RULES.all))) {
	          $it.schema = $sch;
	          $it.schemaPath = it.schemaPath + '.patternProperties' + it.util.getProperty($pProperty);
	          $it.errSchemaPath = it.errSchemaPath + '/patternProperties/' + it.util.escapeFragment($pProperty);
	          if ($ownProperties) {
	            out += ' ' + ($dataProperties) + ' = ' + ($dataProperties) + ' || Object.keys(' + ($data) + '); for (var ' + ($idx) + '=0; ' + ($idx) + '<' + ($dataProperties) + '.length; ' + ($idx) + '++) { var ' + ($key) + ' = ' + ($dataProperties) + '[' + ($idx) + ']; ';
	          } else {
	            out += ' for (var ' + ($key) + ' in ' + ($data) + ') { ';
	          }
	          out += ' if (' + (it.usePattern($pProperty)) + '.test(' + ($key) + ')) { ';
	          $it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
	          var $passData = $data + '[' + $key + ']';
	          $it.dataPathArr[$dataNxt] = $key;
	          var $code = it.validate($it);
	          $it.baseId = $currentBaseId;
	          if (it.util.varOccurences($code, $nextData) < 2) {
	            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
	          } else {
	            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
	          }
	          if ($breakOnError) {
	            out += ' if (!' + ($nextValid) + ') break; ';
	          }
	          out += ' } ';
	          if ($breakOnError) {
	            out += ' else ' + ($nextValid) + ' = true; ';
	          }
	          out += ' }  ';
	          if ($breakOnError) {
	            out += ' if (' + ($nextValid) + ') { ';
	            $closingBraces += '}';
	          }
	        }
	      }
	    }
	  }
	  if ($breakOnError) {
	    out += ' ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';
	  }
	  return out;
	};
	return properties$2;
}

var propertyNames;
var hasRequiredPropertyNames;

function requirePropertyNames () {
	if (hasRequiredPropertyNames) return propertyNames;
	hasRequiredPropertyNames = 1;
	propertyNames = function generate_propertyNames(it, $keyword, $ruleType) {
	  var out = ' ';
	  var $lvl = it.level;
	  var $dataLvl = it.dataLevel;
	  var $schema = it.schema[$keyword];
	  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
	  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
	  var $breakOnError = !it.opts.allErrors;
	  var $data = 'data' + ($dataLvl || '');
	  var $errs = 'errs__' + $lvl;
	  var $it = it.util.copy(it);
	  var $closingBraces = '';
	  $it.level++;
	  var $nextValid = 'valid' + $it.level;
	  out += 'var ' + ($errs) + ' = errors;';
	  if ((it.opts.strictKeywords ? (typeof $schema == 'object' && Object.keys($schema).length > 0) || $schema === false : it.util.schemaHasRules($schema, it.RULES.all))) {
	    $it.schema = $schema;
	    $it.schemaPath = $schemaPath;
	    $it.errSchemaPath = $errSchemaPath;
	    var $key = 'key' + $lvl,
	      $idx = 'idx' + $lvl,
	      $i = 'i' + $lvl,
	      $invalidName = '\' + ' + $key + ' + \'',
	      $dataNxt = $it.dataLevel = it.dataLevel + 1,
	      $nextData = 'data' + $dataNxt,
	      $dataProperties = 'dataProperties' + $lvl,
	      $ownProperties = it.opts.ownProperties,
	      $currentBaseId = it.baseId;
	    if ($ownProperties) {
	      out += ' var ' + ($dataProperties) + ' = undefined; ';
	    }
	    if ($ownProperties) {
	      out += ' ' + ($dataProperties) + ' = ' + ($dataProperties) + ' || Object.keys(' + ($data) + '); for (var ' + ($idx) + '=0; ' + ($idx) + '<' + ($dataProperties) + '.length; ' + ($idx) + '++) { var ' + ($key) + ' = ' + ($dataProperties) + '[' + ($idx) + ']; ';
	    } else {
	      out += ' for (var ' + ($key) + ' in ' + ($data) + ') { ';
	    }
	    out += ' var startErrs' + ($lvl) + ' = errors; ';
	    var $passData = $key;
	    var $wasComposite = it.compositeRule;
	    it.compositeRule = $it.compositeRule = true;
	    var $code = it.validate($it);
	    $it.baseId = $currentBaseId;
	    if (it.util.varOccurences($code, $nextData) < 2) {
	      out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
	    } else {
	      out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
	    }
	    it.compositeRule = $it.compositeRule = $wasComposite;
	    out += ' if (!' + ($nextValid) + ') { for (var ' + ($i) + '=startErrs' + ($lvl) + '; ' + ($i) + '<errors; ' + ($i) + '++) { vErrors[' + ($i) + '].propertyName = ' + ($key) + '; }   var err =   ';
	    if (it.createErrors !== false) {
	      out += ' { keyword: \'' + ('propertyNames') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { propertyName: \'' + ($invalidName) + '\' } ';
	      if (it.opts.messages !== false) {
	        out += ' , message: \'property name \\\'' + ($invalidName) + '\\\' is invalid\' ';
	      }
	      if (it.opts.verbose) {
	        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
	      }
	      out += ' } ';
	    } else {
	      out += ' {} ';
	    }
	    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
	    if (!it.compositeRule && $breakOnError) {
	      if (it.async) {
	        out += ' throw new ValidationError(vErrors); ';
	      } else {
	        out += ' validate.errors = vErrors; return false; ';
	      }
	    }
	    if ($breakOnError) {
	      out += ' break; ';
	    }
	    out += ' } }';
	  }
	  if ($breakOnError) {
	    out += ' ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';
	  }
	  return out;
	};
	return propertyNames;
}

var required$1;
var hasRequiredRequired;

function requireRequired () {
	if (hasRequiredRequired) return required$1;
	hasRequiredRequired = 1;
	required$1 = function generate_required(it, $keyword, $ruleType) {
	  var out = ' ';
	  var $lvl = it.level;
	  var $dataLvl = it.dataLevel;
	  var $schema = it.schema[$keyword];
	  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
	  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
	  var $breakOnError = !it.opts.allErrors;
	  var $data = 'data' + ($dataLvl || '');
	  var $valid = 'valid' + $lvl;
	  var $isData = it.opts.$data && $schema && $schema.$data;
	  if ($isData) {
	    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
	  }
	  var $vSchema = 'schema' + $lvl;
	  if (!$isData) {
	    if ($schema.length < it.opts.loopRequired && it.schema.properties && Object.keys(it.schema.properties).length) {
	      var $required = [];
	      var arr1 = $schema;
	      if (arr1) {
	        var $property, i1 = -1,
	          l1 = arr1.length - 1;
	        while (i1 < l1) {
	          $property = arr1[i1 += 1];
	          var $propertySch = it.schema.properties[$property];
	          if (!($propertySch && (it.opts.strictKeywords ? (typeof $propertySch == 'object' && Object.keys($propertySch).length > 0) || $propertySch === false : it.util.schemaHasRules($propertySch, it.RULES.all)))) {
	            $required[$required.length] = $property;
	          }
	        }
	      }
	    } else {
	      var $required = $schema;
	    }
	  }
	  if ($isData || $required.length) {
	    var $currentErrorPath = it.errorPath,
	      $loopRequired = $isData || $required.length >= it.opts.loopRequired,
	      $ownProperties = it.opts.ownProperties;
	    if ($breakOnError) {
	      out += ' var missing' + ($lvl) + '; ';
	      if ($loopRequired) {
	        if (!$isData) {
	          out += ' var ' + ($vSchema) + ' = validate.schema' + ($schemaPath) + '; ';
	        }
	        var $i = 'i' + $lvl,
	          $propertyPath = 'schema' + $lvl + '[' + $i + ']',
	          $missingProperty = '\' + ' + $propertyPath + ' + \'';
	        if (it.opts._errorDataPathProperty) {
	          it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
	        }
	        out += ' var ' + ($valid) + ' = true; ';
	        if ($isData) {
	          out += ' if (schema' + ($lvl) + ' === undefined) ' + ($valid) + ' = true; else if (!Array.isArray(schema' + ($lvl) + ')) ' + ($valid) + ' = false; else {';
	        }
	        out += ' for (var ' + ($i) + ' = 0; ' + ($i) + ' < ' + ($vSchema) + '.length; ' + ($i) + '++) { ' + ($valid) + ' = ' + ($data) + '[' + ($vSchema) + '[' + ($i) + ']] !== undefined ';
	        if ($ownProperties) {
	          out += ' &&   Object.prototype.hasOwnProperty.call(' + ($data) + ', ' + ($vSchema) + '[' + ($i) + ']) ';
	        }
	        out += '; if (!' + ($valid) + ') break; } ';
	        if ($isData) {
	          out += '  }  ';
	        }
	        out += '  if (!' + ($valid) + ') {   ';
	        var $$outStack = $$outStack || [];
	        $$outStack.push(out);
	        out = '';
	        if (it.createErrors !== false) {
	          out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
	          if (it.opts.messages !== false) {
	            out += ' , message: \'';
	            if (it.opts._errorDataPathProperty) {
	              out += 'is a required property';
	            } else {
	              out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
	            }
	            out += '\' ';
	          }
	          if (it.opts.verbose) {
	            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
	          }
	          out += ' } ';
	        } else {
	          out += ' {} ';
	        }
	        var __err = out;
	        out = $$outStack.pop();
	        if (!it.compositeRule && $breakOnError) {
	          if (it.async) {
	            out += ' throw new ValidationError([' + (__err) + ']); ';
	          } else {
	            out += ' validate.errors = [' + (__err) + ']; return false; ';
	          }
	        } else {
	          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
	        }
	        out += ' } else { ';
	      } else {
	        out += ' if ( ';
	        var arr2 = $required;
	        if (arr2) {
	          var $propertyKey, $i = -1,
	            l2 = arr2.length - 1;
	          while ($i < l2) {
	            $propertyKey = arr2[$i += 1];
	            if ($i) {
	              out += ' || ';
	            }
	            var $prop = it.util.getProperty($propertyKey),
	              $useData = $data + $prop;
	            out += ' ( ( ' + ($useData) + ' === undefined ';
	            if ($ownProperties) {
	              out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
	            }
	            out += ') && (missing' + ($lvl) + ' = ' + (it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop)) + ') ) ';
	          }
	        }
	        out += ') {  ';
	        var $propertyPath = 'missing' + $lvl,
	          $missingProperty = '\' + ' + $propertyPath + ' + \'';
	        if (it.opts._errorDataPathProperty) {
	          it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + ' + ' + $propertyPath;
	        }
	        var $$outStack = $$outStack || [];
	        $$outStack.push(out);
	        out = '';
	        if (it.createErrors !== false) {
	          out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
	          if (it.opts.messages !== false) {
	            out += ' , message: \'';
	            if (it.opts._errorDataPathProperty) {
	              out += 'is a required property';
	            } else {
	              out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
	            }
	            out += '\' ';
	          }
	          if (it.opts.verbose) {
	            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
	          }
	          out += ' } ';
	        } else {
	          out += ' {} ';
	        }
	        var __err = out;
	        out = $$outStack.pop();
	        if (!it.compositeRule && $breakOnError) {
	          if (it.async) {
	            out += ' throw new ValidationError([' + (__err) + ']); ';
	          } else {
	            out += ' validate.errors = [' + (__err) + ']; return false; ';
	          }
	        } else {
	          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
	        }
	        out += ' } else { ';
	      }
	    } else {
	      if ($loopRequired) {
	        if (!$isData) {
	          out += ' var ' + ($vSchema) + ' = validate.schema' + ($schemaPath) + '; ';
	        }
	        var $i = 'i' + $lvl,
	          $propertyPath = 'schema' + $lvl + '[' + $i + ']',
	          $missingProperty = '\' + ' + $propertyPath + ' + \'';
	        if (it.opts._errorDataPathProperty) {
	          it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
	        }
	        if ($isData) {
	          out += ' if (' + ($vSchema) + ' && !Array.isArray(' + ($vSchema) + ')) {  var err =   ';
	          if (it.createErrors !== false) {
	            out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
	            if (it.opts.messages !== false) {
	              out += ' , message: \'';
	              if (it.opts._errorDataPathProperty) {
	                out += 'is a required property';
	              } else {
	                out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
	              }
	              out += '\' ';
	            }
	            if (it.opts.verbose) {
	              out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
	            }
	            out += ' } ';
	          } else {
	            out += ' {} ';
	          }
	          out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (' + ($vSchema) + ' !== undefined) { ';
	        }
	        out += ' for (var ' + ($i) + ' = 0; ' + ($i) + ' < ' + ($vSchema) + '.length; ' + ($i) + '++) { if (' + ($data) + '[' + ($vSchema) + '[' + ($i) + ']] === undefined ';
	        if ($ownProperties) {
	          out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', ' + ($vSchema) + '[' + ($i) + ']) ';
	        }
	        out += ') {  var err =   ';
	        if (it.createErrors !== false) {
	          out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
	          if (it.opts.messages !== false) {
	            out += ' , message: \'';
	            if (it.opts._errorDataPathProperty) {
	              out += 'is a required property';
	            } else {
	              out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
	            }
	            out += '\' ';
	          }
	          if (it.opts.verbose) {
	            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
	          }
	          out += ' } ';
	        } else {
	          out += ' {} ';
	        }
	        out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ';
	        if ($isData) {
	          out += '  }  ';
	        }
	      } else {
	        var arr3 = $required;
	        if (arr3) {
	          var $propertyKey, i3 = -1,
	            l3 = arr3.length - 1;
	          while (i3 < l3) {
	            $propertyKey = arr3[i3 += 1];
	            var $prop = it.util.getProperty($propertyKey),
	              $missingProperty = it.util.escapeQuotes($propertyKey),
	              $useData = $data + $prop;
	            if (it.opts._errorDataPathProperty) {
	              it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
	            }
	            out += ' if ( ' + ($useData) + ' === undefined ';
	            if ($ownProperties) {
	              out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
	            }
	            out += ') {  var err =   ';
	            if (it.createErrors !== false) {
	              out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
	              if (it.opts.messages !== false) {
	                out += ' , message: \'';
	                if (it.opts._errorDataPathProperty) {
	                  out += 'is a required property';
	                } else {
	                  out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
	                }
	                out += '\' ';
	              }
	              if (it.opts.verbose) {
	                out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
	              }
	              out += ' } ';
	            } else {
	              out += ' {} ';
	            }
	            out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ';
	          }
	        }
	      }
	    }
	    it.errorPath = $currentErrorPath;
	  } else if ($breakOnError) {
	    out += ' if (true) {';
	  }
	  return out;
	};
	return required$1;
}

var uniqueItems;
var hasRequiredUniqueItems;

function requireUniqueItems () {
	if (hasRequiredUniqueItems) return uniqueItems;
	hasRequiredUniqueItems = 1;
	uniqueItems = function generate_uniqueItems(it, $keyword, $ruleType) {
	  var out = ' ';
	  var $lvl = it.level;
	  var $dataLvl = it.dataLevel;
	  var $schema = it.schema[$keyword];
	  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
	  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
	  var $breakOnError = !it.opts.allErrors;
	  var $data = 'data' + ($dataLvl || '');
	  var $valid = 'valid' + $lvl;
	  var $isData = it.opts.$data && $schema && $schema.$data,
	    $schemaValue;
	  if ($isData) {
	    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
	    $schemaValue = 'schema' + $lvl;
	  } else {
	    $schemaValue = $schema;
	  }
	  if (($schema || $isData) && it.opts.uniqueItems !== false) {
	    if ($isData) {
	      out += ' var ' + ($valid) + '; if (' + ($schemaValue) + ' === false || ' + ($schemaValue) + ' === undefined) ' + ($valid) + ' = true; else if (typeof ' + ($schemaValue) + ' != \'boolean\') ' + ($valid) + ' = false; else { ';
	    }
	    out += ' var i = ' + ($data) + '.length , ' + ($valid) + ' = true , j; if (i > 1) { ';
	    var $itemType = it.schema.items && it.schema.items.type,
	      $typeIsArray = Array.isArray($itemType);
	    if (!$itemType || $itemType == 'object' || $itemType == 'array' || ($typeIsArray && ($itemType.indexOf('object') >= 0 || $itemType.indexOf('array') >= 0))) {
	      out += ' outer: for (;i--;) { for (j = i; j--;) { if (equal(' + ($data) + '[i], ' + ($data) + '[j])) { ' + ($valid) + ' = false; break outer; } } } ';
	    } else {
	      out += ' var itemIndices = {}, item; for (;i--;) { var item = ' + ($data) + '[i]; ';
	      var $method = 'checkDataType' + ($typeIsArray ? 's' : '');
	      out += ' if (' + (it.util[$method]($itemType, 'item', it.opts.strictNumbers, true)) + ') continue; ';
	      if ($typeIsArray) {
	        out += ' if (typeof item == \'string\') item = \'"\' + item; ';
	      }
	      out += ' if (typeof itemIndices[item] == \'number\') { ' + ($valid) + ' = false; j = itemIndices[item]; break; } itemIndices[item] = i; } ';
	    }
	    out += ' } ';
	    if ($isData) {
	      out += '  }  ';
	    }
	    out += ' if (!' + ($valid) + ') {   ';
	    var $$outStack = $$outStack || [];
	    $$outStack.push(out);
	    out = '';
	    if (it.createErrors !== false) {
	      out += ' { keyword: \'' + ('uniqueItems') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { i: i, j: j } ';
	      if (it.opts.messages !== false) {
	        out += ' , message: \'should NOT have duplicate items (items ## \' + j + \' and \' + i + \' are identical)\' ';
	      }
	      if (it.opts.verbose) {
	        out += ' , schema:  ';
	        if ($isData) {
	          out += 'validate.schema' + ($schemaPath);
	        } else {
	          out += '' + ($schema);
	        }
	        out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
	      }
	      out += ' } ';
	    } else {
	      out += ' {} ';
	    }
	    var __err = out;
	    out = $$outStack.pop();
	    if (!it.compositeRule && $breakOnError) {
	      if (it.async) {
	        out += ' throw new ValidationError([' + (__err) + ']); ';
	      } else {
	        out += ' validate.errors = [' + (__err) + ']; return false; ';
	      }
	    } else {
	      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
	    }
	    out += ' } ';
	    if ($breakOnError) {
	      out += ' else { ';
	    }
	  } else {
	    if ($breakOnError) {
	      out += ' if (true) { ';
	    }
	  }
	  return out;
	};
	return uniqueItems;
}

var dotjs;
var hasRequiredDotjs;

function requireDotjs () {
	if (hasRequiredDotjs) return dotjs;
	hasRequiredDotjs = 1;
	dotjs = {
	  '$ref': requireRef(),
	  allOf: requireAllOf(),
	  anyOf: requireAnyOf(),
	  '$comment': requireComment(),
	  const: require_const(),
	  contains: requireContains(),
	  dependencies: requireDependencies(),
	  'enum': require_enum(),
	  format: requireFormat(),
	  'if': require_if(),
	  items: requireItems(),
	  maximum: require_limit(),
	  minimum: require_limit(),
	  maxItems: require_limitItems(),
	  minItems: require_limitItems(),
	  maxLength: require_limitLength(),
	  minLength: require_limitLength(),
	  maxProperties: require_limitProperties(),
	  minProperties: require_limitProperties(),
	  multipleOf: requireMultipleOf(),
	  not: requireNot(),
	  oneOf: requireOneOf(),
	  pattern: requirePattern(),
	  properties: requireProperties(),
	  propertyNames: requirePropertyNames(),
	  required: requireRequired(),
	  uniqueItems: requireUniqueItems(),
	  validate: requireValidate()
	};
	return dotjs;
}

var rules;
var hasRequiredRules;

function requireRules () {
	if (hasRequiredRules) return rules;
	hasRequiredRules = 1;
	var ruleModules = requireDotjs()
	  , toHash = requireUtil$3().toHash;
	rules = function rules() {
	  var RULES = [
	    { type: 'number',
	      rules: [ { 'maximum': ['exclusiveMaximum'] },
	               { 'minimum': ['exclusiveMinimum'] }, 'multipleOf', 'format'] },
	    { type: 'string',
	      rules: [ 'maxLength', 'minLength', 'pattern', 'format' ] },
	    { type: 'array',
	      rules: [ 'maxItems', 'minItems', 'items', 'contains', 'uniqueItems' ] },
	    { type: 'object',
	      rules: [ 'maxProperties', 'minProperties', 'required', 'dependencies', 'propertyNames',
	               { 'properties': ['additionalProperties', 'patternProperties'] } ] },
	    { rules: [ '$ref', 'const', 'enum', 'not', 'anyOf', 'oneOf', 'allOf', 'if' ] }
	  ];
	  var ALL = [ 'type', '$comment' ];
	  var KEYWORDS = [
	    '$schema', '$id', 'id', '$data', '$async', 'title',
	    'description', 'default', 'definitions',
	    'examples', 'readOnly', 'writeOnly',
	    'contentMediaType', 'contentEncoding',
	    'additionalItems', 'then', 'else'
	  ];
	  var TYPES = [ 'number', 'integer', 'string', 'array', 'object', 'boolean', 'null' ];
	  RULES.all = toHash(ALL);
	  RULES.types = toHash(TYPES);
	  RULES.forEach(function (group) {
	    group.rules = group.rules.map(function (keyword) {
	      var implKeywords;
	      if (typeof keyword == 'object') {
	        var key = Object.keys(keyword)[0];
	        implKeywords = keyword[key];
	        keyword = key;
	        implKeywords.forEach(function (k) {
	          ALL.push(k);
	          RULES.all[k] = true;
	        });
	      }
	      ALL.push(keyword);
	      var rule = RULES.all[keyword] = {
	        keyword: keyword,
	        code: ruleModules[keyword],
	        implements: implKeywords
	      };
	      return rule;
	    });
	    RULES.all.$comment = {
	      keyword: '$comment',
	      code: ruleModules.$comment
	    };
	    if (group.type) RULES.types[group.type] = group;
	  });
	  RULES.keywords = toHash(ALL.concat(KEYWORDS));
	  RULES.custom = {};
	  return RULES;
	};
	return rules;
}

var data$1;
var hasRequiredData$1;

function requireData$1 () {
	if (hasRequiredData$1) return data$1;
	hasRequiredData$1 = 1;
	var KEYWORDS = [
	  'multipleOf',
	  'maximum',
	  'exclusiveMaximum',
	  'minimum',
	  'exclusiveMinimum',
	  'maxLength',
	  'minLength',
	  'pattern',
	  'additionalItems',
	  'maxItems',
	  'minItems',
	  'uniqueItems',
	  'maxProperties',
	  'minProperties',
	  'required',
	  'additionalProperties',
	  'enum',
	  'format',
	  'const'
	];
	data$1 = function (metaSchema, keywordsJsonPointers) {
	  for (var i=0; i<keywordsJsonPointers.length; i++) {
	    metaSchema = JSON.parse(JSON.stringify(metaSchema));
	    var segments = keywordsJsonPointers[i].split('/');
	    var keywords = metaSchema;
	    var j;
	    for (j=1; j<segments.length; j++)
	      keywords = keywords[segments[j]];
	    for (j=0; j<KEYWORDS.length; j++) {
	      var key = KEYWORDS[j];
	      var schema = keywords[key];
	      if (schema) {
	        keywords[key] = {
	          anyOf: [
	            schema,
	            { $ref: 'https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#' }
	          ]
	        };
	      }
	    }
	  }
	  return metaSchema;
	};
	return data$1;
}

var async$1;
var hasRequiredAsync;

function requireAsync () {
	if (hasRequiredAsync) return async$1;
	hasRequiredAsync = 1;
	var MissingRefError = requireError_classes().MissingRef;
	async$1 = compileAsync;
	function compileAsync(schema, meta, callback) {
	  var self = this;
	  if (typeof this._opts.loadSchema != 'function')
	    throw new Error('options.loadSchema should be a function');
	  if (typeof meta == 'function') {
	    callback = meta;
	    meta = undefined;
	  }
	  var p = loadMetaSchemaOf(schema).then(function () {
	    var schemaObj = self._addSchema(schema, undefined, meta);
	    return schemaObj.validate || _compileAsync(schemaObj);
	  });
	  if (callback) {
	    p.then(
	      function(v) { callback(null, v); },
	      callback
	    );
	  }
	  return p;
	  function loadMetaSchemaOf(sch) {
	    var $schema = sch.$schema;
	    return $schema && !self.getSchema($schema)
	            ? compileAsync.call(self, { $ref: $schema }, true)
	            : Promise.resolve();
	  }
	  function _compileAsync(schemaObj) {
	    try { return self._compile(schemaObj); }
	    catch(e) {
	      if (e instanceof MissingRefError) return loadMissingSchema(e);
	      throw e;
	    }
	    function loadMissingSchema(e) {
	      var ref = e.missingSchema;
	      if (added(ref)) throw new Error('Schema ' + ref + ' is loaded but ' + e.missingRef + ' cannot be resolved');
	      var schemaPromise = self._loadingSchemas[ref];
	      if (!schemaPromise) {
	        schemaPromise = self._loadingSchemas[ref] = self._opts.loadSchema(ref);
	        schemaPromise.then(removePromise, removePromise);
	      }
	      return schemaPromise.then(function (sch) {
	        if (!added(ref)) {
	          return loadMetaSchemaOf(sch).then(function () {
	            if (!added(ref)) self.addSchema(sch, ref, undefined, meta);
	          });
	        }
	      }).then(function() {
	        return _compileAsync(schemaObj);
	      });
	      function removePromise() {
	        delete self._loadingSchemas[ref];
	      }
	      function added(ref) {
	        return self._refs[ref] || self._schemas[ref];
	      }
	    }
	  }
	}
	return async$1;
}

var custom;
var hasRequiredCustom;

function requireCustom () {
	if (hasRequiredCustom) return custom;
	hasRequiredCustom = 1;
	custom = function generate_custom(it, $keyword, $ruleType) {
	  var out = ' ';
	  var $lvl = it.level;
	  var $dataLvl = it.dataLevel;
	  var $schema = it.schema[$keyword];
	  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
	  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
	  var $breakOnError = !it.opts.allErrors;
	  var $errorKeyword;
	  var $data = 'data' + ($dataLvl || '');
	  var $valid = 'valid' + $lvl;
	  var $errs = 'errs__' + $lvl;
	  var $isData = it.opts.$data && $schema && $schema.$data,
	    $schemaValue;
	  if ($isData) {
	    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
	    $schemaValue = 'schema' + $lvl;
	  } else {
	    $schemaValue = $schema;
	  }
	  var $rule = this,
	    $definition = 'definition' + $lvl,
	    $rDef = $rule.definition,
	    $closingBraces = '';
	  var $compile, $inline, $macro, $ruleValidate, $validateCode;
	  if ($isData && $rDef.$data) {
	    $validateCode = 'keywordValidate' + $lvl;
	    var $validateSchema = $rDef.validateSchema;
	    out += ' var ' + ($definition) + ' = RULES.custom[\'' + ($keyword) + '\'].definition; var ' + ($validateCode) + ' = ' + ($definition) + '.validate;';
	  } else {
	    $ruleValidate = it.useCustomRule($rule, $schema, it.schema, it);
	    if (!$ruleValidate) return;
	    $schemaValue = 'validate.schema' + $schemaPath;
	    $validateCode = $ruleValidate.code;
	    $compile = $rDef.compile;
	    $inline = $rDef.inline;
	    $macro = $rDef.macro;
	  }
	  var $ruleErrs = $validateCode + '.errors',
	    $i = 'i' + $lvl,
	    $ruleErr = 'ruleErr' + $lvl,
	    $asyncKeyword = $rDef.async;
	  if ($asyncKeyword && !it.async) throw new Error('async keyword in sync schema');
	  if (!($inline || $macro)) {
	    out += '' + ($ruleErrs) + ' = null;';
	  }
	  out += 'var ' + ($errs) + ' = errors;var ' + ($valid) + ';';
	  if ($isData && $rDef.$data) {
	    $closingBraces += '}';
	    out += ' if (' + ($schemaValue) + ' === undefined) { ' + ($valid) + ' = true; } else { ';
	    if ($validateSchema) {
	      $closingBraces += '}';
	      out += ' ' + ($valid) + ' = ' + ($definition) + '.validateSchema(' + ($schemaValue) + '); if (' + ($valid) + ') { ';
	    }
	  }
	  if ($inline) {
	    if ($rDef.statements) {
	      out += ' ' + ($ruleValidate.validate) + ' ';
	    } else {
	      out += ' ' + ($valid) + ' = ' + ($ruleValidate.validate) + '; ';
	    }
	  } else if ($macro) {
	    var $it = it.util.copy(it);
	    var $closingBraces = '';
	    $it.level++;
	    var $nextValid = 'valid' + $it.level;
	    $it.schema = $ruleValidate.validate;
	    $it.schemaPath = '';
	    var $wasComposite = it.compositeRule;
	    it.compositeRule = $it.compositeRule = true;
	    var $code = it.validate($it).replace(/validate\.schema/g, $validateCode);
	    it.compositeRule = $it.compositeRule = $wasComposite;
	    out += ' ' + ($code);
	  } else {
	    var $$outStack = $$outStack || [];
	    $$outStack.push(out);
	    out = '';
	    out += '  ' + ($validateCode) + '.call( ';
	    if (it.opts.passContext) {
	      out += 'this';
	    } else {
	      out += 'self';
	    }
	    if ($compile || $rDef.schema === false) {
	      out += ' , ' + ($data) + ' ';
	    } else {
	      out += ' , ' + ($schemaValue) + ' , ' + ($data) + ' , validate.schema' + (it.schemaPath) + ' ';
	    }
	    out += ' , (dataPath || \'\')';
	    if (it.errorPath != '""') {
	      out += ' + ' + (it.errorPath);
	    }
	    var $parentData = $dataLvl ? 'data' + (($dataLvl - 1) || '') : 'parentData',
	      $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';
	    out += ' , ' + ($parentData) + ' , ' + ($parentDataProperty) + ' , rootData )  ';
	    var def_callRuleValidate = out;
	    out = $$outStack.pop();
	    if ($rDef.errors === false) {
	      out += ' ' + ($valid) + ' = ';
	      if ($asyncKeyword) {
	        out += 'await ';
	      }
	      out += '' + (def_callRuleValidate) + '; ';
	    } else {
	      if ($asyncKeyword) {
	        $ruleErrs = 'customErrors' + $lvl;
	        out += ' var ' + ($ruleErrs) + ' = null; try { ' + ($valid) + ' = await ' + (def_callRuleValidate) + '; } catch (e) { ' + ($valid) + ' = false; if (e instanceof ValidationError) ' + ($ruleErrs) + ' = e.errors; else throw e; } ';
	      } else {
	        out += ' ' + ($ruleErrs) + ' = null; ' + ($valid) + ' = ' + (def_callRuleValidate) + '; ';
	      }
	    }
	  }
	  if ($rDef.modifying) {
	    out += ' if (' + ($parentData) + ') ' + ($data) + ' = ' + ($parentData) + '[' + ($parentDataProperty) + '];';
	  }
	  out += '' + ($closingBraces);
	  if ($rDef.valid) {
	    if ($breakOnError) {
	      out += ' if (true) { ';
	    }
	  } else {
	    out += ' if ( ';
	    if ($rDef.valid === undefined) {
	      out += ' !';
	      if ($macro) {
	        out += '' + ($nextValid);
	      } else {
	        out += '' + ($valid);
	      }
	    } else {
	      out += ' ' + (!$rDef.valid) + ' ';
	    }
	    out += ') { ';
	    $errorKeyword = $rule.keyword;
	    var $$outStack = $$outStack || [];
	    $$outStack.push(out);
	    out = '';
	    var $$outStack = $$outStack || [];
	    $$outStack.push(out);
	    out = '';
	    if (it.createErrors !== false) {
	      out += ' { keyword: \'' + ($errorKeyword || 'custom') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { keyword: \'' + ($rule.keyword) + '\' } ';
	      if (it.opts.messages !== false) {
	        out += ' , message: \'should pass "' + ($rule.keyword) + '" keyword validation\' ';
	      }
	      if (it.opts.verbose) {
	        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
	      }
	      out += ' } ';
	    } else {
	      out += ' {} ';
	    }
	    var __err = out;
	    out = $$outStack.pop();
	    if (!it.compositeRule && $breakOnError) {
	      if (it.async) {
	        out += ' throw new ValidationError([' + (__err) + ']); ';
	      } else {
	        out += ' validate.errors = [' + (__err) + ']; return false; ';
	      }
	    } else {
	      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
	    }
	    var def_customError = out;
	    out = $$outStack.pop();
	    if ($inline) {
	      if ($rDef.errors) {
	        if ($rDef.errors != 'full') {
	          out += '  for (var ' + ($i) + '=' + ($errs) + '; ' + ($i) + '<errors; ' + ($i) + '++) { var ' + ($ruleErr) + ' = vErrors[' + ($i) + ']; if (' + ($ruleErr) + '.dataPath === undefined) ' + ($ruleErr) + '.dataPath = (dataPath || \'\') + ' + (it.errorPath) + '; if (' + ($ruleErr) + '.schemaPath === undefined) { ' + ($ruleErr) + '.schemaPath = "' + ($errSchemaPath) + '"; } ';
	          if (it.opts.verbose) {
	            out += ' ' + ($ruleErr) + '.schema = ' + ($schemaValue) + '; ' + ($ruleErr) + '.data = ' + ($data) + '; ';
	          }
	          out += ' } ';
	        }
	      } else {
	        if ($rDef.errors === false) {
	          out += ' ' + (def_customError) + ' ';
	        } else {
	          out += ' if (' + ($errs) + ' == errors) { ' + (def_customError) + ' } else {  for (var ' + ($i) + '=' + ($errs) + '; ' + ($i) + '<errors; ' + ($i) + '++) { var ' + ($ruleErr) + ' = vErrors[' + ($i) + ']; if (' + ($ruleErr) + '.dataPath === undefined) ' + ($ruleErr) + '.dataPath = (dataPath || \'\') + ' + (it.errorPath) + '; if (' + ($ruleErr) + '.schemaPath === undefined) { ' + ($ruleErr) + '.schemaPath = "' + ($errSchemaPath) + '"; } ';
	          if (it.opts.verbose) {
	            out += ' ' + ($ruleErr) + '.schema = ' + ($schemaValue) + '; ' + ($ruleErr) + '.data = ' + ($data) + '; ';
	          }
	          out += ' } } ';
	        }
	      }
	    } else if ($macro) {
	      out += '   var err =   ';
	      if (it.createErrors !== false) {
	        out += ' { keyword: \'' + ($errorKeyword || 'custom') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { keyword: \'' + ($rule.keyword) + '\' } ';
	        if (it.opts.messages !== false) {
	          out += ' , message: \'should pass "' + ($rule.keyword) + '" keyword validation\' ';
	        }
	        if (it.opts.verbose) {
	          out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
	        }
	        out += ' } ';
	      } else {
	        out += ' {} ';
	      }
	      out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
	      if (!it.compositeRule && $breakOnError) {
	        if (it.async) {
	          out += ' throw new ValidationError(vErrors); ';
	        } else {
	          out += ' validate.errors = vErrors; return false; ';
	        }
	      }
	    } else {
	      if ($rDef.errors === false) {
	        out += ' ' + (def_customError) + ' ';
	      } else {
	        out += ' if (Array.isArray(' + ($ruleErrs) + ')) { if (vErrors === null) vErrors = ' + ($ruleErrs) + '; else vErrors = vErrors.concat(' + ($ruleErrs) + '); errors = vErrors.length;  for (var ' + ($i) + '=' + ($errs) + '; ' + ($i) + '<errors; ' + ($i) + '++) { var ' + ($ruleErr) + ' = vErrors[' + ($i) + ']; if (' + ($ruleErr) + '.dataPath === undefined) ' + ($ruleErr) + '.dataPath = (dataPath || \'\') + ' + (it.errorPath) + ';  ' + ($ruleErr) + '.schemaPath = "' + ($errSchemaPath) + '";  ';
	        if (it.opts.verbose) {
	          out += ' ' + ($ruleErr) + '.schema = ' + ($schemaValue) + '; ' + ($ruleErr) + '.data = ' + ($data) + '; ';
	        }
	        out += ' } } else { ' + (def_customError) + ' } ';
	      }
	    }
	    out += ' } ';
	    if ($breakOnError) {
	      out += ' else { ';
	    }
	  }
	  return out;
	};
	return custom;
}

var $schema$1 = "http://json-schema.org/draft-07/schema#";
var $id$1 = "http://json-schema.org/draft-07/schema#";
var title = "Core schema meta-schema";
var definitions = {
	schemaArray: {
		type: "array",
		minItems: 1,
		items: {
			$ref: "#"
		}
	},
	nonNegativeInteger: {
		type: "integer",
		minimum: 0
	},
	nonNegativeIntegerDefault0: {
		allOf: [
			{
				$ref: "#/definitions/nonNegativeInteger"
			},
			{
				"default": 0
			}
		]
	},
	simpleTypes: {
		"enum": [
			"array",
			"boolean",
			"integer",
			"null",
			"number",
			"object",
			"string"
		]
	},
	stringArray: {
		type: "array",
		items: {
			type: "string"
		},
		uniqueItems: true,
		"default": [
		]
	}
};
var type$1 = [
	"object",
	"boolean"
];
var properties$1 = {
	$id: {
		type: "string",
		format: "uri-reference"
	},
	$schema: {
		type: "string",
		format: "uri"
	},
	$ref: {
		type: "string",
		format: "uri-reference"
	},
	$comment: {
		type: "string"
	},
	title: {
		type: "string"
	},
	description: {
		type: "string"
	},
	"default": true,
	readOnly: {
		type: "boolean",
		"default": false
	},
	examples: {
		type: "array",
		items: true
	},
	multipleOf: {
		type: "number",
		exclusiveMinimum: 0
	},
	maximum: {
		type: "number"
	},
	exclusiveMaximum: {
		type: "number"
	},
	minimum: {
		type: "number"
	},
	exclusiveMinimum: {
		type: "number"
	},
	maxLength: {
		$ref: "#/definitions/nonNegativeInteger"
	},
	minLength: {
		$ref: "#/definitions/nonNegativeIntegerDefault0"
	},
	pattern: {
		type: "string",
		format: "regex"
	},
	additionalItems: {
		$ref: "#"
	},
	items: {
		anyOf: [
			{
				$ref: "#"
			},
			{
				$ref: "#/definitions/schemaArray"
			}
		],
		"default": true
	},
	maxItems: {
		$ref: "#/definitions/nonNegativeInteger"
	},
	minItems: {
		$ref: "#/definitions/nonNegativeIntegerDefault0"
	},
	uniqueItems: {
		type: "boolean",
		"default": false
	},
	contains: {
		$ref: "#"
	},
	maxProperties: {
		$ref: "#/definitions/nonNegativeInteger"
	},
	minProperties: {
		$ref: "#/definitions/nonNegativeIntegerDefault0"
	},
	required: {
		$ref: "#/definitions/stringArray"
	},
	additionalProperties: {
		$ref: "#"
	},
	definitions: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		"default": {
		}
	},
	properties: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		"default": {
		}
	},
	patternProperties: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		propertyNames: {
			format: "regex"
		},
		"default": {
		}
	},
	dependencies: {
		type: "object",
		additionalProperties: {
			anyOf: [
				{
					$ref: "#"
				},
				{
					$ref: "#/definitions/stringArray"
				}
			]
		}
	},
	propertyNames: {
		$ref: "#"
	},
	"const": true,
	"enum": {
		type: "array",
		items: true,
		minItems: 1,
		uniqueItems: true
	},
	type: {
		anyOf: [
			{
				$ref: "#/definitions/simpleTypes"
			},
			{
				type: "array",
				items: {
					$ref: "#/definitions/simpleTypes"
				},
				minItems: 1,
				uniqueItems: true
			}
		]
	},
	format: {
		type: "string"
	},
	contentMediaType: {
		type: "string"
	},
	contentEncoding: {
		type: "string"
	},
	"if": {
		$ref: "#"
	},
	then: {
		$ref: "#"
	},
	"else": {
		$ref: "#"
	},
	allOf: {
		$ref: "#/definitions/schemaArray"
	},
	anyOf: {
		$ref: "#/definitions/schemaArray"
	},
	oneOf: {
		$ref: "#/definitions/schemaArray"
	},
	not: {
		$ref: "#"
	}
};
var require$$13 = {
	$schema: $schema$1,
	$id: $id$1,
	title: title,
	definitions: definitions,
	type: type$1,
	properties: properties$1,
	"default": true
};

var definition_schema;
var hasRequiredDefinition_schema;

function requireDefinition_schema () {
	if (hasRequiredDefinition_schema) return definition_schema;
	hasRequiredDefinition_schema = 1;
	var metaSchema = require$$13;
	definition_schema = {
	  $id: 'https://github.com/ajv-validator/ajv/blob/master/lib/definition_schema.js',
	  definitions: {
	    simpleTypes: metaSchema.definitions.simpleTypes
	  },
	  type: 'object',
	  dependencies: {
	    schema: ['validate'],
	    $data: ['validate'],
	    statements: ['inline'],
	    valid: {not: {required: ['macro']}}
	  },
	  properties: {
	    type: metaSchema.properties.type,
	    schema: {type: 'boolean'},
	    statements: {type: 'boolean'},
	    dependencies: {
	      type: 'array',
	      items: {type: 'string'}
	    },
	    metaSchema: {type: 'object'},
	    modifying: {type: 'boolean'},
	    valid: {type: 'boolean'},
	    $data: {type: 'boolean'},
	    async: {type: 'boolean'},
	    errors: {
	      anyOf: [
	        {type: 'boolean'},
	        {const: 'full'}
	      ]
	    }
	  }
	};
	return definition_schema;
}

var keyword$1;
var hasRequiredKeyword$1;

function requireKeyword$1 () {
	if (hasRequiredKeyword$1) return keyword$1;
	hasRequiredKeyword$1 = 1;
	var IDENTIFIER = /^[a-z_$][a-z0-9_$-]*$/i;
	var customRuleCode = requireCustom();
	var definitionSchema = requireDefinition_schema();
	keyword$1 = {
	  add: addKeyword,
	  get: getKeyword,
	  remove: removeKeyword,
	  validate: validateKeyword
	};
	function addKeyword(keyword, definition) {
	  var RULES = this.RULES;
	  if (RULES.keywords[keyword])
	    throw new Error('Keyword ' + keyword + ' is already defined');
	  if (!IDENTIFIER.test(keyword))
	    throw new Error('Keyword ' + keyword + ' is not a valid identifier');
	  if (definition) {
	    this.validateKeyword(definition, true);
	    var dataType = definition.type;
	    if (Array.isArray(dataType)) {
	      for (var i=0; i<dataType.length; i++)
	        _addRule(keyword, dataType[i], definition);
	    } else {
	      _addRule(keyword, dataType, definition);
	    }
	    var metaSchema = definition.metaSchema;
	    if (metaSchema) {
	      if (definition.$data && this._opts.$data) {
	        metaSchema = {
	          anyOf: [
	            metaSchema,
	            { '$ref': 'https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#' }
	          ]
	        };
	      }
	      definition.validateSchema = this.compile(metaSchema, true);
	    }
	  }
	  RULES.keywords[keyword] = RULES.all[keyword] = true;
	  function _addRule(keyword, dataType, definition) {
	    var ruleGroup;
	    for (var i=0; i<RULES.length; i++) {
	      var rg = RULES[i];
	      if (rg.type == dataType) {
	        ruleGroup = rg;
	        break;
	      }
	    }
	    if (!ruleGroup) {
	      ruleGroup = { type: dataType, rules: [] };
	      RULES.push(ruleGroup);
	    }
	    var rule = {
	      keyword: keyword,
	      definition: definition,
	      custom: true,
	      code: customRuleCode,
	      implements: definition.implements
	    };
	    ruleGroup.rules.push(rule);
	    RULES.custom[keyword] = rule;
	  }
	  return this;
	}
	function getKeyword(keyword) {
	  var rule = this.RULES.custom[keyword];
	  return rule ? rule.definition : this.RULES.keywords[keyword] || false;
	}
	function removeKeyword(keyword) {
	  var RULES = this.RULES;
	  delete RULES.keywords[keyword];
	  delete RULES.all[keyword];
	  delete RULES.custom[keyword];
	  for (var i=0; i<RULES.length; i++) {
	    var rules = RULES[i].rules;
	    for (var j=0; j<rules.length; j++) {
	      if (rules[j].keyword == keyword) {
	        rules.splice(j, 1);
	        break;
	      }
	    }
	  }
	  return this;
	}
	function validateKeyword(definition, throwError) {
	  validateKeyword.errors = null;
	  var v = this._validateKeyword = this._validateKeyword
	                                  || this.compile(definitionSchema, true);
	  if (v(definition)) return true;
	  validateKeyword.errors = v.errors;
	  if (throwError)
	    throw new Error('custom keyword definition is invalid: '  + this.errorsText(v.errors));
	  else
	    return false;
	}
	return keyword$1;
}

var $schema = "http://json-schema.org/draft-07/schema#";
var $id = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#";
var description = "Meta-schema for $data reference (JSON Schema extension proposal)";
var type = "object";
var required = [
	"$data"
];
var properties = {
	$data: {
		type: "string",
		anyOf: [
			{
				format: "relative-json-pointer"
			},
			{
				format: "json-pointer"
			}
		]
	}
};
var additionalProperties = false;
var require$$12 = {
	$schema: $schema,
	$id: $id,
	description: description,
	type: type,
	required: required,
	properties: properties,
	additionalProperties: additionalProperties
};

var ajv;
var hasRequiredAjv;

function requireAjv () {
	if (hasRequiredAjv) return ajv;
	hasRequiredAjv = 1;
	var compileSchema = requireCompile$1()
	  , resolve = requireResolve()
	  , Cache = requireCache()
	  , SchemaObject = requireSchema_obj()
	  , stableStringify = requireFastJsonStableStringify()
	  , formats = requireFormats()
	  , rules = requireRules()
	  , $dataMetaSchema = requireData$1()
	  , util = requireUtil$3();
	ajv = Ajv;
	Ajv.prototype.validate = validate;
	Ajv.prototype.compile = compile;
	Ajv.prototype.addSchema = addSchema;
	Ajv.prototype.addMetaSchema = addMetaSchema;
	Ajv.prototype.validateSchema = validateSchema;
	Ajv.prototype.getSchema = getSchema;
	Ajv.prototype.removeSchema = removeSchema;
	Ajv.prototype.addFormat = addFormat;
	Ajv.prototype.errorsText = errorsText;
	Ajv.prototype._addSchema = _addSchema;
	Ajv.prototype._compile = _compile;
	Ajv.prototype.compileAsync = requireAsync();
	var customKeyword = requireKeyword$1();
	Ajv.prototype.addKeyword = customKeyword.add;
	Ajv.prototype.getKeyword = customKeyword.get;
	Ajv.prototype.removeKeyword = customKeyword.remove;
	Ajv.prototype.validateKeyword = customKeyword.validate;
	var errorClasses = requireError_classes();
	Ajv.ValidationError = errorClasses.Validation;
	Ajv.MissingRefError = errorClasses.MissingRef;
	Ajv.$dataMetaSchema = $dataMetaSchema;
	var META_SCHEMA_ID = 'http://json-schema.org/draft-07/schema';
	var META_IGNORE_OPTIONS = [ 'removeAdditional', 'useDefaults', 'coerceTypes', 'strictDefaults' ];
	var META_SUPPORT_DATA = ['/properties'];
	function Ajv(opts) {
	  if (!(this instanceof Ajv)) return new Ajv(opts);
	  opts = this._opts = util.copy(opts) || {};
	  setLogger(this);
	  this._schemas = {};
	  this._refs = {};
	  this._fragments = {};
	  this._formats = formats(opts.format);
	  this._cache = opts.cache || new Cache;
	  this._loadingSchemas = {};
	  this._compilations = [];
	  this.RULES = rules();
	  this._getId = chooseGetId(opts);
	  opts.loopRequired = opts.loopRequired || Infinity;
	  if (opts.errorDataPath == 'property') opts._errorDataPathProperty = true;
	  if (opts.serialize === undefined) opts.serialize = stableStringify;
	  this._metaOpts = getMetaSchemaOptions(this);
	  if (opts.formats) addInitialFormats(this);
	  if (opts.keywords) addInitialKeywords(this);
	  addDefaultMetaSchema(this);
	  if (typeof opts.meta == 'object') this.addMetaSchema(opts.meta);
	  if (opts.nullable) this.addKeyword('nullable', {metaSchema: {type: 'boolean'}});
	  addInitialSchemas(this);
	}
	function validate(schemaKeyRef, data) {
	  var v;
	  if (typeof schemaKeyRef == 'string') {
	    v = this.getSchema(schemaKeyRef);
	    if (!v) throw new Error('no schema with key or ref "' + schemaKeyRef + '"');
	  } else {
	    var schemaObj = this._addSchema(schemaKeyRef);
	    v = schemaObj.validate || this._compile(schemaObj);
	  }
	  var valid = v(data);
	  if (v.$async !== true) this.errors = v.errors;
	  return valid;
	}
	function compile(schema, _meta) {
	  var schemaObj = this._addSchema(schema, undefined, _meta);
	  return schemaObj.validate || this._compile(schemaObj);
	}
	function addSchema(schema, key, _skipValidation, _meta) {
	  if (Array.isArray(schema)){
	    for (var i=0; i<schema.length; i++) this.addSchema(schema[i], undefined, _skipValidation, _meta);
	    return this;
	  }
	  var id = this._getId(schema);
	  if (id !== undefined && typeof id != 'string')
	    throw new Error('schema id must be string');
	  key = resolve.normalizeId(key || id);
	  checkUnique(this, key);
	  this._schemas[key] = this._addSchema(schema, _skipValidation, _meta, true);
	  return this;
	}
	function addMetaSchema(schema, key, skipValidation) {
	  this.addSchema(schema, key, skipValidation, true);
	  return this;
	}
	function validateSchema(schema, throwOrLogError) {
	  var $schema = schema.$schema;
	  if ($schema !== undefined && typeof $schema != 'string')
	    throw new Error('$schema must be a string');
	  $schema = $schema || this._opts.defaultMeta || defaultMeta(this);
	  if (!$schema) {
	    this.logger.warn('meta-schema not available');
	    this.errors = null;
	    return true;
	  }
	  var valid = this.validate($schema, schema);
	  if (!valid && throwOrLogError) {
	    var message = 'schema is invalid: ' + this.errorsText();
	    if (this._opts.validateSchema == 'log') this.logger.error(message);
	    else throw new Error(message);
	  }
	  return valid;
	}
	function defaultMeta(self) {
	  var meta = self._opts.meta;
	  self._opts.defaultMeta = typeof meta == 'object'
	                            ? self._getId(meta) || meta
	                            : self.getSchema(META_SCHEMA_ID)
	                              ? META_SCHEMA_ID
	                              : undefined;
	  return self._opts.defaultMeta;
	}
	function getSchema(keyRef) {
	  var schemaObj = _getSchemaObj(this, keyRef);
	  switch (typeof schemaObj) {
	    case 'object': return schemaObj.validate || this._compile(schemaObj);
	    case 'string': return this.getSchema(schemaObj);
	    case 'undefined': return _getSchemaFragment(this, keyRef);
	  }
	}
	function _getSchemaFragment(self, ref) {
	  var res = resolve.schema.call(self, { schema: {} }, ref);
	  if (res) {
	    var schema = res.schema
	      , root = res.root
	      , baseId = res.baseId;
	    var v = compileSchema.call(self, schema, root, undefined, baseId);
	    self._fragments[ref] = new SchemaObject({
	      ref: ref,
	      fragment: true,
	      schema: schema,
	      root: root,
	      baseId: baseId,
	      validate: v
	    });
	    return v;
	  }
	}
	function _getSchemaObj(self, keyRef) {
	  keyRef = resolve.normalizeId(keyRef);
	  return self._schemas[keyRef] || self._refs[keyRef] || self._fragments[keyRef];
	}
	function removeSchema(schemaKeyRef) {
	  if (schemaKeyRef instanceof RegExp) {
	    _removeAllSchemas(this, this._schemas, schemaKeyRef);
	    _removeAllSchemas(this, this._refs, schemaKeyRef);
	    return this;
	  }
	  switch (typeof schemaKeyRef) {
	    case 'undefined':
	      _removeAllSchemas(this, this._schemas);
	      _removeAllSchemas(this, this._refs);
	      this._cache.clear();
	      return this;
	    case 'string':
	      var schemaObj = _getSchemaObj(this, schemaKeyRef);
	      if (schemaObj) this._cache.del(schemaObj.cacheKey);
	      delete this._schemas[schemaKeyRef];
	      delete this._refs[schemaKeyRef];
	      return this;
	    case 'object':
	      var serialize = this._opts.serialize;
	      var cacheKey = serialize ? serialize(schemaKeyRef) : schemaKeyRef;
	      this._cache.del(cacheKey);
	      var id = this._getId(schemaKeyRef);
	      if (id) {
	        id = resolve.normalizeId(id);
	        delete this._schemas[id];
	        delete this._refs[id];
	      }
	  }
	  return this;
	}
	function _removeAllSchemas(self, schemas, regex) {
	  for (var keyRef in schemas) {
	    var schemaObj = schemas[keyRef];
	    if (!schemaObj.meta && (!regex || regex.test(keyRef))) {
	      self._cache.del(schemaObj.cacheKey);
	      delete schemas[keyRef];
	    }
	  }
	}
	function _addSchema(schema, skipValidation, meta, shouldAddSchema) {
	  if (typeof schema != 'object' && typeof schema != 'boolean')
	    throw new Error('schema should be object or boolean');
	  var serialize = this._opts.serialize;
	  var cacheKey = serialize ? serialize(schema) : schema;
	  var cached = this._cache.get(cacheKey);
	  if (cached) return cached;
	  shouldAddSchema = shouldAddSchema || this._opts.addUsedSchema !== false;
	  var id = resolve.normalizeId(this._getId(schema));
	  if (id && shouldAddSchema) checkUnique(this, id);
	  var willValidate = this._opts.validateSchema !== false && !skipValidation;
	  var recursiveMeta;
	  if (willValidate && !(recursiveMeta = id && id == resolve.normalizeId(schema.$schema)))
	    this.validateSchema(schema, true);
	  var localRefs = resolve.ids.call(this, schema);
	  var schemaObj = new SchemaObject({
	    id: id,
	    schema: schema,
	    localRefs: localRefs,
	    cacheKey: cacheKey,
	    meta: meta
	  });
	  if (id[0] != '#' && shouldAddSchema) this._refs[id] = schemaObj;
	  this._cache.put(cacheKey, schemaObj);
	  if (willValidate && recursiveMeta) this.validateSchema(schema, true);
	  return schemaObj;
	}
	function _compile(schemaObj, root) {
	  if (schemaObj.compiling) {
	    schemaObj.validate = callValidate;
	    callValidate.schema = schemaObj.schema;
	    callValidate.errors = null;
	    callValidate.root = root ? root : callValidate;
	    if (schemaObj.schema.$async === true)
	      callValidate.$async = true;
	    return callValidate;
	  }
	  schemaObj.compiling = true;
	  var currentOpts;
	  if (schemaObj.meta) {
	    currentOpts = this._opts;
	    this._opts = this._metaOpts;
	  }
	  var v;
	  try { v = compileSchema.call(this, schemaObj.schema, root, schemaObj.localRefs); }
	  catch(e) {
	    delete schemaObj.validate;
	    throw e;
	  }
	  finally {
	    schemaObj.compiling = false;
	    if (schemaObj.meta) this._opts = currentOpts;
	  }
	  schemaObj.validate = v;
	  schemaObj.refs = v.refs;
	  schemaObj.refVal = v.refVal;
	  schemaObj.root = v.root;
	  return v;
	  function callValidate() {
	    var _validate = schemaObj.validate;
	    var result = _validate.apply(this, arguments);
	    callValidate.errors = _validate.errors;
	    return result;
	  }
	}
	function chooseGetId(opts) {
	  switch (opts.schemaId) {
	    case 'auto': return _get$IdOrId;
	    case 'id': return _getId;
	    default: return _get$Id;
	  }
	}
	function _getId(schema) {
	  if (schema.$id) this.logger.warn('schema $id ignored', schema.$id);
	  return schema.id;
	}
	function _get$Id(schema) {
	  if (schema.id) this.logger.warn('schema id ignored', schema.id);
	  return schema.$id;
	}
	function _get$IdOrId(schema) {
	  if (schema.$id && schema.id && schema.$id != schema.id)
	    throw new Error('schema $id is different from id');
	  return schema.$id || schema.id;
	}
	function errorsText(errors, options) {
	  errors = errors || this.errors;
	  if (!errors) return 'No errors';
	  options = options || {};
	  var separator = options.separator === undefined ? ', ' : options.separator;
	  var dataVar = options.dataVar === undefined ? 'data' : options.dataVar;
	  var text = '';
	  for (var i=0; i<errors.length; i++) {
	    var e = errors[i];
	    if (e) text += dataVar + e.dataPath + ' ' + e.message + separator;
	  }
	  return text.slice(0, -separator.length);
	}
	function addFormat(name, format) {
	  if (typeof format == 'string') format = new RegExp(format);
	  this._formats[name] = format;
	  return this;
	}
	function addDefaultMetaSchema(self) {
	  var $dataSchema;
	  if (self._opts.$data) {
	    $dataSchema = require$$12;
	    self.addMetaSchema($dataSchema, $dataSchema.$id, true);
	  }
	  if (self._opts.meta === false) return;
	  var metaSchema = require$$13;
	  if (self._opts.$data) metaSchema = $dataMetaSchema(metaSchema, META_SUPPORT_DATA);
	  self.addMetaSchema(metaSchema, META_SCHEMA_ID, true);
	  self._refs['http://json-schema.org/schema'] = META_SCHEMA_ID;
	}
	function addInitialSchemas(self) {
	  var optsSchemas = self._opts.schemas;
	  if (!optsSchemas) return;
	  if (Array.isArray(optsSchemas)) self.addSchema(optsSchemas);
	  else for (var key in optsSchemas) self.addSchema(optsSchemas[key], key);
	}
	function addInitialFormats(self) {
	  for (var name in self._opts.formats) {
	    var format = self._opts.formats[name];
	    self.addFormat(name, format);
	  }
	}
	function addInitialKeywords(self) {
	  for (var name in self._opts.keywords) {
	    var keyword = self._opts.keywords[name];
	    self.addKeyword(name, keyword);
	  }
	}
	function checkUnique(self, id) {
	  if (self._schemas[id] || self._refs[id])
	    throw new Error('schema with key or id "' + id + '" already exists');
	}
	function getMetaSchemaOptions(self) {
	  var metaOpts = util.copy(self._opts);
	  for (var i=0; i<META_IGNORE_OPTIONS.length; i++)
	    delete metaOpts[META_IGNORE_OPTIONS[i]];
	  return metaOpts;
	}
	function setLogger(self) {
	  var logger = self._opts.logger;
	  if (logger === false) {
	    self.logger = {log: noop, warn: noop, error: noop};
	  } else {
	    if (logger === undefined) logger = console;
	    if (!(typeof logger == 'object' && logger.log && logger.warn && logger.error))
	      throw new Error('logger must implement log, warn and error methods');
	    self.logger = logger;
	  }
	}
	function noop() {}
	return ajv;
}

var ajvExports = requireAjv();
var Ajv = /*@__PURE__*/getDefaultExportFromCjs(ajvExports);

class Server extends Protocol {
    constructor(_serverInfo, options) {
        var _a;
        super(options);
        this._serverInfo = _serverInfo;
        this._loggingLevels = new Map();
        this.LOG_LEVEL_SEVERITY = new Map(LoggingLevelSchema.options.map((level, index) => [level, index]));
        this.isMessageIgnored = (level, sessionId) => {
            const currentLevel = this._loggingLevels.get(sessionId);
            return currentLevel ? this.LOG_LEVEL_SEVERITY.get(level) < this.LOG_LEVEL_SEVERITY.get(currentLevel) : false;
        };
        this._capabilities = (_a = options === null || options === void 0 ? void 0 : options.capabilities) !== null && _a !== void 0 ? _a : {};
        this._instructions = options === null || options === void 0 ? void 0 : options.instructions;
        this.setRequestHandler(InitializeRequestSchema, request => this._oninitialize(request));
        this.setNotificationHandler(InitializedNotificationSchema, () => { var _a; return (_a = this.oninitialized) === null || _a === void 0 ? void 0 : _a.call(this); });
        if (this._capabilities.logging) {
            this.setRequestHandler(SetLevelRequestSchema, async (request, extra) => {
                var _a;
                const transportSessionId = extra.sessionId || ((_a = extra.requestInfo) === null || _a === void 0 ? void 0 : _a.headers['mcp-session-id']) || undefined;
                const { level } = request.params;
                const parseResult = LoggingLevelSchema.safeParse(level);
                if (parseResult.success) {
                    this._loggingLevels.set(transportSessionId, parseResult.data);
                }
                return {};
            });
        }
    }
    registerCapabilities(capabilities) {
        if (this.transport) {
            throw new Error('Cannot register capabilities after connecting to transport');
        }
        this._capabilities = mergeCapabilities(this._capabilities, capabilities);
    }
    assertCapabilityForMethod(method) {
        var _a, _b, _c;
        switch (method) {
            case 'sampling/createMessage':
                if (!((_a = this._clientCapabilities) === null || _a === void 0 ? void 0 : _a.sampling)) {
                    throw new Error(`Client does not support sampling (required for ${method})`);
                }
                break;
            case 'elicitation/create':
                if (!((_b = this._clientCapabilities) === null || _b === void 0 ? void 0 : _b.elicitation)) {
                    throw new Error(`Client does not support elicitation (required for ${method})`);
                }
                break;
            case 'roots/list':
                if (!((_c = this._clientCapabilities) === null || _c === void 0 ? void 0 : _c.roots)) {
                    throw new Error(`Client does not support listing roots (required for ${method})`);
                }
                break;
        }
    }
    assertNotificationCapability(method) {
        switch (method) {
            case 'notifications/message':
                if (!this._capabilities.logging) {
                    throw new Error(`Server does not support logging (required for ${method})`);
                }
                break;
            case 'notifications/resources/updated':
            case 'notifications/resources/list_changed':
                if (!this._capabilities.resources) {
                    throw new Error(`Server does not support notifying about resources (required for ${method})`);
                }
                break;
            case 'notifications/tools/list_changed':
                if (!this._capabilities.tools) {
                    throw new Error(`Server does not support notifying of tool list changes (required for ${method})`);
                }
                break;
            case 'notifications/prompts/list_changed':
                if (!this._capabilities.prompts) {
                    throw new Error(`Server does not support notifying of prompt list changes (required for ${method})`);
                }
                break;
        }
    }
    assertRequestHandlerCapability(method) {
        switch (method) {
            case 'sampling/createMessage':
                if (!this._capabilities.sampling) {
                    throw new Error(`Server does not support sampling (required for ${method})`);
                }
                break;
            case 'logging/setLevel':
                if (!this._capabilities.logging) {
                    throw new Error(`Server does not support logging (required for ${method})`);
                }
                break;
            case 'prompts/get':
            case 'prompts/list':
                if (!this._capabilities.prompts) {
                    throw new Error(`Server does not support prompts (required for ${method})`);
                }
                break;
            case 'resources/list':
            case 'resources/templates/list':
            case 'resources/read':
                if (!this._capabilities.resources) {
                    throw new Error(`Server does not support resources (required for ${method})`);
                }
                break;
            case 'tools/call':
            case 'tools/list':
                if (!this._capabilities.tools) {
                    throw new Error(`Server does not support tools (required for ${method})`);
                }
                break;
        }
    }
    async _oninitialize(request) {
        const requestedVersion = request.params.protocolVersion;
        this._clientCapabilities = request.params.capabilities;
        this._clientVersion = request.params.clientInfo;
        const protocolVersion = SUPPORTED_PROTOCOL_VERSIONS.includes(requestedVersion) ? requestedVersion : LATEST_PROTOCOL_VERSION;
        return {
            protocolVersion,
            capabilities: this.getCapabilities(),
            serverInfo: this._serverInfo,
            ...(this._instructions && { instructions: this._instructions })
        };
    }
    getClientCapabilities() {
        return this._clientCapabilities;
    }
    getClientVersion() {
        return this._clientVersion;
    }
    getCapabilities() {
        return this._capabilities;
    }
    async ping() {
        return this.request({ method: 'ping' }, EmptyResultSchema);
    }
    async createMessage(params, options) {
        return this.request({ method: 'sampling/createMessage', params }, CreateMessageResultSchema, options);
    }
    async elicitInput(params, options) {
        const result = await this.request({ method: 'elicitation/create', params }, ElicitResultSchema, options);
        if (result.action === 'accept' && result.content) {
            try {
                const ajv = new Ajv();
                const validate = ajv.compile(params.requestedSchema);
                const isValid = validate(result.content);
                if (!isValid) {
                    throw new McpError(ErrorCode.InvalidParams, `Elicitation response content does not match requested schema: ${ajv.errorsText(validate.errors)}`);
                }
            }
            catch (error) {
                if (error instanceof McpError) {
                    throw error;
                }
                throw new McpError(ErrorCode.InternalError, `Error validating elicitation response: ${error}`);
            }
        }
        return result;
    }
    async listRoots(params, options) {
        return this.request({ method: 'roots/list', params }, ListRootsResultSchema, options);
    }
    async sendLoggingMessage(params, sessionId) {
        if (this._capabilities.logging) {
            if (!this.isMessageIgnored(params.level, sessionId)) {
                return this.notification({ method: 'notifications/message', params });
            }
        }
    }
    async sendResourceUpdated(params) {
        return this.notification({
            method: 'notifications/resources/updated',
            params
        });
    }
    async sendResourceListChanged() {
        return this.notification({
            method: 'notifications/resources/list_changed'
        });
    }
    async sendToolListChanged() {
        return this.notification({ method: 'notifications/tools/list_changed' });
    }
    async sendPromptListChanged() {
        return this.notification({ method: 'notifications/prompts/list_changed' });
    }
}

const ignoreOverride = Symbol("Let zodToJsonSchema decide on which parser to use");
const defaultOptions = {
    name: undefined,
    $refStrategy: "root",
    basePath: ["#"],
    effectStrategy: "input",
    pipeStrategy: "all",
    dateStrategy: "format:date-time",
    mapStrategy: "entries",
    removeAdditionalStrategy: "passthrough",
    allowedAdditionalProperties: true,
    rejectedAdditionalProperties: false,
    definitionPath: "definitions",
    target: "jsonSchema7",
    strictUnions: false,
    definitions: {},
    errorMessages: false,
    markdownDescription: false,
    patternStrategy: "escape",
    applyRegexFlags: false,
    emailStrategy: "format:email",
    base64Strategy: "contentEncoding:base64",
    nameStrategy: "ref",
    openAiAnyTypeName: "OpenAiAnyType"
};
const getDefaultOptions = (options) => (typeof options === "string"
    ? {
        ...defaultOptions,
        name: options,
    }
    : {
        ...defaultOptions,
        ...options,
    });

const getRefs = (options) => {
    const _options = getDefaultOptions(options);
    const currentPath = _options.name !== undefined
        ? [..._options.basePath, _options.definitionPath, _options.name]
        : _options.basePath;
    return {
        ..._options,
        flags: { hasReferencedOpenAiAnyType: false },
        currentPath: currentPath,
        propertyPath: undefined,
        seen: new Map(Object.entries(_options.definitions).map(([name, def]) => [
            def._def,
            {
                def: def._def,
                path: [..._options.basePath, _options.definitionPath, name],
                jsonSchema: undefined,
            },
        ])),
    };
};

function addErrorMessage(res, key, errorMessage, refs) {
    if (!refs?.errorMessages)
        return;
    if (errorMessage) {
        res.errorMessage = {
            ...res.errorMessage,
            [key]: errorMessage,
        };
    }
}
function setResponseValueAndErrors(res, key, value, errorMessage, refs) {
    res[key] = value;
    addErrorMessage(res, key, errorMessage, refs);
}

const getRelativePath = (pathA, pathB) => {
    let i = 0;
    for (; i < pathA.length && i < pathB.length; i++) {
        if (pathA[i] !== pathB[i])
            break;
    }
    return [(pathA.length - i).toString(), ...pathB.slice(i)].join("/");
};

function parseAnyDef(refs) {
    if (refs.target !== "openAi") {
        return {};
    }
    const anyDefinitionPath = [
        ...refs.basePath,
        refs.definitionPath,
        refs.openAiAnyTypeName,
    ];
    refs.flags.hasReferencedOpenAiAnyType = true;
    return {
        $ref: refs.$refStrategy === "relative"
            ? getRelativePath(anyDefinitionPath, refs.currentPath)
            : anyDefinitionPath.join("/"),
    };
}

function parseArrayDef(def, refs) {
    const res = {
        type: "array",
    };
    if (def.type?._def &&
        def.type?._def?.typeName !== ZodFirstPartyTypeKind.ZodAny) {
        res.items = parseDef(def.type._def, {
            ...refs,
            currentPath: [...refs.currentPath, "items"],
        });
    }
    if (def.minLength) {
        setResponseValueAndErrors(res, "minItems", def.minLength.value, def.minLength.message, refs);
    }
    if (def.maxLength) {
        setResponseValueAndErrors(res, "maxItems", def.maxLength.value, def.maxLength.message, refs);
    }
    if (def.exactLength) {
        setResponseValueAndErrors(res, "minItems", def.exactLength.value, def.exactLength.message, refs);
        setResponseValueAndErrors(res, "maxItems", def.exactLength.value, def.exactLength.message, refs);
    }
    return res;
}

function parseBigintDef(def, refs) {
    const res = {
        type: "integer",
        format: "int64",
    };
    if (!def.checks)
        return res;
    for (const check of def.checks) {
        switch (check.kind) {
            case "min":
                if (refs.target === "jsonSchema7") {
                    if (check.inclusive) {
                        setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
                    }
                    else {
                        setResponseValueAndErrors(res, "exclusiveMinimum", check.value, check.message, refs);
                    }
                }
                else {
                    if (!check.inclusive) {
                        res.exclusiveMinimum = true;
                    }
                    setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
                }
                break;
            case "max":
                if (refs.target === "jsonSchema7") {
                    if (check.inclusive) {
                        setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
                    }
                    else {
                        setResponseValueAndErrors(res, "exclusiveMaximum", check.value, check.message, refs);
                    }
                }
                else {
                    if (!check.inclusive) {
                        res.exclusiveMaximum = true;
                    }
                    setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
                }
                break;
            case "multipleOf":
                setResponseValueAndErrors(res, "multipleOf", check.value, check.message, refs);
                break;
        }
    }
    return res;
}

function parseBooleanDef() {
    return {
        type: "boolean",
    };
}

function parseBrandedDef(_def, refs) {
    return parseDef(_def.type._def, refs);
}

const parseCatchDef = (def, refs) => {
    return parseDef(def.innerType._def, refs);
};

function parseDateDef(def, refs, overrideDateStrategy) {
    const strategy = overrideDateStrategy ?? refs.dateStrategy;
    if (Array.isArray(strategy)) {
        return {
            anyOf: strategy.map((item, i) => parseDateDef(def, refs, item)),
        };
    }
    switch (strategy) {
        case "string":
        case "format:date-time":
            return {
                type: "string",
                format: "date-time",
            };
        case "format:date":
            return {
                type: "string",
                format: "date",
            };
        case "integer":
            return integerDateParser(def, refs);
    }
}
const integerDateParser = (def, refs) => {
    const res = {
        type: "integer",
        format: "unix-time",
    };
    if (refs.target === "openApi3") {
        return res;
    }
    for (const check of def.checks) {
        switch (check.kind) {
            case "min":
                setResponseValueAndErrors(res, "minimum", check.value,
                check.message, refs);
                break;
            case "max":
                setResponseValueAndErrors(res, "maximum", check.value,
                check.message, refs);
                break;
        }
    }
    return res;
};

function parseDefaultDef(_def, refs) {
    return {
        ...parseDef(_def.innerType._def, refs),
        default: _def.defaultValue(),
    };
}

function parseEffectsDef(_def, refs) {
    return refs.effectStrategy === "input"
        ? parseDef(_def.schema._def, refs)
        : parseAnyDef(refs);
}

function parseEnumDef(def) {
    return {
        type: "string",
        enum: Array.from(def.values),
    };
}

const isJsonSchema7AllOfType = (type) => {
    if ("type" in type && type.type === "string")
        return false;
    return "allOf" in type;
};
function parseIntersectionDef(def, refs) {
    const allOf = [
        parseDef(def.left._def, {
            ...refs,
            currentPath: [...refs.currentPath, "allOf", "0"],
        }),
        parseDef(def.right._def, {
            ...refs,
            currentPath: [...refs.currentPath, "allOf", "1"],
        }),
    ].filter((x) => !!x);
    let unevaluatedProperties = refs.target === "jsonSchema2019-09"
        ? { unevaluatedProperties: false }
        : undefined;
    const mergedAllOf = [];
    allOf.forEach((schema) => {
        if (isJsonSchema7AllOfType(schema)) {
            mergedAllOf.push(...schema.allOf);
            if (schema.unevaluatedProperties === undefined) {
                unevaluatedProperties = undefined;
            }
        }
        else {
            let nestedSchema = schema;
            if ("additionalProperties" in schema &&
                schema.additionalProperties === false) {
                const { additionalProperties, ...rest } = schema;
                nestedSchema = rest;
            }
            else {
                unevaluatedProperties = undefined;
            }
            mergedAllOf.push(nestedSchema);
        }
    });
    return mergedAllOf.length
        ? {
            allOf: mergedAllOf,
            ...unevaluatedProperties,
        }
        : undefined;
}

function parseLiteralDef(def, refs) {
    const parsedType = typeof def.value;
    if (parsedType !== "bigint" &&
        parsedType !== "number" &&
        parsedType !== "boolean" &&
        parsedType !== "string") {
        return {
            type: Array.isArray(def.value) ? "array" : "object",
        };
    }
    if (refs.target === "openApi3") {
        return {
            type: parsedType === "bigint" ? "integer" : parsedType,
            enum: [def.value],
        };
    }
    return {
        type: parsedType === "bigint" ? "integer" : parsedType,
        const: def.value,
    };
}

let emojiRegex = undefined;
const zodPatterns = {
    cuid: /^[cC][^\s-]{8,}$/,
    cuid2: /^[0-9a-z]+$/,
    ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
    email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
    emoji: () => {
        if (emojiRegex === undefined) {
            emojiRegex = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u");
        }
        return emojiRegex;
    },
    uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
    ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
    ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
    ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
    ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
    base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
    base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
    nanoid: /^[a-zA-Z0-9_-]{21}$/,
    jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/,
};
function parseStringDef(def, refs) {
    const res = {
        type: "string",
    };
    if (def.checks) {
        for (const check of def.checks) {
            switch (check.kind) {
                case "min":
                    setResponseValueAndErrors(res, "minLength", typeof res.minLength === "number"
                        ? Math.max(res.minLength, check.value)
                        : check.value, check.message, refs);
                    break;
                case "max":
                    setResponseValueAndErrors(res, "maxLength", typeof res.maxLength === "number"
                        ? Math.min(res.maxLength, check.value)
                        : check.value, check.message, refs);
                    break;
                case "email":
                    switch (refs.emailStrategy) {
                        case "format:email":
                            addFormat(res, "email", check.message, refs);
                            break;
                        case "format:idn-email":
                            addFormat(res, "idn-email", check.message, refs);
                            break;
                        case "pattern:zod":
                            addPattern(res, zodPatterns.email, check.message, refs);
                            break;
                    }
                    break;
                case "url":
                    addFormat(res, "uri", check.message, refs);
                    break;
                case "uuid":
                    addFormat(res, "uuid", check.message, refs);
                    break;
                case "regex":
                    addPattern(res, check.regex, check.message, refs);
                    break;
                case "cuid":
                    addPattern(res, zodPatterns.cuid, check.message, refs);
                    break;
                case "cuid2":
                    addPattern(res, zodPatterns.cuid2, check.message, refs);
                    break;
                case "startsWith":
                    addPattern(res, RegExp(`^${escapeLiteralCheckValue(check.value, refs)}`), check.message, refs);
                    break;
                case "endsWith":
                    addPattern(res, RegExp(`${escapeLiteralCheckValue(check.value, refs)}$`), check.message, refs);
                    break;
                case "datetime":
                    addFormat(res, "date-time", check.message, refs);
                    break;
                case "date":
                    addFormat(res, "date", check.message, refs);
                    break;
                case "time":
                    addFormat(res, "time", check.message, refs);
                    break;
                case "duration":
                    addFormat(res, "duration", check.message, refs);
                    break;
                case "length":
                    setResponseValueAndErrors(res, "minLength", typeof res.minLength === "number"
                        ? Math.max(res.minLength, check.value)
                        : check.value, check.message, refs);
                    setResponseValueAndErrors(res, "maxLength", typeof res.maxLength === "number"
                        ? Math.min(res.maxLength, check.value)
                        : check.value, check.message, refs);
                    break;
                case "includes": {
                    addPattern(res, RegExp(escapeLiteralCheckValue(check.value, refs)), check.message, refs);
                    break;
                }
                case "ip": {
                    if (check.version !== "v6") {
                        addFormat(res, "ipv4", check.message, refs);
                    }
                    if (check.version !== "v4") {
                        addFormat(res, "ipv6", check.message, refs);
                    }
                    break;
                }
                case "base64url":
                    addPattern(res, zodPatterns.base64url, check.message, refs);
                    break;
                case "jwt":
                    addPattern(res, zodPatterns.jwt, check.message, refs);
                    break;
                case "cidr": {
                    if (check.version !== "v6") {
                        addPattern(res, zodPatterns.ipv4Cidr, check.message, refs);
                    }
                    if (check.version !== "v4") {
                        addPattern(res, zodPatterns.ipv6Cidr, check.message, refs);
                    }
                    break;
                }
                case "emoji":
                    addPattern(res, zodPatterns.emoji(), check.message, refs);
                    break;
                case "ulid": {
                    addPattern(res, zodPatterns.ulid, check.message, refs);
                    break;
                }
                case "base64": {
                    switch (refs.base64Strategy) {
                        case "format:binary": {
                            addFormat(res, "binary", check.message, refs);
                            break;
                        }
                        case "contentEncoding:base64": {
                            setResponseValueAndErrors(res, "contentEncoding", "base64", check.message, refs);
                            break;
                        }
                        case "pattern:zod": {
                            addPattern(res, zodPatterns.base64, check.message, refs);
                            break;
                        }
                    }
                    break;
                }
                case "nanoid": {
                    addPattern(res, zodPatterns.nanoid, check.message, refs);
                }
            }
        }
    }
    return res;
}
function escapeLiteralCheckValue(literal, refs) {
    return refs.patternStrategy === "escape"
        ? escapeNonAlphaNumeric(literal)
        : literal;
}
const ALPHA_NUMERIC = new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");
function escapeNonAlphaNumeric(source) {
    let result = "";
    for (let i = 0; i < source.length; i++) {
        if (!ALPHA_NUMERIC.has(source[i])) {
            result += "\\";
        }
        result += source[i];
    }
    return result;
}
function addFormat(schema, value, message, refs) {
    if (schema.format || schema.anyOf?.some((x) => x.format)) {
        if (!schema.anyOf) {
            schema.anyOf = [];
        }
        if (schema.format) {
            schema.anyOf.push({
                format: schema.format,
                ...(schema.errorMessage &&
                    refs.errorMessages && {
                    errorMessage: { format: schema.errorMessage.format },
                }),
            });
            delete schema.format;
            if (schema.errorMessage) {
                delete schema.errorMessage.format;
                if (Object.keys(schema.errorMessage).length === 0) {
                    delete schema.errorMessage;
                }
            }
        }
        schema.anyOf.push({
            format: value,
            ...(message &&
                refs.errorMessages && { errorMessage: { format: message } }),
        });
    }
    else {
        setResponseValueAndErrors(schema, "format", value, message, refs);
    }
}
function addPattern(schema, regex, message, refs) {
    if (schema.pattern || schema.allOf?.some((x) => x.pattern)) {
        if (!schema.allOf) {
            schema.allOf = [];
        }
        if (schema.pattern) {
            schema.allOf.push({
                pattern: schema.pattern,
                ...(schema.errorMessage &&
                    refs.errorMessages && {
                    errorMessage: { pattern: schema.errorMessage.pattern },
                }),
            });
            delete schema.pattern;
            if (schema.errorMessage) {
                delete schema.errorMessage.pattern;
                if (Object.keys(schema.errorMessage).length === 0) {
                    delete schema.errorMessage;
                }
            }
        }
        schema.allOf.push({
            pattern: stringifyRegExpWithFlags(regex, refs),
            ...(message &&
                refs.errorMessages && { errorMessage: { pattern: message } }),
        });
    }
    else {
        setResponseValueAndErrors(schema, "pattern", stringifyRegExpWithFlags(regex, refs), message, refs);
    }
}
function stringifyRegExpWithFlags(regex, refs) {
    if (!refs.applyRegexFlags || !regex.flags) {
        return regex.source;
    }
    const flags = {
        i: regex.flags.includes("i"),
        m: regex.flags.includes("m"),
        s: regex.flags.includes("s"),
    };
    const source = flags.i ? regex.source.toLowerCase() : regex.source;
    let pattern = "";
    let isEscaped = false;
    let inCharGroup = false;
    let inCharRange = false;
    for (let i = 0; i < source.length; i++) {
        if (isEscaped) {
            pattern += source[i];
            isEscaped = false;
            continue;
        }
        if (flags.i) {
            if (inCharGroup) {
                if (source[i].match(/[a-z]/)) {
                    if (inCharRange) {
                        pattern += source[i];
                        pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();
                        inCharRange = false;
                    }
                    else if (source[i + 1] === "-" && source[i + 2]?.match(/[a-z]/)) {
                        pattern += source[i];
                        inCharRange = true;
                    }
                    else {
                        pattern += `${source[i]}${source[i].toUpperCase()}`;
                    }
                    continue;
                }
            }
            else if (source[i].match(/[a-z]/)) {
                pattern += `[${source[i]}${source[i].toUpperCase()}]`;
                continue;
            }
        }
        if (flags.m) {
            if (source[i] === "^") {
                pattern += `(^|(?<=[\r\n]))`;
                continue;
            }
            else if (source[i] === "$") {
                pattern += `($|(?=[\r\n]))`;
                continue;
            }
        }
        if (flags.s && source[i] === ".") {
            pattern += inCharGroup ? `${source[i]}\r\n` : `[${source[i]}\r\n]`;
            continue;
        }
        pattern += source[i];
        if (source[i] === "\\") {
            isEscaped = true;
        }
        else if (inCharGroup && source[i] === "]") {
            inCharGroup = false;
        }
        else if (!inCharGroup && source[i] === "[") {
            inCharGroup = true;
        }
    }
    try {
        new RegExp(pattern);
    }
    catch {
        console.warn(`Could not convert regex pattern at ${refs.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`);
        return regex.source;
    }
    return pattern;
}

function parseRecordDef(def, refs) {
    if (refs.target === "openAi") {
        console.warn("Warning: OpenAI may not support records in schemas! Try an array of key-value pairs instead.");
    }
    if (refs.target === "openApi3" &&
        def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) {
        return {
            type: "object",
            required: def.keyType._def.values,
            properties: def.keyType._def.values.reduce((acc, key) => ({
                ...acc,
                [key]: parseDef(def.valueType._def, {
                    ...refs,
                    currentPath: [...refs.currentPath, "properties", key],
                }) ?? parseAnyDef(refs),
            }), {}),
            additionalProperties: refs.rejectedAdditionalProperties,
        };
    }
    const schema = {
        type: "object",
        additionalProperties: parseDef(def.valueType._def, {
            ...refs,
            currentPath: [...refs.currentPath, "additionalProperties"],
        }) ?? refs.allowedAdditionalProperties,
    };
    if (refs.target === "openApi3") {
        return schema;
    }
    if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodString &&
        def.keyType._def.checks?.length) {
        const { type, ...keyType } = parseStringDef(def.keyType._def, refs);
        return {
            ...schema,
            propertyNames: keyType,
        };
    }
    else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) {
        return {
            ...schema,
            propertyNames: {
                enum: def.keyType._def.values,
            },
        };
    }
    else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodBranded &&
        def.keyType._def.type._def.typeName === ZodFirstPartyTypeKind.ZodString &&
        def.keyType._def.type._def.checks?.length) {
        const { type, ...keyType } = parseBrandedDef(def.keyType._def, refs);
        return {
            ...schema,
            propertyNames: keyType,
        };
    }
    return schema;
}

function parseMapDef(def, refs) {
    if (refs.mapStrategy === "record") {
        return parseRecordDef(def, refs);
    }
    const keys = parseDef(def.keyType._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items", "items", "0"],
    }) || parseAnyDef(refs);
    const values = parseDef(def.valueType._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items", "items", "1"],
    }) || parseAnyDef(refs);
    return {
        type: "array",
        maxItems: 125,
        items: {
            type: "array",
            items: [keys, values],
            minItems: 2,
            maxItems: 2,
        },
    };
}

function parseNativeEnumDef(def) {
    const object = def.values;
    const actualKeys = Object.keys(def.values).filter((key) => {
        return typeof object[object[key]] !== "number";
    });
    const actualValues = actualKeys.map((key) => object[key]);
    const parsedTypes = Array.from(new Set(actualValues.map((values) => typeof values)));
    return {
        type: parsedTypes.length === 1
            ? parsedTypes[0] === "string"
                ? "string"
                : "number"
            : ["string", "number"],
        enum: actualValues,
    };
}

function parseNeverDef(refs) {
    return refs.target === "openAi"
        ? undefined
        : {
            not: parseAnyDef({
                ...refs,
                currentPath: [...refs.currentPath, "not"],
            }),
        };
}

function parseNullDef(refs) {
    return refs.target === "openApi3"
        ? {
            enum: ["null"],
            nullable: true,
        }
        : {
            type: "null",
        };
}

const primitiveMappings = {
    ZodString: "string",
    ZodNumber: "number",
    ZodBigInt: "integer",
    ZodBoolean: "boolean",
    ZodNull: "null",
};
function parseUnionDef(def, refs) {
    if (refs.target === "openApi3")
        return asAnyOf(def, refs);
    const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
    if (options.every((x) => x._def.typeName in primitiveMappings &&
        (!x._def.checks || !x._def.checks.length))) {
        const types = options.reduce((types, x) => {
            const type = primitiveMappings[x._def.typeName];
            return type && !types.includes(type) ? [...types, type] : types;
        }, []);
        return {
            type: types.length > 1 ? types : types[0],
        };
    }
    else if (options.every((x) => x._def.typeName === "ZodLiteral" && !x.description)) {
        const types = options.reduce((acc, x) => {
            const type = typeof x._def.value;
            switch (type) {
                case "string":
                case "number":
                case "boolean":
                    return [...acc, type];
                case "bigint":
                    return [...acc, "integer"];
                case "object":
                    if (x._def.value === null)
                        return [...acc, "null"];
                case "symbol":
                case "undefined":
                case "function":
                default:
                    return acc;
            }
        }, []);
        if (types.length === options.length) {
            const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);
            return {
                type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
                enum: options.reduce((acc, x) => {
                    return acc.includes(x._def.value) ? acc : [...acc, x._def.value];
                }, []),
            };
        }
    }
    else if (options.every((x) => x._def.typeName === "ZodEnum")) {
        return {
            type: "string",
            enum: options.reduce((acc, x) => [
                ...acc,
                ...x._def.values.filter((x) => !acc.includes(x)),
            ], []),
        };
    }
    return asAnyOf(def, refs);
}
const asAnyOf = (def, refs) => {
    const anyOf = (def.options instanceof Map
        ? Array.from(def.options.values())
        : def.options)
        .map((x, i) => parseDef(x._def, {
        ...refs,
        currentPath: [...refs.currentPath, "anyOf", `${i}`],
    }))
        .filter((x) => !!x &&
        (!refs.strictUnions ||
            (typeof x === "object" && Object.keys(x).length > 0)));
    return anyOf.length ? { anyOf } : undefined;
};

function parseNullableDef(def, refs) {
    if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(def.innerType._def.typeName) &&
        (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
        if (refs.target === "openApi3") {
            return {
                type: primitiveMappings[def.innerType._def.typeName],
                nullable: true,
            };
        }
        return {
            type: [
                primitiveMappings[def.innerType._def.typeName],
                "null",
            ],
        };
    }
    if (refs.target === "openApi3") {
        const base = parseDef(def.innerType._def, {
            ...refs,
            currentPath: [...refs.currentPath],
        });
        if (base && "$ref" in base)
            return { allOf: [base], nullable: true };
        return base && { ...base, nullable: true };
    }
    const base = parseDef(def.innerType._def, {
        ...refs,
        currentPath: [...refs.currentPath, "anyOf", "0"],
    });
    return base && { anyOf: [base, { type: "null" }] };
}

function parseNumberDef(def, refs) {
    const res = {
        type: "number",
    };
    if (!def.checks)
        return res;
    for (const check of def.checks) {
        switch (check.kind) {
            case "int":
                res.type = "integer";
                addErrorMessage(res, "type", check.message, refs);
                break;
            case "min":
                if (refs.target === "jsonSchema7") {
                    if (check.inclusive) {
                        setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
                    }
                    else {
                        setResponseValueAndErrors(res, "exclusiveMinimum", check.value, check.message, refs);
                    }
                }
                else {
                    if (!check.inclusive) {
                        res.exclusiveMinimum = true;
                    }
                    setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
                }
                break;
            case "max":
                if (refs.target === "jsonSchema7") {
                    if (check.inclusive) {
                        setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
                    }
                    else {
                        setResponseValueAndErrors(res, "exclusiveMaximum", check.value, check.message, refs);
                    }
                }
                else {
                    if (!check.inclusive) {
                        res.exclusiveMaximum = true;
                    }
                    setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
                }
                break;
            case "multipleOf":
                setResponseValueAndErrors(res, "multipleOf", check.value, check.message, refs);
                break;
        }
    }
    return res;
}

function parseObjectDef(def, refs) {
    const forceOptionalIntoNullable = refs.target === "openAi";
    const result = {
        type: "object",
        properties: {},
    };
    const required = [];
    const shape = def.shape();
    for (const propName in shape) {
        let propDef = shape[propName];
        if (propDef === undefined || propDef._def === undefined) {
            continue;
        }
        let propOptional = safeIsOptional(propDef);
        if (propOptional && forceOptionalIntoNullable) {
            if (propDef._def.typeName === "ZodOptional") {
                propDef = propDef._def.innerType;
            }
            if (!propDef.isNullable()) {
                propDef = propDef.nullable();
            }
            propOptional = false;
        }
        const parsedDef = parseDef(propDef._def, {
            ...refs,
            currentPath: [...refs.currentPath, "properties", propName],
            propertyPath: [...refs.currentPath, "properties", propName],
        });
        if (parsedDef === undefined) {
            continue;
        }
        result.properties[propName] = parsedDef;
        if (!propOptional) {
            required.push(propName);
        }
    }
    if (required.length) {
        result.required = required;
    }
    const additionalProperties = decideAdditionalProperties(def, refs);
    if (additionalProperties !== undefined) {
        result.additionalProperties = additionalProperties;
    }
    return result;
}
function decideAdditionalProperties(def, refs) {
    if (def.catchall._def.typeName !== "ZodNever") {
        return parseDef(def.catchall._def, {
            ...refs,
            currentPath: [...refs.currentPath, "additionalProperties"],
        });
    }
    switch (def.unknownKeys) {
        case "passthrough":
            return refs.allowedAdditionalProperties;
        case "strict":
            return refs.rejectedAdditionalProperties;
        case "strip":
            return refs.removeAdditionalStrategy === "strict"
                ? refs.allowedAdditionalProperties
                : refs.rejectedAdditionalProperties;
    }
}
function safeIsOptional(schema) {
    try {
        return schema.isOptional();
    }
    catch {
        return true;
    }
}

const parseOptionalDef = (def, refs) => {
    if (refs.currentPath.toString() === refs.propertyPath?.toString()) {
        return parseDef(def.innerType._def, refs);
    }
    const innerSchema = parseDef(def.innerType._def, {
        ...refs,
        currentPath: [...refs.currentPath, "anyOf", "1"],
    });
    return innerSchema
        ? {
            anyOf: [
                {
                    not: parseAnyDef(refs),
                },
                innerSchema,
            ],
        }
        : parseAnyDef(refs);
};

const parsePipelineDef = (def, refs) => {
    if (refs.pipeStrategy === "input") {
        return parseDef(def.in._def, refs);
    }
    else if (refs.pipeStrategy === "output") {
        return parseDef(def.out._def, refs);
    }
    const a = parseDef(def.in._def, {
        ...refs,
        currentPath: [...refs.currentPath, "allOf", "0"],
    });
    const b = parseDef(def.out._def, {
        ...refs,
        currentPath: [...refs.currentPath, "allOf", a ? "1" : "0"],
    });
    return {
        allOf: [a, b].filter((x) => x !== undefined),
    };
};

function parsePromiseDef(def, refs) {
    return parseDef(def.type._def, refs);
}

function parseSetDef(def, refs) {
    const items = parseDef(def.valueType._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items"],
    });
    const schema = {
        type: "array",
        uniqueItems: true,
        items,
    };
    if (def.minSize) {
        setResponseValueAndErrors(schema, "minItems", def.minSize.value, def.minSize.message, refs);
    }
    if (def.maxSize) {
        setResponseValueAndErrors(schema, "maxItems", def.maxSize.value, def.maxSize.message, refs);
    }
    return schema;
}

function parseTupleDef(def, refs) {
    if (def.rest) {
        return {
            type: "array",
            minItems: def.items.length,
            items: def.items
                .map((x, i) => parseDef(x._def, {
                ...refs,
                currentPath: [...refs.currentPath, "items", `${i}`],
            }))
                .reduce((acc, x) => (x === undefined ? acc : [...acc, x]), []),
            additionalItems: parseDef(def.rest._def, {
                ...refs,
                currentPath: [...refs.currentPath, "additionalItems"],
            }),
        };
    }
    else {
        return {
            type: "array",
            minItems: def.items.length,
            maxItems: def.items.length,
            items: def.items
                .map((x, i) => parseDef(x._def, {
                ...refs,
                currentPath: [...refs.currentPath, "items", `${i}`],
            }))
                .reduce((acc, x) => (x === undefined ? acc : [...acc, x]), []),
        };
    }
}

function parseUndefinedDef(refs) {
    return {
        not: parseAnyDef(refs),
    };
}

function parseUnknownDef(refs) {
    return parseAnyDef(refs);
}

const parseReadonlyDef = (def, refs) => {
    return parseDef(def.innerType._def, refs);
};

const selectParser = (def, typeName, refs) => {
    switch (typeName) {
        case ZodFirstPartyTypeKind.ZodString:
            return parseStringDef(def, refs);
        case ZodFirstPartyTypeKind.ZodNumber:
            return parseNumberDef(def, refs);
        case ZodFirstPartyTypeKind.ZodObject:
            return parseObjectDef(def, refs);
        case ZodFirstPartyTypeKind.ZodBigInt:
            return parseBigintDef(def, refs);
        case ZodFirstPartyTypeKind.ZodBoolean:
            return parseBooleanDef();
        case ZodFirstPartyTypeKind.ZodDate:
            return parseDateDef(def, refs);
        case ZodFirstPartyTypeKind.ZodUndefined:
            return parseUndefinedDef(refs);
        case ZodFirstPartyTypeKind.ZodNull:
            return parseNullDef(refs);
        case ZodFirstPartyTypeKind.ZodArray:
            return parseArrayDef(def, refs);
        case ZodFirstPartyTypeKind.ZodUnion:
        case ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
            return parseUnionDef(def, refs);
        case ZodFirstPartyTypeKind.ZodIntersection:
            return parseIntersectionDef(def, refs);
        case ZodFirstPartyTypeKind.ZodTuple:
            return parseTupleDef(def, refs);
        case ZodFirstPartyTypeKind.ZodRecord:
            return parseRecordDef(def, refs);
        case ZodFirstPartyTypeKind.ZodLiteral:
            return parseLiteralDef(def, refs);
        case ZodFirstPartyTypeKind.ZodEnum:
            return parseEnumDef(def);
        case ZodFirstPartyTypeKind.ZodNativeEnum:
            return parseNativeEnumDef(def);
        case ZodFirstPartyTypeKind.ZodNullable:
            return parseNullableDef(def, refs);
        case ZodFirstPartyTypeKind.ZodOptional:
            return parseOptionalDef(def, refs);
        case ZodFirstPartyTypeKind.ZodMap:
            return parseMapDef(def, refs);
        case ZodFirstPartyTypeKind.ZodSet:
            return parseSetDef(def, refs);
        case ZodFirstPartyTypeKind.ZodLazy:
            return () => def.getter()._def;
        case ZodFirstPartyTypeKind.ZodPromise:
            return parsePromiseDef(def, refs);
        case ZodFirstPartyTypeKind.ZodNaN:
        case ZodFirstPartyTypeKind.ZodNever:
            return parseNeverDef(refs);
        case ZodFirstPartyTypeKind.ZodEffects:
            return parseEffectsDef(def, refs);
        case ZodFirstPartyTypeKind.ZodAny:
            return parseAnyDef(refs);
        case ZodFirstPartyTypeKind.ZodUnknown:
            return parseUnknownDef(refs);
        case ZodFirstPartyTypeKind.ZodDefault:
            return parseDefaultDef(def, refs);
        case ZodFirstPartyTypeKind.ZodBranded:
            return parseBrandedDef(def, refs);
        case ZodFirstPartyTypeKind.ZodReadonly:
            return parseReadonlyDef(def, refs);
        case ZodFirstPartyTypeKind.ZodCatch:
            return parseCatchDef(def, refs);
        case ZodFirstPartyTypeKind.ZodPipeline:
            return parsePipelineDef(def, refs);
        case ZodFirstPartyTypeKind.ZodFunction:
        case ZodFirstPartyTypeKind.ZodVoid:
        case ZodFirstPartyTypeKind.ZodSymbol:
            return undefined;
        default:
            return ((_) => undefined)();
    }
};

function parseDef(def, refs, forceResolution = false) {
    const seenItem = refs.seen.get(def);
    if (refs.override) {
        const overrideResult = refs.override?.(def, refs, seenItem, forceResolution);
        if (overrideResult !== ignoreOverride) {
            return overrideResult;
        }
    }
    if (seenItem && !forceResolution) {
        const seenSchema = get$ref(seenItem, refs);
        if (seenSchema !== undefined) {
            return seenSchema;
        }
    }
    const newItem = { def, path: refs.currentPath, jsonSchema: undefined };
    refs.seen.set(def, newItem);
    const jsonSchemaOrGetter = selectParser(def, def.typeName, refs);
    const jsonSchema = typeof jsonSchemaOrGetter === "function"
        ? parseDef(jsonSchemaOrGetter(), refs)
        : jsonSchemaOrGetter;
    if (jsonSchema) {
        addMeta(def, refs, jsonSchema);
    }
    if (refs.postProcess) {
        const postProcessResult = refs.postProcess(jsonSchema, def, refs);
        newItem.jsonSchema = jsonSchema;
        return postProcessResult;
    }
    newItem.jsonSchema = jsonSchema;
    return jsonSchema;
}
const get$ref = (item, refs) => {
    switch (refs.$refStrategy) {
        case "root":
            return { $ref: item.path.join("/") };
        case "relative":
            return { $ref: getRelativePath(refs.currentPath, item.path) };
        case "none":
        case "seen": {
            if (item.path.length < refs.currentPath.length &&
                item.path.every((value, index) => refs.currentPath[index] === value)) {
                console.warn(`Recursive reference detected at ${refs.currentPath.join("/")}! Defaulting to any`);
                return parseAnyDef(refs);
            }
            return refs.$refStrategy === "seen" ? parseAnyDef(refs) : undefined;
        }
    }
};
const addMeta = (def, refs, jsonSchema) => {
    if (def.description) {
        jsonSchema.description = def.description;
        if (refs.markdownDescription) {
            jsonSchema.markdownDescription = def.description;
        }
    }
    return jsonSchema;
};

const zodToJsonSchema = (schema, options) => {
    const refs = getRefs(options);
    let definitions = typeof options === "object" && options.definitions
        ? Object.entries(options.definitions).reduce((acc, [name, schema]) => ({
            ...acc,
            [name]: parseDef(schema._def, {
                ...refs,
                currentPath: [...refs.basePath, refs.definitionPath, name],
            }, true) ?? parseAnyDef(refs),
        }), {})
        : undefined;
    const name = typeof options === "string"
        ? options
        : options?.nameStrategy === "title"
            ? undefined
            : options?.name;
    const main = parseDef(schema._def, name === undefined
        ? refs
        : {
            ...refs,
            currentPath: [...refs.basePath, refs.definitionPath, name],
        }, false) ?? parseAnyDef(refs);
    const title = typeof options === "object" &&
        options.name !== undefined &&
        options.nameStrategy === "title"
        ? options.name
        : undefined;
    if (title !== undefined) {
        main.title = title;
    }
    if (refs.flags.hasReferencedOpenAiAnyType) {
        if (!definitions) {
            definitions = {};
        }
        if (!definitions[refs.openAiAnyTypeName]) {
            definitions[refs.openAiAnyTypeName] = {
                type: ["string", "number", "integer", "boolean", "array", "null"],
                items: {
                    $ref: refs.$refStrategy === "relative"
                        ? "1"
                        : [
                            ...refs.basePath,
                            refs.definitionPath,
                            refs.openAiAnyTypeName,
                        ].join("/"),
                },
            };
        }
    }
    const combined = name === undefined
        ? definitions
            ? {
                ...main,
                [refs.definitionPath]: definitions,
            }
            : main
        : {
            $ref: [
                ...(refs.$refStrategy === "relative" ? [] : refs.basePath),
                refs.definitionPath,
                name,
            ].join("/"),
            [refs.definitionPath]: {
                ...definitions,
                [name]: main,
            },
        };
    if (refs.target === "jsonSchema7") {
        combined.$schema = "http://json-schema.org/draft-07/schema#";
    }
    else if (refs.target === "jsonSchema2019-09" || refs.target === "openAi") {
        combined.$schema = "https://json-schema.org/draft/2019-09/schema#";
    }
    if (refs.target === "openAi" &&
        ("anyOf" in combined ||
            "oneOf" in combined ||
            "allOf" in combined ||
            ("type" in combined && Array.isArray(combined.type)))) {
        console.warn("Warning: OpenAI may not support schemas with unions as roots! Try wrapping it in an object property.");
    }
    return combined;
};

var McpZodTypeKind;
(function (McpZodTypeKind) {
    McpZodTypeKind["Completable"] = "McpCompletable";
})(McpZodTypeKind || (McpZodTypeKind = {}));
class Completable extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const data = ctx.data;
        return this._def.type._parse({
            data,
            path: ctx.path,
            parent: ctx
        });
    }
    unwrap() {
        return this._def.type;
    }
}
Completable.create = (type, params) => {
    return new Completable({
        type,
        typeName: McpZodTypeKind.Completable,
        complete: params.complete,
        ...processCreateParams(params)
    });
};
function processCreateParams(params) {
    if (!params)
        return {};
    const { errorMap, invalid_type_error, required_error, description } = params;
    if (errorMap && (invalid_type_error || required_error)) {
        throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    }
    if (errorMap)
        return { errorMap: errorMap, description };
    const customMap = (iss, ctx) => {
        var _a, _b;
        const { message } = params;
        if (iss.code === 'invalid_enum_value') {
            return { message: message !== null && message !== void 0 ? message : ctx.defaultError };
        }
        if (typeof ctx.data === 'undefined') {
            return { message: (_a = message !== null && message !== void 0 ? message : required_error) !== null && _a !== void 0 ? _a : ctx.defaultError };
        }
        if (iss.code !== 'invalid_type')
            return { message: ctx.defaultError };
        return { message: (_b = message !== null && message !== void 0 ? message : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError };
    };
    return { errorMap: customMap, description };
}

class McpServer {
    constructor(serverInfo, options) {
        this._registeredResources = {};
        this._registeredResourceTemplates = {};
        this._registeredTools = {};
        this._registeredPrompts = {};
        this._toolHandlersInitialized = false;
        this._completionHandlerInitialized = false;
        this._resourceHandlersInitialized = false;
        this._promptHandlersInitialized = false;
        this.server = new Server(serverInfo, options);
    }
    async connect(transport) {
        return await this.server.connect(transport);
    }
    async close() {
        await this.server.close();
    }
    setToolRequestHandlers() {
        if (this._toolHandlersInitialized) {
            return;
        }
        this.server.assertCanSetRequestHandler(ListToolsRequestSchema.shape.method.value);
        this.server.assertCanSetRequestHandler(CallToolRequestSchema.shape.method.value);
        this.server.registerCapabilities({
            tools: {
                listChanged: true
            }
        });
        this.server.setRequestHandler(ListToolsRequestSchema, () => ({
            tools: Object.entries(this._registeredTools)
                .filter(([, tool]) => tool.enabled)
                .map(([name, tool]) => {
                const toolDefinition = {
                    name,
                    title: tool.title,
                    description: tool.description,
                    inputSchema: tool.inputSchema
                        ? zodToJsonSchema(tool.inputSchema, {
                            strictUnions: true
                        })
                        : EMPTY_OBJECT_JSON_SCHEMA,
                    annotations: tool.annotations,
                    _meta: tool._meta
                };
                if (tool.outputSchema) {
                    toolDefinition.outputSchema = zodToJsonSchema(tool.outputSchema, {
                        strictUnions: true
                    });
                }
                return toolDefinition;
            })
        }));
        this.server.setRequestHandler(CallToolRequestSchema, async (request, extra) => {
            const tool = this._registeredTools[request.params.name];
            if (!tool) {
                throw new McpError(ErrorCode.InvalidParams, `Tool ${request.params.name} not found`);
            }
            if (!tool.enabled) {
                throw new McpError(ErrorCode.InvalidParams, `Tool ${request.params.name} disabled`);
            }
            let result;
            if (tool.inputSchema) {
                const parseResult = await tool.inputSchema.safeParseAsync(request.params.arguments);
                if (!parseResult.success) {
                    throw new McpError(ErrorCode.InvalidParams, `Invalid arguments for tool ${request.params.name}: ${parseResult.error.message}`);
                }
                const args = parseResult.data;
                const cb = tool.callback;
                try {
                    result = await Promise.resolve(cb(args, extra));
                }
                catch (error) {
                    result = {
                        content: [
                            {
                                type: 'text',
                                text: error instanceof Error ? error.message : String(error)
                            }
                        ],
                        isError: true
                    };
                }
            }
            else {
                const cb = tool.callback;
                try {
                    result = await Promise.resolve(cb(extra));
                }
                catch (error) {
                    result = {
                        content: [
                            {
                                type: 'text',
                                text: error instanceof Error ? error.message : String(error)
                            }
                        ],
                        isError: true
                    };
                }
            }
            if (tool.outputSchema && !result.isError) {
                if (!result.structuredContent) {
                    throw new McpError(ErrorCode.InvalidParams, `Tool ${request.params.name} has an output schema but no structured content was provided`);
                }
                const parseResult = await tool.outputSchema.safeParseAsync(result.structuredContent);
                if (!parseResult.success) {
                    throw new McpError(ErrorCode.InvalidParams, `Invalid structured content for tool ${request.params.name}: ${parseResult.error.message}`);
                }
            }
            return result;
        });
        this._toolHandlersInitialized = true;
    }
    setCompletionRequestHandler() {
        if (this._completionHandlerInitialized) {
            return;
        }
        this.server.assertCanSetRequestHandler(CompleteRequestSchema.shape.method.value);
        this.server.registerCapabilities({
            completions: {}
        });
        this.server.setRequestHandler(CompleteRequestSchema, async (request) => {
            switch (request.params.ref.type) {
                case 'ref/prompt':
                    return this.handlePromptCompletion(request, request.params.ref);
                case 'ref/resource':
                    return this.handleResourceCompletion(request, request.params.ref);
                default:
                    throw new McpError(ErrorCode.InvalidParams, `Invalid completion reference: ${request.params.ref}`);
            }
        });
        this._completionHandlerInitialized = true;
    }
    async handlePromptCompletion(request, ref) {
        const prompt = this._registeredPrompts[ref.name];
        if (!prompt) {
            throw new McpError(ErrorCode.InvalidParams, `Prompt ${ref.name} not found`);
        }
        if (!prompt.enabled) {
            throw new McpError(ErrorCode.InvalidParams, `Prompt ${ref.name} disabled`);
        }
        if (!prompt.argsSchema) {
            return EMPTY_COMPLETION_RESULT;
        }
        const field = prompt.argsSchema.shape[request.params.argument.name];
        if (!(field instanceof Completable)) {
            return EMPTY_COMPLETION_RESULT;
        }
        const def = field._def;
        const suggestions = await def.complete(request.params.argument.value, request.params.context);
        return createCompletionResult(suggestions);
    }
    async handleResourceCompletion(request, ref) {
        const template = Object.values(this._registeredResourceTemplates).find(t => t.resourceTemplate.uriTemplate.toString() === ref.uri);
        if (!template) {
            if (this._registeredResources[ref.uri]) {
                return EMPTY_COMPLETION_RESULT;
            }
            throw new McpError(ErrorCode.InvalidParams, `Resource template ${request.params.ref.uri} not found`);
        }
        const completer = template.resourceTemplate.completeCallback(request.params.argument.name);
        if (!completer) {
            return EMPTY_COMPLETION_RESULT;
        }
        const suggestions = await completer(request.params.argument.value, request.params.context);
        return createCompletionResult(suggestions);
    }
    setResourceRequestHandlers() {
        if (this._resourceHandlersInitialized) {
            return;
        }
        this.server.assertCanSetRequestHandler(ListResourcesRequestSchema.shape.method.value);
        this.server.assertCanSetRequestHandler(ListResourceTemplatesRequestSchema.shape.method.value);
        this.server.assertCanSetRequestHandler(ReadResourceRequestSchema.shape.method.value);
        this.server.registerCapabilities({
            resources: {
                listChanged: true
            }
        });
        this.server.setRequestHandler(ListResourcesRequestSchema, async (request, extra) => {
            const resources = Object.entries(this._registeredResources)
                .filter(([_, resource]) => resource.enabled)
                .map(([uri, resource]) => ({
                uri,
                name: resource.name,
                ...resource.metadata
            }));
            const templateResources = [];
            for (const template of Object.values(this._registeredResourceTemplates)) {
                if (!template.resourceTemplate.listCallback) {
                    continue;
                }
                const result = await template.resourceTemplate.listCallback(extra);
                for (const resource of result.resources) {
                    templateResources.push({
                        ...template.metadata,
                        ...resource
                    });
                }
            }
            return { resources: [...resources, ...templateResources] };
        });
        this.server.setRequestHandler(ListResourceTemplatesRequestSchema, async () => {
            const resourceTemplates = Object.entries(this._registeredResourceTemplates).map(([name, template]) => ({
                name,
                uriTemplate: template.resourceTemplate.uriTemplate.toString(),
                ...template.metadata
            }));
            return { resourceTemplates };
        });
        this.server.setRequestHandler(ReadResourceRequestSchema, async (request, extra) => {
            const uri = new URL(request.params.uri);
            const resource = this._registeredResources[uri.toString()];
            if (resource) {
                if (!resource.enabled) {
                    throw new McpError(ErrorCode.InvalidParams, `Resource ${uri} disabled`);
                }
                return resource.readCallback(uri, extra);
            }
            for (const template of Object.values(this._registeredResourceTemplates)) {
                const variables = template.resourceTemplate.uriTemplate.match(uri.toString());
                if (variables) {
                    return template.readCallback(uri, variables, extra);
                }
            }
            throw new McpError(ErrorCode.InvalidParams, `Resource ${uri} not found`);
        });
        this.setCompletionRequestHandler();
        this._resourceHandlersInitialized = true;
    }
    setPromptRequestHandlers() {
        if (this._promptHandlersInitialized) {
            return;
        }
        this.server.assertCanSetRequestHandler(ListPromptsRequestSchema.shape.method.value);
        this.server.assertCanSetRequestHandler(GetPromptRequestSchema.shape.method.value);
        this.server.registerCapabilities({
            prompts: {
                listChanged: true
            }
        });
        this.server.setRequestHandler(ListPromptsRequestSchema, () => ({
            prompts: Object.entries(this._registeredPrompts)
                .filter(([, prompt]) => prompt.enabled)
                .map(([name, prompt]) => {
                return {
                    name,
                    title: prompt.title,
                    description: prompt.description,
                    arguments: prompt.argsSchema ? promptArgumentsFromSchema(prompt.argsSchema) : undefined
                };
            })
        }));
        this.server.setRequestHandler(GetPromptRequestSchema, async (request, extra) => {
            const prompt = this._registeredPrompts[request.params.name];
            if (!prompt) {
                throw new McpError(ErrorCode.InvalidParams, `Prompt ${request.params.name} not found`);
            }
            if (!prompt.enabled) {
                throw new McpError(ErrorCode.InvalidParams, `Prompt ${request.params.name} disabled`);
            }
            if (prompt.argsSchema) {
                const parseResult = await prompt.argsSchema.safeParseAsync(request.params.arguments);
                if (!parseResult.success) {
                    throw new McpError(ErrorCode.InvalidParams, `Invalid arguments for prompt ${request.params.name}: ${parseResult.error.message}`);
                }
                const args = parseResult.data;
                const cb = prompt.callback;
                return await Promise.resolve(cb(args, extra));
            }
            else {
                const cb = prompt.callback;
                return await Promise.resolve(cb(extra));
            }
        });
        this.setCompletionRequestHandler();
        this._promptHandlersInitialized = true;
    }
    resource(name, uriOrTemplate, ...rest) {
        let metadata;
        if (typeof rest[0] === 'object') {
            metadata = rest.shift();
        }
        const readCallback = rest[0];
        if (typeof uriOrTemplate === 'string') {
            if (this._registeredResources[uriOrTemplate]) {
                throw new Error(`Resource ${uriOrTemplate} is already registered`);
            }
            const registeredResource = this._createRegisteredResource(name, undefined, uriOrTemplate, metadata, readCallback);
            this.setResourceRequestHandlers();
            this.sendResourceListChanged();
            return registeredResource;
        }
        else {
            if (this._registeredResourceTemplates[name]) {
                throw new Error(`Resource template ${name} is already registered`);
            }
            const registeredResourceTemplate = this._createRegisteredResourceTemplate(name, undefined, uriOrTemplate, metadata, readCallback);
            this.setResourceRequestHandlers();
            this.sendResourceListChanged();
            return registeredResourceTemplate;
        }
    }
    registerResource(name, uriOrTemplate, config, readCallback) {
        if (typeof uriOrTemplate === 'string') {
            if (this._registeredResources[uriOrTemplate]) {
                throw new Error(`Resource ${uriOrTemplate} is already registered`);
            }
            const registeredResource = this._createRegisteredResource(name, config.title, uriOrTemplate, config, readCallback);
            this.setResourceRequestHandlers();
            this.sendResourceListChanged();
            return registeredResource;
        }
        else {
            if (this._registeredResourceTemplates[name]) {
                throw new Error(`Resource template ${name} is already registered`);
            }
            const registeredResourceTemplate = this._createRegisteredResourceTemplate(name, config.title, uriOrTemplate, config, readCallback);
            this.setResourceRequestHandlers();
            this.sendResourceListChanged();
            return registeredResourceTemplate;
        }
    }
    _createRegisteredResource(name, title, uri, metadata, readCallback) {
        const registeredResource = {
            name,
            title,
            metadata,
            readCallback,
            enabled: true,
            disable: () => registeredResource.update({ enabled: false }),
            enable: () => registeredResource.update({ enabled: true }),
            remove: () => registeredResource.update({ uri: null }),
            update: updates => {
                if (typeof updates.uri !== 'undefined' && updates.uri !== uri) {
                    delete this._registeredResources[uri];
                    if (updates.uri)
                        this._registeredResources[updates.uri] = registeredResource;
                }
                if (typeof updates.name !== 'undefined')
                    registeredResource.name = updates.name;
                if (typeof updates.title !== 'undefined')
                    registeredResource.title = updates.title;
                if (typeof updates.metadata !== 'undefined')
                    registeredResource.metadata = updates.metadata;
                if (typeof updates.callback !== 'undefined')
                    registeredResource.readCallback = updates.callback;
                if (typeof updates.enabled !== 'undefined')
                    registeredResource.enabled = updates.enabled;
                this.sendResourceListChanged();
            }
        };
        this._registeredResources[uri] = registeredResource;
        return registeredResource;
    }
    _createRegisteredResourceTemplate(name, title, template, metadata, readCallback) {
        const registeredResourceTemplate = {
            resourceTemplate: template,
            title,
            metadata,
            readCallback,
            enabled: true,
            disable: () => registeredResourceTemplate.update({ enabled: false }),
            enable: () => registeredResourceTemplate.update({ enabled: true }),
            remove: () => registeredResourceTemplate.update({ name: null }),
            update: updates => {
                if (typeof updates.name !== 'undefined' && updates.name !== name) {
                    delete this._registeredResourceTemplates[name];
                    if (updates.name)
                        this._registeredResourceTemplates[updates.name] = registeredResourceTemplate;
                }
                if (typeof updates.title !== 'undefined')
                    registeredResourceTemplate.title = updates.title;
                if (typeof updates.template !== 'undefined')
                    registeredResourceTemplate.resourceTemplate = updates.template;
                if (typeof updates.metadata !== 'undefined')
                    registeredResourceTemplate.metadata = updates.metadata;
                if (typeof updates.callback !== 'undefined')
                    registeredResourceTemplate.readCallback = updates.callback;
                if (typeof updates.enabled !== 'undefined')
                    registeredResourceTemplate.enabled = updates.enabled;
                this.sendResourceListChanged();
            }
        };
        this._registeredResourceTemplates[name] = registeredResourceTemplate;
        return registeredResourceTemplate;
    }
    _createRegisteredPrompt(name, title, description, argsSchema, callback) {
        const registeredPrompt = {
            title,
            description,
            argsSchema: argsSchema === undefined ? undefined : objectType(argsSchema),
            callback,
            enabled: true,
            disable: () => registeredPrompt.update({ enabled: false }),
            enable: () => registeredPrompt.update({ enabled: true }),
            remove: () => registeredPrompt.update({ name: null }),
            update: updates => {
                if (typeof updates.name !== 'undefined' && updates.name !== name) {
                    delete this._registeredPrompts[name];
                    if (updates.name)
                        this._registeredPrompts[updates.name] = registeredPrompt;
                }
                if (typeof updates.title !== 'undefined')
                    registeredPrompt.title = updates.title;
                if (typeof updates.description !== 'undefined')
                    registeredPrompt.description = updates.description;
                if (typeof updates.argsSchema !== 'undefined')
                    registeredPrompt.argsSchema = objectType(updates.argsSchema);
                if (typeof updates.callback !== 'undefined')
                    registeredPrompt.callback = updates.callback;
                if (typeof updates.enabled !== 'undefined')
                    registeredPrompt.enabled = updates.enabled;
                this.sendPromptListChanged();
            }
        };
        this._registeredPrompts[name] = registeredPrompt;
        return registeredPrompt;
    }
    _createRegisteredTool(name, title, description, inputSchema, outputSchema, annotations, _meta, callback) {
        const registeredTool = {
            title,
            description,
            inputSchema: inputSchema === undefined ? undefined : objectType(inputSchema),
            outputSchema: outputSchema === undefined ? undefined : objectType(outputSchema),
            annotations,
            _meta,
            callback,
            enabled: true,
            disable: () => registeredTool.update({ enabled: false }),
            enable: () => registeredTool.update({ enabled: true }),
            remove: () => registeredTool.update({ name: null }),
            update: updates => {
                if (typeof updates.name !== 'undefined' && updates.name !== name) {
                    delete this._registeredTools[name];
                    if (updates.name)
                        this._registeredTools[updates.name] = registeredTool;
                }
                if (typeof updates.title !== 'undefined')
                    registeredTool.title = updates.title;
                if (typeof updates.description !== 'undefined')
                    registeredTool.description = updates.description;
                if (typeof updates.paramsSchema !== 'undefined')
                    registeredTool.inputSchema = objectType(updates.paramsSchema);
                if (typeof updates.callback !== 'undefined')
                    registeredTool.callback = updates.callback;
                if (typeof updates.annotations !== 'undefined')
                    registeredTool.annotations = updates.annotations;
                if (typeof updates._meta !== 'undefined')
                    registeredTool._meta = updates._meta;
                if (typeof updates.enabled !== 'undefined')
                    registeredTool.enabled = updates.enabled;
                this.sendToolListChanged();
            }
        };
        this._registeredTools[name] = registeredTool;
        this.setToolRequestHandlers();
        this.sendToolListChanged();
        return registeredTool;
    }
    tool(name, ...rest) {
        if (this._registeredTools[name]) {
            throw new Error(`Tool ${name} is already registered`);
        }
        let description;
        let inputSchema;
        let outputSchema;
        let annotations;
        if (typeof rest[0] === 'string') {
            description = rest.shift();
        }
        if (rest.length > 1) {
            const firstArg = rest[0];
            if (isZodRawShape(firstArg)) {
                inputSchema = rest.shift();
                if (rest.length > 1 && typeof rest[0] === 'object' && rest[0] !== null && !isZodRawShape(rest[0])) {
                    annotations = rest.shift();
                }
            }
            else if (typeof firstArg === 'object' && firstArg !== null) {
                annotations = rest.shift();
            }
        }
        const callback = rest[0];
        return this._createRegisteredTool(name, undefined, description, inputSchema, outputSchema, annotations, undefined, callback);
    }
    registerTool(name, config, cb) {
        if (this._registeredTools[name]) {
            throw new Error(`Tool ${name} is already registered`);
        }
        const { title, description, inputSchema, outputSchema, annotations, _meta } = config;
        return this._createRegisteredTool(name, title, description, inputSchema, outputSchema, annotations, _meta, cb);
    }
    prompt(name, ...rest) {
        if (this._registeredPrompts[name]) {
            throw new Error(`Prompt ${name} is already registered`);
        }
        let description;
        if (typeof rest[0] === 'string') {
            description = rest.shift();
        }
        let argsSchema;
        if (rest.length > 1) {
            argsSchema = rest.shift();
        }
        const cb = rest[0];
        const registeredPrompt = this._createRegisteredPrompt(name, undefined, description, argsSchema, cb);
        this.setPromptRequestHandlers();
        this.sendPromptListChanged();
        return registeredPrompt;
    }
    registerPrompt(name, config, cb) {
        if (this._registeredPrompts[name]) {
            throw new Error(`Prompt ${name} is already registered`);
        }
        const { title, description, argsSchema } = config;
        const registeredPrompt = this._createRegisteredPrompt(name, title, description, argsSchema, cb);
        this.setPromptRequestHandlers();
        this.sendPromptListChanged();
        return registeredPrompt;
    }
    isConnected() {
        return this.server.transport !== undefined;
    }
    async sendLoggingMessage(params, sessionId) {
        return this.server.sendLoggingMessage(params, sessionId);
    }
    sendResourceListChanged() {
        if (this.isConnected()) {
            this.server.sendResourceListChanged();
        }
    }
    sendToolListChanged() {
        if (this.isConnected()) {
            this.server.sendToolListChanged();
        }
    }
    sendPromptListChanged() {
        if (this.isConnected()) {
            this.server.sendPromptListChanged();
        }
    }
}
const EMPTY_OBJECT_JSON_SCHEMA = {
    type: 'object',
    properties: {}
};
function isZodRawShape(obj) {
    if (typeof obj !== 'object' || obj === null)
        return false;
    const isEmptyObject = Object.keys(obj).length === 0;
    return isEmptyObject || Object.values(obj).some(isZodTypeLike);
}
function isZodTypeLike(value) {
    return (value !== null &&
        typeof value === 'object' &&
        'parse' in value &&
        typeof value.parse === 'function' &&
        'safeParse' in value &&
        typeof value.safeParse === 'function');
}
function promptArgumentsFromSchema(schema) {
    return Object.entries(schema.shape).map(([name, field]) => ({
        name,
        description: field.description,
        required: !field.isOptional()
    }));
}
function createCompletionResult(suggestions) {
    return {
        completion: {
            values: suggestions.slice(0, 100),
            total: suggestions.length,
            hasMore: suggestions.length > 100
        }
    };
}
const EMPTY_COMPLETION_RESULT = {
    completion: {
        values: [],
        hasMore: false
    }
};

class ReadBuffer {
    append(chunk) {
        this._buffer = this._buffer ? Buffer.concat([this._buffer, chunk]) : chunk;
    }
    readMessage() {
        if (!this._buffer) {
            return null;
        }
        const index = this._buffer.indexOf('\n');
        if (index === -1) {
            return null;
        }
        const line = this._buffer.toString('utf8', 0, index).replace(/\r$/, '');
        this._buffer = this._buffer.subarray(index + 1);
        return deserializeMessage(line);
    }
    clear() {
        this._buffer = undefined;
    }
}
function deserializeMessage(line) {
    return JSONRPCMessageSchema.parse(JSON.parse(line));
}
function serializeMessage(message) {
    return JSON.stringify(message) + '\n';
}

class StdioServerTransport {
    constructor(_stdin = process$2.stdin, _stdout = process$2.stdout) {
        this._stdin = _stdin;
        this._stdout = _stdout;
        this._readBuffer = new ReadBuffer();
        this._started = false;
        this._ondata = (chunk) => {
            this._readBuffer.append(chunk);
            this.processReadBuffer();
        };
        this._onerror = (error) => {
            var _a;
            (_a = this.onerror) === null || _a === void 0 ? void 0 : _a.call(this, error);
        };
    }
    async start() {
        if (this._started) {
            throw new Error('StdioServerTransport already started! If using Server class, note that connect() calls start() automatically.');
        }
        this._started = true;
        this._stdin.on('data', this._ondata);
        this._stdin.on('error', this._onerror);
    }
    processReadBuffer() {
        var _a, _b;
        while (true) {
            try {
                const message = this._readBuffer.readMessage();
                if (message === null) {
                    break;
                }
                (_a = this.onmessage) === null || _a === void 0 ? void 0 : _a.call(this, message);
            }
            catch (error) {
                (_b = this.onerror) === null || _b === void 0 ? void 0 : _b.call(this, error);
            }
        }
    }
    async close() {
        var _a;
        this._stdin.off('data', this._ondata);
        this._stdin.off('error', this._onerror);
        const remainingDataListeners = this._stdin.listenerCount('data');
        if (remainingDataListeners === 0) {
            this._stdin.pause();
        }
        this._readBuffer.clear();
        (_a = this.onclose) === null || _a === void 0 ? void 0 : _a.call(this);
    }
    send(message) {
        return new Promise(resolve => {
            const json = serializeMessage(message);
            if (this._stdout.write(json)) {
                resolve();
            }
            else {
                this._stdout.once('drain', resolve);
            }
        });
    }
}

/**
                               Apache License
                         Version 2.0, January 2004
                      http://www.apache.org/licenses/
 TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
 1. Definitions.
    "License" shall mean the terms and conditions for use, reproduction,
    and distribution as defined by Sections 1 through 9 of this document.
    "Licensor" shall mean the copyright owner or entity authorized by
    the copyright owner that is granting the License.
    "Legal Entity" shall mean the union of the acting entity and all
    other entities that control, are controlled by, or are under common
    control with that entity. For the purposes of this definition,
    "control" means (i) the power, direct or indirect, to cause the
    direction or management of such entity, whether by contract or
    otherwise, or (ii) ownership of fifty percent (50%) or more of the
    outstanding shares, or (iii) beneficial ownership of such entity.
    "You" (or "Your") shall mean an individual or Legal Entity
    exercising permissions granted by this License.
    "Source" form shall mean the preferred form for making modifications,
    including but not limited to software source code, documentation
    source, and configuration files.
    "Object" form shall mean any form resulting from mechanical
    transformation or translation of a Source form, including but
    not limited to compiled object code, generated documentation,
    and conversions to other media types.
    "Work" shall mean the work of authorship, whether in Source or
    Object form, made available under the License, as indicated by a
    copyright notice that is included in or attached to the work
    (an example is provided in the Appendix below).
    "Derivative Works" shall mean any work, whether in Source or Object
    form, that is based on (or derived from) the Work and for which the
    editorial revisions, annotations, elaborations, or other modifications
    represent, as a whole, an original work of authorship. For the purposes
    of this License, Derivative Works shall not include works that remain
    separable from, or merely link (or bind by name) to the interfaces of,
    the Work and Derivative Works thereof.
    "Contribution" shall mean any work of authorship, including
    the original version of the Work and any modifications or additions
    to that Work or Derivative Works thereof, that is intentionally
    submitted to Licensor for inclusion in the Work by the copyright owner
    or by an individual or Legal Entity authorized to submit on behalf of
    the copyright owner. For the purposes of this definition, "submitted"
    means any form of electronic, verbal, or written communication sent
    to the Licensor or its representatives, including but not limited to
    communication on electronic mailing lists, source code control systems,
    and issue tracking systems that are managed by, or on behalf of, the
    Licensor for the purpose of discussing and improving the Work, but
    excluding communication that is conspicuously marked or otherwise
    designated in writing by the copyright owner as "Not a Contribution."
    "Contributor" shall mean Licensor and any individual or Legal Entity
    on behalf of whom a Contribution has been received by Licensor and
    subsequently incorporated within the Work.
 2. Grant of Copyright License. Subject to the terms and conditions of
    this License, each Contributor hereby grants to You a perpetual,
    worldwide, non-exclusive, no-charge, royalty-free, irrevocable
    copyright license to reproduce, prepare Derivative Works of,
    publicly display, publicly perform, sublicense, and distribute the
    Work and such Derivative Works in Source or Object form.
 3. Grant of Patent License. Subject to the terms and conditions of
    this License, each Contributor hereby grants to You a perpetual,
    worldwide, non-exclusive, no-charge, royalty-free, irrevocable
    (except as stated in this section) patent license to make, have made,
    use, offer to sell, sell, import, and otherwise transfer the Work,
    where such license applies only to those patent claims licensable
    by such Contributor that are necessarily infringed by their
    Contribution(s) alone or by combination of their Contribution(s)
    with the Work to which such Contribution(s) was submitted. If You
    institute patent litigation against any entity (including a
    cross-claim or counterclaim in a lawsuit) alleging that the Work
    or a Contribution incorporated within the Work constitutes direct
    or contributory patent infringement, then any patent licenses
    granted to You under this License for that Work shall terminate
    as of the date such litigation is filed.
 4. Redistribution. You may reproduce and distribute copies of the
    Work or Derivative Works thereof in any medium, with or without
    modifications, and in Source or Object form, provided that You
    meet the following conditions:
    (a) You must give any other recipients of the Work or
        Derivative Works a copy of this License; and
    (b) You must cause any modified files to carry prominent notices
        stating that You changed the files; and
    (c) You must retain, in the Source form of any Derivative Works
        that You distribute, all copyright, patent, trademark, and
        attribution notices from the Source form of the Work,
        excluding those notices that do not pertain to any part of
        the Derivative Works; and
    (d) If the Work includes a "NOTICE" text file as part of its
        distribution, then any Derivative Works that You distribute must
        include a readable copy of the attribution notices contained
        within such NOTICE file, excluding those notices that do not
        pertain to any part of the Derivative Works, in at least one
        of the following places: within a NOTICE text file distributed
        as part of the Derivative Works; within the Source form or
        documentation, if provided along with the Derivative Works; or,
        within a display generated by the Derivative Works, if and
        wherever such third-party notices normally appear. The contents
        of the NOTICE file are for informational purposes only and
        do not modify the License. You may add Your own attribution
        notices within Derivative Works that You distribute, alongside
        or as an addendum to the NOTICE text from the Work, provided
        that such additional attribution notices cannot be construed
        as modifying the License.
    You may add Your own copyright statement to Your modifications and
    may provide additional or different license terms and conditions
    for use, reproduction, or distribution of Your modifications, or
    for any such Derivative Works as a whole, provided Your use,
    reproduction, and distribution of the Work otherwise complies with
    the conditions stated in this License.
 5. Submission of Contributions. Unless You explicitly state otherwise,
    any Contribution intentionally submitted for inclusion in the Work
    by You to the Licensor shall be under the terms and conditions of
    this License, without any additional terms or conditions.
    Notwithstanding the above, nothing herein shall supersede or modify
    the terms of any separate license agreement you may have executed
    with Licensor regarding such Contributions.
 6. Trademarks. This License does not grant permission to use the trade
    names, trademarks, service marks, or product names of the Licensor,
    except as required for reasonable and customary use in describing the
    origin of the Work and reproducing the content of the NOTICE file.
 7. Disclaimer of Warranty. Unless required by applicable law or
    agreed to in writing, Licensor provides the Work (and each
    Contributor provides its Contributions) on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
    implied, including, without limitation, any warranties or conditions
    of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
    PARTICULAR PURPOSE. You are solely responsible for determining the
    appropriateness of using or redistributing the Work and assume any
    risks associated with Your exercise of permissions under this License.
 8. Limitation of Liability. In no event and under no legal theory,
    whether in tort (including negligence), contract, or otherwise,
    unless required by applicable law (such as deliberate and grossly
    negligent acts) or agreed to in writing, shall any Contributor be
    liable to You for damages, including any direct, indirect, special,
    incidental, or consequential damages of any character arising as a
    result of this License or out of the use or inability to use the
    Work (including but not limited to damages for loss of goodwill,
    work stoppage, computer failure or malfunction, or any and all
    other commercial damages or losses), even if such Contributor
    has been advised of the possibility of such damages.
 9. Accepting Warranty or Additional Liability. While redistributing
    the Work or Derivative Works thereof, You may choose to offer,
    and charge a fee for, acceptance of support, warranty, indemnity,
    or other liability obligations and/or rights consistent with this
    License. However, in accepting such obligations, You may act only
    on Your own behalf and on Your sole responsibility, not on behalf
    of any other Contributor, and only if You agree to indemnify,
    defend, and hold each Contributor harmless for any liability
    incurred by, or claims asserted against, such Contributor by reason
    of your accepting any such warranty or additional liability.
 END OF TERMS AND CONDITIONS
 APPENDIX: How to apply the Apache License to your work.
    To apply the Apache License to your work, attach the following
    boilerplate notice, with the fields enclosed by brackets "[]"
    replaced with your own identifying information. (Don't include
    the brackets!)  The text should be enclosed in the appropriate
    comment syntax for the file format. We also recommend that a
    file or class name and description of purpose be included on the
    same "printed page" as the copyright notice for easier
    identification within third-party archives.
 Copyright (c) 2015-2018 Google, Inc., Netflix, Inc., Microsoft Corp. and contributors
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at
     http://www.apache.org/licenses/LICENSE-2.0
 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/
var extendStatics$1 = function(d, b) {
  extendStatics$1 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
  };
  return extendStatics$1(d, b);
};
function __extends$1(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics$1(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __awaiter$1(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, [])).next());
  });
}
function __generator$1(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __values$1(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function() {
      if (o && i >= o.length) o = void 0;
      return { value: o && o[i++], done: !o };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read$1(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
}
function __spreadArray$1(to, from2, pack) {
  if (arguments.length === 2) for (var i = 0, l = from2.length, ar; i < l; i++) {
    if (ar || !(i in from2)) {
      if (!ar) ar = Array.prototype.slice.call(from2, 0, i);
      ar[i] = from2[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from2));
}
function __await$1(v) {
  return this instanceof __await$1 ? (this.v = v, this) : new __await$1(v);
}
function __asyncGenerator$1(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function awaitReturn(f) {
    return function(v) {
      return Promise.resolve(v).then(f, reject);
    };
  }
  function verb(n, f) {
    if (g[n]) {
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
      if (f) i[n] = f(i[n]);
    }
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await$1 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
}
function __asyncValues$1(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values$1 === "function" ? __values$1(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
}
function isFunction(value) {
  return typeof value === "function";
}
function createErrorClass(createImpl) {
  var _super = function(instance) {
    Error.call(instance);
    instance.stack = new Error().stack;
  };
  var ctorFunc = createImpl(_super);
  ctorFunc.prototype = Object.create(Error.prototype);
  ctorFunc.prototype.constructor = ctorFunc;
  return ctorFunc;
}
var UnsubscriptionError = createErrorClass(function(_super) {
  return function UnsubscriptionErrorImpl(errors) {
    _super(this);
    this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i) {
      return i + 1 + ") " + err.toString();
    }).join("\n  ") : "";
    this.name = "UnsubscriptionError";
    this.errors = errors;
  };
});
function arrRemove(arr, item) {
  if (arr) {
    var index = arr.indexOf(item);
    0 <= index && arr.splice(index, 1);
  }
}
var Subscription = (function() {
  function Subscription2(initialTeardown) {
    this.initialTeardown = initialTeardown;
    this.closed = false;
    this._parentage = null;
    this._finalizers = null;
  }
  Subscription2.prototype.unsubscribe = function() {
    var e_1, _a, e_2, _b;
    var errors;
    if (!this.closed) {
      this.closed = true;
      var _parentage = this._parentage;
      if (_parentage) {
        this._parentage = null;
        if (Array.isArray(_parentage)) {
          try {
            for (var _parentage_1 = __values$1(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
              var parent_1 = _parentage_1_1.value;
              parent_1.remove(this);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return)) _a.call(_parentage_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
        } else {
          _parentage.remove(this);
        }
      }
      var initialFinalizer = this.initialTeardown;
      if (isFunction(initialFinalizer)) {
        try {
          initialFinalizer();
        } catch (e) {
          errors = e instanceof UnsubscriptionError ? e.errors : [e];
        }
      }
      var _finalizers = this._finalizers;
      if (_finalizers) {
        this._finalizers = null;
        try {
          for (var _finalizers_1 = __values$1(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
            var finalizer = _finalizers_1_1.value;
            try {
              execFinalizer(finalizer);
            } catch (err) {
              errors = errors !== null && errors !== void 0 ? errors : [];
              if (err instanceof UnsubscriptionError) {
                errors = __spreadArray$1(__spreadArray$1([], __read$1(errors)), __read$1(err.errors));
              } else {
                errors.push(err);
              }
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return)) _b.call(_finalizers_1);
          } finally {
            if (e_2) throw e_2.error;
          }
        }
      }
      if (errors) {
        throw new UnsubscriptionError(errors);
      }
    }
  };
  Subscription2.prototype.add = function(teardown) {
    var _a;
    if (teardown && teardown !== this) {
      if (this.closed) {
        execFinalizer(teardown);
      } else {
        if (teardown instanceof Subscription2) {
          if (teardown.closed || teardown._hasParent(this)) {
            return;
          }
          teardown._addParent(this);
        }
        (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
      }
    }
  };
  Subscription2.prototype._hasParent = function(parent) {
    var _parentage = this._parentage;
    return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
  };
  Subscription2.prototype._addParent = function(parent) {
    var _parentage = this._parentage;
    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
  };
  Subscription2.prototype._removeParent = function(parent) {
    var _parentage = this._parentage;
    if (_parentage === parent) {
      this._parentage = null;
    } else if (Array.isArray(_parentage)) {
      arrRemove(_parentage, parent);
    }
  };
  Subscription2.prototype.remove = function(teardown) {
    var _finalizers = this._finalizers;
    _finalizers && arrRemove(_finalizers, teardown);
    if (teardown instanceof Subscription2) {
      teardown._removeParent(this);
    }
  };
  Subscription2.EMPTY = (function() {
    var empty = new Subscription2();
    empty.closed = true;
    return empty;
  })();
  return Subscription2;
})();
var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
function isSubscription(value) {
  return value instanceof Subscription || value && "closed" in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe);
}
function execFinalizer(finalizer) {
  if (isFunction(finalizer)) {
    finalizer();
  } else {
    finalizer.unsubscribe();
  }
}
var config = {
  Promise: void 0};
var timeoutProvider = {
  setTimeout: function(handler, timeout) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    return setTimeout.apply(void 0, __spreadArray$1([handler, timeout], __read$1(args)));
  },
  clearTimeout: function(handle) {
    return (clearTimeout)(handle);
  },
  delegate: void 0
};
function reportUnhandledError(err) {
  timeoutProvider.setTimeout(function() {
    {
      throw err;
    }
  });
}
function noop() {
}
function errorContext(cb) {
  {
    cb();
  }
}
var Subscriber = (function(_super) {
  __extends$1(Subscriber2, _super);
  function Subscriber2(destination) {
    var _this = _super.call(this) || this;
    _this.isStopped = false;
    if (destination) {
      _this.destination = destination;
      if (isSubscription(destination)) {
        destination.add(_this);
      }
    } else {
      _this.destination = EMPTY_OBSERVER;
    }
    return _this;
  }
  Subscriber2.create = function(next, error, complete) {
    return new SafeSubscriber(next, error, complete);
  };
  Subscriber2.prototype.next = function(value) {
    if (this.isStopped) ; else {
      this._next(value);
    }
  };
  Subscriber2.prototype.error = function(err) {
    if (this.isStopped) ; else {
      this.isStopped = true;
      this._error(err);
    }
  };
  Subscriber2.prototype.complete = function() {
    if (this.isStopped) ; else {
      this.isStopped = true;
      this._complete();
    }
  };
  Subscriber2.prototype.unsubscribe = function() {
    if (!this.closed) {
      this.isStopped = true;
      _super.prototype.unsubscribe.call(this);
      this.destination = null;
    }
  };
  Subscriber2.prototype._next = function(value) {
    this.destination.next(value);
  };
  Subscriber2.prototype._error = function(err) {
    try {
      this.destination.error(err);
    } finally {
      this.unsubscribe();
    }
  };
  Subscriber2.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  };
  return Subscriber2;
})(Subscription);
var ConsumerObserver = (function() {
  function ConsumerObserver2(partialObserver) {
    this.partialObserver = partialObserver;
  }
  ConsumerObserver2.prototype.next = function(value) {
    var partialObserver = this.partialObserver;
    if (partialObserver.next) {
      try {
        partialObserver.next(value);
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  ConsumerObserver2.prototype.error = function(err) {
    var partialObserver = this.partialObserver;
    if (partialObserver.error) {
      try {
        partialObserver.error(err);
      } catch (error) {
        handleUnhandledError(error);
      }
    } else {
      handleUnhandledError(err);
    }
  };
  ConsumerObserver2.prototype.complete = function() {
    var partialObserver = this.partialObserver;
    if (partialObserver.complete) {
      try {
        partialObserver.complete();
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  return ConsumerObserver2;
})();
var SafeSubscriber = (function(_super) {
  __extends$1(SafeSubscriber2, _super);
  function SafeSubscriber2(observerOrNext, error, complete) {
    var _this = _super.call(this) || this;
    var partialObserver;
    if (isFunction(observerOrNext) || !observerOrNext) {
      partialObserver = {
        next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
        error: error !== null && error !== void 0 ? error : void 0,
        complete: complete !== null && complete !== void 0 ? complete : void 0
      };
    } else {
      {
        partialObserver = observerOrNext;
      }
    }
    _this.destination = new ConsumerObserver(partialObserver);
    return _this;
  }
  return SafeSubscriber2;
})(Subscriber);
function handleUnhandledError(error) {
  {
    reportUnhandledError(error);
  }
}
function defaultErrorHandler(err) {
  throw err;
}
var EMPTY_OBSERVER = {
  closed: true,
  next: noop,
  error: defaultErrorHandler,
  complete: noop
};
var observable = (function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
})();
function identity(x) {
  return x;
}
function pipe() {
  var fns = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    fns[_i] = arguments[_i];
  }
  return pipeFromArray(fns);
}
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce(function(prev, fn) {
      return fn(prev);
    }, input);
  };
}
var Observable = (function() {
  function Observable2(subscribe) {
    if (subscribe) {
      this._subscribe = subscribe;
    }
  }
  Observable2.prototype.lift = function(operator) {
    var observable2 = new Observable2();
    observable2.source = this;
    observable2.operator = operator;
    return observable2;
  };
  Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
    var _this = this;
    var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
    errorContext(function() {
      var _a = _this, operator = _a.operator, source = _a.source;
      subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
    });
    return subscriber;
  };
  Observable2.prototype._trySubscribe = function(sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      sink.error(err);
    }
  };
  Observable2.prototype.forEach = function(next, promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var subscriber = new SafeSubscriber({
        next: function(value) {
          try {
            next(value);
          } catch (err) {
            reject(err);
            subscriber.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
      _this.subscribe(subscriber);
    });
  };
  Observable2.prototype._subscribe = function(subscriber) {
    var _a;
    return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
  };
  Observable2.prototype[observable] = function() {
    return this;
  };
  Observable2.prototype.pipe = function() {
    var operations = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      operations[_i] = arguments[_i];
    }
    return pipeFromArray(operations)(this);
  };
  Observable2.prototype.toPromise = function(promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var value;
      _this.subscribe(function(x) {
        return value = x;
      }, function(err) {
        return reject(err);
      }, function() {
        return resolve(value);
      });
    });
  };
  Observable2.create = function(subscribe) {
    return new Observable2(subscribe);
  };
  return Observable2;
})();
function getPromiseCtor(promiseCtor) {
  var _a;
  return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a !== void 0 ? _a : Promise;
}
function isObserver(value) {
  return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);
}
function isSubscriber(value) {
  return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
}
function hasLift(source) {
  return isFunction(source === null || source === void 0 ? void 0 : source.lift);
}
function operate(init) {
  return function(source) {
    if (hasLift(source)) {
      return source.lift(function(liftedSource) {
        try {
          return init(liftedSource, this);
        } catch (err) {
          this.error(err);
        }
      });
    }
    throw new TypeError("Unable to lift unknown Observable type");
  };
}
function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
}
var OperatorSubscriber = (function(_super) {
  __extends$1(OperatorSubscriber2, _super);
  function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
    var _this = _super.call(this, destination) || this;
    _this.onFinalize = onFinalize;
    _this.shouldUnsubscribe = shouldUnsubscribe;
    _this._next = onNext ? function(value) {
      try {
        onNext(value);
      } catch (err) {
        destination.error(err);
      }
    } : _super.prototype._next;
    _this._error = onError ? function(err) {
      try {
        onError(err);
      } catch (err2) {
        destination.error(err2);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._error;
    _this._complete = onComplete ? function() {
      try {
        onComplete();
      } catch (err) {
        destination.error(err);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._complete;
    return _this;
  }
  OperatorSubscriber2.prototype.unsubscribe = function() {
    var _a;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var closed_1 = this.closed;
      _super.prototype.unsubscribe.call(this);
      !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
    }
  };
  return OperatorSubscriber2;
})(Subscriber);
var ObjectUnsubscribedError = createErrorClass(function(_super) {
  return function ObjectUnsubscribedErrorImpl() {
    _super(this);
    this.name = "ObjectUnsubscribedError";
    this.message = "object unsubscribed";
  };
});
var Subject = (function(_super) {
  __extends$1(Subject2, _super);
  function Subject2() {
    var _this = _super.call(this) || this;
    _this.closed = false;
    _this.currentObservers = null;
    _this.observers = [];
    _this.isStopped = false;
    _this.hasError = false;
    _this.thrownError = null;
    return _this;
  }
  Subject2.prototype.lift = function(operator) {
    var subject = new AnonymousSubject(this, this);
    subject.operator = operator;
    return subject;
  };
  Subject2.prototype._throwIfClosed = function() {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
  };
  Subject2.prototype.next = function(value) {
    var _this = this;
    errorContext(function() {
      var e_1, _a;
      _this._throwIfClosed();
      if (!_this.isStopped) {
        if (!_this.currentObservers) {
          _this.currentObservers = Array.from(_this.observers);
        }
        try {
          for (var _b = __values$1(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
            var observer = _c.value;
            observer.next(value);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
      }
    });
  };
  Subject2.prototype.error = function(err) {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.hasError = _this.isStopped = true;
        _this.thrownError = err;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().error(err);
        }
      }
    });
  };
  Subject2.prototype.complete = function() {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.isStopped = true;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().complete();
        }
      }
    });
  };
  Subject2.prototype.unsubscribe = function() {
    this.isStopped = this.closed = true;
    this.observers = this.currentObservers = null;
  };
  Object.defineProperty(Subject2.prototype, "observed", {
    get: function() {
      var _a;
      return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
    },
    enumerable: false,
    configurable: true
  });
  Subject2.prototype._trySubscribe = function(subscriber) {
    this._throwIfClosed();
    return _super.prototype._trySubscribe.call(this, subscriber);
  };
  Subject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._checkFinalizedStatuses(subscriber);
    return this._innerSubscribe(subscriber);
  };
  Subject2.prototype._innerSubscribe = function(subscriber) {
    var _this = this;
    var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
    if (hasError || isStopped) {
      return EMPTY_SUBSCRIPTION;
    }
    this.currentObservers = null;
    observers.push(subscriber);
    return new Subscription(function() {
      _this.currentObservers = null;
      arrRemove(observers, subscriber);
    });
  };
  Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
    var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped) {
      subscriber.complete();
    }
  };
  Subject2.prototype.asObservable = function() {
    var observable2 = new Observable();
    observable2.source = this;
    return observable2;
  };
  Subject2.create = function(destination, source) {
    return new AnonymousSubject(destination, source);
  };
  return Subject2;
})(Observable);
var AnonymousSubject = (function(_super) {
  __extends$1(AnonymousSubject2, _super);
  function AnonymousSubject2(destination, source) {
    var _this = _super.call(this) || this;
    _this.destination = destination;
    _this.source = source;
    return _this;
  }
  AnonymousSubject2.prototype.next = function(value) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
  };
  AnonymousSubject2.prototype.error = function(err) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
  };
  AnonymousSubject2.prototype.complete = function() {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
  };
  AnonymousSubject2.prototype._subscribe = function(subscriber) {
    var _a, _b;
    return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
  };
  return AnonymousSubject2;
})(Subject);
var dateTimestampProvider = {
  now: function() {
    return (dateTimestampProvider.delegate || Date).now();
  },
  delegate: void 0
};
var ReplaySubject = (function(_super) {
  __extends$1(ReplaySubject2, _super);
  function ReplaySubject2(_bufferSize, _windowTime, _timestampProvider) {
    if (_bufferSize === void 0) {
      _bufferSize = Infinity;
    }
    if (_windowTime === void 0) {
      _windowTime = Infinity;
    }
    if (_timestampProvider === void 0) {
      _timestampProvider = dateTimestampProvider;
    }
    var _this = _super.call(this) || this;
    _this._bufferSize = _bufferSize;
    _this._windowTime = _windowTime;
    _this._timestampProvider = _timestampProvider;
    _this._buffer = [];
    _this._infiniteTimeWindow = true;
    _this._infiniteTimeWindow = _windowTime === Infinity;
    _this._bufferSize = Math.max(1, _bufferSize);
    _this._windowTime = Math.max(1, _windowTime);
    return _this;
  }
  ReplaySubject2.prototype.next = function(value) {
    var _a = this, isStopped = _a.isStopped, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow, _timestampProvider = _a._timestampProvider, _windowTime = _a._windowTime;
    if (!isStopped) {
      _buffer.push(value);
      !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
    }
    this._trimBuffer();
    _super.prototype.next.call(this, value);
  };
  ReplaySubject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._trimBuffer();
    var subscription = this._innerSubscribe(subscriber);
    var _a = this, _infiniteTimeWindow = _a._infiniteTimeWindow, _buffer = _a._buffer;
    var copy = _buffer.slice();
    for (var i = 0; i < copy.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {
      subscriber.next(copy[i]);
    }
    this._checkFinalizedStatuses(subscriber);
    return subscription;
  };
  ReplaySubject2.prototype._trimBuffer = function() {
    var _a = this, _bufferSize = _a._bufferSize, _timestampProvider = _a._timestampProvider, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow;
    var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
    _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
    if (!_infiniteTimeWindow) {
      var now = _timestampProvider.now();
      var last2 = 0;
      for (var i = 1; i < _buffer.length && _buffer[i] <= now; i += 2) {
        last2 = i;
      }
      last2 && _buffer.splice(0, last2 + 1);
    }
  };
  return ReplaySubject2;
})(Subject);
var Action = (function(_super) {
  __extends$1(Action2, _super);
  function Action2(scheduler, work) {
    return _super.call(this) || this;
  }
  Action2.prototype.schedule = function(state, delay2) {
    return this;
  };
  return Action2;
})(Subscription);
var intervalProvider = {
  setInterval: function(handler, timeout) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    return setInterval.apply(void 0, __spreadArray$1([handler, timeout], __read$1(args)));
  },
  clearInterval: function(handle) {
    return (clearInterval)(handle);
  },
  delegate: void 0
};
var AsyncAction = (function(_super) {
  __extends$1(AsyncAction2, _super);
  function AsyncAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    _this.pending = false;
    return _this;
  }
  AsyncAction2.prototype.schedule = function(state, delay2) {
    var _a;
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (this.closed) {
      return this;
    }
    this.state = state;
    var id = this.id;
    var scheduler = this.scheduler;
    if (id != null) {
      this.id = this.recycleAsyncId(scheduler, id, delay2);
    }
    this.pending = true;
    this.delay = delay2;
    this.id = (_a = this.id) !== null && _a !== void 0 ? _a : this.requestAsyncId(scheduler, this.id, delay2);
    return this;
  };
  AsyncAction2.prototype.requestAsyncId = function(scheduler, _id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay2);
  };
  AsyncAction2.prototype.recycleAsyncId = function(_scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null && this.delay === delay2 && this.pending === false) {
      return id;
    }
    if (id != null) {
      intervalProvider.clearInterval(id);
    }
    return void 0;
  };
  AsyncAction2.prototype.execute = function(state, delay2) {
    if (this.closed) {
      return new Error("executing a cancelled action");
    }
    this.pending = false;
    var error = this._execute(state, delay2);
    if (error) {
      return error;
    } else if (this.pending === false && this.id != null) {
      this.id = this.recycleAsyncId(this.scheduler, this.id, null);
    }
  };
  AsyncAction2.prototype._execute = function(state, _delay) {
    var errored = false;
    var errorValue;
    try {
      this.work(state);
    } catch (e) {
      errored = true;
      errorValue = e ? e : new Error("Scheduled action threw falsy error");
    }
    if (errored) {
      this.unsubscribe();
      return errorValue;
    }
  };
  AsyncAction2.prototype.unsubscribe = function() {
    if (!this.closed) {
      var _a = this, id = _a.id, scheduler = _a.scheduler;
      var actions = scheduler.actions;
      this.work = this.state = this.scheduler = null;
      this.pending = false;
      arrRemove(actions, this);
      if (id != null) {
        this.id = this.recycleAsyncId(scheduler, id, null);
      }
      this.delay = null;
      _super.prototype.unsubscribe.call(this);
    }
  };
  return AsyncAction2;
})(Action);
var Scheduler = (function() {
  function Scheduler2(schedulerActionCtor, now) {
    if (now === void 0) {
      now = Scheduler2.now;
    }
    this.schedulerActionCtor = schedulerActionCtor;
    this.now = now;
  }
  Scheduler2.prototype.schedule = function(work, delay2, state) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return new this.schedulerActionCtor(this, work).schedule(state, delay2);
  };
  Scheduler2.now = dateTimestampProvider.now;
  return Scheduler2;
})();
var AsyncScheduler = (function(_super) {
  __extends$1(AsyncScheduler2, _super);
  function AsyncScheduler2(SchedulerAction, now) {
    if (now === void 0) {
      now = Scheduler.now;
    }
    var _this = _super.call(this, SchedulerAction, now) || this;
    _this.actions = [];
    _this._active = false;
    return _this;
  }
  AsyncScheduler2.prototype.flush = function(action) {
    var actions = this.actions;
    if (this._active) {
      actions.push(action);
      return;
    }
    var error;
    this._active = true;
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while (action = actions.shift());
    this._active = false;
    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AsyncScheduler2;
})(Scheduler);
var asyncScheduler = new AsyncScheduler(AsyncAction);
var async = asyncScheduler;
var EMPTY = new Observable(function(subscriber) {
  return subscriber.complete();
});
function isScheduler(value) {
  return value && isFunction(value.schedule);
}
function last(arr) {
  return arr[arr.length - 1];
}
function popScheduler(args) {
  return isScheduler(last(args)) ? args.pop() : void 0;
}
function popNumber(args, defaultValue) {
  return typeof last(args) === "number" ? args.pop() : defaultValue;
}
var isArrayLike = (function(x) {
  return x && typeof x.length === "number" && typeof x !== "function";
});
function isPromise(value) {
  return isFunction(value === null || value === void 0 ? void 0 : value.then);
}
function isInteropObservable(input) {
  return isFunction(input[observable]);
}
function isAsyncIterable(obj) {
  return Symbol.asyncIterator && isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
}
function createInvalidObservableTypeError(input) {
  return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}
function getSymbolIterator() {
  if (typeof Symbol !== "function" || !Symbol.iterator) {
    return "@@iterator";
  }
  return Symbol.iterator;
}
var iterator = getSymbolIterator();
function isIterable(input) {
  return isFunction(input === null || input === void 0 ? void 0 : input[iterator]);
}
function readableStreamLikeToAsyncGenerator(readableStream) {
  return __asyncGenerator$1(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
    var reader, _a, value, done;
    return __generator$1(this, function(_b) {
      switch (_b.label) {
        case 0:
          reader = readableStream.getReader();
          _b.label = 1;
        case 1:
          _b.trys.push([1, , 9, 10]);
          _b.label = 2;
        case 2:
          return [4, __await$1(reader.read())];
        case 3:
          _a = _b.sent(), value = _a.value, done = _a.done;
          if (!done) return [3, 5];
          return [4, __await$1(void 0)];
        case 4:
          return [2, _b.sent()];
        case 5:
          return [4, __await$1(value)];
        case 6:
          return [4, _b.sent()];
        case 7:
          _b.sent();
          return [3, 2];
        case 8:
          return [3, 10];
        case 9:
          reader.releaseLock();
          return [7];
        case 10:
          return [2];
      }
    });
  });
}
function isReadableStreamLike(obj) {
  return isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
}
function innerFrom(input) {
  if (input instanceof Observable) {
    return input;
  }
  if (input != null) {
    if (isInteropObservable(input)) {
      return fromInteropObservable(input);
    }
    if (isArrayLike(input)) {
      return fromArrayLike(input);
    }
    if (isPromise(input)) {
      return fromPromise(input);
    }
    if (isAsyncIterable(input)) {
      return fromAsyncIterable(input);
    }
    if (isIterable(input)) {
      return fromIterable(input);
    }
    if (isReadableStreamLike(input)) {
      return fromReadableStreamLike(input);
    }
  }
  throw createInvalidObservableTypeError(input);
}
function fromInteropObservable(obj) {
  return new Observable(function(subscriber) {
    var obs = obj[observable]();
    if (isFunction(obs.subscribe)) {
      return obs.subscribe(subscriber);
    }
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
function fromArrayLike(array) {
  return new Observable(function(subscriber) {
    for (var i = 0; i < array.length && !subscriber.closed; i++) {
      subscriber.next(array[i]);
    }
    subscriber.complete();
  });
}
function fromPromise(promise) {
  return new Observable(function(subscriber) {
    promise.then(function(value) {
      if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
      }
    }, function(err) {
      return subscriber.error(err);
    }).then(null, reportUnhandledError);
  });
}
function fromIterable(iterable) {
  return new Observable(function(subscriber) {
    var e_1, _a;
    try {
      for (var iterable_1 = __values$1(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
        var value = iterable_1_1.value;
        subscriber.next(value);
        if (subscriber.closed) {
          return;
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) _a.call(iterable_1);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
    subscriber.complete();
  });
}
function fromAsyncIterable(asyncIterable) {
  return new Observable(function(subscriber) {
    process$1(asyncIterable, subscriber).catch(function(err) {
      return subscriber.error(err);
    });
  });
}
function fromReadableStreamLike(readableStream) {
  return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
}
function process$1(asyncIterable, subscriber) {
  var asyncIterable_1, asyncIterable_1_1;
  var e_2, _a;
  return __awaiter$1(this, void 0, void 0, function() {
    var value, e_2_1;
    return __generator$1(this, function(_b) {
      switch (_b.label) {
        case 0:
          _b.trys.push([0, 5, 6, 11]);
          asyncIterable_1 = __asyncValues$1(asyncIterable);
          _b.label = 1;
        case 1:
          return [4, asyncIterable_1.next()];
        case 2:
          if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done)) return [3, 4];
          value = asyncIterable_1_1.value;
          subscriber.next(value);
          if (subscriber.closed) {
            return [2];
          }
          _b.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          e_2_1 = _b.sent();
          e_2 = { error: e_2_1 };
          return [3, 11];
        case 6:
          _b.trys.push([6, , 9, 10]);
          if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return))) return [3, 8];
          return [4, _a.call(asyncIterable_1)];
        case 7:
          _b.sent();
          _b.label = 8;
        case 8:
          return [3, 10];
        case 9:
          if (e_2) throw e_2.error;
          return [7];
        case 10:
          return [7];
        case 11:
          subscriber.complete();
          return [2];
      }
    });
  });
}
function executeSchedule(parentSubscription, scheduler, work, delay2, repeat) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  if (repeat === void 0) {
    repeat = false;
  }
  var scheduleSubscription = scheduler.schedule(function() {
    work();
    if (repeat) {
      parentSubscription.add(this.schedule(null, delay2));
    } else {
      this.unsubscribe();
    }
  }, delay2);
  parentSubscription.add(scheduleSubscription);
  if (!repeat) {
    return scheduleSubscription;
  }
}
function observeOn(scheduler, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return operate(function(source, subscriber) {
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.next(value);
      }, delay2);
    }, function() {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.complete();
      }, delay2);
    }, function(err) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.error(err);
      }, delay2);
    }));
  });
}
function subscribeOn(scheduler, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return operate(function(source, subscriber) {
    subscriber.add(scheduler.schedule(function() {
      return source.subscribe(subscriber);
    }, delay2));
  });
}
function scheduleObservable(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}
function schedulePromise(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}
function scheduleArray(input, scheduler) {
  return new Observable(function(subscriber) {
    var i = 0;
    return scheduler.schedule(function() {
      if (i === input.length) {
        subscriber.complete();
      } else {
        subscriber.next(input[i++]);
        if (!subscriber.closed) {
          this.schedule();
        }
      }
    });
  });
}
function scheduleIterable(input, scheduler) {
  return new Observable(function(subscriber) {
    var iterator2;
    executeSchedule(subscriber, scheduler, function() {
      iterator2 = input[iterator]();
      executeSchedule(subscriber, scheduler, function() {
        var _a;
        var value;
        var done;
        try {
          _a = iterator2.next(), value = _a.value, done = _a.done;
        } catch (err) {
          subscriber.error(err);
          return;
        }
        if (done) {
          subscriber.complete();
        } else {
          subscriber.next(value);
        }
      }, 0, true);
    });
    return function() {
      return isFunction(iterator2 === null || iterator2 === void 0 ? void 0 : iterator2.return) && iterator2.return();
    };
  });
}
function scheduleAsyncIterable(input, scheduler) {
  if (!input) {
    throw new Error("Iterable cannot be null");
  }
  return new Observable(function(subscriber) {
    executeSchedule(subscriber, scheduler, function() {
      var iterator2 = input[Symbol.asyncIterator]();
      executeSchedule(subscriber, scheduler, function() {
        iterator2.next().then(function(result) {
          if (result.done) {
            subscriber.complete();
          } else {
            subscriber.next(result.value);
          }
        });
      }, 0, true);
    });
  });
}
function scheduleReadableStreamLike(input, scheduler) {
  return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);
}
function scheduled(input, scheduler) {
  if (input != null) {
    if (isInteropObservable(input)) {
      return scheduleObservable(input, scheduler);
    }
    if (isArrayLike(input)) {
      return scheduleArray(input, scheduler);
    }
    if (isPromise(input)) {
      return schedulePromise(input, scheduler);
    }
    if (isAsyncIterable(input)) {
      return scheduleAsyncIterable(input, scheduler);
    }
    if (isIterable(input)) {
      return scheduleIterable(input, scheduler);
    }
    if (isReadableStreamLike(input)) {
      return scheduleReadableStreamLike(input, scheduler);
    }
  }
  throw createInvalidObservableTypeError(input);
}
function from(input, scheduler) {
  return scheduler ? scheduled(input, scheduler) : innerFrom(input);
}
function of() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler = popScheduler(args);
  return from(args, scheduler);
}
var EmptyError = createErrorClass(function(_super) {
  return function EmptyErrorImpl() {
    _super(this);
    this.name = "EmptyError";
    this.message = "no elements in sequence";
  };
});
function lastValueFrom(source, config2) {
  var hasConfig = typeof config2 === "object";
  return new Promise(function(resolve, reject) {
    var _hasValue = false;
    var _value;
    source.subscribe({
      next: function(value) {
        _value = value;
        _hasValue = true;
      },
      error: reject,
      complete: function() {
        if (_hasValue) {
          resolve(_value);
        } else if (hasConfig) {
          resolve(config2.defaultValue);
        } else {
          reject(new EmptyError());
        }
      }
    });
  });
}
function firstValueFrom(source, config2) {
  return new Promise(function(resolve, reject) {
    var subscriber = new SafeSubscriber({
      next: function(value) {
        resolve(value);
        subscriber.unsubscribe();
      },
      error: reject,
      complete: function() {
        {
          reject(new EmptyError());
        }
      }
    });
    source.subscribe(subscriber);
  });
}
function isValidDate(value) {
  return value instanceof Date && !isNaN(value);
}
function map(project, thisArg) {
  return operate(function(source, subscriber) {
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      subscriber.next(project.call(thisArg, value, index++));
    }));
  });
}
var isArray = Array.isArray;
function callOrApply(fn, args) {
  return isArray(args) ? fn.apply(void 0, __spreadArray$1([], __read$1(args))) : fn(args);
}
function mapOneOrManyArgs(fn) {
  return map(function(args) {
    return callOrApply(fn, args);
  });
}
function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {
  var buffer = [];
  var active = 0;
  var index = 0;
  var isComplete = false;
  var checkComplete = function() {
    if (isComplete && !buffer.length && !active) {
      subscriber.complete();
    }
  };
  var outerNext = function(value) {
    return active < concurrent ? doInnerSub(value) : buffer.push(value);
  };
  var doInnerSub = function(value) {
    expand && subscriber.next(value);
    active++;
    var innerComplete = false;
    innerFrom(project(value, index++)).subscribe(createOperatorSubscriber(subscriber, function(innerValue) {
      onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
      if (expand) {
        outerNext(innerValue);
      } else {
        subscriber.next(innerValue);
      }
    }, function() {
      innerComplete = true;
    }, void 0, function() {
      if (innerComplete) {
        try {
          active--;
          var _loop_1 = function() {
            var bufferedValue = buffer.shift();
            if (innerSubScheduler) ; else {
              doInnerSub(bufferedValue);
            }
          };
          while (buffer.length && active < concurrent) {
            _loop_1();
          }
          checkComplete();
        } catch (err) {
          subscriber.error(err);
        }
      }
    }));
  };
  source.subscribe(createOperatorSubscriber(subscriber, outerNext, function() {
    isComplete = true;
    checkComplete();
  }));
  return function() {
    additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
  };
}
function mergeMap(project, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  if (isFunction(resultSelector)) {
    return mergeMap(function(a, i) {
      return map(function(b, ii) {
        return resultSelector(a, b, i, ii);
      })(innerFrom(project(a, i)));
    }, concurrent);
  } else if (typeof resultSelector === "number") {
    concurrent = resultSelector;
  }
  return operate(function(source, subscriber) {
    return mergeInternals(source, subscriber, project, concurrent);
  });
}
function mergeAll(concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  return mergeMap(identity, concurrent);
}
function concatAll() {
  return mergeAll(1);
}
function concat() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  return concatAll()(from(args, popScheduler(args)));
}
function defer(observableFactory) {
  return new Observable(function(subscriber) {
    innerFrom(observableFactory()).subscribe(subscriber);
  });
}
var nodeEventEmitterMethods = ["addListener", "removeListener"];
var eventTargetMethods = ["addEventListener", "removeEventListener"];
var jqueryMethods = ["on", "off"];
function fromEvent(target, eventName, options, resultSelector) {
  if (isFunction(options)) {
    resultSelector = options;
    options = void 0;
  }
  if (resultSelector) {
    return fromEvent(target, eventName, options).pipe(mapOneOrManyArgs(resultSelector));
  }
  var _a = __read$1(isEventTarget(target) ? eventTargetMethods.map(function(methodName) {
    return function(handler) {
      return target[methodName](eventName, handler, options);
    };
  }) : isNodeStyleEventEmitter(target) ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName)) : isJQueryStyleEventEmitter(target) ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName)) : [], 2), add = _a[0], remove = _a[1];
  if (!add) {
    if (isArrayLike(target)) {
      return mergeMap(function(subTarget) {
        return fromEvent(subTarget, eventName, options);
      })(innerFrom(target));
    }
  }
  if (!add) {
    throw new TypeError("Invalid event target");
  }
  return new Observable(function(subscriber) {
    var handler = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return subscriber.next(1 < args.length ? args : args[0]);
    };
    add(handler);
    return function() {
      return remove(handler);
    };
  });
}
function toCommonHandlerRegistry(target, eventName) {
  return function(methodName) {
    return function(handler) {
      return target[methodName](eventName, handler);
    };
  };
}
function isNodeStyleEventEmitter(target) {
  return isFunction(target.addListener) && isFunction(target.removeListener);
}
function isJQueryStyleEventEmitter(target) {
  return isFunction(target.on) && isFunction(target.off);
}
function isEventTarget(target) {
  return isFunction(target.addEventListener) && isFunction(target.removeEventListener);
}
function timer(dueTime, intervalOrScheduler, scheduler) {
  if (dueTime === void 0) {
    dueTime = 0;
  }
  if (scheduler === void 0) {
    scheduler = async;
  }
  return new Observable(function(subscriber) {
    var due = isValidDate(dueTime) ? +dueTime - scheduler.now() : dueTime;
    if (due < 0) {
      due = 0;
    }
    var n = 0;
    return scheduler.schedule(function() {
      if (!subscriber.closed) {
        subscriber.next(n++);
        {
          subscriber.complete();
        }
      }
    }, due);
  });
}
function merge() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler = popScheduler(args);
  var concurrent = popNumber(args, Infinity);
  var sources = args;
  return !sources.length ? EMPTY : sources.length === 1 ? innerFrom(sources[0]) : mergeAll(concurrent)(from(sources, scheduler));
}
var NEVER = new Observable(noop);
var isArray3 = Array.isArray;
function argsOrArgArray(args) {
  return args.length === 1 && isArray3(args[0]) ? args[0] : args;
}
function filter(predicate, thisArg) {
  return operate(function(source, subscriber) {
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return predicate.call(thisArg, value, index++) && subscriber.next(value);
    }));
  });
}
function race() {
  var sources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    sources[_i] = arguments[_i];
  }
  sources = argsOrArgArray(sources);
  return sources.length === 1 ? innerFrom(sources[0]) : new Observable(raceInit(sources));
}
function raceInit(sources) {
  return function(subscriber) {
    var subscriptions = [];
    var _loop_1 = function(i2) {
      subscriptions.push(innerFrom(sources[i2]).subscribe(createOperatorSubscriber(subscriber, function(value) {
        if (subscriptions) {
          for (var s = 0; s < subscriptions.length; s++) {
            s !== i2 && subscriptions[s].unsubscribe();
          }
          subscriptions = null;
        }
        subscriber.next(value);
      })));
    };
    for (var i = 0; subscriptions && !subscriber.closed && i < sources.length; i++) {
      _loop_1(i);
    }
  };
}
function bufferCount(bufferSize, startBufferEvery) {
  if (startBufferEvery === void 0) {
    startBufferEvery = null;
  }
  startBufferEvery = startBufferEvery !== null && startBufferEvery !== void 0 ? startBufferEvery : bufferSize;
  return operate(function(source, subscriber) {
    var buffers = [];
    var count = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var e_1, _a, e_2, _b;
      var toEmit = null;
      if (count++ % startBufferEvery === 0) {
        buffers.push([]);
      }
      try {
        for (var buffers_1 = __values$1(buffers), buffers_1_1 = buffers_1.next(); !buffers_1_1.done; buffers_1_1 = buffers_1.next()) {
          var buffer = buffers_1_1.value;
          buffer.push(value);
          if (bufferSize <= buffer.length) {
            toEmit = toEmit !== null && toEmit !== void 0 ? toEmit : [];
            toEmit.push(buffer);
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (buffers_1_1 && !buffers_1_1.done && (_a = buffers_1.return)) _a.call(buffers_1);
        } finally {
          if (e_1) throw e_1.error;
        }
      }
      if (toEmit) {
        try {
          for (var toEmit_1 = __values$1(toEmit), toEmit_1_1 = toEmit_1.next(); !toEmit_1_1.done; toEmit_1_1 = toEmit_1.next()) {
            var buffer = toEmit_1_1.value;
            arrRemove(buffers, buffer);
            subscriber.next(buffer);
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (toEmit_1_1 && !toEmit_1_1.done && (_b = toEmit_1.return)) _b.call(toEmit_1);
          } finally {
            if (e_2) throw e_2.error;
          }
        }
      }
    }, function() {
      var e_3, _a;
      try {
        for (var buffers_2 = __values$1(buffers), buffers_2_1 = buffers_2.next(); !buffers_2_1.done; buffers_2_1 = buffers_2.next()) {
          var buffer = buffers_2_1.value;
          subscriber.next(buffer);
        }
      } catch (e_3_1) {
        e_3 = { error: e_3_1 };
      } finally {
        try {
          if (buffers_2_1 && !buffers_2_1.done && (_a = buffers_2.return)) _a.call(buffers_2);
        } finally {
          if (e_3) throw e_3.error;
        }
      }
      subscriber.complete();
    }, void 0, function() {
      buffers = null;
    }));
  });
}
function catchError(selector) {
  return operate(function(source, subscriber) {
    var innerSub = null;
    var syncUnsub = false;
    var handledResult;
    innerSub = source.subscribe(createOperatorSubscriber(subscriber, void 0, void 0, function(err) {
      handledResult = innerFrom(selector(err, catchError(selector)(source)));
      if (innerSub) {
        innerSub.unsubscribe();
        innerSub = null;
        handledResult.subscribe(subscriber);
      } else {
        syncUnsub = true;
      }
    }));
    if (syncUnsub) {
      innerSub.unsubscribe();
      innerSub = null;
      handledResult.subscribe(subscriber);
    }
  });
}
function concatMap(project, resultSelector) {
  return isFunction(resultSelector) ? mergeMap(project, resultSelector, 1) : mergeMap(project, 1);
}
function defaultIfEmpty(defaultValue) {
  return operate(function(source, subscriber) {
    var hasValue = false;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      hasValue = true;
      subscriber.next(value);
    }, function() {
      if (!hasValue) {
        subscriber.next(defaultValue);
      }
      subscriber.complete();
    }));
  });
}
function take(count) {
  return count <= 0 ? function() {
    return EMPTY;
  } : operate(function(source, subscriber) {
    var seen = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      if (++seen <= count) {
        subscriber.next(value);
        if (count <= seen) {
          subscriber.complete();
        }
      }
    }));
  });
}
function ignoreElements() {
  return operate(function(source, subscriber) {
    source.subscribe(createOperatorSubscriber(subscriber, noop));
  });
}
function distinctUntilChanged(comparator, keySelector) {
  if (keySelector === void 0) {
    keySelector = identity;
  }
  comparator = comparator !== null && comparator !== void 0 ? comparator : defaultCompare;
  return operate(function(source, subscriber) {
    var previousKey;
    var first2 = true;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var currentKey = keySelector(value);
      if (first2 || !comparator(previousKey, currentKey)) {
        first2 = false;
        previousKey = currentKey;
        subscriber.next(value);
      }
    }));
  });
}
function defaultCompare(a, b) {
  return a === b;
}
function throwIfEmpty(errorFactory) {
  if (errorFactory === void 0) {
    errorFactory = defaultErrorFactory;
  }
  return operate(function(source, subscriber) {
    var hasValue = false;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      hasValue = true;
      subscriber.next(value);
    }, function() {
      return hasValue ? subscriber.complete() : subscriber.error(errorFactory());
    }));
  });
}
function defaultErrorFactory() {
  return new EmptyError();
}
function first(predicate, defaultValue) {
  var hasDefaultValue = arguments.length >= 2;
  return function(source) {
    return source.pipe(predicate ? filter(function(v, i) {
      return predicate(v, i, source);
    }) : identity, take(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function() {
      return new EmptyError();
    }));
  };
}
function mergeScan(accumulator, seed, concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  return operate(function(source, subscriber) {
    var state = seed;
    return mergeInternals(source, subscriber, function(value, index) {
      return accumulator(state, value, index);
    }, concurrent, function(value) {
      state = value;
    }, false, void 0, function() {
      return state = null;
    });
  });
}
function raceWith() {
  var otherSources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    otherSources[_i] = arguments[_i];
  }
  return !otherSources.length ? identity : operate(function(source, subscriber) {
    raceInit(__spreadArray$1([source], __read$1(otherSources)))(subscriber);
  });
}
function retry(configOrCount) {
  if (configOrCount === void 0) {
    configOrCount = Infinity;
  }
  var config2;
  if (configOrCount && typeof configOrCount === "object") {
    config2 = configOrCount;
  } else {
    config2 = {
      count: configOrCount
    };
  }
  var _a = config2.count, count = _a === void 0 ? Infinity : _a, delay2 = config2.delay, _b = config2.resetOnSuccess, resetOnSuccess = _b === void 0 ? false : _b;
  return count <= 0 ? identity : operate(function(source, subscriber) {
    var soFar = 0;
    var innerSub;
    var subscribeForRetry = function() {
      var syncUnsub = false;
      innerSub = source.subscribe(createOperatorSubscriber(subscriber, function(value) {
        if (resetOnSuccess) {
          soFar = 0;
        }
        subscriber.next(value);
      }, void 0, function(err) {
        if (soFar++ < count) {
          var resub_1 = function() {
            if (innerSub) {
              innerSub.unsubscribe();
              innerSub = null;
              subscribeForRetry();
            } else {
              syncUnsub = true;
            }
          };
          if (delay2 != null) {
            var notifier = typeof delay2 === "number" ? timer(delay2) : innerFrom(delay2(err, soFar));
            var notifierSubscriber_1 = createOperatorSubscriber(subscriber, function() {
              notifierSubscriber_1.unsubscribe();
              resub_1();
            }, function() {
              subscriber.complete();
            });
            notifier.subscribe(notifierSubscriber_1);
          } else {
            resub_1();
          }
        } else {
          subscriber.error(err);
        }
      }));
      if (syncUnsub) {
        innerSub.unsubscribe();
        innerSub = null;
        subscribeForRetry();
      }
    };
    subscribeForRetry();
  });
}
function startWith() {
  var values = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    values[_i] = arguments[_i];
  }
  var scheduler = popScheduler(values);
  return operate(function(source, subscriber) {
    (scheduler ? concat(values, source, scheduler) : concat(values, source)).subscribe(subscriber);
  });
}
function switchMap(project, resultSelector) {
  return operate(function(source, subscriber) {
    var innerSubscriber = null;
    var index = 0;
    var isComplete = false;
    var checkComplete = function() {
      return isComplete && !innerSubscriber && subscriber.complete();
    };
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();
      var innerIndex = 0;
      var outerIndex = index++;
      innerFrom(project(value, outerIndex)).subscribe(innerSubscriber = createOperatorSubscriber(subscriber, function(innerValue) {
        return subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue);
      }, function() {
        innerSubscriber = null;
        checkComplete();
      }));
    }, function() {
      isComplete = true;
      checkComplete();
    }));
  });
}
function takeUntil(notifier) {
  return operate(function(source, subscriber) {
    innerFrom(notifier).subscribe(createOperatorSubscriber(subscriber, function() {
      return subscriber.complete();
    }, noop));
    !subscriber.closed && source.subscribe(subscriber);
  });
}
function tap(observerOrNext, error, complete) {
  var tapObserver = isFunction(observerOrNext) || error || complete ? { next: observerOrNext, error, complete } : observerOrNext;
  return tapObserver ? operate(function(source, subscriber) {
    var _a;
    (_a = tapObserver.subscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
    var isUnsub = true;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var _a2;
      (_a2 = tapObserver.next) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, value);
      subscriber.next(value);
    }, function() {
      var _a2;
      isUnsub = false;
      (_a2 = tapObserver.complete) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
      subscriber.complete();
    }, function(err) {
      var _a2;
      isUnsub = false;
      (_a2 = tapObserver.error) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, err);
      subscriber.error(err);
    }, function() {
      var _a2, _b;
      if (isUnsub) {
        (_a2 = tapObserver.unsubscribe) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
      }
      (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);
    }));
  }) : identity;
}

/**
MIT License
Copyright (c) 2021 Jason Miller
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
function mitt_default(n) {
  return { all: n = n ||  new Map(), on: function(t, e) {
    var i = n.get(t);
    i ? i.push(e) : n.set(t, [e]);
  }, off: function(t, e) {
    var i = n.get(t);
    i && (e ? i.splice(i.indexOf(e) >>> 0, 1) : n.set(t, []));
  }, emit: function(t, e) {
    var i = n.get(t);
    i && i.slice().map(function(n2) {
      n2(e);
    }), (i = n.get("*")) && i.slice().map(function(n2) {
      n2(t, e);
    });
  } };
}

/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
Symbol.dispose ??= Symbol('dispose');
Symbol.asyncDispose ??= Symbol('asyncDispose');
const disposeSymbol = Symbol.dispose;
const asyncDisposeSymbol = Symbol.asyncDispose;
class DisposableStackPolyfill {
    #disposed = false;
    #stack = [];
    get disposed() {
        return this.#disposed;
    }
    dispose() {
        this[disposeSymbol]();
    }
    use(value) {
        if (value && typeof value[disposeSymbol] === 'function') {
            this.#stack.push(value);
        }
        return value;
    }
    adopt(value, onDispose) {
        this.#stack.push({
            [disposeSymbol]() {
                onDispose(value);
            },
        });
        return value;
    }
    defer(onDispose) {
        this.#stack.push({
            [disposeSymbol]() {
                onDispose();
            },
        });
    }
    move() {
        if (this.#disposed) {
            throw new ReferenceError('A disposed stack can not use anything new');
        }
        const stack = new DisposableStackPolyfill();
        stack.#stack = this.#stack;
        this.#stack = [];
        this.#disposed = true;
        return stack;
    }
    [disposeSymbol]() {
        if (this.#disposed) {
            return;
        }
        this.#disposed = true;
        const errors = [];
        for (const resource of this.#stack.reverse()) {
            try {
                resource[disposeSymbol]();
            }
            catch (e) {
                errors.push(e);
            }
        }
        if (errors.length === 1) {
            throw errors[0];
        }
        else if (errors.length > 1) {
            let suppressed = null;
            for (const error of errors) {
                if (suppressed === null) {
                    suppressed = error;
                }
                else {
                    suppressed = new SuppressedErrorPolyfill(error, suppressed);
                }
            }
            throw suppressed;
        }
    }
    [Symbol.toStringTag] = 'DisposableStack';
}
const DisposableStack = globalThis.DisposableStack ?? DisposableStackPolyfill;
class AsyncDisposableStackPolyfill {
    #disposed = false;
    #stack = [];
    get disposed() {
        return this.#disposed;
    }
    async disposeAsync() {
        await this[asyncDisposeSymbol]();
    }
    use(value) {
        if (value) {
            const asyncDispose = value[asyncDisposeSymbol];
            const dispose = value[disposeSymbol];
            if (typeof asyncDispose === 'function') {
                this.#stack.push(value);
            }
            else if (typeof dispose === 'function') {
                this.#stack.push({
                    [asyncDisposeSymbol]: async () => {
                        value[disposeSymbol]();
                    },
                });
            }
        }
        return value;
    }
    adopt(value, onDispose) {
        this.#stack.push({
            [asyncDisposeSymbol]() {
                return onDispose(value);
            },
        });
        return value;
    }
    defer(onDispose) {
        this.#stack.push({
            [asyncDisposeSymbol]() {
                return onDispose();
            },
        });
    }
    move() {
        if (this.#disposed) {
            throw new ReferenceError('A disposed stack can not use anything new');
        }
        const stack = new AsyncDisposableStackPolyfill();
        stack.#stack = this.#stack;
        this.#stack = [];
        this.#disposed = true;
        return stack;
    }
    async [asyncDisposeSymbol]() {
        if (this.#disposed) {
            return;
        }
        this.#disposed = true;
        const errors = [];
        for (const resource of this.#stack.reverse()) {
            try {
                await resource[asyncDisposeSymbol]();
            }
            catch (e) {
                errors.push(e);
            }
        }
        if (errors.length === 1) {
            throw errors[0];
        }
        else if (errors.length > 1) {
            let suppressed = null;
            for (const error of errors) {
                if (suppressed === null) {
                    suppressed = error;
                }
                else {
                    suppressed = new SuppressedErrorPolyfill(error, suppressed);
                }
            }
            throw suppressed;
        }
    }
    [Symbol.toStringTag] = 'AsyncDisposableStack';
}
const AsyncDisposableStack = globalThis.AsyncDisposableStack ?? AsyncDisposableStackPolyfill;
class SuppressedErrorPolyfill extends Error {
    #error;
    #suppressed;
    constructor(error, suppressed, message = 'An error was suppressed during disposal') {
        super(message);
        this.name = 'SuppressedError';
        this.#error = error;
        this.#suppressed = suppressed;
    }
    get error() {
        return this.#error;
    }
    get suppressed() {
        return this.#suppressed;
    }
}

/**
 * @license
 * Copyright 2022 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class EventEmitter {
    #emitter;
    #handlers = new Map();
    constructor(emitter = mitt_default(new Map())) {
        this.#emitter = emitter;
    }
    on(type, handler) {
        const handlers = this.#handlers.get(type);
        if (handlers === undefined) {
            this.#handlers.set(type, [handler]);
        }
        else {
            handlers.push(handler);
        }
        this.#emitter.on(type, handler);
        return this;
    }
    off(type, handler) {
        const handlers = this.#handlers.get(type) ?? [];
        if (handler === undefined) {
            for (const handler of handlers) {
                this.#emitter.off(type, handler);
            }
            this.#handlers.delete(type);
            return this;
        }
        const index = handlers.lastIndexOf(handler);
        if (index > -1) {
            this.#emitter.off(type, ...handlers.splice(index, 1));
        }
        return this;
    }
    emit(type, event) {
        this.#emitter.emit(type, event);
        return this.listenerCount(type) > 0;
    }
    once(type, handler) {
        const onceHandler = eventData => {
            handler(eventData);
            this.off(type, onceHandler);
        };
        return this.on(type, onceHandler);
    }
    listenerCount(type) {
        return this.#handlers.get(type)?.length || 0;
    }
    removeAllListeners(type) {
        if (type !== undefined) {
            return this.off(type);
        }
        this[disposeSymbol]();
        return this;
    }
    [disposeSymbol]() {
        for (const [type, handlers] of this.#handlers) {
            for (const handler of handlers) {
                this.#emitter.off(type, handler);
            }
        }
        this.#handlers.clear();
    }
}

/**
 * @license
 * Copyright 2020 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const isNode = !!(typeof process !== 'undefined' && process.version);
const environment = {
    value: {
        get fs() {
            throw new Error('fs is not available in this environment');
        },
        get ScreenRecorder() {
            throw new Error('ScreenRecorder is not available in this environment');
        },
    },
};

/**
 * @license
 * Copyright 2020 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const assert = (value, message) => {
    if (!value) {
        throw new Error(message);
    }
};

/**
 * @license
 * Copyright 2024 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
function stringToTypedArray(string, base64Encoded = false) {
    if (base64Encoded) {
        if (typeof Buffer === 'function') {
            return Buffer.from(string, 'base64');
        }
        return Uint8Array.from(atob(string), m => {
            return m.codePointAt(0);
        });
    }
    return new TextEncoder().encode(string);
}
function stringToBase64(str) {
    return typedArrayToBase64(new TextEncoder().encode(str));
}
function typedArrayToBase64(typedArray) {
    const chunkSize = 65534;
    const chunks = [];
    for (let i = 0; i < typedArray.length; i += chunkSize) {
        const chunk = typedArray.subarray(i, i + chunkSize);
        chunks.push(String.fromCodePoint.apply(null, chunk));
    }
    const binaryString = chunks.join('');
    return btoa(binaryString);
}
function mergeUint8Arrays(items) {
    let length = 0;
    for (const item of items) {
        length += item.length;
    }
    const result = new Uint8Array(length);
    let offset = 0;
    for (const item of items) {
        result.set(item, offset);
        offset += item.length;
    }
    return result;
}

/**
 * @license
 * Copyright 2025 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const packageVersion = '24.26.0';

/**
 * @license
 * Copyright 2020 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
let debugModule = null;
async function importDebug() {
    if (!debugModule) {
        debugModule = (await Promise.resolve().then(function () { return index; })).default;
    }
    return debugModule;
}
const debug$1 = (prefix) => {
    if (isNode) {
        return async (...logArgs) => {
            (await importDebug())(prefix)(logArgs);
        };
    }
    return (...logArgs) => {
        const debugLevel = globalThis.__PUPPETEER_DEBUG;
        if (!debugLevel) {
            return;
        }
        const everythingShouldBeLogged = debugLevel === '*';
        const prefixMatchesDebugLevel = everythingShouldBeLogged ||
            (debugLevel.endsWith('*')
                ? prefix.startsWith(debugLevel)
                : prefix === debugLevel);
        if (!prefixMatchesDebugLevel) {
            return;
        }
        console.log(`${prefix}:`, ...logArgs);
    };
};

/**
 * @license
 * Copyright 2018 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class PuppeteerError extends Error {
    constructor(message, options) {
        super(message, options);
        this.name = this.constructor.name;
    }
    get [Symbol.toStringTag]() {
        return this.constructor.name;
    }
}
let TimeoutError$1 = class TimeoutError extends PuppeteerError {
};
class TouchError extends PuppeteerError {
}
class ProtocolError extends PuppeteerError {
    #code;
    #originalMessage = '';
    set code(code) {
        this.#code = code;
    }
    get code() {
        return this.#code;
    }
    set originalMessage(originalMessage) {
        this.#originalMessage = originalMessage;
    }
    get originalMessage() {
        return this.#originalMessage;
    }
}
class UnsupportedOperation extends PuppeteerError {
}
class TargetCloseError extends ProtocolError {
}
class ConnectionClosedError extends ProtocolError {
}

/**
 * @license
 * Copyright 2020 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const paperFormats = {
    letter: {
        cm: { width: 21.59, height: 27.94 },
        in: { width: 8.5, height: 11 },
    },
    legal: {
        cm: { width: 21.59, height: 35.56 },
        in: { width: 8.5, height: 14 },
    },
    tabloid: {
        cm: { width: 27.94, height: 43.18 },
        in: { width: 11, height: 17 },
    },
    ledger: {
        cm: { width: 43.18, height: 27.94 },
        in: { width: 17, height: 11 },
    },
    a0: {
        cm: { width: 84.1, height: 118.9 },
        in: { width: 33.1102, height: 46.811 },
    },
    a1: {
        cm: { width: 59.4, height: 84.1 },
        in: { width: 23.3858, height: 33.1102 },
    },
    a2: {
        cm: { width: 42, height: 59.4 },
        in: { width: 16.5354, height: 23.3858 },
    },
    a3: {
        cm: { width: 29.7, height: 42 },
        in: { width: 11.6929, height: 16.5354 },
    },
    a4: {
        cm: { width: 21, height: 29.7 },
        in: { width: 8.2677, height: 11.6929 },
    },
    a5: {
        cm: { width: 14.8, height: 21 },
        in: { width: 5.8268, height: 8.2677 },
    },
    a6: {
        cm: { width: 10.5, height: 14.8 },
        in: { width: 4.1339, height: 5.8268 },
    },
};

/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const debugError = debug$1('puppeteer:error');
const DEFAULT_VIEWPORT = Object.freeze({ width: 800, height: 600 });
const SOURCE_URL = Symbol('Source URL for Puppeteer evaluation scripts');
class PuppeteerURL {
    static INTERNAL_URL = 'pptr:internal';
    static fromCallSite(functionName, site) {
        const url = new PuppeteerURL();
        url.#functionName = functionName;
        url.#siteString = site.toString();
        return url;
    }
    static parse = (url) => {
        url = url.slice('pptr:'.length);
        const [functionName = '', siteString = ''] = url.split(';');
        const puppeteerUrl = new PuppeteerURL();
        puppeteerUrl.#functionName = functionName;
        puppeteerUrl.#siteString = decodeURIComponent(siteString);
        return puppeteerUrl;
    };
    static isPuppeteerURL = (url) => {
        return url.startsWith('pptr:');
    };
    #functionName;
    #siteString;
    get functionName() {
        return this.#functionName;
    }
    get siteString() {
        return this.#siteString;
    }
    toString() {
        return `pptr:${[
            this.#functionName,
            encodeURIComponent(this.#siteString),
        ].join(';')}`;
    }
}
const withSourcePuppeteerURLIfNone = (functionName, object) => {
    if (Object.prototype.hasOwnProperty.call(object, SOURCE_URL)) {
        return object;
    }
    const original = Error.prepareStackTrace;
    Error.prepareStackTrace = (_, stack) => {
        return stack[2];
    };
    const site = new Error().stack;
    Error.prepareStackTrace = original;
    return Object.assign(object, {
        [SOURCE_URL]: PuppeteerURL.fromCallSite(functionName, site),
    });
};
const getSourcePuppeteerURLIfAvailable = (object) => {
    if (Object.prototype.hasOwnProperty.call(object, SOURCE_URL)) {
        return object[SOURCE_URL];
    }
    return undefined;
};
const isString = (obj) => {
    return typeof obj === 'string' || obj instanceof String;
};
const isNumber = (obj) => {
    return typeof obj === 'number' || obj instanceof Number;
};
function evaluationString(
fun, ...args) {
    if (isString(fun)) {
        assert(args.length === 0, 'Cannot evaluate a string with arguments');
        return fun;
    }
    function serializeArgument(arg) {
        if (Object.is(arg, undefined)) {
            return 'undefined';
        }
        return JSON.stringify(arg);
    }
    return `(${fun})(${args.map(serializeArgument).join(',')})`;
}
async function getReadableAsTypedArray(readable, path) {
    const buffers = [];
    const reader = readable.getReader();
    if (path) {
        const fileHandle = await environment.value.fs.promises.open(path, 'w+');
        try {
            while (true) {
                const { done, value } = await reader.read();
                if (done) {
                    break;
                }
                buffers.push(value);
                await fileHandle.writeFile(value);
            }
        }
        finally {
            await fileHandle.close();
        }
    }
    else {
        while (true) {
            const { done, value } = await reader.read();
            if (done) {
                break;
            }
            buffers.push(value);
        }
    }
    try {
        const concat = mergeUint8Arrays(buffers);
        if (concat.length === 0) {
            return null;
        }
        return concat;
    }
    catch (error) {
        debugError(error);
        return null;
    }
}
async function getReadableFromProtocolStream(client, handle) {
    return new ReadableStream({
        async pull(controller) {
            const { data, base64Encoded, eof } = await client.send('IO.read', {
                handle,
            });
            controller.enqueue(stringToTypedArray(data, base64Encoded ?? false));
            if (eof) {
                await client.send('IO.close', { handle });
                controller.close();
            }
        },
    });
}
function validateDialogType(type) {
    let dialogType = null;
    const validDialogTypes = new Set([
        'alert',
        'confirm',
        'prompt',
        'beforeunload',
    ]);
    if (validDialogTypes.has(type)) {
        dialogType = type;
    }
    assert(dialogType, `Unknown javascript dialog type: ${type}`);
    return dialogType;
}
function timeout(ms, cause) {
    return ms === 0
        ? NEVER
        : timer(ms).pipe(map(() => {
            throw new TimeoutError$1(`Timed out after waiting ${ms}ms`, { cause });
        }));
}
const UTILITY_WORLD_NAME = '__puppeteer_utility_world__' + packageVersion;
const SOURCE_URL_REGEX = /^[\x20\t]*\/\/[@#] sourceURL=\s{0,10}(\S*?)\s{0,10}$/m;
function getSourceUrlComment(url) {
    return `//# sourceURL=${url}`;
}
const NETWORK_IDLE_TIME = 500;
function parsePDFOptions(options = {}, lengthUnit = 'in') {
    const defaults = {
        scale: 1,
        displayHeaderFooter: false,
        headerTemplate: '',
        footerTemplate: '',
        printBackground: false,
        landscape: false,
        pageRanges: '',
        preferCSSPageSize: false,
        omitBackground: false,
        outline: false,
        tagged: true,
        waitForFonts: true,
    };
    let width = 8.5;
    let height = 11;
    if (options.format) {
        const format = paperFormats[options.format.toLowerCase()][lengthUnit];
        assert(format, 'Unknown paper format: ' + options.format);
        width = format.width;
        height = format.height;
    }
    else {
        width = convertPrintParameterToInches(options.width, lengthUnit) ?? width;
        height =
            convertPrintParameterToInches(options.height, lengthUnit) ?? height;
    }
    const margin = {
        top: convertPrintParameterToInches(options.margin?.top, lengthUnit) || 0,
        left: convertPrintParameterToInches(options.margin?.left, lengthUnit) || 0,
        bottom: convertPrintParameterToInches(options.margin?.bottom, lengthUnit) || 0,
        right: convertPrintParameterToInches(options.margin?.right, lengthUnit) || 0,
    };
    if (options.outline) {
        options.tagged = true;
    }
    return {
        ...defaults,
        ...options,
        width,
        height,
        margin,
    };
}
const unitToPixels = {
    px: 1,
    in: 96,
    cm: 37.8,
    mm: 3.78,
};
function convertPrintParameterToInches(parameter, lengthUnit = 'in') {
    if (typeof parameter === 'undefined') {
        return undefined;
    }
    let pixels;
    if (isNumber(parameter)) {
        pixels = parameter;
    }
    else if (isString(parameter)) {
        const text = parameter;
        let unit = text.substring(text.length - 2).toLowerCase();
        let valueText = '';
        if (unit in unitToPixels) {
            valueText = text.substring(0, text.length - 2);
        }
        else {
            unit = 'px';
            valueText = text;
        }
        const value = Number(valueText);
        assert(!isNaN(value), 'Failed to parse parameter value: ' + text);
        pixels = value * unitToPixels[unit];
    }
    else {
        throw new Error('page.pdf() Cannot handle parameter type: ' + typeof parameter);
    }
    return pixels / unitToPixels[lengthUnit];
}
function fromEmitterEvent(emitter, eventName) {
    return new Observable(subscriber => {
        const listener = (event) => {
            subscriber.next(event);
        };
        emitter.on(eventName, listener);
        return () => {
            emitter.off(eventName, listener);
        };
    });
}
function fromAbortSignal(signal, cause) {
    return signal
        ? fromEvent(signal, 'abort').pipe(map(() => {
            if (signal.reason instanceof Error) {
                signal.reason.cause = cause;
                throw signal.reason;
            }
            throw new Error(signal.reason, { cause });
        }))
        : NEVER;
}
function filterAsync(predicate) {
    return mergeMap((value) => {
        return from(Promise.resolve(predicate(value))).pipe(filter(isMatch => {
            return isMatch;
        }), map(() => {
            return value;
        }));
    });
}

const WEB_PERMISSION_TO_PROTOCOL_PERMISSION = new Map([
    ['accelerometer', 'sensors'],
    ['ambient-light-sensor', 'sensors'],
    ['background-sync', 'backgroundSync'],
    ['camera', 'videoCapture'],
    ['clipboard-read', 'clipboardReadWrite'],
    ['clipboard-sanitized-write', 'clipboardSanitizedWrite'],
    ['clipboard-write', 'clipboardReadWrite'],
    ['geolocation', 'geolocation'],
    ['gyroscope', 'sensors'],
    ['idle-detection', 'idleDetection'],
    ['keyboard-lock', 'keyboardLock'],
    ['magnetometer', 'sensors'],
    ['microphone', 'audioCapture'],
    ['midi', 'midi'],
    ['notifications', 'notifications'],
    ['payment-handler', 'paymentHandler'],
    ['persistent-storage', 'durableStorage'],
    ['pointer-lock', 'pointerLock'],
    ['midi-sysex', 'midiSysex'],
]);
let Browser$1 = class Browser extends EventEmitter {
    constructor() {
        super();
    }
    async waitForTarget(predicate, options = {}) {
        const { timeout: ms = 30000, signal } = options;
        return await firstValueFrom(merge(fromEmitterEvent(this, "targetcreated" ), fromEmitterEvent(this, "targetchanged" ), from(this.targets())).pipe(filterAsync(predicate), raceWith(fromAbortSignal(signal), timeout(ms))));
    }
    async pages() {
        const contextPages = await Promise.all(this.browserContexts().map(context => {
            return context.pages();
        }));
        return contextPages.reduce((acc, x) => {
            return acc.concat(x);
        }, []);
    }
    async cookies() {
        return await this.defaultBrowserContext().cookies();
    }
    async setCookie(...cookies) {
        return await this.defaultBrowserContext().setCookie(...cookies);
    }
    async deleteCookie(...cookies) {
        return await this.defaultBrowserContext().deleteCookie(...cookies);
    }
    async deleteMatchingCookies(...filters) {
        return await this.defaultBrowserContext().deleteMatchingCookies(...filters);
    }
    isConnected() {
        return this.connected;
    }
    [disposeSymbol]() {
        if (this.process()) {
            return void this.close().catch(debugError);
        }
        return void this.disconnect().catch(debugError);
    }
    [asyncDisposeSymbol]() {
        if (this.process()) {
            return this.close();
        }
        return this.disconnect();
    }
};

/**
 * @license
 * Copyright 2024 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class Deferred {
    static create(opts) {
        return new Deferred(opts);
    }
    static async race(awaitables) {
        const deferredWithTimeout = new Set();
        try {
            const promises = awaitables.map(value => {
                if (value instanceof Deferred) {
                    if (value.#timeoutId) {
                        deferredWithTimeout.add(value);
                    }
                    return value.valueOrThrow();
                }
                return value;
            });
            return await Promise.race(promises);
        }
        finally {
            for (const deferred of deferredWithTimeout) {
                deferred.reject(new Error('Timeout cleared'));
            }
        }
    }
    #isResolved = false;
    #isRejected = false;
    #value;
    #resolve;
    #taskPromise = new Promise(resolve => {
        this.#resolve = resolve;
    });
    #timeoutId;
    #timeoutError;
    constructor(opts) {
        if (opts && opts.timeout > 0) {
            this.#timeoutError = new TimeoutError$1(opts.message);
            this.#timeoutId = setTimeout(() => {
                this.reject(this.#timeoutError);
            }, opts.timeout);
        }
    }
    #finish(value) {
        clearTimeout(this.#timeoutId);
        this.#value = value;
        this.#resolve();
    }
    resolve(value) {
        if (this.#isRejected || this.#isResolved) {
            return;
        }
        this.#isResolved = true;
        this.#finish(value);
    }
    reject(error) {
        if (this.#isRejected || this.#isResolved) {
            return;
        }
        this.#isRejected = true;
        this.#finish(error);
    }
    resolved() {
        return this.#isResolved;
    }
    finished() {
        return this.#isResolved || this.#isRejected;
    }
    value() {
        return this.#value;
    }
    #promise;
    valueOrThrow() {
        if (!this.#promise) {
            this.#promise = (async () => {
                await this.#taskPromise;
                if (this.#isRejected) {
                    throw this.#value;
                }
                return this.#value;
            })();
        }
        return this.#promise;
    }
}

/**
 * @license
 * Copyright 2024 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class Mutex {
    static Guard = class Guard {
        #mutex;
        #onRelease;
        constructor(mutex, onRelease) {
            this.#mutex = mutex;
            this.#onRelease = onRelease;
        }
        [disposeSymbol]() {
            this.#onRelease?.();
            return this.#mutex.release();
        }
    };
    #locked = false;
    #acquirers = [];
    async acquire(onRelease) {
        if (!this.#locked) {
            this.#locked = true;
            return new Mutex.Guard(this);
        }
        const deferred = Deferred.create();
        this.#acquirers.push(deferred.resolve.bind(deferred));
        await deferred.valueOrThrow();
        return new Mutex.Guard(this, onRelease);
    }
    release() {
        const resolve = this.#acquirers.shift();
        if (!resolve) {
            this.#locked = false;
            return;
        }
        resolve();
    }
}

/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class BrowserContext extends EventEmitter {
    constructor() {
        super();
    }
    #pageScreenshotMutex;
    #screenshotOperationsCount = 0;
    startScreenshot() {
        const mutex = this.#pageScreenshotMutex || new Mutex();
        this.#pageScreenshotMutex = mutex;
        this.#screenshotOperationsCount++;
        return mutex.acquire(() => {
            this.#screenshotOperationsCount--;
            if (this.#screenshotOperationsCount === 0) {
                this.#pageScreenshotMutex = undefined;
            }
        });
    }
    waitForScreenshotOperations() {
        return this.#pageScreenshotMutex?.acquire();
    }
    async waitForTarget(predicate, options = {}) {
        const { timeout: ms = 30000 } = options;
        return await firstValueFrom(merge(fromEmitterEvent(this, "targetcreated" ), fromEmitterEvent(this, "targetchanged" ), from(this.targets())).pipe(filterAsync(predicate), raceWith(timeout(ms))));
    }
    async deleteCookie(...cookies) {
        return await this.setCookie(...cookies.map(cookie => {
            return {
                ...cookie,
                expires: 1,
            };
        }));
    }
    async deleteMatchingCookies(...filters) {
        const cookies = await this.cookies();
        const cookiesToDelete = cookies.filter(cookie => {
            return filters.some(filter => {
                if (filter.name === cookie.name) {
                    if (filter.domain !== undefined && filter.domain === cookie.domain) {
                        return true;
                    }
                    if (filter.path !== undefined && filter.path === cookie.path) {
                        return true;
                    }
                    if (filter.partitionKey !== undefined &&
                        cookie.partitionKey !== undefined) {
                        if (typeof cookie.partitionKey !== 'object') {
                            throw new Error('Unexpected string partition key');
                        }
                        if (typeof filter.partitionKey === 'string') {
                            if (filter.partitionKey === cookie.partitionKey?.sourceOrigin) {
                                return true;
                            }
                        }
                        else {
                            if (filter.partitionKey.sourceOrigin ===
                                cookie.partitionKey?.sourceOrigin) {
                                return true;
                            }
                        }
                    }
                    if (filter.url !== undefined) {
                        const url = new URL(filter.url);
                        if (url.hostname === cookie.domain &&
                            url.pathname === cookie.path) {
                            return true;
                        }
                    }
                    return true;
                }
                return false;
            });
        });
        await this.deleteCookie(...cookiesToDelete);
    }
    get closed() {
        return !this.browser().browserContexts().includes(this);
    }
    get id() {
        return undefined;
    }
    [disposeSymbol]() {
        return void this.close().catch(debugError);
    }
    [asyncDisposeSymbol]() {
        return this.close();
    }
}

var CDPSessionEvent;
(function (CDPSessionEvent) {
    CDPSessionEvent.Disconnected = Symbol('CDPSession.Disconnected');
    CDPSessionEvent.Swapped = Symbol('CDPSession.Swapped');
    CDPSessionEvent.Ready = Symbol('CDPSession.Ready');
    CDPSessionEvent.SessionAttached = 'sessionattached';
    CDPSessionEvent.SessionDetached = 'sessiondetached';
})(CDPSessionEvent || (CDPSessionEvent = {}));
class CDPSession extends EventEmitter {
    constructor() {
        super();
    }
    parentSession() {
        return undefined;
    }
}

/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class Dialog {
    #type;
    #message;
    #defaultValue;
    handled = false;
    constructor(type, message, defaultValue = '') {
        this.#type = type;
        this.#message = message;
        this.#defaultValue = defaultValue;
    }
    type() {
        return this.#type;
    }
    message() {
        return this.#message;
    }
    defaultValue() {
        return this.#defaultValue;
    }
    async accept(promptText) {
        assert(!this.handled, 'Cannot accept dialog which is already handled!');
        this.handled = true;
        await this.handle({
            accept: true,
            text: promptText,
        });
    }
    async dismiss() {
        assert(!this.handled, 'Cannot dismiss dialog which is already handled!');
        this.handled = true;
        await this.handle({
            accept: false,
        });
    }
}

class AsyncIterableUtil {
    static async *map(iterable, map) {
        for await (const value of iterable) {
            yield await map(value);
        }
    }
    static async *flatMap(iterable, map) {
        for await (const value of iterable) {
            yield* map(value);
        }
    }
    static async collect(iterable) {
        const result = [];
        for await (const value of iterable) {
            result.push(value);
        }
        return result;
    }
    static async first(iterable) {
        for await (const value of iterable) {
            return value;
        }
        return;
    }
}

/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const _isElementHandle = Symbol('_isElementHandle');

/**
 * @license
 * Copyright 2022 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
function isErrorLike$1(obj) {
    return (typeof obj === 'object' && obj !== null && 'name' in obj && 'message' in obj);
}
function rewriteError$1(error, message, originalMessage) {
    error.message = message;
    error.originalMessage = originalMessage ?? error.originalMessage;
    return error;
}
function createProtocolErrorMessage(object) {
    let message = object.error.message;
    if (object.error &&
        typeof object.error === 'object' &&
        'data' in object.error) {
        message += ` ${object.error.data}`;
    }
    return message;
}

/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const createdFunctions = new Map();
const createFunction = (functionValue) => {
    let fn = createdFunctions.get(functionValue);
    if (fn) {
        return fn;
    }
    fn = new Function(`return ${functionValue}`)();
    createdFunctions.set(functionValue, fn);
    return fn;
};
function stringifyFunction(fn) {
    let value = fn.toString();
    if (value.match(/^(async )*function(\(|\s)/) ||
        value.match(/^(async )*function\s*\*\s*/)) {
        return value;
    }
    const isArrow = value.startsWith('(') ||
        value.match(/^async\s*\(/) ||
        value.match(/^(async)*\s*(?:[$_\p{ID_Start}])(?:[$\u200C\u200D\p{ID_Continue}])*\s*=>/u);
    if (isArrow) {
        return value;
    }
    let prefix = 'function ';
    if (value.startsWith('async ')) {
        prefix = `async ${prefix}`;
        value = value.substring('async '.length);
    }
    return `${prefix}${value}`;
}
const interpolateFunction = (fn, replacements) => {
    let value = stringifyFunction(fn);
    for (const [name, jsValue] of Object.entries(replacements)) {
        value = value.replace(new RegExp(`PLACEHOLDER\\(\\s*(?:'${name}'|"${name}")\\s*\\)`, 'g'),
        `(${jsValue})`);
    }
    return createFunction(value);
};

/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var __addDisposableResource$d = (undefined && undefined.__addDisposableResource) || function (env, value, async) {
    if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
        var dispose, inner;
        if (async) {
            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
            if (async) inner = dispose;
        }
        if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
        if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };
        env.stack.push({ value: value, dispose: dispose, async: async });
    }
    else if (async) {
        env.stack.push({ async: true });
    }
    return value;
};
var __disposeResources$d = (undefined && undefined.__disposeResources) || (function (SuppressedError) {
    return function (env) {
        function fail(e) {
            env.error = env.hasError ? new SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
            env.hasError = true;
        }
        var r, s = 0;
        function next() {
            while (r = env.stack.pop()) {
                try {
                    if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
                    if (r.dispose) {
                        var result = r.dispose.call(r.value);
                        if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
                    }
                    else s |= 1;
                }
                catch (e) {
                    fail(e);
                }
            }
            if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
            if (env.hasError) throw env.error;
        }
        return next();
    };
})(typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
});
const DEFAULT_BATCH_SIZE = 20;
async function* fastTransposeIteratorHandle(iterator, size) {
    const env_1 = { stack: [], error: void 0, hasError: false };
    try {
        const array = __addDisposableResource$d(env_1, await iterator.evaluateHandle(async (iterator, size) => {
            const results = [];
            while (results.length < size) {
                const result = await iterator.next();
                if (result.done) {
                    break;
                }
                results.push(result.value);
            }
            return results;
        }, size), false);
        const properties = (await array.getProperties());
        const handles = properties.values();
        const stack = __addDisposableResource$d(env_1, new DisposableStack(), false);
        stack.defer(() => {
            for (const handle_1 of handles) {
                const env_2 = { stack: [], error: void 0, hasError: false };
                try {
                    const handle = __addDisposableResource$d(env_2, handle_1, false);
                    handle[disposeSymbol]();
                }
                catch (e_2) {
                    env_2.error = e_2;
                    env_2.hasError = true;
                }
                finally {
                    __disposeResources$d(env_2);
                }
            }
        });
        yield* handles;
        return properties.size === 0;
    }
    catch (e_1) {
        env_1.error = e_1;
        env_1.hasError = true;
    }
    finally {
        __disposeResources$d(env_1);
    }
}
async function* transposeIteratorHandle(iterator) {
    let size = DEFAULT_BATCH_SIZE;
    while (!(yield* fastTransposeIteratorHandle(iterator, size))) {
        size <<= 1;
    }
}
async function* transposeIterableHandle(handle) {
    const env_3 = { stack: [], error: void 0, hasError: false };
    try {
        const generatorHandle = __addDisposableResource$d(env_3, await handle.evaluateHandle(iterable => {
            return (async function* () {
                yield* iterable;
            })();
        }), false);
        yield* transposeIteratorHandle(generatorHandle);
    }
    catch (e_3) {
        env_3.error = e_3;
        env_3.hasError = true;
    }
    finally {
        __disposeResources$d(env_3);
    }
}

/**
 * @license
 * Copyright 2022 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class LazyArg {
    static create = (get) => {
        return new LazyArg(get);
    };
    #get;
    constructor(get) {
        this.#get = get;
    }
    async get(context) {
        return await this.#get(context);
    }
}

/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var __addDisposableResource$c = (undefined && undefined.__addDisposableResource) || function (env, value, async) {
    if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
        var dispose, inner;
        if (async) {
            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
            if (async) inner = dispose;
        }
        if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
        if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };
        env.stack.push({ value: value, dispose: dispose, async: async });
    }
    else if (async) {
        env.stack.push({ async: true });
    }
    return value;
};
var __disposeResources$c = (undefined && undefined.__disposeResources) || (function (SuppressedError) {
    return function (env) {
        function fail(e) {
            env.error = env.hasError ? new SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
            env.hasError = true;
        }
        var r, s = 0;
        function next() {
            while (r = env.stack.pop()) {
                try {
                    if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
                    if (r.dispose) {
                        var result = r.dispose.call(r.value);
                        if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
                    }
                    else s |= 1;
                }
                catch (e) {
                    fail(e);
                }
            }
            if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
            if (env.hasError) throw env.error;
        }
        return next();
    };
})(typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
});
class QueryHandler {
    static querySelectorAll;
    static querySelector;
    static get _querySelector() {
        if (this.querySelector) {
            return this.querySelector;
        }
        if (!this.querySelectorAll) {
            throw new Error('Cannot create default `querySelector`.');
        }
        return (this.querySelector = interpolateFunction(async (node, selector, PuppeteerUtil) => {
            const querySelectorAll = PLACEHOLDER('querySelectorAll');
            const results = querySelectorAll(node, selector, PuppeteerUtil);
            for await (const result of results) {
                return result;
            }
            return null;
        }, {
            querySelectorAll: stringifyFunction(this.querySelectorAll),
        }));
    }
    static get _querySelectorAll() {
        if (this.querySelectorAll) {
            return this.querySelectorAll;
        }
        if (!this.querySelector) {
            throw new Error('Cannot create default `querySelectorAll`.');
        }
        return (this.querySelectorAll = interpolateFunction(async function* (node, selector, PuppeteerUtil) {
            const querySelector = PLACEHOLDER('querySelector');
            const result = await querySelector(node, selector, PuppeteerUtil);
            if (result) {
                yield result;
            }
        }, {
            querySelector: stringifyFunction(this.querySelector),
        }));
    }
    static async *queryAll(element, selector) {
        const env_1 = { stack: [], error: void 0, hasError: false };
        try {
            const handle = __addDisposableResource$c(env_1, await element.evaluateHandle(this._querySelectorAll, selector, LazyArg.create(context => {
                return context.puppeteerUtil;
            })), false);
            yield* transposeIterableHandle(handle);
        }
        catch (e_1) {
            env_1.error = e_1;
            env_1.hasError = true;
        }
        finally {
            __disposeResources$c(env_1);
        }
    }
    static async queryOne(element, selector) {
        const env_2 = { stack: [], error: void 0, hasError: false };
        try {
            const result = __addDisposableResource$c(env_2, await element.evaluateHandle(this._querySelector, selector, LazyArg.create(context => {
                return context.puppeteerUtil;
            })), false);
            if (!(_isElementHandle in result)) {
                return null;
            }
            return result.move();
        }
        catch (e_2) {
            env_2.error = e_2;
            env_2.hasError = true;
        }
        finally {
            __disposeResources$c(env_2);
        }
    }
    static async waitFor(elementOrFrame, selector, options) {
        const env_3 = { stack: [], error: void 0, hasError: false };
        try {
            let frame;
            const element = __addDisposableResource$c(env_3, await (async () => {
                if (!(_isElementHandle in elementOrFrame)) {
                    frame = elementOrFrame;
                    return;
                }
                frame = elementOrFrame.frame;
                return await frame.isolatedRealm().adoptHandle(elementOrFrame);
            })(), false);
            const { visible = false, hidden = false, timeout, signal } = options;
            const polling = visible || hidden ? "raf"  : options.polling;
            try {
                const env_4 = { stack: [], error: void 0, hasError: false };
                try {
                    signal?.throwIfAborted();
                    const handle = __addDisposableResource$c(env_4, await frame.isolatedRealm().waitForFunction(async (PuppeteerUtil, query, selector, root, visible) => {
                        const querySelector = PuppeteerUtil.createFunction(query);
                        const node = await querySelector(root ?? document, selector, PuppeteerUtil);
                        return PuppeteerUtil.checkVisibility(node, visible);
                    }, {
                        polling,
                        root: element,
                        timeout,
                        signal,
                    }, LazyArg.create(context => {
                        return context.puppeteerUtil;
                    }), stringifyFunction(this._querySelector), selector, element, visible ? true : hidden ? false : undefined), false);
                    if (signal?.aborted) {
                        throw signal.reason;
                    }
                    if (!(_isElementHandle in handle)) {
                        return null;
                    }
                    return await frame.mainRealm().transferHandle(handle);
                }
                catch (e_3) {
                    env_4.error = e_3;
                    env_4.hasError = true;
                }
                finally {
                    __disposeResources$c(env_4);
                }
            }
            catch (error) {
                if (!isErrorLike$1(error)) {
                    throw error;
                }
                if (error.name === 'AbortError') {
                    throw error;
                }
                const waitForSelectorError = new (error instanceof TimeoutError$1 ? TimeoutError$1 : Error)(`Waiting for selector \`${selector}\` failed`);
                waitForSelectorError.cause = error;
                throw waitForSelectorError;
            }
        }
        catch (e_4) {
            env_3.error = e_4;
            env_3.hasError = true;
        }
        finally {
            __disposeResources$c(env_3);
        }
    }
}

/**
 * @license
 * Copyright 2020 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const isKnownAttribute = (attribute) => {
    return ['name', 'role'].includes(attribute);
};
const ATTRIBUTE_REGEXP = /\[\s*(?<attribute>\w+)\s*=\s*(?<quote>"|')(?<value>\\.|.*?(?=\k<quote>))\k<quote>\s*\]/g;
const parseARIASelector = (selector) => {
    if (selector.length > 10_000) {
        throw new Error(`Selector ${selector} is too long`);
    }
    const queryOptions = {};
    const defaultName = selector.replace(ATTRIBUTE_REGEXP, (_, attribute, __, value) => {
        assert(isKnownAttribute(attribute), `Unknown aria attribute "${attribute}" in selector`);
        queryOptions[attribute] = value;
        return '';
    });
    if (defaultName && !queryOptions.name) {
        queryOptions.name = defaultName;
    }
    return queryOptions;
};
class ARIAQueryHandler extends QueryHandler {
    static querySelector = async (node, selector, { ariaQuerySelector }) => {
        return await ariaQuerySelector(node, selector);
    };
    static async *queryAll(element, selector) {
        const { name, role } = parseARIASelector(selector);
        yield* element.queryAXTree(name, role);
    }
    static queryOne = async (element, selector) => {
        return ((await AsyncIterableUtil.first(this.queryAll(element, selector))) ?? null);
    };
}

/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class CSSQueryHandler extends QueryHandler {
    static querySelector = (element, selector, { cssQuerySelector }) => {
        return cssQuerySelector(element, selector);
    };
    static querySelectorAll = (element, selector, { cssQuerySelectorAll }) => {
        return cssQuerySelectorAll(element, selector);
    };
}

const source = "\"use strict\";var g=Object.defineProperty;var X=Object.getOwnPropertyDescriptor;var B=Object.getOwnPropertyNames;var Y=Object.prototype.hasOwnProperty;var l=(t,e)=>{for(var r in e)g(t,r,{get:e[r],enumerable:!0})},G=(t,e,r,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let s of B(e))!Y.call(t,s)&&s!==r&&g(t,s,{get:()=>e[s],enumerable:!(o=X(e,s))||o.enumerable});return t};var J=t=>G(g({},\"__esModule\",{value:!0}),t);var pe={};l(pe,{default:()=>he});module.exports=J(pe);var N=class extends Error{constructor(e,r){super(e,r),this.name=this.constructor.name}get[Symbol.toStringTag](){return this.constructor.name}},p=class extends N{};var c=class t{static create(e){return new t(e)}static async race(e){let r=new Set;try{let o=e.map(s=>s instanceof t?(s.#s&&r.add(s),s.valueOrThrow()):s);return await Promise.race(o)}finally{for(let o of r)o.reject(new Error(\"Timeout cleared\"))}}#e=!1;#r=!1;#o;#t;#a=new Promise(e=>{this.#t=e});#s;#i;constructor(e){e&&e.timeout>0&&(this.#i=new p(e.message),this.#s=setTimeout(()=>{this.reject(this.#i)},e.timeout))}#l(e){clearTimeout(this.#s),this.#o=e,this.#t()}resolve(e){this.#r||this.#e||(this.#e=!0,this.#l(e))}reject(e){this.#r||this.#e||(this.#r=!0,this.#l(e))}resolved(){return this.#e}finished(){return this.#e||this.#r}value(){return this.#o}#n;valueOrThrow(){return this.#n||(this.#n=(async()=>{if(await this.#a,this.#r)throw this.#o;return this.#o})()),this.#n}};var L=new Map,W=t=>{let e=L.get(t);return e||(e=new Function(`return ${t}`)(),L.set(t,e),e)};var b={};l(b,{ariaQuerySelector:()=>z,ariaQuerySelectorAll:()=>x});var z=(t,e)=>globalThis.__ariaQuerySelector(t,e),x=async function*(t,e){yield*await globalThis.__ariaQuerySelectorAll(t,e)};var E={};l(E,{cssQuerySelector:()=>K,cssQuerySelectorAll:()=>Z});var K=(t,e)=>t.querySelector(e),Z=function(t,e){return t.querySelectorAll(e)};var A={};l(A,{customQuerySelectors:()=>P});var v=class{#e=new Map;register(e,r){if(!r.queryOne&&r.queryAll){let o=r.queryAll;r.queryOne=(s,i)=>{for(let n of o(s,i))return n;return null}}else if(r.queryOne&&!r.queryAll){let o=r.queryOne;r.queryAll=(s,i)=>{let n=o(s,i);return n?[n]:[]}}else if(!r.queryOne||!r.queryAll)throw new Error(\"At least one query method must be defined.\");this.#e.set(e,{querySelector:r.queryOne,querySelectorAll:r.queryAll})}unregister(e){this.#e.delete(e)}get(e){return this.#e.get(e)}clear(){this.#e.clear()}},P=new v;var R={};l(R,{pierceQuerySelector:()=>ee,pierceQuerySelectorAll:()=>te});var ee=(t,e)=>{let r=null,o=s=>{let i=document.createTreeWalker(s,NodeFilter.SHOW_ELEMENT);do{let n=i.currentNode;n.shadowRoot&&o(n.shadowRoot),!(n instanceof ShadowRoot)&&n!==s&&!r&&n.matches(e)&&(r=n)}while(!r&&i.nextNode())};return t instanceof Document&&(t=t.documentElement),o(t),r},te=(t,e)=>{let r=[],o=s=>{let i=document.createTreeWalker(s,NodeFilter.SHOW_ELEMENT);do{let n=i.currentNode;n.shadowRoot&&o(n.shadowRoot),!(n instanceof ShadowRoot)&&n!==s&&n.matches(e)&&r.push(n)}while(i.nextNode())};return t instanceof Document&&(t=t.documentElement),o(t),r};var u=(t,e)=>{if(!t)throw new Error(e)};var y=class{#e;#r;#o;#t;constructor(e,r){this.#e=e,this.#r=r}async start(){let e=this.#t=c.create(),r=await this.#e();if(r){e.resolve(r);return}this.#o=new MutationObserver(async()=>{let o=await this.#e();o&&(e.resolve(o),await this.stop())}),this.#o.observe(this.#r,{childList:!0,subtree:!0,attributes:!0})}async stop(){u(this.#t,\"Polling never started.\"),this.#t.finished()||this.#t.reject(new Error(\"Polling stopped\")),this.#o&&(this.#o.disconnect(),this.#o=void 0)}result(){return u(this.#t,\"Polling never started.\"),this.#t.valueOrThrow()}},w=class{#e;#r;constructor(e){this.#e=e}async start(){let e=this.#r=c.create(),r=await this.#e();if(r){e.resolve(r);return}let o=async()=>{if(e.finished())return;let s=await this.#e();if(!s){window.requestAnimationFrame(o);return}e.resolve(s),await this.stop()};window.requestAnimationFrame(o)}async stop(){u(this.#r,\"Polling never started.\"),this.#r.finished()||this.#r.reject(new Error(\"Polling stopped\"))}result(){return u(this.#r,\"Polling never started.\"),this.#r.valueOrThrow()}},T=class{#e;#r;#o;#t;constructor(e,r){this.#e=e,this.#r=r}async start(){let e=this.#t=c.create(),r=await this.#e();if(r){e.resolve(r);return}this.#o=setInterval(async()=>{let o=await this.#e();o&&(e.resolve(o),await this.stop())},this.#r)}async stop(){u(this.#t,\"Polling never started.\"),this.#t.finished()||this.#t.reject(new Error(\"Polling stopped\")),this.#o&&(clearInterval(this.#o),this.#o=void 0)}result(){return u(this.#t,\"Polling never started.\"),this.#t.valueOrThrow()}};var _={};l(_,{PCombinator:()=>H,pQuerySelector:()=>fe,pQuerySelectorAll:()=>$});var a=class{static async*map(e,r){for await(let o of e)yield await r(o)}static async*flatMap(e,r){for await(let o of e)yield*r(o)}static async collect(e){let r=[];for await(let o of e)r.push(o);return r}static async first(e){for await(let r of e)return r}};var C={};l(C,{textQuerySelectorAll:()=>m});var re=new Set([\"checkbox\",\"image\",\"radio\"]),oe=t=>t instanceof HTMLSelectElement||t instanceof HTMLTextAreaElement||t instanceof HTMLInputElement&&!re.has(t.type),se=new Set([\"SCRIPT\",\"STYLE\"]),f=t=>!se.has(t.nodeName)&&!document.head?.contains(t),I=new WeakMap,F=t=>{for(;t;)I.delete(t),t instanceof ShadowRoot?t=t.host:t=t.parentNode},j=new WeakSet,ne=new MutationObserver(t=>{for(let e of t)F(e.target)}),d=t=>{let e=I.get(t);if(e||(e={full:\"\",immediate:[]},!f(t)))return e;let r=\"\";if(oe(t))e.full=t.value,e.immediate.push(t.value),t.addEventListener(\"input\",o=>{F(o.target)},{once:!0,capture:!0});else{for(let o=t.firstChild;o;o=o.nextSibling){if(o.nodeType===Node.TEXT_NODE){e.full+=o.nodeValue??\"\",r+=o.nodeValue??\"\";continue}r&&e.immediate.push(r),r=\"\",o.nodeType===Node.ELEMENT_NODE&&(e.full+=d(o).full)}r&&e.immediate.push(r),t instanceof Element&&t.shadowRoot&&(e.full+=d(t.shadowRoot).full),j.has(t)||(ne.observe(t,{childList:!0,characterData:!0,subtree:!0}),j.add(t))}return I.set(t,e),e};var m=function*(t,e){let r=!1;for(let o of t.childNodes)if(o instanceof Element&&f(o)){let s;o.shadowRoot?s=m(o.shadowRoot,e):s=m(o,e);for(let i of s)yield i,r=!0}r||t instanceof Element&&f(t)&&d(t).full.includes(e)&&(yield t)};var k={};l(k,{checkVisibility:()=>le,pierce:()=>S,pierceAll:()=>O});var ie=[\"hidden\",\"collapse\"],le=(t,e)=>{if(!t)return e===!1;if(e===void 0)return t;let r=t.nodeType===Node.TEXT_NODE?t.parentElement:t,o=window.getComputedStyle(r),s=o&&!ie.includes(o.visibility)&&!ae(r);return e===s?t:!1};function ae(t){let e=t.getBoundingClientRect();return e.width===0||e.height===0}var ce=t=>\"shadowRoot\"in t&&t.shadowRoot instanceof ShadowRoot;function*S(t){ce(t)?yield t.shadowRoot:yield t}function*O(t){t=S(t).next().value,yield t;let e=[document.createTreeWalker(t,NodeFilter.SHOW_ELEMENT)];for(let r of e){let o;for(;o=r.nextNode();)o.shadowRoot&&(yield o.shadowRoot,e.push(document.createTreeWalker(o.shadowRoot,NodeFilter.SHOW_ELEMENT)))}}var D={};l(D,{xpathQuerySelectorAll:()=>q});var q=function*(t,e,r=-1){let s=(t.ownerDocument||document).evaluate(e,t,null,XPathResult.ORDERED_NODE_ITERATOR_TYPE),i=[],n;for(;(n=s.iterateNext())&&(i.push(n),!(r&&i.length===r)););for(let h=0;h<i.length;h++)n=i[h],yield n,delete i[h]};var ue=/[-\\w\\P{ASCII}*]/u,H=(r=>(r.Descendent=\">>>\",r.Child=\">>>>\",r))(H||{}),V=t=>\"querySelectorAll\"in t,Q=class{#e;#r=[];#o=void 0;elements;constructor(e,r){this.elements=[e],this.#e=r,this.#t()}async run(){if(typeof this.#o==\"string\")switch(this.#o.trimStart()){case\":scope\":this.#t();break}for(;this.#o!==void 0;this.#t()){let e=this.#o;typeof e==\"string\"?e[0]&&ue.test(e[0])?this.elements=a.flatMap(this.elements,async function*(r){V(r)&&(yield*r.querySelectorAll(e))}):this.elements=a.flatMap(this.elements,async function*(r){if(!r.parentElement){if(!V(r))return;yield*r.querySelectorAll(e);return}let o=0;for(let s of r.parentElement.children)if(++o,s===r)break;yield*r.parentElement.querySelectorAll(`:scope>:nth-child(${o})${e}`)}):this.elements=a.flatMap(this.elements,async function*(r){switch(e.name){case\"text\":yield*m(r,e.value);break;case\"xpath\":yield*q(r,e.value);break;case\"aria\":yield*x(r,e.value);break;default:let o=P.get(e.name);if(!o)throw new Error(`Unknown selector type: ${e.name}`);yield*o.querySelectorAll(r,e.value)}})}}#t(){if(this.#r.length!==0){this.#o=this.#r.shift();return}if(this.#e.length===0){this.#o=void 0;return}let e=this.#e.shift();switch(e){case\">>>>\":{this.elements=a.flatMap(this.elements,S),this.#t();break}case\">>>\":{this.elements=a.flatMap(this.elements,O),this.#t();break}default:this.#r=e,this.#t();break}}},M=class{#e=new WeakMap;calculate(e,r=[]){if(e===null)return r;e instanceof ShadowRoot&&(e=e.host);let o=this.#e.get(e);if(o)return[...o,...r];let s=0;for(let n=e.previousSibling;n;n=n.previousSibling)++s;let i=this.calculate(e.parentNode,[s]);return this.#e.set(e,i),[...i,...r]}},U=(t,e)=>{if(t.length+e.length===0)return 0;let[r=-1,...o]=t,[s=-1,...i]=e;return r===s?U(o,i):r<s?-1:1},de=async function*(t){let e=new Set;for await(let o of t)e.add(o);let r=new M;yield*[...e.values()].map(o=>[o,r.calculate(o)]).sort(([,o],[,s])=>U(o,s)).map(([o])=>o)},$=function(t,e){let r=JSON.parse(e);if(r.some(o=>{let s=0;return o.some(i=>(typeof i==\"string\"?++s:s=0,s>1))}))throw new Error(\"Multiple deep combinators found in sequence.\");return de(a.flatMap(r,o=>{let s=new Q(t,o);return s.run(),s.elements}))},fe=async function(t,e){for await(let r of $(t,e))return r;return null};var me=Object.freeze({...b,...A,...R,..._,...C,...k,...D,...E,Deferred:c,createFunction:W,createTextContent:d,IntervalPoller:T,isSuitableNodeForTextMatching:f,MutationPoller:y,RAFPoller:w}),he=me;\n";

/**
 * @license
 * Copyright 2024 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class ScriptInjector {
    #updated = false;
    #amendments = new Set();
    append(statement) {
        this.#update(() => {
            this.#amendments.add(statement);
        });
    }
    pop(statement) {
        this.#update(() => {
            this.#amendments.delete(statement);
        });
    }
    inject(inject, force = false) {
        if (this.#updated || force) {
            inject(this.#get());
        }
        this.#updated = false;
    }
    #update(callback) {
        callback();
        this.#updated = true;
    }
    #get() {
        return `(() => {
      const module = {};
      ${source}
      ${[...this.#amendments]
            .map(statement => {
            return `(${statement})(module.exports.default);`;
        })
            .join('')}
      return module.exports.default;
    })()`;
    }
}
const scriptInjector = new ScriptInjector();

/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class CustomQueryHandlerRegistry {
    #handlers = new Map();
    get(name) {
        const handler = this.#handlers.get(name);
        return handler ? handler[1] : undefined;
    }
    register(name, handler) {
        assert(!this.#handlers.has(name), `Cannot register over existing handler: ${name}`);
        assert(/^[a-zA-Z]+$/.test(name), `Custom query handler names may only contain [a-zA-Z]`);
        assert(handler.queryAll || handler.queryOne, `At least one query method must be implemented.`);
        const Handler = class extends QueryHandler {
            static querySelectorAll = interpolateFunction((node, selector, PuppeteerUtil) => {
                return PuppeteerUtil.customQuerySelectors
                    .get(PLACEHOLDER('name'))
                    .querySelectorAll(node, selector);
            }, { name: JSON.stringify(name) });
            static querySelector = interpolateFunction((node, selector, PuppeteerUtil) => {
                return PuppeteerUtil.customQuerySelectors
                    .get(PLACEHOLDER('name'))
                    .querySelector(node, selector);
            }, { name: JSON.stringify(name) });
        };
        const registerScript = interpolateFunction((PuppeteerUtil) => {
            PuppeteerUtil.customQuerySelectors.register(PLACEHOLDER('name'), {
                queryAll: PLACEHOLDER('queryAll'),
                queryOne: PLACEHOLDER('queryOne'),
            });
        }, {
            name: JSON.stringify(name),
            queryAll: handler.queryAll
                ? stringifyFunction(handler.queryAll)
                : String(undefined),
            queryOne: handler.queryOne
                ? stringifyFunction(handler.queryOne)
                : String(undefined),
        }).toString();
        this.#handlers.set(name, [registerScript, Handler]);
        scriptInjector.append(registerScript);
    }
    unregister(name) {
        const handler = this.#handlers.get(name);
        if (!handler) {
            throw new Error(`Cannot unregister unknown handler: ${name}`);
        }
        scriptInjector.pop(handler[0]);
        this.#handlers.delete(name);
    }
    names() {
        return [...this.#handlers.keys()];
    }
    clear() {
        for (const [registerScript] of this.#handlers) {
            scriptInjector.pop(registerScript);
        }
        this.#handlers.clear();
    }
}
const customQueryHandlers = new CustomQueryHandlerRegistry();

/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class PierceQueryHandler extends QueryHandler {
    static querySelector = (element, selector, { pierceQuerySelector }) => {
        return pierceQuerySelector(element, selector);
    };
    static querySelectorAll = (element, selector, { pierceQuerySelectorAll }) => {
        return pierceQuerySelectorAll(element, selector);
    };
}

/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class PQueryHandler extends QueryHandler {
    static querySelectorAll = (element, selector, { pQuerySelectorAll }) => {
        return pQuerySelectorAll(element, selector);
    };
    static querySelector = (element, selector, { pQuerySelector }) => {
        return pQuerySelector(element, selector);
    };
}

/**
MIT License
Copyright (c) 2020 Lea Verou
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
var TOKENS = {
  attribute: /\[\s*(?:(?<namespace>\*|[-\w\P{ASCII}]*)\|)?(?<name>[-\w\P{ASCII}]+)\s*(?:(?<operator>\W?=)\s*(?<value>.+?)\s*(\s(?<caseSensitive>[iIsS]))?\s*)?\]/gu,
  id: /#(?<name>[-\w\P{ASCII}]+)/gu,
  class: /\.(?<name>[-\w\P{ASCII}]+)/gu,
  comma: /\s*,\s*/g,
  combinator: /\s*[\s>+~]\s*/g,
  "pseudo-element": /::(?<name>[-\w\P{ASCII}]+)(?:\((?<argument>Â¶*)\))?/gu,
  "pseudo-class": /:(?<name>[-\w\P{ASCII}]+)(?:\((?<argument>Â¶*)\))?/gu,
  universal: /(?:(?<namespace>\*|[-\w\P{ASCII}]*)\|)?\*/gu,
  type: /(?:(?<namespace>\*|[-\w\P{ASCII}]*)\|)?(?<name>[-\w\P{ASCII}]+)/gu
};
var TRIM_TOKENS =  new Set(["combinator", "comma"]);
var getArgumentPatternByType = (type) => {
  switch (type) {
    case "pseudo-element":
    case "pseudo-class":
      return new RegExp(TOKENS[type].source.replace("(?<argument>\xB6*)", "(?<argument>.*)"), "gu");
    default:
      return TOKENS[type];
  }
};
function gobbleParens(text, offset) {
  let nesting = 0;
  let result = "";
  for (; offset < text.length; offset++) {
    const char = text[offset];
    switch (char) {
      case "(":
        ++nesting;
        break;
      case ")":
        --nesting;
        break;
    }
    result += char;
    if (nesting === 0) {
      return result;
    }
  }
  return result;
}
function tokenizeBy(text, grammar = TOKENS) {
  if (!text) {
    return [];
  }
  const tokens = [text];
  for (const [type, pattern] of Object.entries(grammar)) {
    for (let i = 0; i < tokens.length; i++) {
      const token = tokens[i];
      if (typeof token !== "string") {
        continue;
      }
      pattern.lastIndex = 0;
      const match = pattern.exec(token);
      if (!match) {
        continue;
      }
      const from = match.index - 1;
      const args = [];
      const content = match[0];
      const before = token.slice(0, from + 1);
      if (before) {
        args.push(before);
      }
      args.push({
        ...match.groups,
        type,
        content
      });
      const after = token.slice(from + content.length + 1);
      if (after) {
        args.push(after);
      }
      tokens.splice(i, 1, ...args);
    }
  }
  let offset = 0;
  for (const token of tokens) {
    switch (typeof token) {
      case "string":
        throw new Error(`Unexpected sequence ${token} found at index ${offset}`);
      case "object":
        offset += token.content.length;
        token.pos = [offset - token.content.length, offset];
        if (TRIM_TOKENS.has(token.type)) {
          token.content = token.content.trim() || " ";
        }
        break;
    }
  }
  return tokens;
}
var STRING_PATTERN = /(['"])([^\\\n]*?)\1/g;
var ESCAPE_PATTERN = /\\./g;
function tokenize(selector, grammar = TOKENS) {
  selector = selector.trim();
  if (selector === "") {
    return [];
  }
  const replacements = [];
  selector = selector.replace(ESCAPE_PATTERN, (value, offset) => {
    replacements.push({ value, offset });
    return "\uE000".repeat(value.length);
  });
  selector = selector.replace(STRING_PATTERN, (value, quote, content, offset) => {
    replacements.push({ value, offset });
    return `${quote}${"\uE001".repeat(content.length)}${quote}`;
  });
  {
    let pos = 0;
    let offset;
    while ((offset = selector.indexOf("(", pos)) > -1) {
      const value = gobbleParens(selector, offset);
      replacements.push({ value, offset });
      selector = `${selector.substring(0, offset)}(${"\xB6".repeat(value.length - 2)})${selector.substring(offset + value.length)}`;
      pos = offset + value.length;
    }
  }
  const tokens = tokenizeBy(selector, grammar);
  const changedTokens =  new Set();
  for (const replacement of replacements.reverse()) {
    for (const token of tokens) {
      const { offset, value } = replacement;
      if (!(token.pos[0] <= offset && offset + value.length <= token.pos[1])) {
        continue;
      }
      const { content } = token;
      const tokenOffset = offset - token.pos[0];
      token.content = content.slice(0, tokenOffset) + value + content.slice(tokenOffset + value.length);
      if (token.content !== content) {
        changedTokens.add(token);
      }
    }
  }
  for (const token of changedTokens) {
    const pattern = getArgumentPatternByType(token.type);
    if (!pattern) {
      throw new Error(`Unknown token type: ${token.type}`);
    }
    pattern.lastIndex = 0;
    const match = pattern.exec(token.content);
    if (!match) {
      throw new Error(`Unable to parse content for ${token.type}: ${token.content}`);
    }
    Object.assign(token, match.groups);
  }
  return tokens;
}
function stringify(listOrNode) {
  if (Array.isArray(listOrNode)) {
    return listOrNode.map((token) => token.content).join("");
  }
  switch (listOrNode.type) {
    case "list":
      return listOrNode.list.map(stringify).join(",");
    case "relative":
      return listOrNode.combinator + stringify(listOrNode.right);
    case "complex":
      return stringify(listOrNode.left) + listOrNode.combinator + stringify(listOrNode.right);
    case "compound":
      return listOrNode.list.map(stringify).join("");
    default:
      return listOrNode.content;
  }
}

/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
TOKENS['nesting'] = /&/g;
TOKENS['combinator'] = /\s*(>>>>?|[\s>+~])\s*/g;
const ESCAPE_REGEXP = /\\[\s\S]/g;
const unquote = (text) => {
    if (text.length <= 1) {
        return text;
    }
    if ((text[0] === '"' || text[0] === "'") && text.endsWith(text[0])) {
        text = text.slice(1, -1);
    }
    return text.replace(ESCAPE_REGEXP, match => {
        return match[1];
    });
};
function parsePSelectors(selector) {
    let isPureCSS = true;
    let hasAria = false;
    let hasPseudoClasses = false;
    const tokens = tokenize(selector);
    if (tokens.length === 0) {
        return [[], isPureCSS, hasPseudoClasses, false];
    }
    let compoundSelector = [];
    let complexSelector = [compoundSelector];
    const selectors = [complexSelector];
    const storage = [];
    for (const token of tokens) {
        switch (token.type) {
            case 'combinator':
                switch (token.content) {
                    case ">>>" :
                        isPureCSS = false;
                        if (storage.length) {
                            compoundSelector.push(stringify(storage));
                            storage.splice(0);
                        }
                        compoundSelector = [];
                        complexSelector.push(">>>" );
                        complexSelector.push(compoundSelector);
                        continue;
                    case ">>>>" :
                        isPureCSS = false;
                        if (storage.length) {
                            compoundSelector.push(stringify(storage));
                            storage.splice(0);
                        }
                        compoundSelector = [];
                        complexSelector.push(">>>>" );
                        complexSelector.push(compoundSelector);
                        continue;
                }
                break;
            case 'pseudo-element':
                if (!token.name.startsWith('-p-')) {
                    break;
                }
                isPureCSS = false;
                if (storage.length) {
                    compoundSelector.push(stringify(storage));
                    storage.splice(0);
                }
                const name = token.name.slice(3);
                if (name === 'aria') {
                    hasAria = true;
                }
                compoundSelector.push({
                    name,
                    value: unquote(token.argument ?? ''),
                });
                continue;
            case 'pseudo-class':
                hasPseudoClasses = true;
                break;
            case 'comma':
                if (storage.length) {
                    compoundSelector.push(stringify(storage));
                    storage.splice(0);
                }
                compoundSelector = [];
                complexSelector = [compoundSelector];
                selectors.push(complexSelector);
                continue;
        }
        storage.push(token);
    }
    if (storage.length) {
        compoundSelector.push(stringify(storage));
    }
    return [selectors, isPureCSS, hasPseudoClasses, hasAria];
}

/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class TextQueryHandler extends QueryHandler {
    static querySelectorAll = (element, selector, { textQuerySelectorAll }) => {
        return textQuerySelectorAll(element, selector);
    };
}

/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class XPathQueryHandler extends QueryHandler {
    static querySelectorAll = (element, selector, { xpathQuerySelectorAll }) => {
        return xpathQuerySelectorAll(element, selector);
    };
    static querySelector = (element, selector, { xpathQuerySelectorAll }) => {
        for (const result of xpathQuerySelectorAll(element, selector, 1)) {
            return result;
        }
        return null;
    };
}

/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const BUILTIN_QUERY_HANDLERS = {
    aria: ARIAQueryHandler,
    pierce: PierceQueryHandler,
    xpath: XPathQueryHandler,
    text: TextQueryHandler,
};
const QUERY_SEPARATORS = ['=', '/'];
function getQueryHandlerAndSelector(selector) {
    for (const handlerMap of [
        customQueryHandlers.names().map(name => {
            return [name, customQueryHandlers.get(name)];
        }),
        Object.entries(BUILTIN_QUERY_HANDLERS),
    ]) {
        for (const [name, QueryHandler] of handlerMap) {
            for (const separator of QUERY_SEPARATORS) {
                const prefix = `${name}${separator}`;
                if (selector.startsWith(prefix)) {
                    selector = selector.slice(prefix.length);
                    return {
                        updatedSelector: selector,
                        polling: name === 'aria' ? "raf"  : "mutation" ,
                        QueryHandler,
                    };
                }
            }
        }
    }
    try {
        const [pSelector, isPureCSS, hasPseudoClasses, hasAria] = parsePSelectors(selector);
        if (isPureCSS) {
            return {
                updatedSelector: selector,
                polling: hasPseudoClasses
                    ? "raf"
                    : "mutation" ,
                QueryHandler: CSSQueryHandler,
            };
        }
        return {
            updatedSelector: JSON.stringify(pSelector),
            polling: hasAria ? "raf"  : "mutation" ,
            QueryHandler: PQueryHandler,
        };
    }
    catch {
        return {
            updatedSelector: selector,
            polling: "mutation" ,
            QueryHandler: CSSQueryHandler,
        };
    }
}

/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var __addDisposableResource$b = (undefined && undefined.__addDisposableResource) || function (env, value, async) {
    if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
        var dispose, inner;
        if (async) {
            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
            if (async) inner = dispose;
        }
        if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
        if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };
        env.stack.push({ value: value, dispose: dispose, async: async });
    }
    else if (async) {
        env.stack.push({ async: true });
    }
    return value;
};
var __disposeResources$b = (undefined && undefined.__disposeResources) || (function (SuppressedError) {
    return function (env) {
        function fail(e) {
            env.error = env.hasError ? new SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
            env.hasError = true;
        }
        var r, s = 0;
        function next() {
            while (r = env.stack.pop()) {
                try {
                    if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
                    if (r.dispose) {
                        var result = r.dispose.call(r.value);
                        if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
                    }
                    else s |= 1;
                }
                catch (e) {
                    fail(e);
                }
            }
            if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
            if (env.hasError) throw env.error;
        }
        return next();
    };
})(typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
});
const instances = new WeakSet();
function moveable(Class, _) {
    let hasDispose = false;
    if (Class.prototype[disposeSymbol]) {
        const dispose = Class.prototype[disposeSymbol];
        Class.prototype[disposeSymbol] = function () {
            if (instances.has(this)) {
                instances.delete(this);
                return;
            }
            return dispose.call(this);
        };
        hasDispose = true;
    }
    if (Class.prototype[asyncDisposeSymbol]) {
        const asyncDispose = Class.prototype[asyncDisposeSymbol];
        Class.prototype[asyncDisposeSymbol] = function () {
            if (instances.has(this)) {
                instances.delete(this);
                return;
            }
            return asyncDispose.call(this);
        };
        hasDispose = true;
    }
    if (hasDispose) {
        Class.prototype.move = function () {
            instances.add(this);
            return this;
        };
    }
    return Class;
}
function throwIfDisposed(message = value => {
    return `Attempted to use disposed ${value.constructor.name}.`;
}) {
    return (target, _) => {
        return function (...args) {
            if (this.disposed) {
                throw new Error(message(this));
            }
            return target.call(this, ...args);
        };
    };
}
function invokeAtMostOnceForArguments(target, _) {
    const cache = new WeakMap();
    let cacheDepth = -1;
    return function (...args) {
        if (cacheDepth === -1) {
            cacheDepth = args.length;
        }
        if (cacheDepth !== args.length) {
            throw new Error('Memoized method was called with the wrong number of arguments');
        }
        let freshArguments = false;
        let cacheIterator = cache;
        for (const arg of args) {
            if (cacheIterator.has(arg)) {
                cacheIterator = cacheIterator.get(arg);
            }
            else {
                freshArguments = true;
                cacheIterator.set(arg, new WeakMap());
                cacheIterator = cacheIterator.get(arg);
            }
        }
        if (!freshArguments) {
            return;
        }
        return target.call(this, ...args);
    };
}
function guarded(getKey = function () {
    return this;
}) {
    return (target, _) => {
        const mutexes = new WeakMap();
        return async function (...args) {
            const env_1 = { stack: [], error: void 0, hasError: false };
            try {
                const key = getKey.call(this);
                let mutex = mutexes.get(key);
                if (!mutex) {
                    mutex = new Mutex();
                    mutexes.set(key, mutex);
                }
                const _ = __addDisposableResource$b(env_1, await mutex.acquire(), true);
                return await target.call(this, ...args);
            }
            catch (e_1) {
                env_1.error = e_1;
                env_1.hasError = true;
            }
            finally {
                const result_1 = __disposeResources$b(env_1);
                if (result_1)
                    await result_1;
            }
        };
    };
}

/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var __runInitializers$8 = (undefined && undefined.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate$8 = (undefined && undefined.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
var __addDisposableResource$a = (undefined && undefined.__addDisposableResource) || function (env, value, async) {
    if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
        var dispose, inner;
        if (async) {
            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
            if (async) inner = dispose;
        }
        if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
        if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };
        env.stack.push({ value: value, dispose: dispose, async: async });
    }
    else if (async) {
        env.stack.push({ async: true });
    }
    return value;
};
var __disposeResources$a = (undefined && undefined.__disposeResources) || (function (SuppressedError) {
    return function (env) {
        function fail(e) {
            env.error = env.hasError ? new SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
            env.hasError = true;
        }
        var r, s = 0;
        function next() {
            while (r = env.stack.pop()) {
                try {
                    if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
                    if (r.dispose) {
                        var result = r.dispose.call(r.value);
                        if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
                    }
                    else s |= 1;
                }
                catch (e) {
                    fail(e);
                }
            }
            if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
            if (env.hasError) throw env.error;
        }
        return next();
    };
})(typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
});
let JSHandle = (() => {
    let _classDecorators = [moveable];
    let _classDescriptor;
    let _classExtraInitializers = [];
    let _classThis;
    let _instanceExtraInitializers = [];
    let _getProperty_decorators;
    let _getProperties_decorators;
    (class {
        static { _classThis = this; }
        static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(null) : void 0;
            __esDecorate$8(this, null, _getProperty_decorators, { kind: "method", name: "getProperty", static: false, private: false, access: { has: obj => "getProperty" in obj, get: obj => obj.getProperty }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate$8(this, null, _getProperties_decorators, { kind: "method", name: "getProperties", static: false, private: false, access: { has: obj => "getProperties" in obj, get: obj => obj.getProperties }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate$8(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
            _classThis = _classDescriptor.value;
            if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
            __runInitializers$8(_classThis, _classExtraInitializers);
        }
        constructor() {
            __runInitializers$8(this, _instanceExtraInitializers);
        }
        async evaluate(pageFunction, ...args) {
            pageFunction = withSourcePuppeteerURLIfNone(this.evaluate.name, pageFunction);
            return await this.realm.evaluate(pageFunction, this, ...args);
        }
        async evaluateHandle(pageFunction, ...args) {
            pageFunction = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, pageFunction);
            return await this.realm.evaluateHandle(pageFunction, this, ...args);
        }
        async getProperty(propertyName) {
            return await this.evaluateHandle((object, propertyName) => {
                return object[propertyName];
            }, propertyName);
        }
        async getProperties() {
            const propertyNames = await this.evaluate(object => {
                const enumerableProperties = [];
                const descriptors = Object.getOwnPropertyDescriptors(object);
                for (const propertyName in descriptors) {
                    if (descriptors[propertyName]?.enumerable) {
                        enumerableProperties.push(propertyName);
                    }
                }
                return enumerableProperties;
            });
            const map = new Map();
            const results = await Promise.all(propertyNames.map(key => {
                return this.getProperty(key);
            }));
            for (const [key, value] of Object.entries(propertyNames)) {
                const env_1 = { stack: [], error: void 0, hasError: false };
                try {
                    const handle = __addDisposableResource$a(env_1, results[key], false);
                    if (handle) {
                        map.set(value, handle.move());
                    }
                }
                catch (e_1) {
                    env_1.error = e_1;
                    env_1.hasError = true;
                }
                finally {
                    __disposeResources$a(env_1);
                }
            }
            return map;
        }
        [(_getProperty_decorators = [throwIfDisposed()], _getProperties_decorators = [throwIfDisposed()], disposeSymbol)]() {
            return void this.dispose().catch(debugError);
        }
        [asyncDisposeSymbol]() {
            return this.dispose();
        }
    });
    return _classThis;
})();

var __addDisposableResource$9 = (undefined && undefined.__addDisposableResource) || function (env, value, async) {
    if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
        var dispose, inner;
        if (async) {
            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
            if (async) inner = dispose;
        }
        if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
        if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };
        env.stack.push({ value: value, dispose: dispose, async: async });
    }
    else if (async) {
        env.stack.push({ async: true });
    }
    return value;
};
var __disposeResources$9 = (undefined && undefined.__disposeResources) || (function (SuppressedError) {
    return function (env) {
        function fail(e) {
            env.error = env.hasError ? new SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
            env.hasError = true;
        }
        var r, s = 0;
        function next() {
            while (r = env.stack.pop()) {
                try {
                    if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
                    if (r.dispose) {
                        var result = r.dispose.call(r.value);
                        if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
                    }
                    else s |= 1;
                }
                catch (e) {
                    fail(e);
                }
            }
            if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
            if (env.hasError) throw env.error;
        }
        return next();
    };
})(typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
});
var LocatorEvent;
(function (LocatorEvent) {
    LocatorEvent["Action"] = "action";
})(LocatorEvent || (LocatorEvent = {}));
class Locator extends EventEmitter {
    static race(locators) {
        return RaceLocator.create(locators);
    }
    visibility = null;
    _timeout = 30000;
    #ensureElementIsInTheViewport = true;
    #waitForEnabled = true;
    #waitForStableBoundingBox = true;
    operators = {
        conditions: (conditions, signal) => {
            return mergeMap((handle) => {
                return merge(...conditions.map(condition => {
                    return condition(handle, signal);
                })).pipe(defaultIfEmpty(handle));
            });
        },
        retryAndRaceWithSignalAndTimer: (signal, cause) => {
            const candidates = [];
            if (signal) {
                candidates.push(fromAbortSignal(signal, cause));
            }
            candidates.push(timeout(this._timeout, cause));
            return pipe(retry({ delay: RETRY_DELAY }), raceWith(...candidates));
        },
    };
    get timeout() {
        return this._timeout;
    }
    setTimeout(timeout) {
        const locator = this._clone();
        locator._timeout = timeout;
        return locator;
    }
    setVisibility(visibility) {
        const locator = this._clone();
        locator.visibility = visibility;
        return locator;
    }
    setWaitForEnabled(value) {
        const locator = this._clone();
        locator.#waitForEnabled = value;
        return locator;
    }
    setEnsureElementIsInTheViewport(value) {
        const locator = this._clone();
        locator.#ensureElementIsInTheViewport = value;
        return locator;
    }
    setWaitForStableBoundingBox(value) {
        const locator = this._clone();
        locator.#waitForStableBoundingBox = value;
        return locator;
    }
    copyOptions(locator) {
        this._timeout = locator._timeout;
        this.visibility = locator.visibility;
        this.#waitForEnabled = locator.#waitForEnabled;
        this.#ensureElementIsInTheViewport = locator.#ensureElementIsInTheViewport;
        this.#waitForStableBoundingBox = locator.#waitForStableBoundingBox;
        return this;
    }
    #waitForEnabledIfNeeded = (handle, signal) => {
        if (!this.#waitForEnabled) {
            return EMPTY;
        }
        return from(handle.frame.waitForFunction(element => {
            if (!(element instanceof HTMLElement)) {
                return true;
            }
            const isNativeFormControl = [
                'BUTTON',
                'INPUT',
                'SELECT',
                'TEXTAREA',
                'OPTION',
                'OPTGROUP',
            ].includes(element.nodeName);
            return !isNativeFormControl || !element.hasAttribute('disabled');
        }, {
            timeout: this._timeout,
            signal,
        }, handle)).pipe(ignoreElements());
    };
    #waitForStableBoundingBoxIfNeeded = (handle) => {
        if (!this.#waitForStableBoundingBox) {
            return EMPTY;
        }
        return defer(() => {
            return from(handle.evaluate(element => {
                return new Promise(resolve => {
                    window.requestAnimationFrame(() => {
                        const rect1 = element.getBoundingClientRect();
                        window.requestAnimationFrame(() => {
                            const rect2 = element.getBoundingClientRect();
                            resolve([
                                {
                                    x: rect1.x,
                                    y: rect1.y,
                                    width: rect1.width,
                                    height: rect1.height,
                                },
                                {
                                    x: rect2.x,
                                    y: rect2.y,
                                    width: rect2.width,
                                    height: rect2.height,
                                },
                            ]);
                        });
                    });
                });
            }));
        }).pipe(first(([rect1, rect2]) => {
            return (rect1.x === rect2.x &&
                rect1.y === rect2.y &&
                rect1.width === rect2.width &&
                rect1.height === rect2.height);
        }), retry({ delay: RETRY_DELAY }), ignoreElements());
    };
    #ensureElementIsInTheViewportIfNeeded = (handle) => {
        if (!this.#ensureElementIsInTheViewport) {
            return EMPTY;
        }
        return from(handle.isIntersectingViewport({ threshold: 0 })).pipe(filter(isIntersectingViewport => {
            return !isIntersectingViewport;
        }), mergeMap(() => {
            return from(handle.scrollIntoView());
        }), mergeMap(() => {
            return defer(() => {
                return from(handle.isIntersectingViewport({ threshold: 0 }));
            }).pipe(first(identity), retry({ delay: RETRY_DELAY }), ignoreElements());
        }));
    };
    #click(options) {
        const signal = options?.signal;
        const cause = new Error('Locator.click');
        return this._wait(options).pipe(this.operators.conditions([
            this.#ensureElementIsInTheViewportIfNeeded,
            this.#waitForStableBoundingBoxIfNeeded,
            this.#waitForEnabledIfNeeded,
        ], signal), tap(() => {
            return this.emit(LocatorEvent.Action, undefined);
        }), mergeMap(handle => {
            return from(handle.click(options)).pipe(catchError(err => {
                void handle.dispose().catch(debugError);
                throw err;
            }));
        }), this.operators.retryAndRaceWithSignalAndTimer(signal, cause));
    }
    #fill(value, options) {
        const signal = options?.signal;
        const cause = new Error('Locator.fill');
        return this._wait(options).pipe(this.operators.conditions([
            this.#ensureElementIsInTheViewportIfNeeded,
            this.#waitForStableBoundingBoxIfNeeded,
            this.#waitForEnabledIfNeeded,
        ], signal), tap(() => {
            return this.emit(LocatorEvent.Action, undefined);
        }), mergeMap(handle => {
            return from(handle.evaluate(el => {
                if (el instanceof HTMLSelectElement) {
                    return 'select';
                }
                if (el instanceof HTMLTextAreaElement) {
                    return 'typeable-input';
                }
                if (el instanceof HTMLInputElement) {
                    if (new Set([
                        'textarea',
                        'text',
                        'url',
                        'tel',
                        'search',
                        'password',
                        'number',
                        'email',
                    ]).has(el.type)) {
                        return 'typeable-input';
                    }
                    else {
                        return 'other-input';
                    }
                }
                if (el.isContentEditable) {
                    return 'contenteditable';
                }
                return 'unknown';
            }))
                .pipe(mergeMap(inputType => {
                switch (inputType) {
                    case 'select':
                        return from(handle.select(value).then(noop));
                    case 'contenteditable':
                    case 'typeable-input':
                        return from(handle.evaluate((input, newValue) => {
                            const currentValue = input.isContentEditable
                                ? input.innerText
                                : input.value;
                            if (newValue.length <= currentValue.length ||
                                !newValue.startsWith(input.value)) {
                                if (input.isContentEditable) {
                                    input.innerText = '';
                                }
                                else {
                                    input.value = '';
                                }
                                return newValue;
                            }
                            const originalValue = input.isContentEditable
                                ? input.innerText
                                : input.value;
                            if (input.isContentEditable) {
                                input.innerText = '';
                                input.innerText = originalValue;
                            }
                            else {
                                input.value = '';
                                input.value = originalValue;
                            }
                            return newValue.substring(originalValue.length);
                        }, value)).pipe(mergeMap(textToType => {
                            return from(handle.type(textToType));
                        }));
                    case 'other-input':
                        return from(handle.focus()).pipe(mergeMap(() => {
                            return from(handle.evaluate((input, value) => {
                                input.value = value;
                                input.dispatchEvent(new Event('input', { bubbles: true }));
                                input.dispatchEvent(new Event('change', { bubbles: true }));
                            }, value));
                        }));
                    case 'unknown':
                        throw new Error(`Element cannot be filled out.`);
                }
            }))
                .pipe(catchError(err => {
                void handle.dispose().catch(debugError);
                throw err;
            }));
        }), this.operators.retryAndRaceWithSignalAndTimer(signal, cause));
    }
    #hover(options) {
        const signal = options?.signal;
        const cause = new Error('Locator.hover');
        return this._wait(options).pipe(this.operators.conditions([
            this.#ensureElementIsInTheViewportIfNeeded,
            this.#waitForStableBoundingBoxIfNeeded,
        ], signal), tap(() => {
            return this.emit(LocatorEvent.Action, undefined);
        }), mergeMap(handle => {
            return from(handle.hover()).pipe(catchError(err => {
                void handle.dispose().catch(debugError);
                throw err;
            }));
        }), this.operators.retryAndRaceWithSignalAndTimer(signal, cause));
    }
    #scroll(options) {
        const signal = options?.signal;
        const cause = new Error('Locator.scroll');
        return this._wait(options).pipe(this.operators.conditions([
            this.#ensureElementIsInTheViewportIfNeeded,
            this.#waitForStableBoundingBoxIfNeeded,
        ], signal), tap(() => {
            return this.emit(LocatorEvent.Action, undefined);
        }), mergeMap(handle => {
            return from(handle.evaluate((el, scrollTop, scrollLeft) => {
                if (scrollTop !== undefined) {
                    el.scrollTop = scrollTop;
                }
                if (scrollLeft !== undefined) {
                    el.scrollLeft = scrollLeft;
                }
            }, options?.scrollTop, options?.scrollLeft)).pipe(catchError(err => {
                void handle.dispose().catch(debugError);
                throw err;
            }));
        }), this.operators.retryAndRaceWithSignalAndTimer(signal, cause));
    }
    clone() {
        return this._clone();
    }
    async waitHandle(options) {
        const cause = new Error('Locator.waitHandle');
        return await firstValueFrom(this._wait(options).pipe(this.operators.retryAndRaceWithSignalAndTimer(options?.signal, cause)));
    }
    async wait(options) {
        const env_1 = { stack: [], error: void 0, hasError: false };
        try {
            const handle = __addDisposableResource$9(env_1, await this.waitHandle(options), false);
            return await handle.jsonValue();
        }
        catch (e_1) {
            env_1.error = e_1;
            env_1.hasError = true;
        }
        finally {
            __disposeResources$9(env_1);
        }
    }
    map(mapper) {
        return new MappedLocator(this._clone(), handle => {
            return handle.evaluateHandle(mapper);
        });
    }
    filter(predicate) {
        return new FilteredLocator(this._clone(), async (handle, signal) => {
            await handle.frame.waitForFunction(predicate, { signal, timeout: this._timeout }, handle);
            return true;
        });
    }
    filterHandle(predicate) {
        return new FilteredLocator(this._clone(), predicate);
    }
    mapHandle(mapper) {
        return new MappedLocator(this._clone(), mapper);
    }
    click(options) {
        return firstValueFrom(this.#click(options));
    }
    fill(value, options) {
        return firstValueFrom(this.#fill(value, options));
    }
    hover(options) {
        return firstValueFrom(this.#hover(options));
    }
    scroll(options) {
        return firstValueFrom(this.#scroll(options));
    }
}
class FunctionLocator extends Locator {
    static create(pageOrFrame, func) {
        return new FunctionLocator(pageOrFrame, func).setTimeout('getDefaultTimeout' in pageOrFrame
            ? pageOrFrame.getDefaultTimeout()
            : pageOrFrame.page().getDefaultTimeout());
    }
    #pageOrFrame;
    #func;
    constructor(pageOrFrame, func) {
        super();
        this.#pageOrFrame = pageOrFrame;
        this.#func = func;
    }
    _clone() {
        return new FunctionLocator(this.#pageOrFrame, this.#func);
    }
    _wait(options) {
        const signal = options?.signal;
        return defer(() => {
            return from(this.#pageOrFrame.waitForFunction(this.#func, {
                timeout: this.timeout,
                signal,
            }));
        }).pipe(throwIfEmpty());
    }
}
class DelegatedLocator extends Locator {
    #delegate;
    constructor(delegate) {
        super();
        this.#delegate = delegate;
        this.copyOptions(this.#delegate);
    }
    get delegate() {
        return this.#delegate;
    }
    setTimeout(timeout) {
        const locator = super.setTimeout(timeout);
        locator.#delegate = this.#delegate.setTimeout(timeout);
        return locator;
    }
    setVisibility(visibility) {
        const locator = super.setVisibility(visibility);
        locator.#delegate = locator.#delegate.setVisibility(visibility);
        return locator;
    }
    setWaitForEnabled(value) {
        const locator = super.setWaitForEnabled(value);
        locator.#delegate = this.#delegate.setWaitForEnabled(value);
        return locator;
    }
    setEnsureElementIsInTheViewport(value) {
        const locator = super.setEnsureElementIsInTheViewport(value);
        locator.#delegate = this.#delegate.setEnsureElementIsInTheViewport(value);
        return locator;
    }
    setWaitForStableBoundingBox(value) {
        const locator = super.setWaitForStableBoundingBox(value);
        locator.#delegate = this.#delegate.setWaitForStableBoundingBox(value);
        return locator;
    }
}
class FilteredLocator extends DelegatedLocator {
    #predicate;
    constructor(base, predicate) {
        super(base);
        this.#predicate = predicate;
    }
    _clone() {
        return new FilteredLocator(this.delegate.clone(), this.#predicate).copyOptions(this);
    }
    _wait(options) {
        return this.delegate._wait(options).pipe(mergeMap(handle => {
            return from(Promise.resolve(this.#predicate(handle, options?.signal))).pipe(filter(value => {
                return value;
            }), map(() => {
                return handle;
            }));
        }), throwIfEmpty());
    }
}
class MappedLocator extends DelegatedLocator {
    #mapper;
    constructor(base, mapper) {
        super(base);
        this.#mapper = mapper;
    }
    _clone() {
        return new MappedLocator(this.delegate.clone(), this.#mapper).copyOptions(this);
    }
    _wait(options) {
        return this.delegate._wait(options).pipe(mergeMap(handle => {
            return from(Promise.resolve(this.#mapper(handle, options?.signal)));
        }));
    }
}
class NodeLocator extends Locator {
    static create(pageOrFrame, selector) {
        return new NodeLocator(pageOrFrame, selector).setTimeout('getDefaultTimeout' in pageOrFrame
            ? pageOrFrame.getDefaultTimeout()
            : pageOrFrame.page().getDefaultTimeout());
    }
    static createFromHandle(pageOrFrame, handle) {
        return new NodeLocator(pageOrFrame, handle).setTimeout('getDefaultTimeout' in pageOrFrame
            ? pageOrFrame.getDefaultTimeout()
            : pageOrFrame.page().getDefaultTimeout());
    }
    #pageOrFrame;
    #selectorOrHandle;
    constructor(pageOrFrame, selectorOrHandle) {
        super();
        this.#pageOrFrame = pageOrFrame;
        this.#selectorOrHandle = selectorOrHandle;
    }
    #waitForVisibilityIfNeeded = (handle) => {
        if (!this.visibility) {
            return EMPTY;
        }
        return (() => {
            switch (this.visibility) {
                case 'hidden':
                    return defer(() => {
                        return from(handle.isHidden());
                    });
                case 'visible':
                    return defer(() => {
                        return from(handle.isVisible());
                    });
            }
        })().pipe(first(identity), retry({ delay: RETRY_DELAY }), ignoreElements());
    };
    _clone() {
        return new NodeLocator(this.#pageOrFrame,
        this.#selectorOrHandle).copyOptions(this);
    }
    _wait(options) {
        const signal = options?.signal;
        return defer(() => {
            if (typeof this.#selectorOrHandle === 'string') {
                return from(this.#pageOrFrame.waitForSelector(this.#selectorOrHandle, {
                    visible: false,
                    timeout: this._timeout,
                    signal,
                }));
            }
            else {
                return of(this.#selectorOrHandle);
            }
        }).pipe(filter((value) => {
            return value !== null;
        }), throwIfEmpty(), this.operators.conditions([this.#waitForVisibilityIfNeeded], signal));
    }
}
function checkLocatorArray(locators) {
    for (const locator of locators) {
        if (!(locator instanceof Locator)) {
            throw new Error('Unknown locator for race candidate');
        }
    }
    return locators;
}
class RaceLocator extends Locator {
    static create(locators) {
        const array = checkLocatorArray(locators);
        return new RaceLocator(array);
    }
    #locators;
    constructor(locators) {
        super();
        this.#locators = locators;
    }
    _clone() {
        return new RaceLocator(this.#locators.map(locator => {
            return locator.clone();
        })).copyOptions(this);
    }
    _wait(options) {
        return race(...this.#locators.map(locator => {
            return locator._wait(options);
        }));
    }
}
const RETRY_DELAY = 100;

/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var __runInitializers$7 = (undefined && undefined.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate$7 = (undefined && undefined.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
var __addDisposableResource$8 = (undefined && undefined.__addDisposableResource) || function (env, value, async) {
    if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
        var dispose, inner;
        if (async) {
            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
            if (async) inner = dispose;
        }
        if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
        if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };
        env.stack.push({ value: value, dispose: dispose, async: async });
    }
    else if (async) {
        env.stack.push({ async: true });
    }
    return value;
};
var __disposeResources$8 = (undefined && undefined.__disposeResources) || (function (SuppressedError) {
    return function (env) {
        function fail(e) {
            env.error = env.hasError ? new SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
            env.hasError = true;
        }
        var r, s = 0;
        function next() {
            while (r = env.stack.pop()) {
                try {
                    if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
                    if (r.dispose) {
                        var result = r.dispose.call(r.value);
                        if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
                    }
                    else s |= 1;
                }
                catch (e) {
                    fail(e);
                }
            }
            if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
            if (env.hasError) throw env.error;
        }
        return next();
    };
})(typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
});
var __setFunctionName$3 = (undefined && undefined.__setFunctionName) || function (f, name, prefix) {
    if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
    return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
};
function bindIsolatedHandle(target, _) {
    return async function (...args) {
        if (this.realm === this.frame.isolatedRealm()) {
            return await target.call(this, ...args);
        }
        let adoptedThis;
        if (this['isolatedHandle']) {
            adoptedThis = this['isolatedHandle'];
        }
        else {
            this['isolatedHandle'] = adoptedThis = await this.frame
                .isolatedRealm()
                .adoptHandle(this);
        }
        const result = await target.call(adoptedThis, ...args);
        if (result === adoptedThis) {
            return this;
        }
        if (result instanceof JSHandle) {
            return await this.realm.transferHandle(result);
        }
        if (Array.isArray(result)) {
            await Promise.all(result.map(async (item, index, result) => {
                if (item instanceof JSHandle) {
                    result[index] = await this.realm.transferHandle(item);
                }
            }));
        }
        if (result instanceof Map) {
            await Promise.all([...result.entries()].map(async ([key, value]) => {
                if (value instanceof JSHandle) {
                    result.set(key, await this.realm.transferHandle(value));
                }
            }));
        }
        return result;
    };
}
let ElementHandle = (() => {
    let _classSuper = JSHandle;
    let _instanceExtraInitializers = [];
    let _getProperty_decorators;
    let _getProperties_decorators;
    let _jsonValue_decorators;
    let _$_decorators;
    let _$$_decorators;
    let _private_$$_decorators;
    let _private_$$_descriptor;
    let _waitForSelector_decorators;
    let _isVisible_decorators;
    let _isHidden_decorators;
    let _toElement_decorators;
    let _clickablePoint_decorators;
    let _hover_decorators;
    let _click_decorators;
    let _drag_decorators;
    let _dragEnter_decorators;
    let _dragOver_decorators;
    let _drop_decorators;
    let _dragAndDrop_decorators;
    let _select_decorators;
    let _tap_decorators;
    let _touchStart_decorators;
    let _touchMove_decorators;
    let _touchEnd_decorators;
    let _focus_decorators;
    let _type_decorators;
    let _press_decorators;
    let _boundingBox_decorators;
    let _boxModel_decorators;
    let _screenshot_decorators;
    let _isIntersectingViewport_decorators;
    let _scrollIntoView_decorators;
    let _asLocator_decorators;
    return class ElementHandle extends _classSuper {
        static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
            _getProperty_decorators = [throwIfDisposed(), bindIsolatedHandle];
            _getProperties_decorators = [throwIfDisposed(), bindIsolatedHandle];
            _jsonValue_decorators = [throwIfDisposed(), bindIsolatedHandle];
            _$_decorators = [throwIfDisposed(), bindIsolatedHandle];
            _$$_decorators = [throwIfDisposed()];
            _private_$$_decorators = [bindIsolatedHandle];
            _waitForSelector_decorators = [throwIfDisposed(), bindIsolatedHandle];
            _isVisible_decorators = [throwIfDisposed(), bindIsolatedHandle];
            _isHidden_decorators = [throwIfDisposed(), bindIsolatedHandle];
            _toElement_decorators = [throwIfDisposed(), bindIsolatedHandle];
            _clickablePoint_decorators = [throwIfDisposed(), bindIsolatedHandle];
            _hover_decorators = [throwIfDisposed(), bindIsolatedHandle];
            _click_decorators = [throwIfDisposed(), bindIsolatedHandle];
            _drag_decorators = [throwIfDisposed(), bindIsolatedHandle];
            _dragEnter_decorators = [throwIfDisposed(), bindIsolatedHandle];
            _dragOver_decorators = [throwIfDisposed(), bindIsolatedHandle];
            _drop_decorators = [throwIfDisposed(), bindIsolatedHandle];
            _dragAndDrop_decorators = [throwIfDisposed(), bindIsolatedHandle];
            _select_decorators = [throwIfDisposed(), bindIsolatedHandle];
            _tap_decorators = [throwIfDisposed(), bindIsolatedHandle];
            _touchStart_decorators = [throwIfDisposed(), bindIsolatedHandle];
            _touchMove_decorators = [throwIfDisposed(), bindIsolatedHandle];
            _touchEnd_decorators = [throwIfDisposed(), bindIsolatedHandle];
            _focus_decorators = [throwIfDisposed(), bindIsolatedHandle];
            _type_decorators = [throwIfDisposed(), bindIsolatedHandle];
            _press_decorators = [throwIfDisposed(), bindIsolatedHandle];
            _boundingBox_decorators = [throwIfDisposed(), bindIsolatedHandle];
            _boxModel_decorators = [throwIfDisposed(), bindIsolatedHandle];
            _screenshot_decorators = [throwIfDisposed(), bindIsolatedHandle];
            _isIntersectingViewport_decorators = [throwIfDisposed(), bindIsolatedHandle];
            _scrollIntoView_decorators = [throwIfDisposed(), bindIsolatedHandle];
            _asLocator_decorators = [throwIfDisposed()];
            __esDecorate$7(this, null, _getProperty_decorators, { kind: "method", name: "getProperty", static: false, private: false, access: { has: obj => "getProperty" in obj, get: obj => obj.getProperty }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate$7(this, null, _getProperties_decorators, { kind: "method", name: "getProperties", static: false, private: false, access: { has: obj => "getProperties" in obj, get: obj => obj.getProperties }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate$7(this, null, _jsonValue_decorators, { kind: "method", name: "jsonValue", static: false, private: false, access: { has: obj => "jsonValue" in obj, get: obj => obj.jsonValue }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate$7(this, null, _$_decorators, { kind: "method", name: "$", static: false, private: false, access: { has: obj => "$" in obj, get: obj => obj.$ }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate$7(this, null, _$$_decorators, { kind: "method", name: "$$", static: false, private: false, access: { has: obj => "$$" in obj, get: obj => obj.$$ }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate$7(this, _private_$$_descriptor = { value: __setFunctionName$3(async function (selector) {
                    return await this.#$$impl(selector);
                }, "#$$") }, _private_$$_decorators, { kind: "method", name: "#$$", static: false, private: true, access: { has: obj => #$$ in obj, get: obj => obj.#$$ }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate$7(this, null, _waitForSelector_decorators, { kind: "method", name: "waitForSelector", static: false, private: false, access: { has: obj => "waitForSelector" in obj, get: obj => obj.waitForSelector }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate$7(this, null, _isVisible_decorators, { kind: "method", name: "isVisible", static: false, private: false, access: { has: obj => "isVisible" in obj, get: obj => obj.isVisible }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate$7(this, null, _isHidden_decorators, { kind: "method", name: "isHidden", static: false, private: false, access: { has: obj => "isHidden" in obj, get: obj => obj.isHidden }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate$7(this, null, _toElement_decorators, { kind: "method", name: "toElement", static: false, private: false, access: { has: obj => "toElement" in obj, get: obj => obj.toElement }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate$7(this, null, _clickablePoint_decorators, { kind: "method", name: "clickablePoint", static: false, private: false, access: { has: obj => "clickablePoint" in obj, get: obj => obj.clickablePoint }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate$7(this, null, _hover_decorators, { kind: "method", name: "hover", static: false, private: false, access: { has: obj => "hover" in obj, get: obj => obj.hover }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate$7(this, null, _click_decorators, { kind: "method", name: "click", static: false, private: false, access: { has: obj => "click" in obj, get: obj => obj.click }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate$7(this, null, _drag_decorators, { kind: "method", name: "drag", static: false, private: false, access: { has: obj => "drag" in obj, get: obj => obj.drag }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate$7(this, null, _dragEnter_decorators, { kind: "method", name: "dragEnter", static: false, private: false, access: { has: obj => "dragEnter" in obj, get: obj => obj.dragEnter }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate$7(this, null, _dragOver_decorators, { kind: "method", name: "dragOver", static: false, private: false, access: { has: obj => "dragOver" in obj, get: obj => obj.dragOver }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate$7(this, null, _drop_decorators, { kind: "method", name: "drop", static: false, private: false, access: { has: obj => "drop" in obj, get: obj => obj.drop }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate$7(this, null, _dragAndDrop_decorators, { kind: "method", name: "dragAndDrop", static: false, private: false, access: { has: obj => "dragAndDrop" in obj, get: obj => obj.dragAndDrop }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate$7(this, null, _select_decorators, { kind: "method", name: "select", static: false, private: false, access: { has: obj => "select" in obj, get: obj => obj.select }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate$7(this, null, _tap_decorators, { kind: "method", name: "tap", static: false, private: false, access: { has: obj => "tap" in obj, get: obj => obj.tap }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate$7(this, null, _touchStart_decorators, { kind: "method", name: "touchStart", static: false, private: false, access: { has: obj => "touchStart" in obj, get: obj => obj.touchStart }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate$7(this, null, _touchMove_decorators, { kind: "method", name: "touchMove", static: false, private: false, access: { has: obj => "touchMove" in obj, get: obj => obj.touchMove }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate$7(this, null, _touchEnd_decorators, { kind: "method", name: "touchEnd", static: false, private: false, access: { has: obj => "touchEnd" in obj, get: obj => obj.touchEnd }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate$7(this, null, _focus_decorators, { kind: "method", name: "focus", static: false, private: false, access: { has: obj => "focus" in obj, get: obj => obj.focus }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate$7(this, null, _type_decorators, { kind: "method", name: "type", static: false, private: false, access: { has: obj => "type" in obj, get: obj => obj.type }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate$7(this, null, _press_decorators, { kind: "method", name: "press", static: false, private: false, access: { has: obj => "press" in obj, get: obj => obj.press }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate$7(this, null, _boundingBox_decorators, { kind: "method", name: "boundingBox", static: false, private: false, access: { has: obj => "boundingBox" in obj, get: obj => obj.boundingBox }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate$7(this, null, _boxModel_decorators, { kind: "method", name: "boxModel", static: false, private: false, access: { has: obj => "boxModel" in obj, get: obj => obj.boxModel }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate$7(this, null, _screenshot_decorators, { kind: "method", name: "screenshot", static: false, private: false, access: { has: obj => "screenshot" in obj, get: obj => obj.screenshot }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate$7(this, null, _isIntersectingViewport_decorators, { kind: "method", name: "isIntersectingViewport", static: false, private: false, access: { has: obj => "isIntersectingViewport" in obj, get: obj => obj.isIntersectingViewport }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate$7(this, null, _scrollIntoView_decorators, { kind: "method", name: "scrollIntoView", static: false, private: false, access: { has: obj => "scrollIntoView" in obj, get: obj => obj.scrollIntoView }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate$7(this, null, _asLocator_decorators, { kind: "method", name: "asLocator", static: false, private: false, access: { has: obj => "asLocator" in obj, get: obj => obj.asLocator }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        isolatedHandle = __runInitializers$7(this, _instanceExtraInitializers);
        handle;
        constructor(handle) {
            super();
            this.handle = handle;
            this[_isElementHandle] = true;
        }
        get id() {
            return this.handle.id;
        }
        get disposed() {
            return this.handle.disposed;
        }
        async getProperty(propertyName) {
            return await this.handle.getProperty(propertyName);
        }
        async getProperties() {
            return await this.handle.getProperties();
        }
        async evaluate(pageFunction, ...args) {
            pageFunction = withSourcePuppeteerURLIfNone(this.evaluate.name, pageFunction);
            return await this.handle.evaluate(pageFunction, ...args);
        }
        async evaluateHandle(pageFunction, ...args) {
            pageFunction = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, pageFunction);
            return await this.handle.evaluateHandle(pageFunction, ...args);
        }
        async jsonValue() {
            return await this.handle.jsonValue();
        }
        toString() {
            return this.handle.toString();
        }
        remoteObject() {
            return this.handle.remoteObject();
        }
        async dispose() {
            await Promise.all([this.handle.dispose(), this.isolatedHandle?.dispose()]);
        }
        asElement() {
            return this;
        }
        async $(selector) {
            const { updatedSelector, QueryHandler } = getQueryHandlerAndSelector(selector);
            return (await QueryHandler.queryOne(this, updatedSelector));
        }
        async $$(selector, options) {
            if (options?.isolate === false) {
                return await this.#$$impl(selector);
            }
            return await this.#$$(selector);
        }
        get #$$() { return _private_$$_descriptor.value; }
        async #$$impl(selector) {
            const { updatedSelector, QueryHandler } = getQueryHandlerAndSelector(selector);
            return await AsyncIterableUtil.collect(QueryHandler.queryAll(this, updatedSelector));
        }
        async $eval(selector, pageFunction, ...args) {
            const env_1 = { stack: [], error: void 0, hasError: false };
            try {
                pageFunction = withSourcePuppeteerURLIfNone(this.$eval.name, pageFunction);
                const elementHandle = __addDisposableResource$8(env_1, await this.$(selector), false);
                if (!elementHandle) {
                    throw new Error(`Error: failed to find element matching selector "${selector}"`);
                }
                return await elementHandle.evaluate(pageFunction, ...args);
            }
            catch (e_1) {
                env_1.error = e_1;
                env_1.hasError = true;
            }
            finally {
                __disposeResources$8(env_1);
            }
        }
        async $$eval(selector, pageFunction, ...args) {
            const env_2 = { stack: [], error: void 0, hasError: false };
            try {
                pageFunction = withSourcePuppeteerURLIfNone(this.$$eval.name, pageFunction);
                const results = await this.$$(selector);
                const elements = __addDisposableResource$8(env_2, await this.evaluateHandle((_, ...elements) => {
                    return elements;
                }, ...results), false);
                const [result] = await Promise.all([
                    elements.evaluate(pageFunction, ...args),
                    ...results.map(results => {
                        return results.dispose();
                    }),
                ]);
                return result;
            }
            catch (e_2) {
                env_2.error = e_2;
                env_2.hasError = true;
            }
            finally {
                __disposeResources$8(env_2);
            }
        }
        async waitForSelector(selector, options = {}) {
            const { updatedSelector, QueryHandler, polling } = getQueryHandlerAndSelector(selector);
            return (await QueryHandler.waitFor(this, updatedSelector, {
                polling,
                ...options,
            }));
        }
        async #checkVisibility(visibility) {
            return await this.evaluate(async (element, PuppeteerUtil, visibility) => {
                return Boolean(PuppeteerUtil.checkVisibility(element, visibility));
            }, LazyArg.create(context => {
                return context.puppeteerUtil;
            }), visibility);
        }
        async isVisible() {
            return await this.#checkVisibility(true);
        }
        async isHidden() {
            return await this.#checkVisibility(false);
        }
        async toElement(tagName) {
            const isMatchingTagName = await this.evaluate((node, tagName) => {
                return node.nodeName === tagName.toUpperCase();
            }, tagName);
            if (!isMatchingTagName) {
                throw new Error(`Element is not a(n) \`${tagName}\` element`);
            }
            return this;
        }
        async clickablePoint(offset) {
            const box = await this.#clickableBox();
            if (!box) {
                throw new Error('Node is either not clickable or not an Element');
            }
            if (offset !== undefined) {
                return {
                    x: box.x + offset.x,
                    y: box.y + offset.y,
                };
            }
            return {
                x: box.x + box.width / 2,
                y: box.y + box.height / 2,
            };
        }
        async hover() {
            await this.scrollIntoViewIfNeeded();
            const { x, y } = await this.clickablePoint();
            await this.frame.page().mouse.move(x, y);
        }
        async click(options = {}) {
            await this.scrollIntoViewIfNeeded();
            const { x, y } = await this.clickablePoint(options.offset);
            try {
                await this.frame.page().mouse.click(x, y, options);
            }
            finally {
                if (options.debugHighlight) {
                    await this.frame.page().evaluate((x, y) => {
                        const highlight = document.createElement('div');
                        highlight.innerHTML = `<style>
        @scope {
          :scope {
              position: fixed;
              left: ${x}px;
              top: ${y}px;
              width: 10px;
              height: 10px;
              border-radius: 50%;
              animation: colorChange 10s 1 normal;
              animation-fill-mode: forwards;
          }

          @keyframes colorChange {
              from {
                  background-color: red;
              }
              to {
                  background-color: #FADADD00;
              }
          }
        }
      </style>`;
                        highlight.addEventListener('animationend', () => {
                            highlight.remove();
                        }, { once: true });
                        document.body.append(highlight);
                    }, x, y);
                }
            }
        }
        async drag(target) {
            await this.scrollIntoViewIfNeeded();
            const page = this.frame.page();
            if (page.isDragInterceptionEnabled()) {
                const source = await this.clickablePoint();
                if (target instanceof ElementHandle) {
                    target = await target.clickablePoint();
                }
                return await page.mouse.drag(source, target);
            }
            try {
                if (!page._isDragging) {
                    page._isDragging = true;
                    await this.hover();
                    await page.mouse.down();
                }
                if (target instanceof ElementHandle) {
                    await target.hover();
                }
                else {
                    await page.mouse.move(target.x, target.y);
                }
            }
            catch (error) {
                page._isDragging = false;
                throw error;
            }
        }
        async dragEnter(data = { items: [], dragOperationsMask: 1 }) {
            const page = this.frame.page();
            await this.scrollIntoViewIfNeeded();
            const target = await this.clickablePoint();
            await page.mouse.dragEnter(target, data);
        }
        async dragOver(data = { items: [], dragOperationsMask: 1 }) {
            const page = this.frame.page();
            await this.scrollIntoViewIfNeeded();
            const target = await this.clickablePoint();
            await page.mouse.dragOver(target, data);
        }
        async drop(dataOrElement = {
            items: [],
            dragOperationsMask: 1,
        }) {
            const page = this.frame.page();
            if ('items' in dataOrElement) {
                await this.scrollIntoViewIfNeeded();
                const destination = await this.clickablePoint();
                await page.mouse.drop(destination, dataOrElement);
            }
            else {
                await dataOrElement.drag(this);
                page._isDragging = false;
                await page.mouse.up();
            }
        }
        async dragAndDrop(target, options) {
            const page = this.frame.page();
            assert(page.isDragInterceptionEnabled(), 'Drag Interception is not enabled!');
            await this.scrollIntoViewIfNeeded();
            const startPoint = await this.clickablePoint();
            const targetPoint = await target.clickablePoint();
            await page.mouse.dragAndDrop(startPoint, targetPoint, options);
        }
        async select(...values) {
            for (const value of values) {
                assert(isString(value), 'Values must be strings. Found value "' +
                    value +
                    '" of type "' +
                    typeof value +
                    '"');
            }
            return await this.evaluate((element, vals) => {
                const values = new Set(vals);
                if (!(element instanceof HTMLSelectElement)) {
                    throw new Error('Element is not a <select> element.');
                }
                const selectedValues = new Set();
                if (!element.multiple) {
                    for (const option of element.options) {
                        option.selected = false;
                    }
                    for (const option of element.options) {
                        if (values.has(option.value)) {
                            option.selected = true;
                            selectedValues.add(option.value);
                            break;
                        }
                    }
                }
                else {
                    for (const option of element.options) {
                        option.selected = values.has(option.value);
                        if (option.selected) {
                            selectedValues.add(option.value);
                        }
                    }
                }
                element.dispatchEvent(new Event('input', { bubbles: true }));
                element.dispatchEvent(new Event('change', { bubbles: true }));
                return [...selectedValues.values()];
            }, values);
        }
        async tap() {
            await this.scrollIntoViewIfNeeded();
            const { x, y } = await this.clickablePoint();
            await this.frame.page().touchscreen.tap(x, y);
        }
        async touchStart() {
            await this.scrollIntoViewIfNeeded();
            const { x, y } = await this.clickablePoint();
            return await this.frame.page().touchscreen.touchStart(x, y);
        }
        async touchMove(touch) {
            await this.scrollIntoViewIfNeeded();
            const { x, y } = await this.clickablePoint();
            if (touch) {
                return await touch.move(x, y);
            }
            await this.frame.page().touchscreen.touchMove(x, y);
        }
        async touchEnd() {
            await this.scrollIntoViewIfNeeded();
            await this.frame.page().touchscreen.touchEnd();
        }
        async focus() {
            await this.evaluate(element => {
                if (!(element instanceof HTMLElement)) {
                    throw new Error('Cannot focus non-HTMLElement');
                }
                return element.focus();
            });
        }
        async type(text, options) {
            await this.focus();
            await this.frame.page().keyboard.type(text, options);
        }
        async press(key, options) {
            await this.focus();
            await this.frame.page().keyboard.press(key, options);
        }
        async #clickableBox() {
            const boxes = await this.evaluate(element => {
                if (!(element instanceof Element)) {
                    return null;
                }
                return [...element.getClientRects()].map(rect => {
                    return { x: rect.x, y: rect.y, width: rect.width, height: rect.height };
                });
            });
            if (!boxes?.length) {
                return null;
            }
            await this.#intersectBoundingBoxesWithFrame(boxes);
            let frame = this.frame;
            let parentFrame;
            while ((parentFrame = frame?.parentFrame())) {
                const env_3 = { stack: [], error: void 0, hasError: false };
                try {
                    const handle = __addDisposableResource$8(env_3, await frame.frameElement(), false);
                    if (!handle) {
                        throw new Error('Unsupported frame type');
                    }
                    const parentBox = await handle.evaluate(element => {
                        if (element.getClientRects().length === 0) {
                            return null;
                        }
                        const rect = element.getBoundingClientRect();
                        const style = window.getComputedStyle(element);
                        return {
                            left: rect.left +
                                parseInt(style.paddingLeft, 10) +
                                parseInt(style.borderLeftWidth, 10),
                            top: rect.top +
                                parseInt(style.paddingTop, 10) +
                                parseInt(style.borderTopWidth, 10),
                        };
                    });
                    if (!parentBox) {
                        return null;
                    }
                    for (const box of boxes) {
                        box.x += parentBox.left;
                        box.y += parentBox.top;
                    }
                    await handle.#intersectBoundingBoxesWithFrame(boxes);
                    frame = parentFrame;
                }
                catch (e_3) {
                    env_3.error = e_3;
                    env_3.hasError = true;
                }
                finally {
                    __disposeResources$8(env_3);
                }
            }
            const box = boxes.find(box => {
                return box.width >= 1 && box.height >= 1;
            });
            if (!box) {
                return null;
            }
            return {
                x: box.x,
                y: box.y,
                height: box.height,
                width: box.width,
            };
        }
        async #intersectBoundingBoxesWithFrame(boxes) {
            const { documentWidth, documentHeight } = await this.frame
                .isolatedRealm()
                .evaluate(() => {
                return {
                    documentWidth: document.documentElement.clientWidth,
                    documentHeight: document.documentElement.clientHeight,
                };
            });
            for (const box of boxes) {
                intersectBoundingBox(box, documentWidth, documentHeight);
            }
        }
        async boundingBox() {
            const box = await this.evaluate(element => {
                if (!(element instanceof Element)) {
                    return null;
                }
                if (element.getClientRects().length === 0) {
                    return null;
                }
                const rect = element.getBoundingClientRect();
                return { x: rect.x, y: rect.y, width: rect.width, height: rect.height };
            });
            if (!box) {
                return null;
            }
            const offset = await this.#getTopLeftCornerOfFrame();
            if (!offset) {
                return null;
            }
            return {
                x: box.x + offset.x,
                y: box.y + offset.y,
                height: box.height,
                width: box.width,
            };
        }
        async boxModel() {
            const model = await this.evaluate(element => {
                if (!(element instanceof Element)) {
                    return null;
                }
                if (element.getClientRects().length === 0) {
                    return null;
                }
                const rect = element.getBoundingClientRect();
                const style = window.getComputedStyle(element);
                const offsets = {
                    padding: {
                        left: parseInt(style.paddingLeft, 10),
                        top: parseInt(style.paddingTop, 10),
                        right: parseInt(style.paddingRight, 10),
                        bottom: parseInt(style.paddingBottom, 10),
                    },
                    margin: {
                        left: -parseInt(style.marginLeft, 10),
                        top: -parseInt(style.marginTop, 10),
                        right: -parseInt(style.marginRight, 10),
                        bottom: -parseInt(style.marginBottom, 10),
                    },
                    border: {
                        left: parseInt(style.borderLeft, 10),
                        top: parseInt(style.borderTop, 10),
                        right: parseInt(style.borderRight, 10),
                        bottom: parseInt(style.borderBottom, 10),
                    },
                };
                const border = [
                    { x: rect.left, y: rect.top },
                    { x: rect.left + rect.width, y: rect.top },
                    { x: rect.left + rect.width, y: rect.top + rect.height },
                    { x: rect.left, y: rect.top + rect.height },
                ];
                const padding = transformQuadWithOffsets(border, offsets.border);
                const content = transformQuadWithOffsets(padding, offsets.padding);
                const margin = transformQuadWithOffsets(border, offsets.margin);
                return {
                    content,
                    padding,
                    border,
                    margin,
                    width: rect.width,
                    height: rect.height,
                };
                function transformQuadWithOffsets(quad, offsets) {
                    return [
                        {
                            x: quad[0].x + offsets.left,
                            y: quad[0].y + offsets.top,
                        },
                        {
                            x: quad[1].x - offsets.right,
                            y: quad[1].y + offsets.top,
                        },
                        {
                            x: quad[2].x - offsets.right,
                            y: quad[2].y - offsets.bottom,
                        },
                        {
                            x: quad[3].x + offsets.left,
                            y: quad[3].y - offsets.bottom,
                        },
                    ];
                }
            });
            if (!model) {
                return null;
            }
            const offset = await this.#getTopLeftCornerOfFrame();
            if (!offset) {
                return null;
            }
            for (const attribute of [
                'content',
                'padding',
                'border',
                'margin',
            ]) {
                for (const point of model[attribute]) {
                    point.x += offset.x;
                    point.y += offset.y;
                }
            }
            return model;
        }
        async #getTopLeftCornerOfFrame() {
            const point = { x: 0, y: 0 };
            let frame = this.frame;
            let parentFrame;
            while ((parentFrame = frame?.parentFrame())) {
                const env_4 = { stack: [], error: void 0, hasError: false };
                try {
                    const handle = __addDisposableResource$8(env_4, await frame.frameElement(), false);
                    if (!handle) {
                        throw new Error('Unsupported frame type');
                    }
                    const parentBox = await handle.evaluate(element => {
                        if (element.getClientRects().length === 0) {
                            return null;
                        }
                        const rect = element.getBoundingClientRect();
                        const style = window.getComputedStyle(element);
                        return {
                            left: rect.left +
                                parseInt(style.paddingLeft, 10) +
                                parseInt(style.borderLeftWidth, 10),
                            top: rect.top +
                                parseInt(style.paddingTop, 10) +
                                parseInt(style.borderTopWidth, 10),
                        };
                    });
                    if (!parentBox) {
                        return null;
                    }
                    point.x += parentBox.left;
                    point.y += parentBox.top;
                    frame = parentFrame;
                }
                catch (e_4) {
                    env_4.error = e_4;
                    env_4.hasError = true;
                }
                finally {
                    __disposeResources$8(env_4);
                }
            }
            return point;
        }
        async screenshot(options = {}) {
            const { scrollIntoView = true, clip } = options;
            const page = this.frame.page();
            if (scrollIntoView) {
                await this.scrollIntoViewIfNeeded();
            }
            const elementClip = await this.#nonEmptyVisibleBoundingBox();
            const [pageLeft, pageTop] = await this.evaluate(() => {
                if (!window.visualViewport) {
                    throw new Error('window.visualViewport is not supported.');
                }
                return [
                    window.visualViewport.pageLeft,
                    window.visualViewport.pageTop,
                ];
            });
            elementClip.x += pageLeft;
            elementClip.y += pageTop;
            if (clip) {
                elementClip.x += clip.x;
                elementClip.y += clip.y;
                elementClip.height = clip.height;
                elementClip.width = clip.width;
            }
            return await page.screenshot({ ...options, clip: elementClip });
        }
        async #nonEmptyVisibleBoundingBox() {
            const box = await this.boundingBox();
            assert(box, 'Node is either not visible or not an HTMLElement');
            assert(box.width !== 0, 'Node has 0 width.');
            assert(box.height !== 0, 'Node has 0 height.');
            return box;
        }
        async assertConnectedElement() {
            const error = await this.evaluate(async (element) => {
                if (!element.isConnected) {
                    return 'Node is detached from document';
                }
                if (element.nodeType !== Node.ELEMENT_NODE) {
                    return 'Node is not of type HTMLElement';
                }
                return;
            });
            if (error) {
                throw new Error(error);
            }
        }
        async scrollIntoViewIfNeeded() {
            if (await this.isIntersectingViewport({
                threshold: 1,
            })) {
                return;
            }
            await this.scrollIntoView();
        }
        async isIntersectingViewport(options = {}) {
            const env_5 = { stack: [], error: void 0, hasError: false };
            try {
                await this.assertConnectedElement();
                const handle = await this.#asSVGElementHandle();
                const target = __addDisposableResource$8(env_5, handle && (await handle.#getOwnerSVGElement()), false);
                return await (target ?? this).evaluate(async (element, threshold) => {
                    const visibleRatio = await new Promise(resolve => {
                        const observer = new IntersectionObserver(entries => {
                            resolve(entries[0].intersectionRatio);
                            observer.disconnect();
                        });
                        observer.observe(element);
                    });
                    return threshold === 1 ? visibleRatio === 1 : visibleRatio > threshold;
                }, options.threshold ?? 0);
            }
            catch (e_5) {
                env_5.error = e_5;
                env_5.hasError = true;
            }
            finally {
                __disposeResources$8(env_5);
            }
        }
        async scrollIntoView() {
            await this.assertConnectedElement();
            await this.evaluate(async (element) => {
                element.scrollIntoView({
                    block: 'center',
                    inline: 'center',
                    behavior: 'instant',
                });
            });
        }
        asLocator() {
            return NodeLocator.createFromHandle(this.frame, this);
        }
        async #asSVGElementHandle() {
            if (await this.evaluate(element => {
                return element instanceof SVGElement;
            })) {
                return this;
            }
            else {
                return null;
            }
        }
        async #getOwnerSVGElement() {
            return await this.evaluateHandle(element => {
                if (element instanceof SVGSVGElement) {
                    return element;
                }
                return element.ownerSVGElement;
            });
        }
    };
})();
function intersectBoundingBox(box, width, height) {
    box.width = Math.max(box.x >= 0
        ? Math.min(width - box.x, box.width)
        : Math.min(width, box.width + box.x), 0);
    box.height = Math.max(box.y >= 0
        ? Math.min(height - box.y, box.height)
        : Math.min(height, box.height + box.y), 0);
    box.x = Math.max(box.x, 0);
    box.y = Math.max(box.y, 0);
}

/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var __runInitializers$6 = (undefined && undefined.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate$6 = (undefined && undefined.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
var __addDisposableResource$7 = (undefined && undefined.__addDisposableResource) || function (env, value, async) {
    if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
        var dispose, inner;
        if (async) {
            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
            if (async) inner = dispose;
        }
        if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
        if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };
        env.stack.push({ value: value, dispose: dispose, async: async });
    }
    else if (async) {
        env.stack.push({ async: true });
    }
    return value;
};
var __disposeResources$7 = (undefined && undefined.__disposeResources) || (function (SuppressedError) {
    return function (env) {
        function fail(e) {
            env.error = env.hasError ? new SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
            env.hasError = true;
        }
        var r, s = 0;
        function next() {
            while (r = env.stack.pop()) {
                try {
                    if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
                    if (r.dispose) {
                        var result = r.dispose.call(r.value);
                        if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
                    }
                    else s |= 1;
                }
                catch (e) {
                    fail(e);
                }
            }
            if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
            if (env.hasError) throw env.error;
        }
        return next();
    };
})(typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
});
var FrameEvent;
(function (FrameEvent) {
    FrameEvent.FrameNavigated = Symbol('Frame.FrameNavigated');
    FrameEvent.FrameSwapped = Symbol('Frame.FrameSwapped');
    FrameEvent.LifecycleEvent = Symbol('Frame.LifecycleEvent');
    FrameEvent.FrameNavigatedWithinDocument = Symbol('Frame.FrameNavigatedWithinDocument');
    FrameEvent.FrameDetached = Symbol('Frame.FrameDetached');
    FrameEvent.FrameSwappedByActivation = Symbol('Frame.FrameSwappedByActivation');
})(FrameEvent || (FrameEvent = {}));
const throwIfDetached = throwIfDisposed(frame => {
    return `Attempted to use detached Frame '${frame._id}'.`;
});
let Frame = (() => {
    let _classSuper = EventEmitter;
    let _instanceExtraInitializers = [];
    let _frameElement_decorators;
    let _evaluateHandle_decorators;
    let _evaluate_decorators;
    let _locator_decorators;
    let _$_decorators;
    let _$$_decorators;
    let _$eval_decorators;
    let _$$eval_decorators;
    let _waitForSelector_decorators;
    let _waitForFunction_decorators;
    let _content_decorators;
    let _addScriptTag_decorators;
    let _addStyleTag_decorators;
    let _click_decorators;
    let _focus_decorators;
    let _hover_decorators;
    let _select_decorators;
    let _tap_decorators;
    let _type_decorators;
    let _title_decorators;
    return class Frame extends _classSuper {
        static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
            _frameElement_decorators = [throwIfDetached];
            _evaluateHandle_decorators = [throwIfDetached];
            _evaluate_decorators = [throwIfDetached];
            _locator_decorators = [throwIfDetached];
            _$_decorators = [throwIfDetached];
            _$$_decorators = [throwIfDetached];
            _$eval_decorators = [throwIfDetached];
            _$$eval_decorators = [throwIfDetached];
            _waitForSelector_decorators = [throwIfDetached];
            _waitForFunction_decorators = [throwIfDetached];
            _content_decorators = [throwIfDetached];
            _addScriptTag_decorators = [throwIfDetached];
            _addStyleTag_decorators = [throwIfDetached];
            _click_decorators = [throwIfDetached];
            _focus_decorators = [throwIfDetached];
            _hover_decorators = [throwIfDetached];
            _select_decorators = [throwIfDetached];
            _tap_decorators = [throwIfDetached];
            _type_decorators = [throwIfDetached];
            _title_decorators = [throwIfDetached];
            __esDecorate$6(this, null, _frameElement_decorators, { kind: "method", name: "frameElement", static: false, private: false, access: { has: obj => "frameElement" in obj, get: obj => obj.frameElement }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate$6(this, null, _evaluateHandle_decorators, { kind: "method", name: "evaluateHandle", static: false, private: false, access: { has: obj => "evaluateHandle" in obj, get: obj => obj.evaluateHandle }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate$6(this, null, _evaluate_decorators, { kind: "method", name: "evaluate", static: false, private: false, access: { has: obj => "evaluate" in obj, get: obj => obj.evaluate }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate$6(this, null, _locator_decorators, { kind: "method", name: "locator", static: false, private: false, access: { has: obj => "locator" in obj, get: obj => obj.locator }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate$6(this, null, _$_decorators, { kind: "method", name: "$", static: false, private: false, access: { has: obj => "$" in obj, get: obj => obj.$ }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate$6(this, null, _$$_decorators, { kind: "method", name: "$$", static: false, private: false, access: { has: obj => "$$" in obj, get: obj => obj.$$ }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate$6(this, null, _$eval_decorators, { kind: "method", name: "$eval", static: false, private: false, access: { has: obj => "$eval" in obj, get: obj => obj.$eval }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate$6(this, null, _$$eval_decorators, { kind: "method", name: "$$eval", static: false, private: false, access: { has: obj => "$$eval" in obj, get: obj => obj.$$eval }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate$6(this, null, _waitForSelector_decorators, { kind: "method", name: "waitForSelector", static: false, private: false, access: { has: obj => "waitForSelector" in obj, get: obj => obj.waitForSelector }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate$6(this, null, _waitForFunction_decorators, { kind: "method", name: "waitForFunction", static: false, private: false, access: { has: obj => "waitForFunction" in obj, get: obj => obj.waitForFunction }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate$6(this, null, _content_decorators, { kind: "method", name: "content", static: false, private: false, access: { has: obj => "content" in obj, get: obj => obj.content }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate$6(this, null, _addScriptTag_decorators, { kind: "method", name: "addScriptTag", static: false, private: false, access: { has: obj => "addScriptTag" in obj, get: obj => obj.addScriptTag }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate$6(this, null, _addStyleTag_decorators, { kind: "method", name: "addStyleTag", static: false, private: false, access: { has: obj => "addStyleTag" in obj, get: obj => obj.addStyleTag }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate$6(this, null, _click_decorators, { kind: "method", name: "click", static: false, private: false, access: { has: obj => "click" in obj, get: obj => obj.click }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate$6(this, null, _focus_decorators, { kind: "method", name: "focus", static: false, private: false, access: { has: obj => "focus" in obj, get: obj => obj.focus }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate$6(this, null, _hover_decorators, { kind: "method", name: "hover", static: false, private: false, access: { has: obj => "hover" in obj, get: obj => obj.hover }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate$6(this, null, _select_decorators, { kind: "method", name: "select", static: false, private: false, access: { has: obj => "select" in obj, get: obj => obj.select }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate$6(this, null, _tap_decorators, { kind: "method", name: "tap", static: false, private: false, access: { has: obj => "tap" in obj, get: obj => obj.tap }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate$6(this, null, _type_decorators, { kind: "method", name: "type", static: false, private: false, access: { has: obj => "type" in obj, get: obj => obj.type }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate$6(this, null, _title_decorators, { kind: "method", name: "title", static: false, private: false, access: { has: obj => "title" in obj, get: obj => obj.title }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        _id = __runInitializers$6(this, _instanceExtraInitializers);
        _parentId;
        _name;
        _hasStartedLoading = false;
        constructor() {
            super();
        }
        #_document;
        #document() {
            if (!this.#_document) {
                this.#_document = this.mainRealm().evaluateHandle(() => {
                    return document;
                });
            }
            return this.#_document;
        }
        clearDocumentHandle() {
            this.#_document = undefined;
        }
        async frameElement() {
            const env_1 = { stack: [], error: void 0, hasError: false };
            try {
                const parentFrame = this.parentFrame();
                if (!parentFrame) {
                    return null;
                }
                const list = __addDisposableResource$7(env_1, await parentFrame.isolatedRealm().evaluateHandle(() => {
                    return document.querySelectorAll('iframe,frame');
                }), false);
                for await (const iframe_1 of transposeIterableHandle(list)) {
                    const env_2 = { stack: [], error: void 0, hasError: false };
                    try {
                        const iframe = __addDisposableResource$7(env_2, iframe_1, false);
                        const frame = await iframe.contentFrame();
                        if (frame?._id === this._id) {
                            return (await parentFrame
                                .mainRealm()
                                .adoptHandle(iframe));
                        }
                    }
                    catch (e_1) {
                        env_2.error = e_1;
                        env_2.hasError = true;
                    }
                    finally {
                        __disposeResources$7(env_2);
                    }
                }
                return null;
            }
            catch (e_2) {
                env_1.error = e_2;
                env_1.hasError = true;
            }
            finally {
                __disposeResources$7(env_1);
            }
        }
        async evaluateHandle(pageFunction, ...args) {
            pageFunction = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, pageFunction);
            return await this.mainRealm().evaluateHandle(pageFunction, ...args);
        }
        async evaluate(pageFunction, ...args) {
            pageFunction = withSourcePuppeteerURLIfNone(this.evaluate.name, pageFunction);
            return await this.mainRealm().evaluate(pageFunction, ...args);
        }
        locator(input) {
            if (typeof input === 'string') {
                return NodeLocator.create(this, input);
            }
            else {
                return FunctionLocator.create(this, input);
            }
        }
        async $(selector) {
            const document = await this.#document();
            return await document.$(selector);
        }
        async $$(selector, options) {
            const document = await this.#document();
            return await document.$$(selector, options);
        }
        async $eval(selector, pageFunction, ...args) {
            pageFunction = withSourcePuppeteerURLIfNone(this.$eval.name, pageFunction);
            const document = await this.#document();
            return await document.$eval(selector, pageFunction, ...args);
        }
        async $$eval(selector, pageFunction, ...args) {
            pageFunction = withSourcePuppeteerURLIfNone(this.$$eval.name, pageFunction);
            const document = await this.#document();
            return await document.$$eval(selector, pageFunction, ...args);
        }
        async waitForSelector(selector, options = {}) {
            const { updatedSelector, QueryHandler, polling } = getQueryHandlerAndSelector(selector);
            return (await QueryHandler.waitFor(this, updatedSelector, {
                polling,
                ...options,
            }));
        }
        async waitForFunction(pageFunction, options = {}, ...args) {
            return await this.mainRealm().waitForFunction(pageFunction, options, ...args);
        }
        async content() {
            return await this.evaluate(() => {
                let content = '';
                for (const node of document.childNodes) {
                    switch (node) {
                        case document.documentElement:
                            content += document.documentElement.outerHTML;
                            break;
                        default:
                            content += new XMLSerializer().serializeToString(node);
                            break;
                    }
                }
                return content;
            });
        }
        async setFrameContent(content) {
            return await this.evaluate(html => {
                document.open();
                document.write(html);
                document.close();
            }, content);
        }
        name() {
            return this._name || '';
        }
        isDetached() {
            return this.detached;
        }
        get disposed() {
            return this.detached;
        }
        async addScriptTag(options) {
            let { content = '', type } = options;
            const { path } = options;
            if (+!!options.url + +!!path + +!!content !== 1) {
                throw new Error('Exactly one of `url`, `path`, or `content` must be specified.');
            }
            if (path) {
                content = await environment.value.fs.promises.readFile(path, 'utf8');
                content += `//# sourceURL=${path.replace(/\n/g, '')}`;
            }
            type = type ?? 'text/javascript';
            return await this.mainRealm().transferHandle(await this.isolatedRealm().evaluateHandle(async ({ url, id, type, content }) => {
                return await new Promise((resolve, reject) => {
                    const script = document.createElement('script');
                    script.type = type;
                    script.text = content;
                    script.addEventListener('error', event => {
                        reject(new Error(event.message ?? 'Could not load script'));
                    }, { once: true });
                    if (id) {
                        script.id = id;
                    }
                    if (url) {
                        script.src = url;
                        script.addEventListener('load', () => {
                            resolve(script);
                        }, { once: true });
                        document.head.appendChild(script);
                    }
                    else {
                        document.head.appendChild(script);
                        resolve(script);
                    }
                });
            }, { ...options, type, content }));
        }
        async addStyleTag(options) {
            let { content = '' } = options;
            const { path } = options;
            if (+!!options.url + +!!path + +!!content !== 1) {
                throw new Error('Exactly one of `url`, `path`, or `content` must be specified.');
            }
            if (path) {
                content = await environment.value.fs.promises.readFile(path, 'utf8');
                content += '/*# sourceURL=' + path.replace(/\n/g, '') + '*/';
                options.content = content;
            }
            return await this.mainRealm().transferHandle(await this.isolatedRealm().evaluateHandle(async ({ url, content }) => {
                return await new Promise((resolve, reject) => {
                    let element;
                    if (!url) {
                        element = document.createElement('style');
                        element.appendChild(document.createTextNode(content));
                    }
                    else {
                        const link = document.createElement('link');
                        link.rel = 'stylesheet';
                        link.href = url;
                        element = link;
                    }
                    element.addEventListener('load', () => {
                        resolve(element);
                    }, { once: true });
                    element.addEventListener('error', event => {
                        reject(new Error(event.message ?? 'Could not load style'));
                    }, { once: true });
                    document.head.appendChild(element);
                    return element;
                });
            }, options));
        }
        async click(selector, options = {}) {
            const env_3 = { stack: [], error: void 0, hasError: false };
            try {
                const handle = __addDisposableResource$7(env_3, await this.$(selector), false);
                assert(handle, `No element found for selector: ${selector}`);
                await handle.click(options);
                await handle.dispose();
            }
            catch (e_3) {
                env_3.error = e_3;
                env_3.hasError = true;
            }
            finally {
                __disposeResources$7(env_3);
            }
        }
        async focus(selector) {
            const env_4 = { stack: [], error: void 0, hasError: false };
            try {
                const handle = __addDisposableResource$7(env_4, await this.$(selector), false);
                assert(handle, `No element found for selector: ${selector}`);
                await handle.focus();
            }
            catch (e_4) {
                env_4.error = e_4;
                env_4.hasError = true;
            }
            finally {
                __disposeResources$7(env_4);
            }
        }
        async hover(selector) {
            const env_5 = { stack: [], error: void 0, hasError: false };
            try {
                const handle = __addDisposableResource$7(env_5, await this.$(selector), false);
                assert(handle, `No element found for selector: ${selector}`);
                await handle.hover();
            }
            catch (e_5) {
                env_5.error = e_5;
                env_5.hasError = true;
            }
            finally {
                __disposeResources$7(env_5);
            }
        }
        async select(selector, ...values) {
            const env_6 = { stack: [], error: void 0, hasError: false };
            try {
                const handle = __addDisposableResource$7(env_6, await this.$(selector), false);
                assert(handle, `No element found for selector: ${selector}`);
                return await handle.select(...values);
            }
            catch (e_6) {
                env_6.error = e_6;
                env_6.hasError = true;
            }
            finally {
                __disposeResources$7(env_6);
            }
        }
        async tap(selector) {
            const env_7 = { stack: [], error: void 0, hasError: false };
            try {
                const handle = __addDisposableResource$7(env_7, await this.$(selector), false);
                assert(handle, `No element found for selector: ${selector}`);
                await handle.tap();
            }
            catch (e_7) {
                env_7.error = e_7;
                env_7.hasError = true;
            }
            finally {
                __disposeResources$7(env_7);
            }
        }
        async type(selector, text, options) {
            const env_8 = { stack: [], error: void 0, hasError: false };
            try {
                const handle = __addDisposableResource$7(env_8, await this.$(selector), false);
                assert(handle, `No element found for selector: ${selector}`);
                await handle.type(text, options);
            }
            catch (e_8) {
                env_8.error = e_8;
                env_8.hasError = true;
            }
            finally {
                __disposeResources$7(env_8);
            }
        }
        async title() {
            return await this.isolatedRealm().evaluate(() => {
                return document.title;
            });
        }
    };
})();

class HTTPRequest {
    _interceptionId;
    _failureText = null;
    _response = null;
    _fromMemoryCache = false;
    _redirectChain = [];
    interception = {
        enabled: false,
        handled: false,
        handlers: [],
        resolutionState: {
            action: InterceptResolutionAction.None,
        },
        requestOverrides: {},
        response: null,
        abortReason: null,
    };
    constructor() { }
    continueRequestOverrides() {
        return this.interception.requestOverrides;
    }
    responseForRequest() {
        return this.interception.response;
    }
    abortErrorReason() {
        return this.interception.abortReason;
    }
    interceptResolutionState() {
        if (!this.interception.enabled) {
            return { action: InterceptResolutionAction.Disabled };
        }
        if (this.interception.handled) {
            return { action: InterceptResolutionAction.AlreadyHandled };
        }
        return { ...this.interception.resolutionState };
    }
    isInterceptResolutionHandled() {
        return this.interception.handled;
    }
    enqueueInterceptAction(pendingHandler) {
        this.interception.handlers.push(pendingHandler);
    }
    async finalizeInterceptions() {
        await this.interception.handlers.reduce((promiseChain, interceptAction) => {
            return promiseChain.then(interceptAction);
        }, Promise.resolve());
        this.interception.handlers = [];
        const { action } = this.interceptResolutionState();
        switch (action) {
            case 'abort':
                return await this._abort(this.interception.abortReason);
            case 'respond':
                if (this.interception.response === null) {
                    throw new Error('Response is missing for the interception');
                }
                return await this._respond(this.interception.response);
            case 'continue':
                return await this._continue(this.interception.requestOverrides);
        }
    }
    verifyInterception() {
        assert(this.interception.enabled, 'Request Interception is not enabled!');
        assert(!this.interception.handled, 'Request is already handled!');
    }
    async continue(overrides = {}, priority) {
        this.verifyInterception();
        if (!this.canBeIntercepted()) {
            return;
        }
        if (priority === undefined) {
            return await this._continue(overrides);
        }
        this.interception.requestOverrides = overrides;
        if (this.interception.resolutionState.priority === undefined ||
            priority > this.interception.resolutionState.priority) {
            this.interception.resolutionState = {
                action: InterceptResolutionAction.Continue,
                priority,
            };
            return;
        }
        if (priority === this.interception.resolutionState.priority) {
            if (this.interception.resolutionState.action === 'abort' ||
                this.interception.resolutionState.action === 'respond') {
                return;
            }
            this.interception.resolutionState.action =
                InterceptResolutionAction.Continue;
        }
        return;
    }
    async respond(response, priority) {
        this.verifyInterception();
        if (!this.canBeIntercepted()) {
            return;
        }
        if (priority === undefined) {
            return await this._respond(response);
        }
        this.interception.response = response;
        if (this.interception.resolutionState.priority === undefined ||
            priority > this.interception.resolutionState.priority) {
            this.interception.resolutionState = {
                action: InterceptResolutionAction.Respond,
                priority,
            };
            return;
        }
        if (priority === this.interception.resolutionState.priority) {
            if (this.interception.resolutionState.action === 'abort') {
                return;
            }
            this.interception.resolutionState.action =
                InterceptResolutionAction.Respond;
        }
    }
    async abort(errorCode = 'failed', priority) {
        this.verifyInterception();
        if (!this.canBeIntercepted()) {
            return;
        }
        const errorReason = errorReasons[errorCode];
        assert(errorReason, 'Unknown error code: ' + errorCode);
        if (priority === undefined) {
            return await this._abort(errorReason);
        }
        this.interception.abortReason = errorReason;
        if (this.interception.resolutionState.priority === undefined ||
            priority >= this.interception.resolutionState.priority) {
            this.interception.resolutionState = {
                action: InterceptResolutionAction.Abort,
                priority,
            };
            return;
        }
    }
    static getResponse(body) {
        const byteBody = isString(body)
            ? new TextEncoder().encode(body)
            : body;
        return {
            contentLength: byteBody.byteLength,
            base64: typedArrayToBase64(byteBody),
        };
    }
}
var InterceptResolutionAction;
(function (InterceptResolutionAction) {
    InterceptResolutionAction["Abort"] = "abort";
    InterceptResolutionAction["Respond"] = "respond";
    InterceptResolutionAction["Continue"] = "continue";
    InterceptResolutionAction["Disabled"] = "disabled";
    InterceptResolutionAction["None"] = "none";
    InterceptResolutionAction["AlreadyHandled"] = "already-handled";
})(InterceptResolutionAction || (InterceptResolutionAction = {}));
function headersArray(headers) {
    const result = [];
    for (const name in headers) {
        const value = headers[name];
        if (!Object.is(value, undefined)) {
            const values = Array.isArray(value) ? value : [value];
            result.push(...values.map(value => {
                return { name, value: value + '' };
            }));
        }
    }
    return result;
}
const STATUS_TEXTS = {
    '100': 'Continue',
    '101': 'Switching Protocols',
    '102': 'Processing',
    '103': 'Early Hints',
    '200': 'OK',
    '201': 'Created',
    '202': 'Accepted',
    '203': 'Non-Authoritative Information',
    '204': 'No Content',
    '205': 'Reset Content',
    '206': 'Partial Content',
    '207': 'Multi-Status',
    '208': 'Already Reported',
    '226': 'IM Used',
    '300': 'Multiple Choices',
    '301': 'Moved Permanently',
    '302': 'Found',
    '303': 'See Other',
    '304': 'Not Modified',
    '305': 'Use Proxy',
    '306': 'Switch Proxy',
    '307': 'Temporary Redirect',
    '308': 'Permanent Redirect',
    '400': 'Bad Request',
    '401': 'Unauthorized',
    '402': 'Payment Required',
    '403': 'Forbidden',
    '404': 'Not Found',
    '405': 'Method Not Allowed',
    '406': 'Not Acceptable',
    '407': 'Proxy Authentication Required',
    '408': 'Request Timeout',
    '409': 'Conflict',
    '410': 'Gone',
    '411': 'Length Required',
    '412': 'Precondition Failed',
    '413': 'Payload Too Large',
    '414': 'URI Too Long',
    '415': 'Unsupported Media Type',
    '416': 'Range Not Satisfiable',
    '417': 'Expectation Failed',
    '418': "I'm a teapot",
    '421': 'Misdirected Request',
    '422': 'Unprocessable Entity',
    '423': 'Locked',
    '424': 'Failed Dependency',
    '425': 'Too Early',
    '426': 'Upgrade Required',
    '428': 'Precondition Required',
    '429': 'Too Many Requests',
    '431': 'Request Header Fields Too Large',
    '451': 'Unavailable For Legal Reasons',
    '500': 'Internal Server Error',
    '501': 'Not Implemented',
    '502': 'Bad Gateway',
    '503': 'Service Unavailable',
    '504': 'Gateway Timeout',
    '505': 'HTTP Version Not Supported',
    '506': 'Variant Also Negotiates',
    '507': 'Insufficient Storage',
    '508': 'Loop Detected',
    '510': 'Not Extended',
    '511': 'Network Authentication Required',
};
const errorReasons = {
    aborted: 'Aborted',
    accessdenied: 'AccessDenied',
    addressunreachable: 'AddressUnreachable',
    blockedbyclient: 'BlockedByClient',
    blockedbyresponse: 'BlockedByResponse',
    connectionaborted: 'ConnectionAborted',
    connectionclosed: 'ConnectionClosed',
    connectionfailed: 'ConnectionFailed',
    connectionrefused: 'ConnectionRefused',
    connectionreset: 'ConnectionReset',
    internetdisconnected: 'InternetDisconnected',
    namenotresolved: 'NameNotResolved',
    timedout: 'TimedOut',
    failed: 'Failed',
};
function handleError(error) {
    if (error.originalMessage.includes('Invalid header') ||
        error.originalMessage.includes('Unsafe header') ||
        error.originalMessage.includes('Expected "header"') ||
        error.originalMessage.includes('invalid argument')) {
        throw error;
    }
    debugError(error);
}

/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class HTTPResponse {
    constructor() { }
    ok() {
        const status = this.status();
        return status === 0 || (status >= 200 && status <= 299);
    }
    async buffer() {
        const content = await this.content();
        return Buffer.from(content);
    }
    async text() {
        const content = await this.content();
        return new TextDecoder().decode(content);
    }
    async json() {
        const content = await this.text();
        return JSON.parse(content);
    }
}

/**
 * @license
 * Copyright 2024 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
function createIncrementalIdGenerator() {
    let id = 0;
    return () => {
        if (id === Number.MAX_SAFE_INTEGER) {
            id = 0;
        }
        return ++id;
    };
}

/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class Keyboard {
    constructor() { }
}
const MouseButton = Object.freeze({
    Left: 'left',
    Right: 'right',
    Middle: 'middle',
    Back: 'back',
    Forward: 'forward',
});
class Mouse {
    constructor() { }
}
class Touchscreen {
    idGenerator = createIncrementalIdGenerator();
    touches = [];
    constructor() { }
    removeHandle(handle) {
        const index = this.touches.indexOf(handle);
        if (index === -1) {
            return;
        }
        this.touches.splice(index, 1);
    }
    async tap(x, y) {
        const touch = await this.touchStart(x, y);
        await touch.end();
    }
    async touchMove(x, y) {
        const touch = this.touches[0];
        if (!touch) {
            throw new TouchError('Must start a new Touch first');
        }
        return await touch.move(x, y);
    }
    async touchEnd() {
        const touch = this.touches.shift();
        if (!touch) {
            throw new TouchError('Must start a new Touch first');
        }
        await touch.end();
    }
}

/**
 * @license
 * Copyright 2019 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const DEFAULT_TIMEOUT = 30000;
class TimeoutSettings {
    #defaultTimeout;
    #defaultNavigationTimeout;
    constructor() {
        this.#defaultTimeout = null;
        this.#defaultNavigationTimeout = null;
    }
    setDefaultTimeout(timeout) {
        this.#defaultTimeout = timeout;
    }
    setDefaultNavigationTimeout(timeout) {
        this.#defaultNavigationTimeout = timeout;
    }
    navigationTimeout() {
        if (this.#defaultNavigationTimeout !== null) {
            return this.#defaultNavigationTimeout;
        }
        if (this.#defaultTimeout !== null) {
            return this.#defaultTimeout;
        }
        return DEFAULT_TIMEOUT;
    }
    timeout() {
        if (this.#defaultTimeout !== null) {
            return this.#defaultTimeout;
        }
        return DEFAULT_TIMEOUT;
    }
}

/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var __runInitializers$5 = (undefined && undefined.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate$5 = (undefined && undefined.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
var __addDisposableResource$6 = (undefined && undefined.__addDisposableResource) || function (env, value, async) {
    if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
        var dispose, inner;
        if (async) {
            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
            if (async) inner = dispose;
        }
        if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
        if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };
        env.stack.push({ value: value, dispose: dispose, async: async });
    }
    else if (async) {
        env.stack.push({ async: true });
    }
    return value;
};
var __disposeResources$6 = (undefined && undefined.__disposeResources) || (function (SuppressedError) {
    return function (env) {
        function fail(e) {
            env.error = env.hasError ? new SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
            env.hasError = true;
        }
        var r, s = 0;
        function next() {
            while (r = env.stack.pop()) {
                try {
                    if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
                    if (r.dispose) {
                        var result = r.dispose.call(r.value);
                        if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
                    }
                    else s |= 1;
                }
                catch (e) {
                    fail(e);
                }
            }
            if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
            if (env.hasError) throw env.error;
        }
        return next();
    };
})(typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
});
function setDefaultScreenshotOptions(options) {
    options.optimizeForSpeed ??= false;
    options.type ??= 'png';
    options.fromSurface ??= true;
    options.fullPage ??= false;
    options.omitBackground ??= false;
    options.encoding ??= 'binary';
    options.captureBeyondViewport ??= true;
}
let Page = (() => {
    let _classSuper = EventEmitter;
    let _instanceExtraInitializers = [];
    let _screenshot_decorators;
    return class Page extends _classSuper {
        static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
            __esDecorate$5(this, null, _screenshot_decorators, { kind: "method", name: "screenshot", static: false, private: false, access: { has: obj => "screenshot" in obj, get: obj => obj.screenshot }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        _isDragging = (__runInitializers$5(this, _instanceExtraInitializers), false);
        _timeoutSettings = new TimeoutSettings();
        #requestHandlers = new WeakMap();
        #inflight$ = new ReplaySubject(1);
        constructor() {
            super();
            fromEmitterEvent(this, "request" )
                .pipe(mergeMap(originalRequest => {
                return concat(of(1), merge(fromEmitterEvent(this, "requestfailed" ), fromEmitterEvent(this, "requestfinished" ), fromEmitterEvent(this, "response" ).pipe(map(response => {
                    return response.request();
                }))).pipe(filter(request => {
                    return request.id === originalRequest.id;
                }), take(1), map(() => {
                    return -1;
                })));
            }), mergeScan((acc, addend) => {
                return of(acc + addend);
            }, 0), takeUntil(fromEmitterEvent(this, "close" )), startWith(0))
                .subscribe(this.#inflight$);
        }
        on(type, handler) {
            if (type !== "request" ) {
                return super.on(type, handler);
            }
            let wrapper = this.#requestHandlers.get(handler);
            if (wrapper === undefined) {
                wrapper = (event) => {
                    event.enqueueInterceptAction(() => {
                        return handler(event);
                    });
                };
                this.#requestHandlers.set(handler, wrapper);
            }
            return super.on(type, wrapper);
        }
        off(type, handler) {
            if (type === "request" ) {
                handler =
                    this.#requestHandlers.get(handler) || handler;
            }
            return super.off(type, handler);
        }
        get accessibility() {
            return this.mainFrame().accessibility;
        }
        locator(input) {
            if (typeof input === 'string') {
                return NodeLocator.create(this, input);
            }
            else {
                return FunctionLocator.create(this, input);
            }
        }
        locatorRace(locators) {
            return Locator.race(locators);
        }
        async $(selector) {
            return await this.mainFrame().$(selector);
        }
        async $$(selector, options) {
            return await this.mainFrame().$$(selector, options);
        }
        async evaluateHandle(pageFunction, ...args) {
            pageFunction = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, pageFunction);
            return await this.mainFrame().evaluateHandle(pageFunction, ...args);
        }
        async $eval(selector, pageFunction, ...args) {
            pageFunction = withSourcePuppeteerURLIfNone(this.$eval.name, pageFunction);
            return await this.mainFrame().$eval(selector, pageFunction, ...args);
        }
        async $$eval(selector, pageFunction, ...args) {
            pageFunction = withSourcePuppeteerURLIfNone(this.$$eval.name, pageFunction);
            return await this.mainFrame().$$eval(selector, pageFunction, ...args);
        }
        async addScriptTag(options) {
            return await this.mainFrame().addScriptTag(options);
        }
        async addStyleTag(options) {
            return await this.mainFrame().addStyleTag(options);
        }
        url() {
            return this.mainFrame().url();
        }
        async content() {
            return await this.mainFrame().content();
        }
        async setContent(html, options) {
            await this.mainFrame().setContent(html, options);
        }
        async goto(url, options) {
            return await this.mainFrame().goto(url, options);
        }
        async waitForNavigation(options = {}) {
            return await this.mainFrame().waitForNavigation(options);
        }
        waitForRequest(urlOrPredicate, options = {}) {
            const { timeout: ms = this._timeoutSettings.timeout(), signal } = options;
            if (typeof urlOrPredicate === 'string') {
                const url = urlOrPredicate;
                urlOrPredicate = (request) => {
                    return request.url() === url;
                };
            }
            const observable$ = fromEmitterEvent(this, "request" ).pipe(filterAsync(urlOrPredicate), raceWith(timeout(ms), fromAbortSignal(signal), fromEmitterEvent(this, "close" ).pipe(map(() => {
                throw new TargetCloseError('Page closed!');
            }))));
            return firstValueFrom(observable$);
        }
        waitForResponse(urlOrPredicate, options = {}) {
            const { timeout: ms = this._timeoutSettings.timeout(), signal } = options;
            if (typeof urlOrPredicate === 'string') {
                const url = urlOrPredicate;
                urlOrPredicate = (response) => {
                    return response.url() === url;
                };
            }
            const observable$ = fromEmitterEvent(this, "response" ).pipe(filterAsync(urlOrPredicate), raceWith(timeout(ms), fromAbortSignal(signal), fromEmitterEvent(this, "close" ).pipe(map(() => {
                throw new TargetCloseError('Page closed!');
            }))));
            return firstValueFrom(observable$);
        }
        waitForNetworkIdle(options = {}) {
            return firstValueFrom(this.waitForNetworkIdle$(options));
        }
        waitForNetworkIdle$(options = {}) {
            const { timeout: ms = this._timeoutSettings.timeout(), idleTime = NETWORK_IDLE_TIME, concurrency = 0, signal, } = options;
            return this.#inflight$.pipe(map(inflight => {
                return inflight > concurrency;
            }), distinctUntilChanged(), switchMap(isInflightOverConcurrency => {
                if (isInflightOverConcurrency) {
                    return EMPTY;
                }
                return timer(idleTime);
            }), map(() => { }), raceWith(timeout(ms), fromAbortSignal(signal), fromEmitterEvent(this, "close" ).pipe(map(() => {
                throw new TargetCloseError('Page closed!');
            }))));
        }
        async waitForFrame(urlOrPredicate, options = {}) {
            const { timeout: ms = this.getDefaultTimeout(), signal } = options;
            const predicate = isString(urlOrPredicate)
                ? (frame) => {
                    return urlOrPredicate === frame.url();
                }
                : urlOrPredicate;
            return await firstValueFrom(merge(fromEmitterEvent(this, "frameattached" ), fromEmitterEvent(this, "framenavigated" ), from(this.frames())).pipe(filterAsync(predicate), first(), raceWith(timeout(ms), fromAbortSignal(signal), fromEmitterEvent(this, "close" ).pipe(map(() => {
                throw new TargetCloseError('Page closed.');
            })))));
        }
        async emulate(device) {
            await Promise.all([
                this.setUserAgent({ userAgent: device.userAgent }),
                this.setViewport(device.viewport),
            ]);
        }
        async evaluate(pageFunction, ...args) {
            pageFunction = withSourcePuppeteerURLIfNone(this.evaluate.name, pageFunction);
            return await this.mainFrame().evaluate(pageFunction, ...args);
        }
        async _maybeWriteTypedArrayToFile(path, typedArray) {
            if (!path) {
                return;
            }
            await environment.value.fs.promises.writeFile(path, typedArray);
        }
        async screencast(options = {}) {
            const ScreenRecorder = environment.value.ScreenRecorder;
            const [width, height, devicePixelRatio] = await this.#getNativePixelDimensions();
            let crop;
            if (options.crop) {
                const { x, y, width: cropWidth, height: cropHeight, } = roundRectangle(normalizeRectangle(options.crop));
                if (x < 0 || y < 0) {
                    throw new Error(`\`crop.x\` and \`crop.y\` must be greater than or equal to 0.`);
                }
                if (cropWidth <= 0 || cropHeight <= 0) {
                    throw new Error(`\`crop.height\` and \`crop.width\` must be greater than or equal to 0.`);
                }
                const viewportWidth = width / devicePixelRatio;
                const viewportHeight = height / devicePixelRatio;
                if (x + cropWidth > viewportWidth) {
                    throw new Error(`\`crop.width\` cannot be larger than the viewport width (${viewportWidth}).`);
                }
                if (y + cropHeight > viewportHeight) {
                    throw new Error(`\`crop.height\` cannot be larger than the viewport height (${viewportHeight}).`);
                }
                crop = {
                    x: x * devicePixelRatio,
                    y: y * devicePixelRatio,
                    width: cropWidth * devicePixelRatio,
                    height: cropHeight * devicePixelRatio,
                };
            }
            if (options.speed !== undefined && options.speed <= 0) {
                throw new Error(`\`speed\` must be greater than 0.`);
            }
            if (options.scale !== undefined && options.scale <= 0) {
                throw new Error(`\`scale\` must be greater than 0.`);
            }
            const recorder = new ScreenRecorder(this, width, height, {
                ...options,
                crop,
            });
            try {
                await this._startScreencast();
            }
            catch (error) {
                void recorder.stop();
                throw error;
            }
            if (options.path) {
                const { createWriteStream } = environment.value.fs;
                const stream = createWriteStream(options.path, 'binary');
                recorder.pipe(stream);
            }
            return recorder;
        }
        #screencastSessionCount = 0;
        #startScreencastPromise;
        async _startScreencast() {
            ++this.#screencastSessionCount;
            if (!this.#startScreencastPromise) {
                this.#startScreencastPromise = this.mainFrame()
                    .client.send('Page.startScreencast', { format: 'png' })
                    .then(() => {
                    return new Promise(resolve => {
                        return this.mainFrame().client.once('Page.screencastFrame', () => {
                            return resolve();
                        });
                    });
                });
            }
            await this.#startScreencastPromise;
        }
        async _stopScreencast() {
            --this.#screencastSessionCount;
            if (!this.#startScreencastPromise) {
                return;
            }
            this.#startScreencastPromise = undefined;
            if (this.#screencastSessionCount === 0) {
                await this.mainFrame().client.send('Page.stopScreencast');
            }
        }
        async #getNativePixelDimensions() {
            const env_1 = { stack: [], error: void 0, hasError: false };
            try {
                const viewport = this.viewport();
                const stack = __addDisposableResource$6(env_1, new DisposableStack(), false);
                if (viewport && viewport.deviceScaleFactor !== 0) {
                    await this.setViewport({ ...viewport, deviceScaleFactor: 0 });
                    stack.defer(() => {
                        void this.setViewport(viewport).catch(debugError);
                    });
                }
                return await this.mainFrame()
                    .isolatedRealm()
                    .evaluate(() => {
                    return [
                        window.visualViewport.width * window.devicePixelRatio,
                        window.visualViewport.height * window.devicePixelRatio,
                        window.devicePixelRatio,
                    ];
                });
            }
            catch (e_1) {
                env_1.error = e_1;
                env_1.hasError = true;
            }
            finally {
                __disposeResources$6(env_1);
            }
        }
        async screenshot(userOptions = {}) {
            const env_2 = { stack: [], error: void 0, hasError: false };
            try {
                const _guard = __addDisposableResource$6(env_2, await this.browserContext().startScreenshot(), false);
                const options = {
                    ...userOptions,
                    clip: userOptions.clip
                        ? {
                            ...userOptions.clip,
                        }
                        : undefined,
                };
                if (options.type === undefined && options.path !== undefined) {
                    const filePath = options.path;
                    const extension = filePath
                        .slice(filePath.lastIndexOf('.') + 1)
                        .toLowerCase();
                    switch (extension) {
                        case 'png':
                            options.type = 'png';
                            break;
                        case 'jpeg':
                        case 'jpg':
                            options.type = 'jpeg';
                            break;
                        case 'webp':
                            options.type = 'webp';
                            break;
                    }
                }
                if (options.quality !== undefined) {
                    if (options.quality < 0 || options.quality > 100) {
                        throw new Error(`Expected 'quality' (${options.quality}) to be between 0 and 100, inclusive.`);
                    }
                    if (options.type === undefined ||
                        !['jpeg', 'webp'].includes(options.type)) {
                        throw new Error(`${options.type ?? 'png'} screenshots do not support 'quality'.`);
                    }
                }
                if (options.clip) {
                    if (options.clip.width <= 0) {
                        throw new Error("'width' in 'clip' must be positive.");
                    }
                    if (options.clip.height <= 0) {
                        throw new Error("'height' in 'clip' must be positive.");
                    }
                }
                setDefaultScreenshotOptions(options);
                const stack = __addDisposableResource$6(env_2, new AsyncDisposableStack(), true);
                if (options.clip) {
                    if (options.fullPage) {
                        throw new Error("'clip' and 'fullPage' are mutually exclusive");
                    }
                    options.clip = roundRectangle(normalizeRectangle(options.clip));
                }
                else {
                    if (options.fullPage) {
                        if (!options.captureBeyondViewport) {
                            const scrollDimensions = await this.mainFrame()
                                .isolatedRealm()
                                .evaluate(() => {
                                const element = document.documentElement;
                                return {
                                    width: element.scrollWidth,
                                    height: element.scrollHeight,
                                };
                            });
                            const viewport = this.viewport();
                            await this.setViewport({
                                ...viewport,
                                ...scrollDimensions,
                            });
                            stack.defer(async () => {
                                await this.setViewport(viewport).catch(debugError);
                            });
                        }
                    }
                    else {
                        options.captureBeyondViewport = false;
                    }
                }
                const data = await this._screenshot(options);
                if (options.encoding === 'base64') {
                    return data;
                }
                const typedArray = stringToTypedArray(data, true);
                await this._maybeWriteTypedArrayToFile(options.path, typedArray);
                return typedArray;
            }
            catch (e_2) {
                env_2.error = e_2;
                env_2.hasError = true;
            }
            finally {
                const result_1 = __disposeResources$6(env_2);
                if (result_1)
                    await result_1;
            }
        }
        async title() {
            return await this.mainFrame().title();
        }
        click(selector, options) {
            return this.mainFrame().click(selector, options);
        }
        focus(selector) {
            return this.mainFrame().focus(selector);
        }
        hover(selector) {
            return this.mainFrame().hover(selector);
        }
        select(selector, ...values) {
            return this.mainFrame().select(selector, ...values);
        }
        tap(selector) {
            return this.mainFrame().tap(selector);
        }
        type(selector, text, options) {
            return this.mainFrame().type(selector, text, options);
        }
        async waitForSelector(selector, options = {}) {
            return await this.mainFrame().waitForSelector(selector, options);
        }
        waitForFunction(pageFunction, options, ...args) {
            return this.mainFrame().waitForFunction(pageFunction, options, ...args);
        }
        [(_screenshot_decorators = [guarded(function () {
                return this.browser();
            })], disposeSymbol)]() {
            return void this.close().catch(debugError);
        }
        [asyncDisposeSymbol]() {
            return this.close();
        }
    };
})();
function normalizeRectangle(clip) {
    return {
        ...clip,
        ...(clip.width < 0
            ? {
                x: clip.x + clip.width,
                width: -clip.width,
            }
            : {
                x: clip.x,
                width: clip.width,
            }),
        ...(clip.height < 0
            ? {
                y: clip.y + clip.height,
                height: -clip.height,
            }
            : {
                y: clip.y,
                height: clip.height,
            }),
    };
}
function roundRectangle(clip) {
    const x = Math.round(clip.x);
    const y = Math.round(clip.y);
    const width = Math.round(clip.width + clip.x - x);
    const height = Math.round(clip.height + clip.y - y);
    return { ...clip, x, y, width, height };
}

/**
 * @license
 * Copyright 2022 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class WaitTask {
    #world;
    #polling;
    #root;
    #fn;
    #args;
    #timeout;
    #genericError = new Error('Waiting failed');
    #timeoutError;
    #result = Deferred.create();
    #poller;
    #signal;
    #reruns = [];
    constructor(world, options, fn, ...args) {
        this.#world = world;
        this.#polling = options.polling;
        this.#root = options.root;
        this.#signal = options.signal;
        this.#signal?.addEventListener('abort', this.#onAbortSignal, {
            once: true,
        });
        switch (typeof fn) {
            case 'string':
                this.#fn = `() => {return (${fn});}`;
                break;
            default:
                this.#fn = stringifyFunction(fn);
                break;
        }
        this.#args = args;
        this.#world.taskManager.add(this);
        if (options.timeout) {
            this.#timeoutError = new TimeoutError$1(`Waiting failed: ${options.timeout}ms exceeded`);
            this.#timeout = setTimeout(() => {
                void this.terminate(this.#timeoutError);
            }, options.timeout);
        }
        void this.rerun();
    }
    get result() {
        return this.#result.valueOrThrow();
    }
    async rerun() {
        for (const prev of this.#reruns) {
            prev.abort();
        }
        this.#reruns.length = 0;
        const controller = new AbortController();
        this.#reruns.push(controller);
        try {
            switch (this.#polling) {
                case 'raf':
                    this.#poller = await this.#world.evaluateHandle(({ RAFPoller, createFunction }, fn, ...args) => {
                        const fun = createFunction(fn);
                        return new RAFPoller(() => {
                            return fun(...args);
                        });
                    }, LazyArg.create(context => {
                        return context.puppeteerUtil;
                    }), this.#fn, ...this.#args);
                    break;
                case 'mutation':
                    this.#poller = await this.#world.evaluateHandle(({ MutationPoller, createFunction }, root, fn, ...args) => {
                        const fun = createFunction(fn);
                        return new MutationPoller(() => {
                            return fun(...args);
                        }, root || document);
                    }, LazyArg.create(context => {
                        return context.puppeteerUtil;
                    }), this.#root, this.#fn, ...this.#args);
                    break;
                default:
                    this.#poller = await this.#world.evaluateHandle(({ IntervalPoller, createFunction }, ms, fn, ...args) => {
                        const fun = createFunction(fn);
                        return new IntervalPoller(() => {
                            return fun(...args);
                        }, ms);
                    }, LazyArg.create(context => {
                        return context.puppeteerUtil;
                    }), this.#polling, this.#fn, ...this.#args);
                    break;
            }
            await this.#poller.evaluate(poller => {
                void poller.start();
            });
            const result = await this.#poller.evaluateHandle(poller => {
                return poller.result();
            });
            this.#result.resolve(result);
            await this.terminate();
        }
        catch (error) {
            if (controller.signal.aborted) {
                return;
            }
            const badError = this.getBadError(error);
            if (badError) {
                this.#genericError.cause = badError;
                await this.terminate(this.#genericError);
            }
        }
    }
    async terminate(error) {
        this.#world.taskManager.delete(this);
        this.#signal?.removeEventListener('abort', this.#onAbortSignal);
        clearTimeout(this.#timeout);
        if (error && !this.#result.finished()) {
            this.#result.reject(error);
        }
        if (this.#poller) {
            try {
                await this.#poller.evaluate(async (poller) => {
                    await poller.stop();
                });
                if (this.#poller) {
                    await this.#poller.dispose();
                    this.#poller = undefined;
                }
            }
            catch {
            }
        }
    }
    getBadError(error) {
        if (isErrorLike$1(error)) {
            if (error.message.includes('Execution context is not available in detached frame')) {
                return new Error('Waiting failed: Frame detached');
            }
            if (error.message.includes('Execution context was destroyed')) {
                return;
            }
            if (error.message.includes('Cannot find context with specified id')) {
                return;
            }
            if (error.message.includes('DiscardedBrowsingContextError')) {
                return;
            }
            return error;
        }
        return new Error('WaitTask failed with an error', {
            cause: error,
        });
    }
    #onAbortSignal = () => {
        void this.terminate(this.#signal?.reason);
    };
}
class TaskManager {
    #tasks = new Set();
    add(task) {
        this.#tasks.add(task);
    }
    delete(task) {
        this.#tasks.delete(task);
    }
    terminateAll(error) {
        for (const task of this.#tasks) {
            void task.terminate(error);
        }
        this.#tasks.clear();
    }
    async rerunAll() {
        await Promise.all([...this.#tasks].map(task => {
            return task.rerun();
        }));
    }
}

/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class Realm {
    timeoutSettings;
    taskManager = new TaskManager();
    constructor(timeoutSettings) {
        this.timeoutSettings = timeoutSettings;
    }
    async waitForFunction(pageFunction, options = {}, ...args) {
        const { polling = 'raf', timeout = this.timeoutSettings.timeout(), root, signal, } = options;
        if (typeof polling === 'number' && polling < 0) {
            throw new Error('Cannot poll with non-positive interval');
        }
        const waitTask = new WaitTask(this, {
            polling,
            root,
            timeout,
            signal,
        }, pageFunction, ...args);
        return await waitTask.result;
    }
    get disposed() {
        return this.#disposed;
    }
    #disposed = false;
    dispose() {
        this.#disposed = true;
        this.taskManager.terminateAll(new Error('waitForFunction failed: frame got detached.'));
    }
    [disposeSymbol]() {
        this.dispose();
    }
}

/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var TargetType;
(function (TargetType) {
    TargetType["PAGE"] = "page";
    TargetType["BACKGROUND_PAGE"] = "background_page";
    TargetType["SERVICE_WORKER"] = "service_worker";
    TargetType["SHARED_WORKER"] = "shared_worker";
    TargetType["BROWSER"] = "browser";
    TargetType["WEBVIEW"] = "webview";
    TargetType["OTHER"] = "other";
    TargetType["TAB"] = "tab";
})(TargetType || (TargetType = {}));
class Target {
    constructor() { }
    async worker() {
        return null;
    }
    async page() {
        return null;
    }
}

/**
 * @license
 * Copyright 2018 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class WebWorker extends EventEmitter {
    timeoutSettings = new TimeoutSettings();
    #url;
    constructor(url) {
        super();
        this.#url = url;
    }
    url() {
        return this.#url;
    }
    async evaluate(func, ...args) {
        func = withSourcePuppeteerURLIfNone(this.evaluate.name, func);
        return await this.mainRealm().evaluate(func, ...args);
    }
    async evaluateHandle(func, ...args) {
        func = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, func);
        return await this.mainRealm().evaluateHandle(func, ...args);
    }
    async close() {
        throw new UnsupportedOperation('WebWorker.close() is not supported');
    }
}

/**
 * @license
 * Copyright 2018 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var __addDisposableResource$5 = (undefined && undefined.__addDisposableResource) || function (env, value, async) {
    if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
        var dispose, inner;
        if (async) {
            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
            if (async) inner = dispose;
        }
        if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
        if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };
        env.stack.push({ value: value, dispose: dispose, async: async });
    }
    else if (async) {
        env.stack.push({ async: true });
    }
    return value;
};
var __disposeResources$5 = (undefined && undefined.__disposeResources) || (function (SuppressedError) {
    return function (env) {
        function fail(e) {
            env.error = env.hasError ? new SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
            env.hasError = true;
        }
        var r, s = 0;
        function next() {
            while (r = env.stack.pop()) {
                try {
                    if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
                    if (r.dispose) {
                        var result = r.dispose.call(r.value);
                        if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
                    }
                    else s |= 1;
                }
                catch (e) {
                    fail(e);
                }
            }
            if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
            if (env.hasError) throw env.error;
        }
        return next();
    };
})(typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
});
class Accessibility {
    #realm;
    #frameId;
    constructor(realm, frameId = '') {
        this.#realm = realm;
        this.#frameId = frameId;
    }
    async snapshot(options = {}) {
        const { interestingOnly = true, root = null, includeIframes = false, } = options;
        const { nodes } = await this.#realm.environment.client.send('Accessibility.getFullAXTree', {
            frameId: this.#frameId,
        });
        let backendNodeId;
        if (root) {
            const { node } = await this.#realm.environment.client.send('DOM.describeNode', {
                objectId: root.id,
            });
            backendNodeId = node.backendNodeId;
        }
        const defaultRoot = AXNode.createTree(this.#realm, nodes);
        const populateIframes = async (root) => {
            if (root.payload.role?.value === 'Iframe') {
                const env_1 = { stack: [], error: void 0, hasError: false };
                try {
                    if (!root.payload.backendDOMNodeId) {
                        return;
                    }
                    const handle = __addDisposableResource$5(env_1, (await this.#realm.adoptBackendNode(root.payload.backendDOMNodeId)), false);
                    if (!handle || !('contentFrame' in handle)) {
                        return;
                    }
                    const frame = await handle.contentFrame();
                    if (!frame) {
                        return;
                    }
                    const iframeSnapshot = await frame.accessibility.snapshot(options);
                    root.iframeSnapshot = iframeSnapshot ?? undefined;
                }
                catch (e_1) {
                    env_1.error = e_1;
                    env_1.hasError = true;
                }
                finally {
                    __disposeResources$5(env_1);
                }
            }
            for (const child of root.children) {
                await populateIframes(child);
            }
        };
        let needle = defaultRoot;
        if (!defaultRoot) {
            return null;
        }
        if (includeIframes) {
            await populateIframes(defaultRoot);
        }
        if (backendNodeId) {
            needle = defaultRoot.find(node => {
                return node.payload.backendDOMNodeId === backendNodeId;
            });
        }
        if (!needle) {
            return null;
        }
        if (!interestingOnly) {
            return this.serializeTree(needle)[0] ?? null;
        }
        const interestingNodes = new Set();
        this.collectInterestingNodes(interestingNodes, defaultRoot, false);
        return this.serializeTree(needle, interestingNodes)[0] ?? null;
    }
    serializeTree(node, interestingNodes) {
        const children = [];
        for (const child of node.children) {
            children.push(...this.serializeTree(child, interestingNodes));
        }
        if (interestingNodes && !interestingNodes.has(node)) {
            return children;
        }
        const serializedNode = node.serialize();
        if (children.length) {
            serializedNode.children = children;
        }
        if (node.iframeSnapshot) {
            if (!serializedNode.children) {
                serializedNode.children = [];
            }
            serializedNode.children.push(node.iframeSnapshot);
        }
        return [serializedNode];
    }
    collectInterestingNodes(collection, node, insideControl) {
        if (node.isInteresting(insideControl) || node.iframeSnapshot) {
            collection.add(node);
        }
        if (node.isLeafNode()) {
            return;
        }
        insideControl = insideControl || node.isControl();
        for (const child of node.children) {
            this.collectInterestingNodes(collection, child, insideControl);
        }
    }
}
class AXNode {
    payload;
    children = [];
    iframeSnapshot;
    #richlyEditable = false;
    #editable = false;
    #focusable = false;
    #hidden = false;
    #name;
    #role;
    #ignored;
    #cachedHasFocusableChild;
    #realm;
    constructor(realm, payload) {
        this.payload = payload;
        this.#name = this.payload.name ? this.payload.name.value : '';
        this.#role = this.payload.role ? this.payload.role.value : 'Unknown';
        this.#ignored = this.payload.ignored;
        this.#realm = realm;
        for (const property of this.payload.properties || []) {
            if (property.name === 'editable') {
                this.#richlyEditable = property.value.value === 'richtext';
                this.#editable = true;
            }
            if (property.name === 'focusable') {
                this.#focusable = property.value.value;
            }
            if (property.name === 'hidden') {
                this.#hidden = property.value.value;
            }
        }
    }
    #isPlainTextField() {
        if (this.#richlyEditable) {
            return false;
        }
        if (this.#editable) {
            return true;
        }
        return this.#role === 'textbox' || this.#role === 'searchbox';
    }
    #isTextOnlyObject() {
        const role = this.#role;
        return (role === 'LineBreak' ||
            role === 'text' ||
            role === 'InlineTextBox' ||
            role === 'StaticText');
    }
    #hasFocusableChild() {
        if (this.#cachedHasFocusableChild === undefined) {
            this.#cachedHasFocusableChild = false;
            for (const child of this.children) {
                if (child.#focusable || child.#hasFocusableChild()) {
                    this.#cachedHasFocusableChild = true;
                    break;
                }
            }
        }
        return this.#cachedHasFocusableChild;
    }
    find(predicate) {
        if (predicate(this)) {
            return this;
        }
        for (const child of this.children) {
            const result = child.find(predicate);
            if (result) {
                return result;
            }
        }
        return null;
    }
    isLeafNode() {
        if (!this.children.length) {
            return true;
        }
        if (this.#isPlainTextField() || this.#isTextOnlyObject()) {
            return true;
        }
        switch (this.#role) {
            case 'doc-cover':
            case 'graphics-symbol':
            case 'img':
            case 'image':
            case 'Meter':
            case 'scrollbar':
            case 'slider':
            case 'separator':
            case 'progressbar':
                return true;
        }
        if (this.#hasFocusableChild()) {
            return false;
        }
        if (this.#role === 'heading' && this.#name) {
            return true;
        }
        return false;
    }
    isControl() {
        switch (this.#role) {
            case 'button':
            case 'checkbox':
            case 'ColorWell':
            case 'combobox':
            case 'DisclosureTriangle':
            case 'listbox':
            case 'menu':
            case 'menubar':
            case 'menuitem':
            case 'menuitemcheckbox':
            case 'menuitemradio':
            case 'radio':
            case 'scrollbar':
            case 'searchbox':
            case 'slider':
            case 'spinbutton':
            case 'switch':
            case 'tab':
            case 'textbox':
            case 'tree':
            case 'treeitem':
                return true;
            default:
                return false;
        }
    }
    isLandmark() {
        switch (this.#role) {
            case 'banner':
            case 'complementary':
            case 'contentinfo':
            case 'form':
            case 'main':
            case 'navigation':
            case 'region':
            case 'search':
                return true;
            default:
                return false;
        }
    }
    isInteresting(insideControl) {
        const role = this.#role;
        if (role === 'Ignored' || this.#hidden || this.#ignored) {
            return false;
        }
        if (this.isLandmark()) {
            return true;
        }
        if (this.#focusable || this.#richlyEditable) {
            return true;
        }
        if (this.isControl()) {
            return true;
        }
        if (insideControl) {
            return false;
        }
        return this.isLeafNode() && !!this.#name;
    }
    serialize() {
        const properties = new Map();
        for (const property of this.payload.properties || []) {
            properties.set(property.name.toLowerCase(), property.value.value);
        }
        if (this.payload.name) {
            properties.set('name', this.payload.name.value);
        }
        if (this.payload.value) {
            properties.set('value', this.payload.value.value);
        }
        if (this.payload.description) {
            properties.set('description', this.payload.description.value);
        }
        const node = {
            role: this.#role,
            elementHandle: async () => {
                const env_2 = { stack: [], error: void 0, hasError: false };
                try {
                    if (!this.payload.backendDOMNodeId) {
                        return null;
                    }
                    const handle = __addDisposableResource$5(env_2, await this.#realm.adoptBackendNode(this.payload.backendDOMNodeId), false);
                    return (await handle.evaluateHandle(node => {
                        return node.nodeType === Node.TEXT_NODE ? node.parentElement : node;
                    }));
                }
                catch (e_2) {
                    env_2.error = e_2;
                    env_2.hasError = true;
                }
                finally {
                    __disposeResources$5(env_2);
                }
            },
        };
        const userStringProperties = [
            'name',
            'value',
            'description',
            'keyshortcuts',
            'roledescription',
            'valuetext',
        ];
        const getUserStringPropertyValue = (key) => {
            return properties.get(key);
        };
        for (const userStringProperty of userStringProperties) {
            if (!properties.has(userStringProperty)) {
                continue;
            }
            node[userStringProperty] = getUserStringPropertyValue(userStringProperty);
        }
        const booleanProperties = [
            'disabled',
            'expanded',
            'focused',
            'modal',
            'multiline',
            'multiselectable',
            'readonly',
            'required',
            'selected',
        ];
        const getBooleanPropertyValue = (key) => {
            return properties.get(key);
        };
        for (const booleanProperty of booleanProperties) {
            if (booleanProperty === 'focused' && this.#role === 'RootWebArea') {
                continue;
            }
            const value = getBooleanPropertyValue(booleanProperty);
            if (!value) {
                continue;
            }
            node[booleanProperty] = getBooleanPropertyValue(booleanProperty);
        }
        const tristateProperties = ['checked', 'pressed'];
        for (const tristateProperty of tristateProperties) {
            if (!properties.has(tristateProperty)) {
                continue;
            }
            const value = properties.get(tristateProperty);
            node[tristateProperty] =
                value === 'mixed' ? 'mixed' : value === 'true' ? true : false;
        }
        const numericalProperties = [
            'level',
            'valuemax',
            'valuemin',
        ];
        const getNumericalPropertyValue = (key) => {
            return properties.get(key);
        };
        for (const numericalProperty of numericalProperties) {
            if (!properties.has(numericalProperty)) {
                continue;
            }
            node[numericalProperty] = getNumericalPropertyValue(numericalProperty);
        }
        const tokenProperties = [
            'autocomplete',
            'haspopup',
            'invalid',
            'orientation',
        ];
        const getTokenPropertyValue = (key) => {
            return properties.get(key);
        };
        for (const tokenProperty of tokenProperties) {
            const value = getTokenPropertyValue(tokenProperty);
            if (!value || value === 'false') {
                continue;
            }
            node[tokenProperty] = getTokenPropertyValue(tokenProperty);
        }
        return node;
    }
    static createTree(realm, payloads) {
        const nodeById = new Map();
        for (const payload of payloads) {
            nodeById.set(payload.nodeId, new AXNode(realm, payload));
        }
        for (const node of nodeById.values()) {
            for (const childId of node.payload.childIds || []) {
                const child = nodeById.get(childId);
                if (child) {
                    node.children.push(child);
                }
            }
        }
        return nodeById.values().next().value ?? null;
    }
}

var __addDisposableResource$4 = (undefined && undefined.__addDisposableResource) || function (env, value, async) {
    if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
        var dispose, inner;
        if (async) {
            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
            if (async) inner = dispose;
        }
        if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
        if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };
        env.stack.push({ value: value, dispose: dispose, async: async });
    }
    else if (async) {
        env.stack.push({ async: true });
    }
    return value;
};
var __disposeResources$4 = (undefined && undefined.__disposeResources) || (function (SuppressedError) {
    return function (env) {
        function fail(e) {
            env.error = env.hasError ? new SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
            env.hasError = true;
        }
        var r, s = 0;
        function next() {
            while (r = env.stack.pop()) {
                try {
                    if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
                    if (r.dispose) {
                        var result = r.dispose.call(r.value);
                        if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
                    }
                    else s |= 1;
                }
                catch (e) {
                    fail(e);
                }
            }
            if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
            if (env.hasError) throw env.error;
        }
        return next();
    };
})(typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
});
class Binding {
    #name;
    #fn;
    #initSource;
    constructor(name, fn, initSource) {
        this.#name = name;
        this.#fn = fn;
        this.#initSource = initSource;
    }
    get name() {
        return this.#name;
    }
    get initSource() {
        return this.#initSource;
    }
    async run(context, id, args, isTrivial) {
        const stack = new DisposableStack();
        try {
            if (!isTrivial) {
                const env_1 = { stack: [], error: void 0, hasError: false };
                try {
                    const handles = __addDisposableResource$4(env_1, await context.evaluateHandle((name, seq) => {
                        return globalThis[name].args.get(seq);
                    }, this.#name, id), false);
                    const properties = await handles.getProperties();
                    for (const [index, handle] of properties) {
                        if (index in args) {
                            switch (handle.remoteObject().subtype) {
                                case 'node':
                                    args[+index] = handle;
                                    break;
                                default:
                                    stack.use(handle);
                            }
                        }
                        else {
                            stack.use(handle);
                        }
                    }
                }
                catch (e_1) {
                    env_1.error = e_1;
                    env_1.hasError = true;
                }
                finally {
                    __disposeResources$4(env_1);
                }
            }
            await context.evaluate((name, seq, result) => {
                const callbacks = globalThis[name].callbacks;
                callbacks.get(seq).resolve(result);
                callbacks.delete(seq);
            }, this.#name, id, await this.#fn(...args));
            for (const arg of args) {
                if (arg instanceof JSHandle) {
                    stack.use(arg);
                }
            }
        }
        catch (error) {
            if (isErrorLike$1(error)) {
                await context
                    .evaluate((name, seq, message, stack) => {
                    const error = new Error(message);
                    error.stack = stack;
                    const callbacks = globalThis[name].callbacks;
                    callbacks.get(seq).reject(error);
                    callbacks.delete(seq);
                }, this.#name, id, error.message, error.stack)
                    .catch(debugError);
            }
            else {
                await context
                    .evaluate((name, seq, error) => {
                    const callbacks = globalThis[name].callbacks;
                    callbacks.get(seq).reject(error);
                    callbacks.delete(seq);
                }, this.#name, id, error)
                    .catch(debugError);
            }
        }
    }
}

/**
 * @license
 * Copyright 2020 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class ConsoleMessage {
    #type;
    #text;
    #args;
    #stackTraceLocations;
    #frame;
    constructor(type, text, args, stackTraceLocations, frame) {
        this.#type = type;
        this.#text = text;
        this.#args = args;
        this.#stackTraceLocations = stackTraceLocations;
        this.#frame = frame;
    }
    type() {
        return this.#type;
    }
    text() {
        return this.#text;
    }
    args() {
        return this.#args;
    }
    location() {
        return (this.#stackTraceLocations[0] ??
            (this.#frame ? { url: this.#frame.url() } : {}));
    }
    stackTrace() {
        return this.#stackTraceLocations;
    }
}

/**
 * @license
 * Copyright 2020 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class FileChooser {
    #element;
    #multiple;
    #handled = false;
    constructor(element, multiple) {
        this.#element = element;
        this.#multiple = multiple;
    }
    isMultiple() {
        return this.#multiple;
    }
    async accept(paths) {
        assert(!this.#handled, 'Cannot accept FileChooser which is already handled!');
        this.#handled = true;
        await this.#element.uploadFile(...paths);
    }
    async cancel() {
        assert(!this.#handled, 'Cannot cancel FileChooser which is already handled!');
        this.#handled = true;
        await this.#element.evaluate(element => {
            element.dispatchEvent(new Event('cancel', { bubbles: true }));
        });
    }
}

/**
 * @license
 * Copyright 2022 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var NetworkManagerEvent;
(function (NetworkManagerEvent) {
    NetworkManagerEvent.Request = Symbol('NetworkManager.Request');
    NetworkManagerEvent.RequestServedFromCache = Symbol('NetworkManager.RequestServedFromCache');
    NetworkManagerEvent.Response = Symbol('NetworkManager.Response');
    NetworkManagerEvent.RequestFailed = Symbol('NetworkManager.RequestFailed');
    NetworkManagerEvent.RequestFinished = Symbol('NetworkManager.RequestFinished');
})(NetworkManagerEvent || (NetworkManagerEvent = {}));

/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const idGenerator = createIncrementalIdGenerator();
class CallbackRegistry {
    #callbacks = new Map();
    #idGenerator = idGenerator;
    create(label, timeout, request) {
        const callback = new Callback(this.#idGenerator(), label, timeout);
        this.#callbacks.set(callback.id, callback);
        try {
            request(callback.id);
        }
        catch (error) {
            callback.promise.catch(debugError).finally(() => {
                this.#callbacks.delete(callback.id);
            });
            callback.reject(error);
            throw error;
        }
        return callback.promise.finally(() => {
            this.#callbacks.delete(callback.id);
        });
    }
    reject(id, message, originalMessage) {
        const callback = this.#callbacks.get(id);
        if (!callback) {
            return;
        }
        this._reject(callback, message, originalMessage);
    }
    rejectRaw(id, error) {
        const callback = this.#callbacks.get(id);
        if (!callback) {
            return;
        }
        callback.reject(error);
    }
    _reject(callback, errorMessage, originalMessage) {
        let error;
        let message;
        if (errorMessage instanceof ProtocolError) {
            error = errorMessage;
            error.cause = callback.error;
            message = errorMessage.message;
        }
        else {
            error = callback.error;
            message = errorMessage;
        }
        callback.reject(rewriteError$1(error, `Protocol error (${callback.label}): ${message}`, originalMessage));
    }
    resolve(id, value) {
        const callback = this.#callbacks.get(id);
        if (!callback) {
            return;
        }
        callback.resolve(value);
    }
    clear() {
        for (const callback of this.#callbacks.values()) {
            this._reject(callback, new TargetCloseError('Target closed'));
        }
        this.#callbacks.clear();
    }
    getPendingProtocolErrors() {
        const result = [];
        for (const callback of this.#callbacks.values()) {
            result.push(new Error(`${callback.label} timed out. Trace: ${callback.error.stack}`));
        }
        return result;
    }
}
class Callback {
    #id;
    #error = new ProtocolError();
    #deferred = Deferred.create();
    #timer;
    #label;
    constructor(id, label, timeout) {
        this.#id = id;
        this.#label = label;
        if (timeout) {
            this.#timer = setTimeout(() => {
                this.#deferred.reject(rewriteError$1(this.#error, `${label} timed out. Increase the 'protocolTimeout' setting in launch/connect calls for a higher timeout if needed.`));
            }, timeout);
        }
    }
    resolve(value) {
        clearTimeout(this.#timer);
        this.#deferred.resolve(value);
    }
    reject(error) {
        clearTimeout(this.#timer);
        this.#deferred.reject(error);
    }
    get id() {
        return this.#id;
    }
    get promise() {
        return this.#deferred.valueOrThrow();
    }
    get error() {
        return this.#error;
    }
    get label() {
        return this.#label;
    }
}

/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class CdpCDPSession extends CDPSession {
    #sessionId;
    #targetType;
    #callbacks = new CallbackRegistry();
    #connection;
    #parentSessionId;
    #target;
    #rawErrors = false;
    #detached = false;
    constructor(connection, targetType, sessionId, parentSessionId, rawErrors) {
        super();
        this.#connection = connection;
        this.#targetType = targetType;
        this.#sessionId = sessionId;
        this.#parentSessionId = parentSessionId;
        this.#rawErrors = rawErrors;
    }
    setTarget(target) {
        this.#target = target;
    }
    target() {
        assert(this.#target, 'Target must exist');
        return this.#target;
    }
    connection() {
        return this.#connection;
    }
    get detached() {
        return this.#connection._closed || this.#detached;
    }
    parentSession() {
        if (!this.#parentSessionId) {
            return this;
        }
        const parent = this.#connection?.session(this.#parentSessionId);
        return parent ?? undefined;
    }
    send(method, params, options) {
        if (this.detached) {
            return Promise.reject(new TargetCloseError(`Protocol error (${method}): Session closed. Most likely the ${this.#targetType} has been closed.`));
        }
        return this.#connection._rawSend(this.#callbacks, method, params, this.#sessionId, options);
    }
    onMessage(object) {
        if (object.id) {
            if (object.error) {
                if (this.#rawErrors) {
                    this.#callbacks.rejectRaw(object.id, object.error);
                }
                else {
                    this.#callbacks.reject(object.id, createProtocolErrorMessage(object), object.error.message);
                }
            }
            else {
                this.#callbacks.resolve(object.id, object.result);
            }
        }
        else {
            assert(!object.id);
            this.emit(object.method, object.params);
        }
    }
    async detach() {
        if (this.detached) {
            throw new Error(`Session already detached. Most likely the ${this.#targetType} has been closed.`);
        }
        await this.#connection.send('Target.detachFromTarget', {
            sessionId: this.#sessionId,
        });
        this.#detached = true;
    }
    onClosed() {
        this.#callbacks.clear();
        this.#detached = true;
        this.emit(CDPSessionEvent.Disconnected, undefined);
    }
    id() {
        return this.#sessionId;
    }
    getPendingProtocolErrors() {
        return this.#callbacks.getPendingProtocolErrors();
    }
}

/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const debugProtocolSend = debug$1('puppeteer:protocol:SEND âº');
const debugProtocolReceive = debug$1('puppeteer:protocol:RECV â');
class Connection extends EventEmitter {
    #url;
    #transport;
    #delay;
    #timeout;
    #sessions = new Map();
    #closed = false;
    #manuallyAttached = new Set();
    #callbacks;
    #rawErrors = false;
    constructor(url, transport, delay = 0, timeout, rawErrors = false) {
        super();
        this.#rawErrors = rawErrors;
        this.#callbacks = new CallbackRegistry();
        this.#url = url;
        this.#delay = delay;
        this.#timeout = timeout ?? 180_000;
        this.#transport = transport;
        this.#transport.onmessage = this.onMessage.bind(this);
        this.#transport.onclose = this.#onClose.bind(this);
    }
    static fromSession(session) {
        return session.connection();
    }
    get delay() {
        return this.#delay;
    }
    get timeout() {
        return this.#timeout;
    }
    get _closed() {
        return this.#closed;
    }
    get _sessions() {
        return this.#sessions;
    }
    _session(sessionId) {
        return this.#sessions.get(sessionId) || null;
    }
    session(sessionId) {
        return this._session(sessionId);
    }
    url() {
        return this.#url;
    }
    send(method, params, options) {
        return this._rawSend(this.#callbacks, method, params, undefined, options);
    }
    _rawSend(callbacks, method, params, sessionId, options) {
        if (this.#closed) {
            return Promise.reject(new ConnectionClosedError('Connection closed.'));
        }
        return callbacks.create(method, options?.timeout ?? this.#timeout, id => {
            const stringifiedMessage = JSON.stringify({
                method,
                params,
                id,
                sessionId,
            });
            debugProtocolSend(stringifiedMessage);
            this.#transport.send(stringifiedMessage);
        });
    }
    async closeBrowser() {
        await this.send('Browser.close');
    }
    async onMessage(message) {
        if (this.#delay) {
            await new Promise(r => {
                return setTimeout(r, this.#delay);
            });
        }
        debugProtocolReceive(message);
        const object = JSON.parse(message);
        if (object.method === 'Target.attachedToTarget') {
            const sessionId = object.params.sessionId;
            const session = new CdpCDPSession(this, object.params.targetInfo.type, sessionId, object.sessionId, this.#rawErrors);
            this.#sessions.set(sessionId, session);
            this.emit(CDPSessionEvent.SessionAttached, session);
            const parentSession = this.#sessions.get(object.sessionId);
            if (parentSession) {
                parentSession.emit(CDPSessionEvent.SessionAttached, session);
            }
        }
        else if (object.method === 'Target.detachedFromTarget') {
            const session = this.#sessions.get(object.params.sessionId);
            if (session) {
                session.onClosed();
                this.#sessions.delete(object.params.sessionId);
                this.emit(CDPSessionEvent.SessionDetached, session);
                const parentSession = this.#sessions.get(object.sessionId);
                if (parentSession) {
                    parentSession.emit(CDPSessionEvent.SessionDetached, session);
                }
            }
        }
        if (object.sessionId) {
            const session = this.#sessions.get(object.sessionId);
            if (session) {
                session.onMessage(object);
            }
        }
        else if (object.id) {
            if (object.error) {
                if (this.#rawErrors) {
                    this.#callbacks.rejectRaw(object.id, object.error);
                }
                else {
                    this.#callbacks.reject(object.id, createProtocolErrorMessage(object), object.error.message);
                }
            }
            else {
                this.#callbacks.resolve(object.id, object.result);
            }
        }
        else {
            this.emit(object.method, object.params);
        }
    }
    #onClose() {
        if (this.#closed) {
            return;
        }
        this.#closed = true;
        this.#transport.onmessage = undefined;
        this.#transport.onclose = undefined;
        this.#callbacks.clear();
        for (const session of this.#sessions.values()) {
            session.onClosed();
        }
        this.#sessions.clear();
        this.emit(CDPSessionEvent.Disconnected, undefined);
    }
    dispose() {
        this.#onClose();
        this.#transport.close();
    }
    isAutoAttached(targetId) {
        return !this.#manuallyAttached.has(targetId);
    }
    async _createSession(targetInfo, isAutoAttachEmulated = true) {
        if (!isAutoAttachEmulated) {
            this.#manuallyAttached.add(targetInfo.targetId);
        }
        const { sessionId } = await this.send('Target.attachToTarget', {
            targetId: targetInfo.targetId,
            flatten: true,
        });
        this.#manuallyAttached.delete(targetInfo.targetId);
        const session = this.#sessions.get(sessionId);
        if (!session) {
            throw new Error('CDPSession creation failed.');
        }
        return session;
    }
    async createSession(targetInfo) {
        return await this._createSession(targetInfo, false);
    }
    getPendingProtocolErrors() {
        const result = [];
        result.push(...this.#callbacks.getPendingProtocolErrors());
        for (const session of this.#sessions.values()) {
            result.push(...session.getPendingProtocolErrors());
        }
        return result;
    }
}
function isTargetClosedError(error) {
    return error instanceof TargetCloseError;
}

/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class Coverage {
    #jsCoverage;
    #cssCoverage;
    constructor(client) {
        this.#jsCoverage = new JSCoverage(client);
        this.#cssCoverage = new CSSCoverage(client);
    }
    updateClient(client) {
        this.#jsCoverage.updateClient(client);
        this.#cssCoverage.updateClient(client);
    }
    async startJSCoverage(options = {}) {
        return await this.#jsCoverage.start(options);
    }
    async stopJSCoverage() {
        return await this.#jsCoverage.stop();
    }
    async startCSSCoverage(options = {}) {
        return await this.#cssCoverage.start(options);
    }
    async stopCSSCoverage() {
        return await this.#cssCoverage.stop();
    }
}
class JSCoverage {
    #client;
    #enabled = false;
    #scriptURLs = new Map();
    #scriptSources = new Map();
    #subscriptions;
    #resetOnNavigation = false;
    #reportAnonymousScripts = false;
    #includeRawScriptCoverage = false;
    constructor(client) {
        this.#client = client;
    }
    updateClient(client) {
        this.#client = client;
    }
    async start(options = {}) {
        assert(!this.#enabled, 'JSCoverage is already enabled');
        const { resetOnNavigation = true, reportAnonymousScripts = false, includeRawScriptCoverage = false, useBlockCoverage = true, } = options;
        this.#resetOnNavigation = resetOnNavigation;
        this.#reportAnonymousScripts = reportAnonymousScripts;
        this.#includeRawScriptCoverage = includeRawScriptCoverage;
        this.#enabled = true;
        this.#scriptURLs.clear();
        this.#scriptSources.clear();
        this.#subscriptions = new DisposableStack();
        const clientEmitter = this.#subscriptions.use(new EventEmitter(this.#client));
        clientEmitter.on('Debugger.scriptParsed', this.#onScriptParsed.bind(this));
        clientEmitter.on('Runtime.executionContextsCleared', this.#onExecutionContextsCleared.bind(this));
        await Promise.all([
            this.#client.send('Profiler.enable'),
            this.#client.send('Profiler.startPreciseCoverage', {
                callCount: this.#includeRawScriptCoverage,
                detailed: useBlockCoverage,
            }),
            this.#client.send('Debugger.enable'),
            this.#client.send('Debugger.setSkipAllPauses', { skip: true }),
        ]);
    }
    #onExecutionContextsCleared() {
        if (!this.#resetOnNavigation) {
            return;
        }
        this.#scriptURLs.clear();
        this.#scriptSources.clear();
    }
    async #onScriptParsed(event) {
        if (PuppeteerURL.isPuppeteerURL(event.url)) {
            return;
        }
        if (!event.url && !this.#reportAnonymousScripts) {
            return;
        }
        try {
            const response = await this.#client.send('Debugger.getScriptSource', {
                scriptId: event.scriptId,
            });
            this.#scriptURLs.set(event.scriptId, event.url);
            this.#scriptSources.set(event.scriptId, response.scriptSource);
        }
        catch (error) {
            debugError(error);
        }
    }
    async stop() {
        assert(this.#enabled, 'JSCoverage is not enabled');
        this.#enabled = false;
        const result = await Promise.all([
            this.#client.send('Profiler.takePreciseCoverage'),
            this.#client.send('Profiler.stopPreciseCoverage'),
            this.#client.send('Profiler.disable'),
            this.#client.send('Debugger.disable'),
        ]);
        this.#subscriptions?.dispose();
        const coverage = [];
        const profileResponse = result[0];
        for (const entry of profileResponse.result) {
            let url = this.#scriptURLs.get(entry.scriptId);
            if (!url && this.#reportAnonymousScripts) {
                url = 'debugger://VM' + entry.scriptId;
            }
            const text = this.#scriptSources.get(entry.scriptId);
            if (text === undefined || url === undefined) {
                continue;
            }
            const flattenRanges = [];
            for (const func of entry.functions) {
                flattenRanges.push(...func.ranges);
            }
            const ranges = convertToDisjointRanges(flattenRanges);
            if (!this.#includeRawScriptCoverage) {
                coverage.push({ url, ranges, text });
            }
            else {
                coverage.push({ url, ranges, text, rawScriptCoverage: entry });
            }
        }
        return coverage;
    }
}
class CSSCoverage {
    #client;
    #enabled = false;
    #stylesheetURLs = new Map();
    #stylesheetSources = new Map();
    #eventListeners;
    #resetOnNavigation = false;
    constructor(client) {
        this.#client = client;
    }
    updateClient(client) {
        this.#client = client;
    }
    async start(options = {}) {
        assert(!this.#enabled, 'CSSCoverage is already enabled');
        const { resetOnNavigation = true } = options;
        this.#resetOnNavigation = resetOnNavigation;
        this.#enabled = true;
        this.#stylesheetURLs.clear();
        this.#stylesheetSources.clear();
        this.#eventListeners = new DisposableStack();
        const clientEmitter = this.#eventListeners.use(new EventEmitter(this.#client));
        clientEmitter.on('CSS.styleSheetAdded', this.#onStyleSheet.bind(this));
        clientEmitter.on('Runtime.executionContextsCleared', this.#onExecutionContextsCleared.bind(this));
        await Promise.all([
            this.#client.send('DOM.enable'),
            this.#client.send('CSS.enable'),
            this.#client.send('CSS.startRuleUsageTracking'),
        ]);
    }
    #onExecutionContextsCleared() {
        if (!this.#resetOnNavigation) {
            return;
        }
        this.#stylesheetURLs.clear();
        this.#stylesheetSources.clear();
    }
    async #onStyleSheet(event) {
        const header = event.header;
        if (!header.sourceURL) {
            return;
        }
        try {
            const response = await this.#client.send('CSS.getStyleSheetText', {
                styleSheetId: header.styleSheetId,
            });
            this.#stylesheetURLs.set(header.styleSheetId, header.sourceURL);
            this.#stylesheetSources.set(header.styleSheetId, response.text);
        }
        catch (error) {
            debugError(error);
        }
    }
    async stop() {
        assert(this.#enabled, 'CSSCoverage is not enabled');
        this.#enabled = false;
        const ruleTrackingResponse = await this.#client.send('CSS.stopRuleUsageTracking');
        await Promise.all([
            this.#client.send('CSS.disable'),
            this.#client.send('DOM.disable'),
        ]);
        this.#eventListeners?.dispose();
        const styleSheetIdToCoverage = new Map();
        for (const entry of ruleTrackingResponse.ruleUsage) {
            let ranges = styleSheetIdToCoverage.get(entry.styleSheetId);
            if (!ranges) {
                ranges = [];
                styleSheetIdToCoverage.set(entry.styleSheetId, ranges);
            }
            ranges.push({
                startOffset: entry.startOffset,
                endOffset: entry.endOffset,
                count: entry.used ? 1 : 0,
            });
        }
        const coverage = [];
        for (const styleSheetId of this.#stylesheetURLs.keys()) {
            const url = this.#stylesheetURLs.get(styleSheetId);
            assert(typeof url !== 'undefined', `Stylesheet URL is undefined (styleSheetId=${styleSheetId})`);
            const text = this.#stylesheetSources.get(styleSheetId);
            assert(typeof text !== 'undefined', `Stylesheet text is undefined (styleSheetId=${styleSheetId})`);
            const ranges = convertToDisjointRanges(styleSheetIdToCoverage.get(styleSheetId) || []);
            coverage.push({ url, ranges, text });
        }
        return coverage;
    }
}
function convertToDisjointRanges(nestedRanges) {
    const points = [];
    for (const range of nestedRanges) {
        points.push({ offset: range.startOffset, type: 0, range });
        points.push({ offset: range.endOffset, type: 1, range });
    }
    points.sort((a, b) => {
        if (a.offset !== b.offset) {
            return a.offset - b.offset;
        }
        if (a.type !== b.type) {
            return b.type - a.type;
        }
        const aLength = a.range.endOffset - a.range.startOffset;
        const bLength = b.range.endOffset - b.range.startOffset;
        if (a.type === 0) {
            return bLength - aLength;
        }
        return aLength - bLength;
    });
    const hitCountStack = [];
    const results = [];
    let lastOffset = 0;
    for (const point of points) {
        if (hitCountStack.length &&
            lastOffset < point.offset &&
            hitCountStack[hitCountStack.length - 1] > 0) {
            const lastResult = results[results.length - 1];
            if (lastResult && lastResult.end === lastOffset) {
                lastResult.end = point.offset;
            }
            else {
                results.push({ start: lastOffset, end: point.offset });
            }
        }
        lastOffset = point.offset;
        if (point.type === 0) {
            hitCountStack.push(point.range.count);
        }
        else {
            hitCountStack.pop();
        }
    }
    return results.filter(range => {
        return range.end - range.start > 0;
    });
}

/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class CdpDialog extends Dialog {
    #client;
    constructor(client, type, message, defaultValue = '') {
        super(type, message, defaultValue);
        this.#client = client;
    }
    async handle(options) {
        await this.#client.send('Page.handleJavaScriptDialog', {
            accept: options.accept,
            promptText: options.text,
        });
    }
}

var __runInitializers$4 = (undefined && undefined.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate$4 = (undefined && undefined.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
var __setFunctionName$2 = (undefined && undefined.__setFunctionName) || function (f, name, prefix) {
    if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
    return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
};
class EmulatedState {
    #state;
    #clientProvider;
    #updater;
    constructor(initialState, clientProvider, updater) {
        this.#state = initialState;
        this.#clientProvider = clientProvider;
        this.#updater = updater;
        this.#clientProvider.registerState(this);
    }
    async setState(state) {
        this.#state = state;
        await this.sync();
    }
    get state() {
        return this.#state;
    }
    async sync() {
        await Promise.all(this.#clientProvider.clients().map(client => {
            return this.#updater(client, this.#state);
        }));
    }
}
let EmulationManager = (() => {
    let _instanceExtraInitializers = [];
    let _private_applyViewport_decorators;
    let _private_applyViewport_descriptor;
    let _private_emulateIdleState_decorators;
    let _private_emulateIdleState_descriptor;
    let _private_emulateTimezone_decorators;
    let _private_emulateTimezone_descriptor;
    let _private_emulateVisionDeficiency_decorators;
    let _private_emulateVisionDeficiency_descriptor;
    let _private_emulateCpuThrottling_decorators;
    let _private_emulateCpuThrottling_descriptor;
    let _private_emulateMediaFeatures_decorators;
    let _private_emulateMediaFeatures_descriptor;
    let _private_emulateMediaType_decorators;
    let _private_emulateMediaType_descriptor;
    let _private_setGeolocation_decorators;
    let _private_setGeolocation_descriptor;
    let _private_setDefaultBackgroundColor_decorators;
    let _private_setDefaultBackgroundColor_descriptor;
    let _private_setJavaScriptEnabled_decorators;
    let _private_setJavaScriptEnabled_descriptor;
    return class EmulationManager {
        static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(null) : void 0;
            _private_applyViewport_decorators = [invokeAtMostOnceForArguments];
            _private_emulateIdleState_decorators = [invokeAtMostOnceForArguments];
            _private_emulateTimezone_decorators = [invokeAtMostOnceForArguments];
            _private_emulateVisionDeficiency_decorators = [invokeAtMostOnceForArguments];
            _private_emulateCpuThrottling_decorators = [invokeAtMostOnceForArguments];
            _private_emulateMediaFeatures_decorators = [invokeAtMostOnceForArguments];
            _private_emulateMediaType_decorators = [invokeAtMostOnceForArguments];
            _private_setGeolocation_decorators = [invokeAtMostOnceForArguments];
            _private_setDefaultBackgroundColor_decorators = [invokeAtMostOnceForArguments];
            _private_setJavaScriptEnabled_decorators = [invokeAtMostOnceForArguments];
            __esDecorate$4(this, _private_applyViewport_descriptor = { value: __setFunctionName$2(async function (client, viewportState) {
                    if (!viewportState.viewport) {
                        await Promise.all([
                            client.send('Emulation.clearDeviceMetricsOverride'),
                            client.send('Emulation.setTouchEmulationEnabled', {
                                enabled: false,
                            }),
                        ]).catch(debugError);
                        return;
                    }
                    const { viewport } = viewportState;
                    const mobile = viewport.isMobile || false;
                    const width = viewport.width;
                    const height = viewport.height;
                    const deviceScaleFactor = viewport.deviceScaleFactor ?? 1;
                    const screenOrientation = viewport.isLandscape
                        ? { angle: 90, type: 'landscapePrimary' }
                        : { angle: 0, type: 'portraitPrimary' };
                    const hasTouch = viewport.hasTouch || false;
                    await Promise.all([
                        client
                            .send('Emulation.setDeviceMetricsOverride', {
                            mobile,
                            width,
                            height,
                            deviceScaleFactor,
                            screenOrientation,
                        })
                            .catch(err => {
                            if (err.message.includes('Target does not support metrics override')) {
                                debugError(err);
                                return;
                            }
                            throw err;
                        }),
                        client.send('Emulation.setTouchEmulationEnabled', {
                            enabled: hasTouch,
                        }),
                    ]);
                }, "#applyViewport") }, _private_applyViewport_decorators, { kind: "method", name: "#applyViewport", static: false, private: true, access: { has: obj => #applyViewport in obj, get: obj => obj.#applyViewport }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate$4(this, _private_emulateIdleState_descriptor = { value: __setFunctionName$2(async function (client, idleStateState) {
                    if (!idleStateState.active) {
                        return;
                    }
                    if (idleStateState.overrides) {
                        await client.send('Emulation.setIdleOverride', {
                            isUserActive: idleStateState.overrides.isUserActive,
                            isScreenUnlocked: idleStateState.overrides.isScreenUnlocked,
                        });
                    }
                    else {
                        await client.send('Emulation.clearIdleOverride');
                    }
                }, "#emulateIdleState") }, _private_emulateIdleState_decorators, { kind: "method", name: "#emulateIdleState", static: false, private: true, access: { has: obj => #emulateIdleState in obj, get: obj => obj.#emulateIdleState }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate$4(this, _private_emulateTimezone_descriptor = { value: __setFunctionName$2(async function (client, timezoneState) {
                    if (!timezoneState.active) {
                        return;
                    }
                    try {
                        await client.send('Emulation.setTimezoneOverride', {
                            timezoneId: timezoneState.timezoneId || '',
                        });
                    }
                    catch (error) {
                        if (isErrorLike$1(error) && error.message.includes('Invalid timezone')) {
                            throw new Error(`Invalid timezone ID: ${timezoneState.timezoneId}`);
                        }
                        throw error;
                    }
                }, "#emulateTimezone") }, _private_emulateTimezone_decorators, { kind: "method", name: "#emulateTimezone", static: false, private: true, access: { has: obj => #emulateTimezone in obj, get: obj => obj.#emulateTimezone }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate$4(this, _private_emulateVisionDeficiency_descriptor = { value: __setFunctionName$2(async function (client, visionDeficiency) {
                    if (!visionDeficiency.active) {
                        return;
                    }
                    await client.send('Emulation.setEmulatedVisionDeficiency', {
                        type: visionDeficiency.visionDeficiency || 'none',
                    });
                }, "#emulateVisionDeficiency") }, _private_emulateVisionDeficiency_decorators, { kind: "method", name: "#emulateVisionDeficiency", static: false, private: true, access: { has: obj => #emulateVisionDeficiency in obj, get: obj => obj.#emulateVisionDeficiency }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate$4(this, _private_emulateCpuThrottling_descriptor = { value: __setFunctionName$2(async function (client, state) {
                    if (!state.active) {
                        return;
                    }
                    await client.send('Emulation.setCPUThrottlingRate', {
                        rate: state.factor ?? 1,
                    });
                }, "#emulateCpuThrottling") }, _private_emulateCpuThrottling_decorators, { kind: "method", name: "#emulateCpuThrottling", static: false, private: true, access: { has: obj => #emulateCpuThrottling in obj, get: obj => obj.#emulateCpuThrottling }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate$4(this, _private_emulateMediaFeatures_descriptor = { value: __setFunctionName$2(async function (client, state) {
                    if (!state.active) {
                        return;
                    }
                    await client.send('Emulation.setEmulatedMedia', {
                        features: state.mediaFeatures,
                    });
                }, "#emulateMediaFeatures") }, _private_emulateMediaFeatures_decorators, { kind: "method", name: "#emulateMediaFeatures", static: false, private: true, access: { has: obj => #emulateMediaFeatures in obj, get: obj => obj.#emulateMediaFeatures }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate$4(this, _private_emulateMediaType_descriptor = { value: __setFunctionName$2(async function (client, state) {
                    if (!state.active) {
                        return;
                    }
                    await client.send('Emulation.setEmulatedMedia', {
                        media: state.type || '',
                    });
                }, "#emulateMediaType") }, _private_emulateMediaType_decorators, { kind: "method", name: "#emulateMediaType", static: false, private: true, access: { has: obj => #emulateMediaType in obj, get: obj => obj.#emulateMediaType }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate$4(this, _private_setGeolocation_descriptor = { value: __setFunctionName$2(async function (client, state) {
                    if (!state.active) {
                        return;
                    }
                    await client.send('Emulation.setGeolocationOverride', state.geoLocation
                        ? {
                            longitude: state.geoLocation.longitude,
                            latitude: state.geoLocation.latitude,
                            accuracy: state.geoLocation.accuracy,
                        }
                        : undefined);
                }, "#setGeolocation") }, _private_setGeolocation_decorators, { kind: "method", name: "#setGeolocation", static: false, private: true, access: { has: obj => #setGeolocation in obj, get: obj => obj.#setGeolocation }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate$4(this, _private_setDefaultBackgroundColor_descriptor = { value: __setFunctionName$2(async function (client, state) {
                    if (!state.active) {
                        return;
                    }
                    await client.send('Emulation.setDefaultBackgroundColorOverride', {
                        color: state.color,
                    });
                }, "#setDefaultBackgroundColor") }, _private_setDefaultBackgroundColor_decorators, { kind: "method", name: "#setDefaultBackgroundColor", static: false, private: true, access: { has: obj => #setDefaultBackgroundColor in obj, get: obj => obj.#setDefaultBackgroundColor }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate$4(this, _private_setJavaScriptEnabled_descriptor = { value: __setFunctionName$2(async function (client, state) {
                    if (!state.active) {
                        return;
                    }
                    await client.send('Emulation.setScriptExecutionDisabled', {
                        value: !state.javaScriptEnabled,
                    });
                }, "#setJavaScriptEnabled") }, _private_setJavaScriptEnabled_decorators, { kind: "method", name: "#setJavaScriptEnabled", static: false, private: true, access: { has: obj => #setJavaScriptEnabled in obj, get: obj => obj.#setJavaScriptEnabled }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        #client = __runInitializers$4(this, _instanceExtraInitializers);
        #emulatingMobile = false;
        #hasTouch = false;
        #states = [];
        #viewportState = new EmulatedState({
            active: false,
        }, this, this.#applyViewport);
        #idleOverridesState = new EmulatedState({
            active: false,
        }, this, this.#emulateIdleState);
        #timezoneState = new EmulatedState({
            active: false,
        }, this, this.#emulateTimezone);
        #visionDeficiencyState = new EmulatedState({
            active: false,
        }, this, this.#emulateVisionDeficiency);
        #cpuThrottlingState = new EmulatedState({
            active: false,
        }, this, this.#emulateCpuThrottling);
        #mediaFeaturesState = new EmulatedState({
            active: false,
        }, this, this.#emulateMediaFeatures);
        #mediaTypeState = new EmulatedState({
            active: false,
        }, this, this.#emulateMediaType);
        #geoLocationState = new EmulatedState({
            active: false,
        }, this, this.#setGeolocation);
        #defaultBackgroundColorState = new EmulatedState({
            active: false,
        }, this, this.#setDefaultBackgroundColor);
        #javascriptEnabledState = new EmulatedState({
            javaScriptEnabled: true,
            active: false,
        }, this, this.#setJavaScriptEnabled);
        #secondaryClients = new Set();
        constructor(client) {
            this.#client = client;
        }
        updateClient(client) {
            this.#client = client;
            this.#secondaryClients.delete(client);
        }
        registerState(state) {
            this.#states.push(state);
        }
        clients() {
            return [this.#client, ...Array.from(this.#secondaryClients)];
        }
        async registerSpeculativeSession(client) {
            this.#secondaryClients.add(client);
            client.once(CDPSessionEvent.Disconnected, () => {
                this.#secondaryClients.delete(client);
            });
            void Promise.all(this.#states.map(s => {
                return s.sync().catch(debugError);
            }));
        }
        get javascriptEnabled() {
            return this.#javascriptEnabledState.state.javaScriptEnabled;
        }
        async emulateViewport(viewport) {
            const currentState = this.#viewportState.state;
            if (!viewport && !currentState.active) {
                return false;
            }
            await this.#viewportState.setState(viewport
                ? {
                    viewport,
                    active: true,
                }
                : {
                    active: false,
                });
            const mobile = viewport?.isMobile || false;
            const hasTouch = viewport?.hasTouch || false;
            const reloadNeeded = this.#emulatingMobile !== mobile || this.#hasTouch !== hasTouch;
            this.#emulatingMobile = mobile;
            this.#hasTouch = hasTouch;
            return reloadNeeded;
        }
        get #applyViewport() { return _private_applyViewport_descriptor.value; }
        async emulateIdleState(overrides) {
            await this.#idleOverridesState.setState({
                active: true,
                overrides,
            });
        }
        get #emulateIdleState() { return _private_emulateIdleState_descriptor.value; }
        get #emulateTimezone() { return _private_emulateTimezone_descriptor.value; }
        async emulateTimezone(timezoneId) {
            await this.#timezoneState.setState({
                timezoneId,
                active: true,
            });
        }
        get #emulateVisionDeficiency() { return _private_emulateVisionDeficiency_descriptor.value; }
        async emulateVisionDeficiency(type) {
            const visionDeficiencies = new Set([
                'none',
                'achromatopsia',
                'blurredVision',
                'deuteranopia',
                'protanopia',
                'reducedContrast',
                'tritanopia',
            ]);
            assert(!type || visionDeficiencies.has(type), `Unsupported vision deficiency: ${type}`);
            await this.#visionDeficiencyState.setState({
                active: true,
                visionDeficiency: type,
            });
        }
        get #emulateCpuThrottling() { return _private_emulateCpuThrottling_descriptor.value; }
        async emulateCPUThrottling(factor) {
            assert(factor === null || factor >= 1, 'Throttling rate should be greater or equal to 1');
            await this.#cpuThrottlingState.setState({
                active: true,
                factor: factor ?? undefined,
            });
        }
        get #emulateMediaFeatures() { return _private_emulateMediaFeatures_descriptor.value; }
        async emulateMediaFeatures(features) {
            if (Array.isArray(features)) {
                for (const mediaFeature of features) {
                    const name = mediaFeature.name;
                    assert(/^(?:prefers-(?:color-scheme|reduced-motion)|color-gamut)$/.test(name), 'Unsupported media feature: ' + name);
                }
            }
            await this.#mediaFeaturesState.setState({
                active: true,
                mediaFeatures: features,
            });
        }
        get #emulateMediaType() { return _private_emulateMediaType_descriptor.value; }
        async emulateMediaType(type) {
            assert(type === 'screen' ||
                type === 'print' ||
                (type ?? undefined) === undefined, 'Unsupported media type: ' + type);
            await this.#mediaTypeState.setState({
                type,
                active: true,
            });
        }
        get #setGeolocation() { return _private_setGeolocation_descriptor.value; }
        async setGeolocation(options) {
            const { longitude, latitude, accuracy = 0 } = options;
            if (longitude < -180 || longitude > 180) {
                throw new Error(`Invalid longitude "${longitude}": precondition -180 <= LONGITUDE <= 180 failed.`);
            }
            if (latitude < -90 || latitude > 90) {
                throw new Error(`Invalid latitude "${latitude}": precondition -90 <= LATITUDE <= 90 failed.`);
            }
            if (accuracy < 0) {
                throw new Error(`Invalid accuracy "${accuracy}": precondition 0 <= ACCURACY failed.`);
            }
            await this.#geoLocationState.setState({
                active: true,
                geoLocation: {
                    longitude,
                    latitude,
                    accuracy,
                },
            });
        }
        get #setDefaultBackgroundColor() { return _private_setDefaultBackgroundColor_descriptor.value; }
        async resetDefaultBackgroundColor() {
            await this.#defaultBackgroundColorState.setState({
                active: true,
                color: undefined,
            });
        }
        async setTransparentBackgroundColor() {
            await this.#defaultBackgroundColorState.setState({
                active: true,
                color: { r: 0, g: 0, b: 0, a: 0 },
            });
        }
        get #setJavaScriptEnabled() { return _private_setJavaScriptEnabled_descriptor.value; }
        async setJavaScriptEnabled(enabled) {
            await this.#javascriptEnabledState.setState({
                active: true,
                javaScriptEnabled: enabled,
            });
        }
    };
})();

/**
 * @license
 * Copyright 2024 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class CdpPreloadScript {
    #id;
    #source;
    #frameToId = new WeakMap();
    constructor(mainFrame, id, source) {
        this.#id = id;
        this.#source = source;
        this.#frameToId.set(mainFrame, id);
    }
    get id() {
        return this.#id;
    }
    get source() {
        return this.#source;
    }
    getIdForFrame(frame) {
        return this.#frameToId.get(frame);
    }
    setIdForFrame(frame, identifier) {
        this.#frameToId.set(frame, identifier);
    }
}

/**
 * @license
 * Copyright 2022 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class DeviceRequestPromptDevice {
    id;
    name;
    constructor(id, name) {
        this.id = id;
        this.name = name;
    }
}
class DeviceRequestPrompt {
    #client;
    #timeoutSettings;
    #id;
    #handled = false;
    #updateDevicesHandle = this.#updateDevices.bind(this);
    #waitForDevicePromises = new Set();
    devices = [];
    constructor(client, timeoutSettings, firstEvent) {
        this.#client = client;
        this.#timeoutSettings = timeoutSettings;
        this.#id = firstEvent.id;
        this.#client.on('DeviceAccess.deviceRequestPrompted', this.#updateDevicesHandle);
        this.#client.on('Target.detachedFromTarget', () => {
            this.#client = null;
        });
        this.#updateDevices(firstEvent);
    }
    #updateDevices(event) {
        if (event.id !== this.#id) {
            return;
        }
        for (const rawDevice of event.devices) {
            if (this.devices.some(device => {
                return device.id === rawDevice.id;
            })) {
                continue;
            }
            const newDevice = new DeviceRequestPromptDevice(rawDevice.id, rawDevice.name);
            this.devices.push(newDevice);
            for (const waitForDevicePromise of this.#waitForDevicePromises) {
                if (waitForDevicePromise.filter(newDevice)) {
                    waitForDevicePromise.promise.resolve(newDevice);
                }
            }
        }
    }
    async waitForDevice(filter, options = {}) {
        for (const device of this.devices) {
            if (filter(device)) {
                return device;
            }
        }
        const { timeout = this.#timeoutSettings.timeout() } = options;
        const deferred = Deferred.create({
            message: `Waiting for \`DeviceRequestPromptDevice\` failed: ${timeout}ms exceeded`,
            timeout,
        });
        if (options.signal) {
            options.signal.addEventListener('abort', () => {
                deferred.reject(options.signal?.reason);
            }, { once: true });
        }
        const handle = { filter, promise: deferred };
        this.#waitForDevicePromises.add(handle);
        try {
            return await deferred.valueOrThrow();
        }
        finally {
            this.#waitForDevicePromises.delete(handle);
        }
    }
    async select(device) {
        assert(this.#client !== null, 'Cannot select device through detached session!');
        assert(this.devices.includes(device), 'Cannot select unknown device!');
        assert(!this.#handled, 'Cannot select DeviceRequestPrompt which is already handled!');
        this.#client.off('DeviceAccess.deviceRequestPrompted', this.#updateDevicesHandle);
        this.#handled = true;
        return await this.#client.send('DeviceAccess.selectPrompt', {
            id: this.#id,
            deviceId: device.id,
        });
    }
    async cancel() {
        assert(this.#client !== null, 'Cannot cancel prompt through detached session!');
        assert(!this.#handled, 'Cannot cancel DeviceRequestPrompt which is already handled!');
        this.#client.off('DeviceAccess.deviceRequestPrompted', this.#updateDevicesHandle);
        this.#handled = true;
        return await this.#client.send('DeviceAccess.cancelPrompt', { id: this.#id });
    }
}
class DeviceRequestPromptManager {
    #client;
    #timeoutSettings;
    #deviceRequestPromptDeferreds = new Set();
    constructor(client, timeoutSettings) {
        this.#client = client;
        this.#timeoutSettings = timeoutSettings;
        this.#client.on('DeviceAccess.deviceRequestPrompted', event => {
            this.#onDeviceRequestPrompted(event);
        });
        this.#client.on('Target.detachedFromTarget', () => {
            this.#client = null;
        });
    }
    async waitForDevicePrompt(options = {}) {
        assert(this.#client !== null, 'Cannot wait for device prompt through detached session!');
        const needsEnable = this.#deviceRequestPromptDeferreds.size === 0;
        let enablePromise;
        if (needsEnable) {
            enablePromise = this.#client.send('DeviceAccess.enable');
        }
        const { timeout = this.#timeoutSettings.timeout() } = options;
        const deferred = Deferred.create({
            message: `Waiting for \`DeviceRequestPrompt\` failed: ${timeout}ms exceeded`,
            timeout,
        });
        if (options.signal) {
            options.signal.addEventListener('abort', () => {
                deferred.reject(options.signal?.reason);
            }, { once: true });
        }
        this.#deviceRequestPromptDeferreds.add(deferred);
        try {
            const [result] = await Promise.all([
                deferred.valueOrThrow(),
                enablePromise,
            ]);
            return result;
        }
        finally {
            this.#deviceRequestPromptDeferreds.delete(deferred);
        }
    }
    #onDeviceRequestPrompted(event) {
        if (!this.#deviceRequestPromptDeferreds.size) {
            return;
        }
        assert(this.#client !== null);
        const devicePrompt = new DeviceRequestPrompt(this.#client, this.#timeoutSettings, event);
        for (const promise of this.#deviceRequestPromptDeferreds) {
            promise.resolve(devicePrompt);
        }
        this.#deviceRequestPromptDeferreds.clear();
    }
}

/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
function createEvaluationError(details) {
    let name;
    let message;
    if (!details.exception) {
        name = 'Error';
        message = details.text;
    }
    else if ((details.exception.type !== 'object' ||
        details.exception.subtype !== 'error') &&
        !details.exception.objectId) {
        return valueFromRemoteObject(details.exception);
    }
    else {
        const detail = getErrorDetails(details);
        name = detail.name;
        message = detail.message;
    }
    const messageHeight = message.split('\n').length;
    const error = new Error(message);
    error.name = name;
    const stackLines = error.stack.split('\n');
    const messageLines = stackLines.splice(0, messageHeight);
    stackLines.shift();
    if (details.stackTrace && stackLines.length < Error.stackTraceLimit) {
        for (const frame of details.stackTrace.callFrames.reverse()) {
            if (PuppeteerURL.isPuppeteerURL(frame.url) &&
                frame.url !== PuppeteerURL.INTERNAL_URL) {
                const url = PuppeteerURL.parse(frame.url);
                stackLines.unshift(`    at ${frame.functionName || url.functionName} (${url.functionName} at ${url.siteString}, <anonymous>:${frame.lineNumber}:${frame.columnNumber})`);
            }
            else {
                stackLines.push(`    at ${frame.functionName || '<anonymous>'} (${frame.url}:${frame.lineNumber}:${frame.columnNumber})`);
            }
            if (stackLines.length >= Error.stackTraceLimit) {
                break;
            }
        }
    }
    error.stack = [...messageLines, ...stackLines].join('\n');
    return error;
}
const getErrorDetails = (details) => {
    let name = '';
    let message;
    const lines = details.exception?.description?.split('\n    at ') ?? [];
    const size = Math.min(details.stackTrace?.callFrames.length ?? 0, lines.length - 1);
    lines.splice(-size, size);
    if (details.exception?.className) {
        name = details.exception.className;
    }
    message = lines.join('\n');
    if (name && message.startsWith(`${name}: `)) {
        message = message.slice(name.length + 2);
    }
    return { message, name };
};
function createClientError(details) {
    let name;
    let message;
    if (!details.exception) {
        name = 'Error';
        message = details.text;
    }
    else if ((details.exception.type !== 'object' ||
        details.exception.subtype !== 'error') &&
        !details.exception.objectId) {
        return valueFromRemoteObject(details.exception);
    }
    else {
        const detail = getErrorDetails(details);
        name = detail.name;
        message = detail.message;
    }
    const error = new Error(message);
    error.name = name;
    const messageHeight = error.message.split('\n').length;
    const messageLines = error.stack.split('\n').splice(0, messageHeight);
    const stackLines = [];
    if (details.stackTrace) {
        for (const frame of details.stackTrace.callFrames) {
            stackLines.push(`    at ${frame.functionName || '<anonymous>'} (${frame.url}:${frame.lineNumber + 1}:${frame.columnNumber + 1})`);
            if (stackLines.length >= Error.stackTraceLimit) {
                break;
            }
        }
    }
    error.stack = [...messageLines, ...stackLines].join('\n');
    return error;
}
function valueFromRemoteObject(remoteObject) {
    assert(!remoteObject.objectId, 'Cannot extract value when objectId is given');
    if (remoteObject.unserializableValue) {
        if (remoteObject.type === 'bigint') {
            return BigInt(remoteObject.unserializableValue.replace('n', ''));
        }
        switch (remoteObject.unserializableValue) {
            case '-0':
                return -0;
            case 'NaN':
                return NaN;
            case 'Infinity':
                return Infinity;
            case '-Infinity':
                return -Infinity;
            default:
                throw new Error('Unsupported unserializable value: ' +
                    remoteObject.unserializableValue);
        }
    }
    return remoteObject.value;
}
function addPageBinding(type, name, prefix) {
    if (globalThis[name]) {
        return;
    }
    Object.assign(globalThis, {
        [name](...args) {
            const callPuppeteer = globalThis[name];
            callPuppeteer.args ??= new Map();
            callPuppeteer.callbacks ??= new Map();
            const seq = (callPuppeteer.lastSeq ?? 0) + 1;
            callPuppeteer.lastSeq = seq;
            callPuppeteer.args.set(seq, args);
            globalThis[prefix + name](JSON.stringify({
                type,
                name,
                seq,
                args,
                isTrivial: !args.some(value => {
                    return value instanceof Node;
                }),
            }));
            return new Promise((resolve, reject) => {
                callPuppeteer.callbacks.set(seq, {
                    resolve(value) {
                        callPuppeteer.args.delete(seq);
                        resolve(value);
                    },
                    reject(value) {
                        callPuppeteer.args.delete(seq);
                        reject(value);
                    },
                });
            });
        },
    });
}
const CDP_BINDING_PREFIX = 'puppeteer_';
function pageBindingInitString(type, name) {
    return evaluationString(addPageBinding, type, name, CDP_BINDING_PREFIX);
}

/**
 * @license
 * Copyright 2019 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class CdpJSHandle extends JSHandle {
    #disposed = false;
    #remoteObject;
    #world;
    constructor(world, remoteObject) {
        super();
        this.#world = world;
        this.#remoteObject = remoteObject;
    }
    get disposed() {
        return this.#disposed;
    }
    get realm() {
        return this.#world;
    }
    get client() {
        return this.realm.environment.client;
    }
    async jsonValue() {
        if (!this.#remoteObject.objectId) {
            return valueFromRemoteObject(this.#remoteObject);
        }
        const value = await this.evaluate(object => {
            return object;
        });
        if (value === undefined) {
            throw new Error('Could not serialize referenced object');
        }
        return value;
    }
    asElement() {
        return null;
    }
    async dispose() {
        if (this.#disposed) {
            return;
        }
        this.#disposed = true;
        await releaseObject(this.client, this.#remoteObject);
    }
    toString() {
        if (!this.#remoteObject.objectId) {
            return 'JSHandle:' + valueFromRemoteObject(this.#remoteObject);
        }
        const type = this.#remoteObject.subtype || this.#remoteObject.type;
        return 'JSHandle@' + type;
    }
    get id() {
        return this.#remoteObject.objectId;
    }
    remoteObject() {
        return this.#remoteObject;
    }
    async getProperties() {
        const response = await this.client.send('Runtime.getProperties', {
            objectId: this.#remoteObject.objectId,
            ownProperties: true,
        });
        const result = new Map();
        for (const property of response.result) {
            if (!property.enumerable || !property.value) {
                continue;
            }
            result.set(property.name, this.#world.createCdpHandle(property.value));
        }
        return result;
    }
}
async function releaseObject(client, remoteObject) {
    if (!remoteObject.objectId) {
        return;
    }
    await client
        .send('Runtime.releaseObject', { objectId: remoteObject.objectId })
        .catch(error => {
        debugError(error);
    });
}

/**
 * @license
 * Copyright 2019 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var __runInitializers$3 = (undefined && undefined.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate$3 = (undefined && undefined.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
const NON_ELEMENT_NODE_ROLES = new Set(['StaticText', 'InlineTextBox']);
let CdpElementHandle = (() => {
    let _classSuper = ElementHandle;
    let _instanceExtraInitializers = [];
    let _contentFrame_decorators;
    let _scrollIntoView_decorators;
    let _uploadFile_decorators;
    let _autofill_decorators;
    return class CdpElementHandle extends _classSuper {
        static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
            _contentFrame_decorators = [throwIfDisposed()];
            _scrollIntoView_decorators = [throwIfDisposed(), bindIsolatedHandle];
            _uploadFile_decorators = [throwIfDisposed(), bindIsolatedHandle];
            _autofill_decorators = [throwIfDisposed()];
            __esDecorate$3(this, null, _contentFrame_decorators, { kind: "method", name: "contentFrame", static: false, private: false, access: { has: obj => "contentFrame" in obj, get: obj => obj.contentFrame }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate$3(this, null, _scrollIntoView_decorators, { kind: "method", name: "scrollIntoView", static: false, private: false, access: { has: obj => "scrollIntoView" in obj, get: obj => obj.scrollIntoView }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate$3(this, null, _uploadFile_decorators, { kind: "method", name: "uploadFile", static: false, private: false, access: { has: obj => "uploadFile" in obj, get: obj => obj.uploadFile }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate$3(this, null, _autofill_decorators, { kind: "method", name: "autofill", static: false, private: false, access: { has: obj => "autofill" in obj, get: obj => obj.autofill }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        #backendNodeId = __runInitializers$3(this, _instanceExtraInitializers);
        constructor(world, remoteObject) {
            super(new CdpJSHandle(world, remoteObject));
        }
        get realm() {
            return this.handle.realm;
        }
        get client() {
            return this.handle.client;
        }
        remoteObject() {
            return this.handle.remoteObject();
        }
        get #frameManager() {
            return this.frame._frameManager;
        }
        get frame() {
            return this.realm.environment;
        }
        async contentFrame() {
            const nodeInfo = await this.client.send('DOM.describeNode', {
                objectId: this.id,
            });
            if (typeof nodeInfo.node.frameId !== 'string') {
                return null;
            }
            return this.#frameManager.frame(nodeInfo.node.frameId);
        }
        async scrollIntoView() {
            await this.assertConnectedElement();
            try {
                await this.client.send('DOM.scrollIntoViewIfNeeded', {
                    objectId: this.id,
                });
            }
            catch (error) {
                debugError(error);
                await super.scrollIntoView();
            }
        }
        async uploadFile(...files) {
            const isMultiple = await this.evaluate(element => {
                return element.multiple;
            });
            assert(files.length <= 1 || isMultiple, 'Multiple file uploads only work with <input type=file multiple>');
            const path = environment.value.path;
            if (path) {
                files = files.map(filePath => {
                    if (path.win32.isAbsolute(filePath) ||
                        path.posix.isAbsolute(filePath)) {
                        return filePath;
                    }
                    else {
                        return path.resolve(filePath);
                    }
                });
            }
            if (files.length === 0) {
                await this.evaluate(element => {
                    element.files = new DataTransfer().files;
                    element.dispatchEvent(new Event('input', { bubbles: true, composed: true }));
                    element.dispatchEvent(new Event('change', { bubbles: true }));
                });
                return;
            }
            const { node: { backendNodeId }, } = await this.client.send('DOM.describeNode', {
                objectId: this.id,
            });
            await this.client.send('DOM.setFileInputFiles', {
                objectId: this.id,
                files,
                backendNodeId,
            });
        }
        async autofill(data) {
            const nodeInfo = await this.client.send('DOM.describeNode', {
                objectId: this.handle.id,
            });
            const fieldId = nodeInfo.node.backendNodeId;
            const frameId = this.frame._id;
            await this.client.send('Autofill.trigger', {
                fieldId,
                frameId,
                card: data.creditCard,
            });
        }
        async *queryAXTree(name, role) {
            const { nodes } = await this.client.send('Accessibility.queryAXTree', {
                objectId: this.id,
                accessibleName: name,
                role,
            });
            const results = nodes.filter(node => {
                if (node.ignored) {
                    return false;
                }
                if (!node.role) {
                    return false;
                }
                if (NON_ELEMENT_NODE_ROLES.has(node.role.value)) {
                    return false;
                }
                return true;
            });
            return yield* AsyncIterableUtil.map(results, node => {
                return this.realm.adoptBackendNode(node.backendDOMNodeId);
            });
        }
        async backendNodeId() {
            if (this.#backendNodeId) {
                return this.#backendNodeId;
            }
            const { node } = await this.client.send('DOM.describeNode', {
                objectId: this.handle.id,
            });
            this.#backendNodeId = node.backendNodeId;
            return this.#backendNodeId;
        }
    };
})();

/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var __addDisposableResource$3 = (undefined && undefined.__addDisposableResource) || function (env, value, async) {
    if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
        var dispose, inner;
        if (async) {
            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
            if (async) inner = dispose;
        }
        if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
        if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };
        env.stack.push({ value: value, dispose: dispose, async: async });
    }
    else if (async) {
        env.stack.push({ async: true });
    }
    return value;
};
var __disposeResources$3 = (undefined && undefined.__disposeResources) || (function (SuppressedError) {
    return function (env) {
        function fail(e) {
            env.error = env.hasError ? new SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
            env.hasError = true;
        }
        var r, s = 0;
        function next() {
            while (r = env.stack.pop()) {
                try {
                    if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
                    if (r.dispose) {
                        var result = r.dispose.call(r.value);
                        if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
                    }
                    else s |= 1;
                }
                catch (e) {
                    fail(e);
                }
            }
            if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
            if (env.hasError) throw env.error;
        }
        return next();
    };
})(typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
});
const ariaQuerySelectorBinding = new Binding('__ariaQuerySelector', ARIAQueryHandler.queryOne, '');
const ariaQuerySelectorAllBinding = new Binding('__ariaQuerySelectorAll', (async (element, selector) => {
    const results = ARIAQueryHandler.queryAll(element, selector);
    return await element.realm.evaluateHandle((...elements) => {
        return elements;
    }, ...(await AsyncIterableUtil.collect(results)));
}), '');
class ExecutionContext extends EventEmitter {
    #client;
    #world;
    #id;
    #name;
    #disposables = new DisposableStack();
    constructor(client, contextPayload, world) {
        super();
        this.#client = client;
        this.#world = world;
        this.#id = contextPayload.id;
        if (contextPayload.name) {
            this.#name = contextPayload.name;
        }
        const clientEmitter = this.#disposables.use(new EventEmitter(this.#client));
        clientEmitter.on('Runtime.bindingCalled', this.#onBindingCalled.bind(this));
        clientEmitter.on('Runtime.executionContextDestroyed', async (event) => {
            if (event.executionContextId === this.#id) {
                this[disposeSymbol]();
            }
        });
        clientEmitter.on('Runtime.executionContextsCleared', async () => {
            this[disposeSymbol]();
        });
        clientEmitter.on('Runtime.consoleAPICalled', this.#onConsoleAPI.bind(this));
        clientEmitter.on(CDPSessionEvent.Disconnected, () => {
            this[disposeSymbol]();
        });
    }
    #bindings = new Map();
    #mutex = new Mutex();
    async #addBinding(binding) {
        const env_1 = { stack: [], error: void 0, hasError: false };
        try {
            if (this.#bindings.has(binding.name)) {
                return;
            }
            const _ = __addDisposableResource$3(env_1, await this.#mutex.acquire(), false);
            try {
                await this.#client.send('Runtime.addBinding', this.#name
                    ? {
                        name: CDP_BINDING_PREFIX + binding.name,
                        executionContextName: this.#name,
                    }
                    : {
                        name: CDP_BINDING_PREFIX + binding.name,
                        executionContextId: this.#id,
                    });
                await this.evaluate(addPageBinding, 'internal', binding.name, CDP_BINDING_PREFIX);
                this.#bindings.set(binding.name, binding);
            }
            catch (error) {
                if (error instanceof Error) {
                    if (error.message.includes('Execution context was destroyed')) {
                        return;
                    }
                    if (error.message.includes('Cannot find context with specified id')) {
                        return;
                    }
                }
                debugError(error);
            }
        }
        catch (e_1) {
            env_1.error = e_1;
            env_1.hasError = true;
        }
        finally {
            __disposeResources$3(env_1);
        }
    }
    async #onBindingCalled(event) {
        if (event.executionContextId !== this.#id) {
            return;
        }
        let payload;
        try {
            payload = JSON.parse(event.payload);
        }
        catch {
            return;
        }
        const { type, name, seq, args, isTrivial } = payload;
        if (type !== 'internal') {
            this.emit('bindingcalled', event);
            return;
        }
        if (!this.#bindings.has(name)) {
            this.emit('bindingcalled', event);
            return;
        }
        try {
            const binding = this.#bindings.get(name);
            await binding?.run(this, seq, args, isTrivial);
        }
        catch (err) {
            debugError(err);
        }
    }
    get id() {
        return this.#id;
    }
    #onConsoleAPI(event) {
        if (event.executionContextId !== this.#id) {
            return;
        }
        this.emit('consoleapicalled', event);
    }
    #bindingsInstalled = false;
    #puppeteerUtil;
    get puppeteerUtil() {
        let promise = Promise.resolve();
        if (!this.#bindingsInstalled) {
            promise = Promise.all([
                this.#addBindingWithoutThrowing(ariaQuerySelectorBinding),
                this.#addBindingWithoutThrowing(ariaQuerySelectorAllBinding),
            ]);
            this.#bindingsInstalled = true;
        }
        scriptInjector.inject(script => {
            if (this.#puppeteerUtil) {
                void this.#puppeteerUtil.then(handle => {
                    void handle.dispose();
                });
            }
            this.#puppeteerUtil = promise.then(() => {
                return this.evaluateHandle(script);
            });
        }, !this.#puppeteerUtil);
        return this.#puppeteerUtil;
    }
    async #addBindingWithoutThrowing(binding) {
        try {
            await this.#addBinding(binding);
        }
        catch (err) {
            debugError(err);
        }
    }
    async evaluate(pageFunction, ...args) {
        return await this.#evaluate(true, pageFunction, ...args);
    }
    async evaluateHandle(pageFunction, ...args) {
        return await this.#evaluate(false, pageFunction, ...args);
    }
    async #evaluate(returnByValue, pageFunction, ...args) {
        const sourceUrlComment = getSourceUrlComment(getSourcePuppeteerURLIfAvailable(pageFunction)?.toString() ??
            PuppeteerURL.INTERNAL_URL);
        if (isString(pageFunction)) {
            const contextId = this.#id;
            const expression = pageFunction;
            const expressionWithSourceUrl = SOURCE_URL_REGEX.test(expression)
                ? expression
                : `${expression}\n${sourceUrlComment}\n`;
            const { exceptionDetails, result: remoteObject } = await this.#client
                .send('Runtime.evaluate', {
                expression: expressionWithSourceUrl,
                contextId,
                returnByValue,
                awaitPromise: true,
                userGesture: true,
            })
                .catch(rewriteError);
            if (exceptionDetails) {
                throw createEvaluationError(exceptionDetails);
            }
            if (returnByValue) {
                return valueFromRemoteObject(remoteObject);
            }
            return this.#world.createCdpHandle(remoteObject);
        }
        const functionDeclaration = stringifyFunction(pageFunction);
        const functionDeclarationWithSourceUrl = SOURCE_URL_REGEX.test(functionDeclaration)
            ? functionDeclaration
            : `${functionDeclaration}\n${sourceUrlComment}\n`;
        let callFunctionOnPromise;
        try {
            callFunctionOnPromise = this.#client.send('Runtime.callFunctionOn', {
                functionDeclaration: functionDeclarationWithSourceUrl,
                executionContextId: this.#id,
                arguments: args.some(arg => {
                    return arg instanceof LazyArg;
                })
                    ? await Promise.all(args.map(arg => {
                        return convertArgumentAsync(this, arg);
                    }))
                    : args.map(arg => {
                        return convertArgument(this, arg);
                    }),
                returnByValue,
                awaitPromise: true,
                userGesture: true,
            });
        }
        catch (error) {
            if (error instanceof TypeError &&
                error.message.startsWith('Converting circular structure to JSON')) {
                error.message += ' Recursive objects are not allowed.';
            }
            throw error;
        }
        const { exceptionDetails, result: remoteObject } = await callFunctionOnPromise.catch(rewriteError);
        if (exceptionDetails) {
            throw createEvaluationError(exceptionDetails);
        }
        if (returnByValue) {
            return valueFromRemoteObject(remoteObject);
        }
        return this.#world.createCdpHandle(remoteObject);
        async function convertArgumentAsync(context, arg) {
            if (arg instanceof LazyArg) {
                arg = await arg.get(context);
            }
            return convertArgument(context, arg);
        }
        function convertArgument(context, arg) {
            if (typeof arg === 'bigint') {
                return { unserializableValue: `${arg.toString()}n` };
            }
            if (Object.is(arg, -0)) {
                return { unserializableValue: '-0' };
            }
            if (Object.is(arg, Infinity)) {
                return { unserializableValue: 'Infinity' };
            }
            if (Object.is(arg, -Infinity)) {
                return { unserializableValue: '-Infinity' };
            }
            if (Object.is(arg, NaN)) {
                return { unserializableValue: 'NaN' };
            }
            const objectHandle = arg && (arg instanceof CdpJSHandle || arg instanceof CdpElementHandle)
                ? arg
                : null;
            if (objectHandle) {
                if (objectHandle.realm !== context.#world) {
                    throw new Error('JSHandles can be evaluated only in the context they were created!');
                }
                if (objectHandle.disposed) {
                    throw new Error('JSHandle is disposed!');
                }
                if (objectHandle.remoteObject().unserializableValue) {
                    return {
                        unserializableValue: objectHandle.remoteObject().unserializableValue,
                    };
                }
                if (!objectHandle.remoteObject().objectId) {
                    return { value: objectHandle.remoteObject().value };
                }
                return { objectId: objectHandle.remoteObject().objectId };
            }
            return { value: arg };
        }
    }
    [disposeSymbol]() {
        this.#disposables.dispose();
        this.emit('disposed', undefined);
    }
}
const rewriteError = (error) => {
    if (error.message.includes('Object reference chain is too long')) {
        return { result: { type: 'undefined' } };
    }
    if (error.message.includes("Object couldn't be returned by value")) {
        return { result: { type: 'undefined' } };
    }
    if (error.message.endsWith('Cannot find context with specified id') ||
        error.message.endsWith('Inspected target navigated or closed')) {
        throw new Error('Execution context was destroyed, most likely because of a navigation.');
    }
    throw error;
};

/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var FrameManagerEvent;
(function (FrameManagerEvent) {
    FrameManagerEvent.FrameAttached = Symbol('FrameManager.FrameAttached');
    FrameManagerEvent.FrameNavigated = Symbol('FrameManager.FrameNavigated');
    FrameManagerEvent.FrameDetached = Symbol('FrameManager.FrameDetached');
    FrameManagerEvent.FrameSwapped = Symbol('FrameManager.FrameSwapped');
    FrameManagerEvent.LifecycleEvent = Symbol('FrameManager.LifecycleEvent');
    FrameManagerEvent.FrameNavigatedWithinDocument = Symbol('FrameManager.FrameNavigatedWithinDocument');
    FrameManagerEvent.ConsoleApiCalled = Symbol('FrameManager.ConsoleApiCalled');
    FrameManagerEvent.BindingCalled = Symbol('FrameManager.BindingCalled');
})(FrameManagerEvent || (FrameManagerEvent = {}));

/**
 * @license
 * Copyright 2019 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class IsolatedWorld extends Realm {
    #context;
    #emitter = new EventEmitter();
    #frameOrWorker;
    constructor(frameOrWorker, timeoutSettings) {
        super(timeoutSettings);
        this.#frameOrWorker = frameOrWorker;
    }
    get environment() {
        return this.#frameOrWorker;
    }
    get client() {
        return this.#frameOrWorker.client;
    }
    get emitter() {
        return this.#emitter;
    }
    setContext(context) {
        this.#context?.[disposeSymbol]();
        context.once('disposed', this.#onContextDisposed.bind(this));
        context.on('consoleapicalled', this.#onContextConsoleApiCalled.bind(this));
        context.on('bindingcalled', this.#onContextBindingCalled.bind(this));
        this.#context = context;
        this.#emitter.emit('context', context);
        void this.taskManager.rerunAll();
    }
    #onContextDisposed() {
        this.#context = undefined;
        if ('clearDocumentHandle' in this.#frameOrWorker) {
            this.#frameOrWorker.clearDocumentHandle();
        }
    }
    #onContextConsoleApiCalled(event) {
        this.#emitter.emit('consoleapicalled', event);
    }
    #onContextBindingCalled(event) {
        this.#emitter.emit('bindingcalled', event);
    }
    hasContext() {
        return !!this.#context;
    }
    get context() {
        return this.#context;
    }
    #executionContext() {
        if (this.disposed) {
            throw new Error(`Execution context is not available in detached frame or worker "${this.environment.url()}" (are you trying to evaluate?)`);
        }
        return this.#context;
    }
    async #waitForExecutionContext() {
        const error = new Error('Execution context was destroyed');
        const result = await firstValueFrom(fromEmitterEvent(this.#emitter, 'context').pipe(raceWith(fromEmitterEvent(this.#emitter, 'disposed').pipe(map(() => {
            throw error;
        })), timeout(this.timeoutSettings.timeout()))));
        return result;
    }
    async evaluateHandle(pageFunction, ...args) {
        pageFunction = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, pageFunction);
        let context = this.#executionContext();
        if (!context) {
            context = await this.#waitForExecutionContext();
        }
        return await context.evaluateHandle(pageFunction, ...args);
    }
    async evaluate(pageFunction, ...args) {
        pageFunction = withSourcePuppeteerURLIfNone(this.evaluate.name, pageFunction);
        let context = this.#executionContext();
        if (!context) {
            context = await this.#waitForExecutionContext();
        }
        return await context.evaluate(pageFunction, ...args);
    }
    async adoptBackendNode(backendNodeId) {
        let context = this.#executionContext();
        if (!context) {
            context = await this.#waitForExecutionContext();
        }
        const { object } = await this.client.send('DOM.resolveNode', {
            backendNodeId: backendNodeId,
            executionContextId: context.id,
        });
        return this.createCdpHandle(object);
    }
    async adoptHandle(handle) {
        if (handle.realm === this) {
            return (await handle.evaluateHandle(value => {
                return value;
            }));
        }
        const nodeInfo = await this.client.send('DOM.describeNode', {
            objectId: handle.id,
        });
        return (await this.adoptBackendNode(nodeInfo.node.backendNodeId));
    }
    async transferHandle(handle) {
        if (handle.realm === this) {
            return handle;
        }
        if (handle.remoteObject().objectId === undefined) {
            return handle;
        }
        const info = await this.client.send('DOM.describeNode', {
            objectId: handle.remoteObject().objectId,
        });
        const newHandle = (await this.adoptBackendNode(info.node.backendNodeId));
        await handle.dispose();
        return newHandle;
    }
    createCdpHandle(remoteObject) {
        if (remoteObject.subtype === 'node') {
            return new CdpElementHandle(this, remoteObject);
        }
        return new CdpJSHandle(this, remoteObject);
    }
    [disposeSymbol]() {
        this.#context?.[disposeSymbol]();
        this.#emitter.emit('disposed', undefined);
        super[disposeSymbol]();
        this.#emitter.removeAllListeners();
    }
}

/**
 * @license
 * Copyright 2022 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const MAIN_WORLD = Symbol('mainWorld');
const PUPPETEER_WORLD = Symbol('puppeteerWorld');

/**
 * @license
 * Copyright 2019 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const puppeteerToProtocolLifecycle = new Map([
    ['load', 'load'],
    ['domcontentloaded', 'DOMContentLoaded'],
    ['networkidle0', 'networkIdle'],
    ['networkidle2', 'networkAlmostIdle'],
]);
class LifecycleWatcher {
    #expectedLifecycle;
    #frame;
    #timeout;
    #navigationRequest = null;
    #subscriptions = new DisposableStack();
    #initialLoaderId;
    #terminationDeferred;
    #sameDocumentNavigationDeferred = Deferred.create();
    #lifecycleDeferred = Deferred.create();
    #newDocumentNavigationDeferred = Deferred.create();
    #error = new Error('LifecycleWatcher terminated');
    #hasSameDocumentNavigation;
    #swapped;
    #navigationResponseReceived;
    constructor(networkManager, frame, waitUntil, timeout, signal) {
        if (Array.isArray(waitUntil)) {
            waitUntil = waitUntil.slice();
        }
        else if (typeof waitUntil === 'string') {
            waitUntil = [waitUntil];
        }
        this.#initialLoaderId = frame._loaderId;
        this.#expectedLifecycle = waitUntil.map(value => {
            const protocolEvent = puppeteerToProtocolLifecycle.get(value);
            assert(protocolEvent, 'Unknown value for options.waitUntil: ' + value);
            return protocolEvent;
        });
        signal?.addEventListener('abort', () => {
            if (signal.reason instanceof Error) {
                signal.reason.cause = this.#error;
            }
            this.#terminationDeferred.reject(signal.reason);
        });
        this.#frame = frame;
        this.#timeout = timeout;
        const frameManagerEmitter = this.#subscriptions.use(new EventEmitter(frame._frameManager));
        frameManagerEmitter.on(FrameManagerEvent.LifecycleEvent, this.#checkLifecycleComplete.bind(this));
        const frameEmitter = this.#subscriptions.use(new EventEmitter(frame));
        frameEmitter.on(FrameEvent.FrameNavigatedWithinDocument, this.#navigatedWithinDocument.bind(this));
        frameEmitter.on(FrameEvent.FrameNavigated, this.#navigated.bind(this));
        frameEmitter.on(FrameEvent.FrameSwapped, this.#frameSwapped.bind(this));
        frameEmitter.on(FrameEvent.FrameSwappedByActivation, this.#frameSwapped.bind(this));
        frameEmitter.on(FrameEvent.FrameDetached, this.#onFrameDetached.bind(this));
        const networkManagerEmitter = this.#subscriptions.use(new EventEmitter(networkManager));
        networkManagerEmitter.on(NetworkManagerEvent.Request, this.#onRequest.bind(this));
        networkManagerEmitter.on(NetworkManagerEvent.Response, this.#onResponse.bind(this));
        networkManagerEmitter.on(NetworkManagerEvent.RequestFailed, this.#onRequestFailed.bind(this));
        this.#terminationDeferred = Deferred.create({
            timeout: this.#timeout,
            message: `Navigation timeout of ${this.#timeout} ms exceeded`,
        });
        this.#checkLifecycleComplete();
    }
    #onRequest(request) {
        if (request.frame() !== this.#frame || !request.isNavigationRequest()) {
            return;
        }
        this.#navigationRequest = request;
        this.#navigationResponseReceived?.resolve();
        this.#navigationResponseReceived = Deferred.create();
        if (request.response() !== null) {
            this.#navigationResponseReceived?.resolve();
        }
    }
    #onRequestFailed(request) {
        if (this.#navigationRequest?.id !== request.id) {
            return;
        }
        this.#navigationResponseReceived?.resolve();
    }
    #onResponse(response) {
        if (this.#navigationRequest?.id !== response.request().id) {
            return;
        }
        this.#navigationResponseReceived?.resolve();
    }
    #onFrameDetached(frame) {
        if (this.#frame === frame) {
            this.#error.message = 'Navigating frame was detached';
            this.#terminationDeferred.resolve(this.#error);
            return;
        }
        this.#checkLifecycleComplete();
    }
    async navigationResponse() {
        await this.#navigationResponseReceived?.valueOrThrow();
        return this.#navigationRequest ? this.#navigationRequest.response() : null;
    }
    sameDocumentNavigationPromise() {
        return this.#sameDocumentNavigationDeferred.valueOrThrow();
    }
    newDocumentNavigationPromise() {
        return this.#newDocumentNavigationDeferred.valueOrThrow();
    }
    lifecyclePromise() {
        return this.#lifecycleDeferred.valueOrThrow();
    }
    terminationPromise() {
        return this.#terminationDeferred.valueOrThrow();
    }
    #navigatedWithinDocument() {
        this.#hasSameDocumentNavigation = true;
        this.#checkLifecycleComplete();
    }
    #navigated(navigationType) {
        if (navigationType === 'BackForwardCacheRestore') {
            return this.#frameSwapped();
        }
        this.#checkLifecycleComplete();
    }
    #frameSwapped() {
        this.#swapped = true;
        this.#checkLifecycleComplete();
    }
    #checkLifecycleComplete() {
        if (!checkLifecycle(this.#frame, this.#expectedLifecycle)) {
            return;
        }
        this.#lifecycleDeferred.resolve();
        if (this.#hasSameDocumentNavigation) {
            this.#sameDocumentNavigationDeferred.resolve(undefined);
        }
        if (this.#swapped || this.#frame._loaderId !== this.#initialLoaderId) {
            this.#newDocumentNavigationDeferred.resolve(undefined);
        }
        function checkLifecycle(frame, expectedLifecycle) {
            for (const event of expectedLifecycle) {
                if (!frame._lifecycleEvents.has(event)) {
                    return false;
                }
            }
            for (const child of frame.childFrames()) {
                if (child._hasStartedLoading &&
                    !checkLifecycle(child, expectedLifecycle)) {
                    return false;
                }
            }
            return true;
        }
    }
    dispose() {
        this.#subscriptions.dispose();
        this.#error.cause = new Error('LifecycleWatcher disposed');
        this.#terminationDeferred.resolve(this.#error);
    }
}

/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var __runInitializers$2 = (undefined && undefined.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate$2 = (undefined && undefined.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
let CdpFrame = (() => {
    let _classSuper = Frame;
    let _instanceExtraInitializers = [];
    let _goto_decorators;
    let _waitForNavigation_decorators;
    let _setContent_decorators;
    let _addPreloadScript_decorators;
    let _addExposedFunctionBinding_decorators;
    let _removeExposedFunctionBinding_decorators;
    let _waitForDevicePrompt_decorators;
    return class CdpFrame extends _classSuper {
        static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
            __esDecorate$2(this, null, _goto_decorators, { kind: "method", name: "goto", static: false, private: false, access: { has: obj => "goto" in obj, get: obj => obj.goto }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate$2(this, null, _waitForNavigation_decorators, { kind: "method", name: "waitForNavigation", static: false, private: false, access: { has: obj => "waitForNavigation" in obj, get: obj => obj.waitForNavigation }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate$2(this, null, _setContent_decorators, { kind: "method", name: "setContent", static: false, private: false, access: { has: obj => "setContent" in obj, get: obj => obj.setContent }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate$2(this, null, _addPreloadScript_decorators, { kind: "method", name: "addPreloadScript", static: false, private: false, access: { has: obj => "addPreloadScript" in obj, get: obj => obj.addPreloadScript }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate$2(this, null, _addExposedFunctionBinding_decorators, { kind: "method", name: "addExposedFunctionBinding", static: false, private: false, access: { has: obj => "addExposedFunctionBinding" in obj, get: obj => obj.addExposedFunctionBinding }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate$2(this, null, _removeExposedFunctionBinding_decorators, { kind: "method", name: "removeExposedFunctionBinding", static: false, private: false, access: { has: obj => "removeExposedFunctionBinding" in obj, get: obj => obj.removeExposedFunctionBinding }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate$2(this, null, _waitForDevicePrompt_decorators, { kind: "method", name: "waitForDevicePrompt", static: false, private: false, access: { has: obj => "waitForDevicePrompt" in obj, get: obj => obj.waitForDevicePrompt }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        #url = (__runInitializers$2(this, _instanceExtraInitializers), '');
        #detached = false;
        #client;
        _frameManager;
        _loaderId = '';
        _lifecycleEvents = new Set();
        _id;
        _parentId;
        accessibility;
        worlds;
        constructor(frameManager, frameId, parentFrameId, client) {
            super();
            this._frameManager = frameManager;
            this.#url = '';
            this._id = frameId;
            this._parentId = parentFrameId;
            this.#detached = false;
            this.#client = client;
            this._loaderId = '';
            this.worlds = {
                [MAIN_WORLD]: new IsolatedWorld(this, this._frameManager.timeoutSettings),
                [PUPPETEER_WORLD]: new IsolatedWorld(this, this._frameManager.timeoutSettings),
            };
            this.accessibility = new Accessibility(this.worlds[MAIN_WORLD], frameId);
            this.on(FrameEvent.FrameSwappedByActivation, () => {
                this._onLoadingStarted();
                this._onLoadingStopped();
            });
            this.worlds[MAIN_WORLD].emitter.on('consoleapicalled', this.#onMainWorldConsoleApiCalled.bind(this));
            this.worlds[MAIN_WORLD].emitter.on('bindingcalled', this.#onMainWorldBindingCalled.bind(this));
        }
        #onMainWorldConsoleApiCalled(event) {
            this._frameManager.emit(FrameManagerEvent.ConsoleApiCalled, [
                this.worlds[MAIN_WORLD],
                event,
            ]);
        }
        #onMainWorldBindingCalled(event) {
            this._frameManager.emit(FrameManagerEvent.BindingCalled, [
                this.worlds[MAIN_WORLD],
                event,
            ]);
        }
        _client() {
            return this.#client;
        }
        updateId(id) {
            this._id = id;
        }
        updateClient(client) {
            this.#client = client;
        }
        page() {
            return this._frameManager.page();
        }
        async goto(url, options = {}) {
            const { referer = this._frameManager.networkManager.extraHTTPHeaders()['referer'], referrerPolicy = this._frameManager.networkManager.extraHTTPHeaders()['referer-policy'], waitUntil = ['load'], timeout = this._frameManager.timeoutSettings.navigationTimeout(), } = options;
            let ensureNewDocumentNavigation = false;
            const watcher = new LifecycleWatcher(this._frameManager.networkManager, this, waitUntil, timeout);
            let error = await Deferred.race([
                navigate(this.#client, url, referer, referrerPolicy ? referrerPolicyToProtocol(referrerPolicy) : undefined, this._id),
                watcher.terminationPromise(),
            ]);
            if (!error) {
                error = await Deferred.race([
                    watcher.terminationPromise(),
                    ensureNewDocumentNavigation
                        ? watcher.newDocumentNavigationPromise()
                        : watcher.sameDocumentNavigationPromise(),
                ]);
            }
            try {
                if (error) {
                    throw error;
                }
                return await watcher.navigationResponse();
            }
            finally {
                watcher.dispose();
            }
            async function navigate(client, url, referrer, referrerPolicy, frameId) {
                try {
                    const response = await client.send('Page.navigate', {
                        url,
                        referrer,
                        frameId,
                        referrerPolicy,
                    });
                    ensureNewDocumentNavigation = !!response.loaderId;
                    if (response.errorText === 'net::ERR_HTTP_RESPONSE_CODE_FAILURE') {
                        return null;
                    }
                    return response.errorText
                        ? new Error(`${response.errorText} at ${url}`)
                        : null;
                }
                catch (error) {
                    if (isErrorLike$1(error)) {
                        return error;
                    }
                    throw error;
                }
            }
        }
        async waitForNavigation(options = {}) {
            const { waitUntil = ['load'], timeout = this._frameManager.timeoutSettings.navigationTimeout(), signal, } = options;
            const watcher = new LifecycleWatcher(this._frameManager.networkManager, this, waitUntil, timeout, signal);
            const error = await Deferred.race([
                watcher.terminationPromise(),
                ...(options.ignoreSameDocumentNavigation
                    ? []
                    : [watcher.sameDocumentNavigationPromise()]),
                watcher.newDocumentNavigationPromise(),
            ]);
            try {
                if (error) {
                    throw error;
                }
                const result = await Deferred.race([watcher.terminationPromise(), watcher.navigationResponse()]);
                if (result instanceof Error) {
                    throw error;
                }
                return result || null;
            }
            finally {
                watcher.dispose();
            }
        }
        get client() {
            return this.#client;
        }
        mainRealm() {
            return this.worlds[MAIN_WORLD];
        }
        isolatedRealm() {
            return this.worlds[PUPPETEER_WORLD];
        }
        async setContent(html, options = {}) {
            const { waitUntil = ['load'], timeout = this._frameManager.timeoutSettings.navigationTimeout(), } = options;
            await this.setFrameContent(html);
            const watcher = new LifecycleWatcher(this._frameManager.networkManager, this, waitUntil, timeout);
            const error = await Deferred.race([
                watcher.terminationPromise(),
                watcher.lifecyclePromise(),
            ]);
            watcher.dispose();
            if (error) {
                throw error;
            }
        }
        url() {
            return this.#url;
        }
        parentFrame() {
            return this._frameManager._frameTree.parentFrame(this._id) || null;
        }
        childFrames() {
            return this._frameManager._frameTree.childFrames(this._id);
        }
        #deviceRequestPromptManager() {
            return this._frameManager._deviceRequestPromptManager(this.#client);
        }
        async addPreloadScript(preloadScript) {
            const parentFrame = this.parentFrame();
            if (parentFrame && this.#client === parentFrame.client) {
                return;
            }
            if (preloadScript.getIdForFrame(this)) {
                return;
            }
            const { identifier } = await this.#client.send('Page.addScriptToEvaluateOnNewDocument', {
                source: preloadScript.source,
            });
            preloadScript.setIdForFrame(this, identifier);
        }
        async addExposedFunctionBinding(binding) {
            if (this !== this._frameManager.mainFrame() && !this._hasStartedLoading) {
                return;
            }
            await Promise.all([
                this.#client.send('Runtime.addBinding', {
                    name: CDP_BINDING_PREFIX + binding.name,
                }),
                this.evaluate(binding.initSource).catch(debugError),
            ]);
        }
        async removeExposedFunctionBinding(binding) {
            if (this !== this._frameManager.mainFrame() && !this._hasStartedLoading) {
                return;
            }
            await Promise.all([
                this.#client.send('Runtime.removeBinding', {
                    name: CDP_BINDING_PREFIX + binding.name,
                }),
                this.evaluate(name => {
                    globalThis[name] = undefined;
                }, binding.name).catch(debugError),
            ]);
        }
        async waitForDevicePrompt(options = {}) {
            return await this.#deviceRequestPromptManager().waitForDevicePrompt(options);
        }
        _navigated(framePayload) {
            this._name = framePayload.name;
            this.#url = `${framePayload.url}${framePayload.urlFragment || ''}`;
        }
        _navigatedWithinDocument(url) {
            this.#url = url;
        }
        _onLifecycleEvent(loaderId, name) {
            if (name === 'init') {
                this._loaderId = loaderId;
                this._lifecycleEvents.clear();
            }
            this._lifecycleEvents.add(name);
        }
        _onLoadingStopped() {
            this._lifecycleEvents.add('DOMContentLoaded');
            this._lifecycleEvents.add('load');
        }
        _onLoadingStarted() {
            this._hasStartedLoading = true;
        }
        get detached() {
            return this.#detached;
        }
        [(_goto_decorators = [throwIfDetached], _waitForNavigation_decorators = [throwIfDetached], _setContent_decorators = [throwIfDetached], _addPreloadScript_decorators = [throwIfDetached], _addExposedFunctionBinding_decorators = [throwIfDetached], _removeExposedFunctionBinding_decorators = [throwIfDetached], _waitForDevicePrompt_decorators = [throwIfDetached], disposeSymbol)]() {
            if (this.#detached) {
                return;
            }
            this.#detached = true;
            this.worlds[MAIN_WORLD][disposeSymbol]();
            this.worlds[PUPPETEER_WORLD][disposeSymbol]();
        }
        exposeFunction() {
            throw new UnsupportedOperation();
        }
        async frameElement() {
            const parent = this.parentFrame();
            if (!parent) {
                return null;
            }
            const { backendNodeId } = await parent.client.send('DOM.getFrameOwner', {
                frameId: this._id,
            });
            return (await parent
                .mainRealm()
                .adoptBackendNode(backendNodeId));
        }
    };
})();
function referrerPolicyToProtocol(referrerPolicy) {
    return referrerPolicy.replaceAll(/-./g, match => {
        return match[1].toUpperCase();
    });
}

/**
 * @license
 * Copyright 2022 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class FrameTree {
    #frames = new Map();
    #parentIds = new Map();
    #childIds = new Map();
    #mainFrame;
    #isMainFrameStale = false;
    #waitRequests = new Map();
    getMainFrame() {
        return this.#mainFrame;
    }
    getById(frameId) {
        return this.#frames.get(frameId);
    }
    waitForFrame(frameId) {
        const frame = this.getById(frameId);
        if (frame) {
            return Promise.resolve(frame);
        }
        const deferred = Deferred.create();
        const callbacks = this.#waitRequests.get(frameId) || new Set();
        callbacks.add(deferred);
        return deferred.valueOrThrow();
    }
    frames() {
        return Array.from(this.#frames.values());
    }
    addFrame(frame) {
        this.#frames.set(frame._id, frame);
        if (frame._parentId) {
            this.#parentIds.set(frame._id, frame._parentId);
            if (!this.#childIds.has(frame._parentId)) {
                this.#childIds.set(frame._parentId, new Set());
            }
            this.#childIds.get(frame._parentId).add(frame._id);
        }
        else if (!this.#mainFrame || this.#isMainFrameStale) {
            this.#mainFrame = frame;
            this.#isMainFrameStale = false;
        }
        this.#waitRequests.get(frame._id)?.forEach(request => {
            return request.resolve(frame);
        });
    }
    removeFrame(frame) {
        this.#frames.delete(frame._id);
        this.#parentIds.delete(frame._id);
        if (frame._parentId) {
            this.#childIds.get(frame._parentId)?.delete(frame._id);
        }
        else {
            this.#isMainFrameStale = true;
        }
    }
    childFrames(frameId) {
        const childIds = this.#childIds.get(frameId);
        if (!childIds) {
            return [];
        }
        return Array.from(childIds)
            .map(id => {
            return this.getById(id);
        })
            .filter((frame) => {
            return frame !== undefined;
        });
    }
    parentFrame(frameId) {
        const parentId = this.#parentIds.get(frameId);
        return parentId ? this.getById(parentId) : undefined;
    }
}

class CdpHTTPRequest extends HTTPRequest {
    id;
    #client;
    #isNavigationRequest;
    #url;
    #resourceType;
    #method;
    #hasPostData = false;
    #postData;
    #headers = {};
    #frame;
    #initiator;
    get client() {
        return this.#client;
    }
    set client(newClient) {
        this.#client = newClient;
    }
    constructor(client, frame, interceptionId, allowInterception, data, redirectChain) {
        super();
        this.#client = client;
        this.id = data.requestId;
        this.#isNavigationRequest =
            data.requestId === data.loaderId && data.type === 'Document';
        this._interceptionId = interceptionId;
        this.#url = data.request.url + (data.request.urlFragment ?? '');
        this.#resourceType = (data.type || 'other').toLowerCase();
        this.#method = data.request.method;
        this.#postData = data.request.postData;
        this.#hasPostData = data.request.hasPostData ?? false;
        this.#frame = frame;
        this._redirectChain = redirectChain;
        this.#initiator = data.initiator;
        this.interception.enabled = allowInterception;
        for (const [key, value] of Object.entries(data.request.headers)) {
            this.#headers[key.toLowerCase()] = value;
        }
    }
    url() {
        return this.#url;
    }
    resourceType() {
        return this.#resourceType;
    }
    method() {
        return this.#method;
    }
    postData() {
        return this.#postData;
    }
    hasPostData() {
        return this.#hasPostData;
    }
    async fetchPostData() {
        try {
            const result = await this.#client.send('Network.getRequestPostData', {
                requestId: this.id,
            });
            return result.postData;
        }
        catch (err) {
            debugError(err);
            return;
        }
    }
    headers() {
        return structuredClone(this.#headers);
    }
    response() {
        return this._response;
    }
    frame() {
        return this.#frame;
    }
    isNavigationRequest() {
        return this.#isNavigationRequest;
    }
    initiator() {
        return this.#initiator;
    }
    redirectChain() {
        return this._redirectChain.slice();
    }
    failure() {
        if (!this._failureText) {
            return null;
        }
        return {
            errorText: this._failureText,
        };
    }
    canBeIntercepted() {
        return !this.url().startsWith('data:') && !this._fromMemoryCache;
    }
    async _continue(overrides = {}) {
        const { url, method, postData, headers } = overrides;
        this.interception.handled = true;
        const postDataBinaryBase64 = postData
            ? stringToBase64(postData)
            : undefined;
        if (this._interceptionId === undefined) {
            throw new Error('HTTPRequest is missing _interceptionId needed for Fetch.continueRequest');
        }
        await this.#client
            .send('Fetch.continueRequest', {
            requestId: this._interceptionId,
            url,
            method,
            postData: postDataBinaryBase64,
            headers: headers ? headersArray(headers) : undefined,
        })
            .catch(error => {
            this.interception.handled = false;
            return handleError(error);
        });
    }
    async _respond(response) {
        this.interception.handled = true;
        let parsedBody;
        if (response.body) {
            parsedBody = HTTPRequest.getResponse(response.body);
        }
        const responseHeaders = {};
        if (response.headers) {
            for (const header of Object.keys(response.headers)) {
                const value = response.headers[header];
                responseHeaders[header.toLowerCase()] = Array.isArray(value)
                    ? value.map(item => {
                        return String(item);
                    })
                    : String(value);
            }
        }
        if (response.contentType) {
            responseHeaders['content-type'] = response.contentType;
        }
        if (parsedBody?.contentLength && !('content-length' in responseHeaders)) {
            responseHeaders['content-length'] = String(parsedBody.contentLength);
        }
        const status = response.status || 200;
        if (this._interceptionId === undefined) {
            throw new Error('HTTPRequest is missing _interceptionId needed for Fetch.fulfillRequest');
        }
        await this.#client
            .send('Fetch.fulfillRequest', {
            requestId: this._interceptionId,
            responseCode: status,
            responsePhrase: STATUS_TEXTS[status],
            responseHeaders: headersArray(responseHeaders),
            body: parsedBody?.base64,
        })
            .catch(error => {
            this.interception.handled = false;
            return handleError(error);
        });
    }
    async _abort(errorReason) {
        this.interception.handled = true;
        if (this._interceptionId === undefined) {
            throw new Error('HTTPRequest is missing _interceptionId needed for Fetch.failRequest');
        }
        await this.#client
            .send('Fetch.failRequest', {
            requestId: this._interceptionId,
            errorReason: errorReason || 'Failed',
        })
            .catch(handleError);
    }
}

/**
 * @license
 * Copyright 2020 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class SecurityDetails {
    #subjectName;
    #issuer;
    #validFrom;
    #validTo;
    #protocol;
    #sanList;
    constructor(securityPayload) {
        this.#subjectName = securityPayload.subjectName;
        this.#issuer = securityPayload.issuer;
        this.#validFrom = securityPayload.validFrom;
        this.#validTo = securityPayload.validTo;
        this.#protocol = securityPayload.protocol;
        this.#sanList = securityPayload.sanList;
    }
    issuer() {
        return this.#issuer;
    }
    validFrom() {
        return this.#validFrom;
    }
    validTo() {
        return this.#validTo;
    }
    protocol() {
        return this.#protocol;
    }
    subjectName() {
        return this.#subjectName;
    }
    subjectAlternativeNames() {
        return this.#sanList;
    }
}

class CdpHTTPResponse extends HTTPResponse {
    #request;
    #contentPromise = null;
    #bodyLoadedDeferred = Deferred.create();
    #remoteAddress;
    #status;
    #statusText;
    #fromDiskCache;
    #fromServiceWorker;
    #headers = {};
    #securityDetails;
    #timing;
    constructor(request, responsePayload, extraInfo) {
        super();
        this.#request = request;
        this.#remoteAddress = {
            ip: responsePayload.remoteIPAddress,
            port: responsePayload.remotePort,
        };
        this.#statusText =
            this.#parseStatusTextFromExtraInfo(extraInfo) ||
                responsePayload.statusText;
        this.#fromDiskCache = !!responsePayload.fromDiskCache;
        this.#fromServiceWorker = !!responsePayload.fromServiceWorker;
        this.#status = extraInfo ? extraInfo.statusCode : responsePayload.status;
        const headers = extraInfo ? extraInfo.headers : responsePayload.headers;
        for (const [key, value] of Object.entries(headers)) {
            this.#headers[key.toLowerCase()] = value;
        }
        this.#securityDetails = responsePayload.securityDetails
            ? new SecurityDetails(responsePayload.securityDetails)
            : null;
        this.#timing = responsePayload.timing || null;
    }
    #parseStatusTextFromExtraInfo(extraInfo) {
        if (!extraInfo || !extraInfo.headersText) {
            return;
        }
        const firstLine = extraInfo.headersText.split('\r', 1)[0];
        if (!firstLine || firstLine.length > 1_000) {
            return;
        }
        const match = firstLine.match(/[^ ]* [^ ]* (.*)/);
        if (!match) {
            return;
        }
        const statusText = match[1];
        if (!statusText) {
            return;
        }
        return statusText;
    }
    _resolveBody(err) {
        if (err) {
            return this.#bodyLoadedDeferred.reject(err);
        }
        return this.#bodyLoadedDeferred.resolve();
    }
    remoteAddress() {
        return this.#remoteAddress;
    }
    url() {
        return this.#request.url();
    }
    status() {
        return this.#status;
    }
    statusText() {
        return this.#statusText;
    }
    headers() {
        return this.#headers;
    }
    securityDetails() {
        return this.#securityDetails;
    }
    timing() {
        return this.#timing;
    }
    content() {
        if (!this.#contentPromise) {
            this.#contentPromise = this.#bodyLoadedDeferred
                .valueOrThrow()
                .then(async () => {
                try {
                    const response = await this.#request.client.send('Network.getResponseBody', {
                        requestId: this.#request.id,
                    });
                    return stringToTypedArray(response.body, response.base64Encoded);
                }
                catch (error) {
                    if (error instanceof ProtocolError &&
                        error.originalMessage ===
                            'No resource with given identifier found') {
                        throw new ProtocolError('Could not load response body for this request. This might happen if the request is a preflight request.');
                    }
                    throw error;
                }
            });
        }
        return this.#contentPromise;
    }
    request() {
        return this.#request;
    }
    fromCache() {
        return this.#fromDiskCache || this.#request._fromMemoryCache;
    }
    fromServiceWorker() {
        return this.#fromServiceWorker;
    }
    frame() {
        return this.#request.frame();
    }
}

/**
 * @license
 * Copyright 2022 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class NetworkEventManager {
    #requestWillBeSentMap = new Map();
    #requestPausedMap = new Map();
    #httpRequestsMap = new Map();
    #responseReceivedExtraInfoMap = new Map();
    #queuedRedirectInfoMap = new Map();
    #queuedEventGroupMap = new Map();
    forget(networkRequestId) {
        this.#requestWillBeSentMap.delete(networkRequestId);
        this.#requestPausedMap.delete(networkRequestId);
        this.#queuedEventGroupMap.delete(networkRequestId);
        this.#queuedRedirectInfoMap.delete(networkRequestId);
        this.#responseReceivedExtraInfoMap.delete(networkRequestId);
    }
    responseExtraInfo(networkRequestId) {
        if (!this.#responseReceivedExtraInfoMap.has(networkRequestId)) {
            this.#responseReceivedExtraInfoMap.set(networkRequestId, []);
        }
        return this.#responseReceivedExtraInfoMap.get(networkRequestId);
    }
    queuedRedirectInfo(fetchRequestId) {
        if (!this.#queuedRedirectInfoMap.has(fetchRequestId)) {
            this.#queuedRedirectInfoMap.set(fetchRequestId, []);
        }
        return this.#queuedRedirectInfoMap.get(fetchRequestId);
    }
    queueRedirectInfo(fetchRequestId, redirectInfo) {
        this.queuedRedirectInfo(fetchRequestId).push(redirectInfo);
    }
    takeQueuedRedirectInfo(fetchRequestId) {
        return this.queuedRedirectInfo(fetchRequestId).shift();
    }
    inFlightRequestsCount() {
        let inFlightRequestCounter = 0;
        for (const request of this.#httpRequestsMap.values()) {
            if (!request.response()) {
                inFlightRequestCounter++;
            }
        }
        return inFlightRequestCounter;
    }
    storeRequestWillBeSent(networkRequestId, event) {
        this.#requestWillBeSentMap.set(networkRequestId, event);
    }
    getRequestWillBeSent(networkRequestId) {
        return this.#requestWillBeSentMap.get(networkRequestId);
    }
    forgetRequestWillBeSent(networkRequestId) {
        this.#requestWillBeSentMap.delete(networkRequestId);
    }
    getRequestPaused(networkRequestId) {
        return this.#requestPausedMap.get(networkRequestId);
    }
    forgetRequestPaused(networkRequestId) {
        this.#requestPausedMap.delete(networkRequestId);
    }
    storeRequestPaused(networkRequestId, event) {
        this.#requestPausedMap.set(networkRequestId, event);
    }
    getRequest(networkRequestId) {
        return this.#httpRequestsMap.get(networkRequestId);
    }
    storeRequest(networkRequestId, request) {
        this.#httpRequestsMap.set(networkRequestId, request);
    }
    forgetRequest(networkRequestId) {
        this.#httpRequestsMap.delete(networkRequestId);
    }
    getQueuedEventGroup(networkRequestId) {
        return this.#queuedEventGroupMap.get(networkRequestId);
    }
    queueEventGroup(networkRequestId, event) {
        this.#queuedEventGroupMap.set(networkRequestId, event);
    }
    forgetQueuedEventGroup(networkRequestId) {
        this.#queuedEventGroupMap.delete(networkRequestId);
    }
    printState() {
        function replacer(_key, value) {
            if (value instanceof Map) {
                return {
                    dataType: 'Map',
                    value: Array.from(value.entries()),
                };
            }
            else if (value instanceof CdpHTTPRequest) {
                return {
                    dataType: 'CdpHTTPRequest',
                    value: `${value.id}: ${value.url()}`,
                };
            }
            {
                return value;
            }
        }
        console.log('httpRequestsMap', JSON.stringify(this.#httpRequestsMap, replacer, 2));
        console.log('requestWillBeSentMap', JSON.stringify(this.#requestWillBeSentMap, replacer, 2));
        console.log('requestWillBeSentMap', JSON.stringify(this.#responseReceivedExtraInfoMap, replacer, 2));
        console.log('requestWillBeSentMap', JSON.stringify(this.#requestPausedMap, replacer, 2));
    }
}

/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class NetworkManager extends EventEmitter {
    #frameManager;
    #networkEventManager = new NetworkEventManager();
    #extraHTTPHeaders;
    #credentials = null;
    #attemptedAuthentications = new Set();
    #userRequestInterceptionEnabled = false;
    #protocolRequestInterceptionEnabled;
    #userCacheDisabled;
    #emulatedNetworkConditions;
    #userAgent;
    #userAgentMetadata;
    #platform;
    #handlers = [
        ['Fetch.requestPaused', this.#onRequestPaused],
        ['Fetch.authRequired', this.#onAuthRequired],
        ['Network.requestWillBeSent', this.#onRequestWillBeSent],
        ['Network.requestServedFromCache', this.#onRequestServedFromCache],
        ['Network.responseReceived', this.#onResponseReceived],
        ['Network.loadingFinished', this.#onLoadingFinished],
        ['Network.loadingFailed', this.#onLoadingFailed],
        ['Network.responseReceivedExtraInfo', this.#onResponseReceivedExtraInfo],
        [CDPSessionEvent.Disconnected, this.#removeClient],
    ];
    #clients = new Map();
    #networkEnabled = true;
    constructor(frameManager, networkEnabled) {
        super();
        this.#frameManager = frameManager;
        this.#networkEnabled = networkEnabled ?? true;
    }
    #canIgnoreError(error) {
        return (isErrorLike$1(error) &&
            (isTargetClosedError(error) || error.message.includes('Not supported')));
    }
    async addClient(client) {
        if (!this.#networkEnabled || this.#clients.has(client)) {
            return;
        }
        const subscriptions = new DisposableStack();
        this.#clients.set(client, subscriptions);
        const clientEmitter = subscriptions.use(new EventEmitter(client));
        for (const [event, handler] of this.#handlers) {
            clientEmitter.on(event, (arg) => {
                return handler.bind(this)(client, arg);
            });
        }
        try {
            await Promise.all([
                client.send('Network.enable'),
                this.#applyExtraHTTPHeaders(client),
                this.#applyNetworkConditions(client),
                this.#applyProtocolCacheDisabled(client),
                this.#applyProtocolRequestInterception(client),
                this.#applyUserAgent(client),
            ]);
        }
        catch (error) {
            if (this.#canIgnoreError(error)) {
                return;
            }
            throw error;
        }
    }
    async #removeClient(client) {
        this.#clients.get(client)?.dispose();
        this.#clients.delete(client);
    }
    async authenticate(credentials) {
        this.#credentials = credentials;
        const enabled = this.#userRequestInterceptionEnabled || !!this.#credentials;
        if (enabled === this.#protocolRequestInterceptionEnabled) {
            return;
        }
        this.#protocolRequestInterceptionEnabled = enabled;
        await this.#applyToAllClients(this.#applyProtocolRequestInterception.bind(this));
    }
    async setExtraHTTPHeaders(headers) {
        const extraHTTPHeaders = {};
        for (const [key, value] of Object.entries(headers)) {
            assert(isString(value), `Expected value of header "${key}" to be String, but "${typeof value}" is found.`);
            extraHTTPHeaders[key.toLowerCase()] = value;
        }
        this.#extraHTTPHeaders = extraHTTPHeaders;
        await this.#applyToAllClients(this.#applyExtraHTTPHeaders.bind(this));
    }
    async #applyExtraHTTPHeaders(client) {
        if (this.#extraHTTPHeaders === undefined) {
            return;
        }
        try {
            await client.send('Network.setExtraHTTPHeaders', {
                headers: this.#extraHTTPHeaders,
            });
        }
        catch (error) {
            if (this.#canIgnoreError(error)) {
                return;
            }
            throw error;
        }
    }
    extraHTTPHeaders() {
        return Object.assign({}, this.#extraHTTPHeaders);
    }
    inFlightRequestsCount() {
        return this.#networkEventManager.inFlightRequestsCount();
    }
    async setOfflineMode(value) {
        if (!this.#emulatedNetworkConditions) {
            this.#emulatedNetworkConditions = {
                offline: false,
                upload: -1,
                download: -1,
                latency: 0,
            };
        }
        this.#emulatedNetworkConditions.offline = value;
        await this.#applyToAllClients(this.#applyNetworkConditions.bind(this));
    }
    async emulateNetworkConditions(networkConditions) {
        if (!this.#emulatedNetworkConditions) {
            this.#emulatedNetworkConditions = {
                offline: networkConditions?.offline ?? false,
                upload: -1,
                download: -1,
                latency: 0,
            };
        }
        this.#emulatedNetworkConditions.upload = networkConditions
            ? networkConditions.upload
            : -1;
        this.#emulatedNetworkConditions.download = networkConditions
            ? networkConditions.download
            : -1;
        this.#emulatedNetworkConditions.latency = networkConditions
            ? networkConditions.latency
            : 0;
        this.#emulatedNetworkConditions.offline =
            networkConditions?.offline ?? false;
        await this.#applyToAllClients(this.#applyNetworkConditions.bind(this));
    }
    async #applyToAllClients(fn) {
        await Promise.all(Array.from(this.#clients.keys()).map(client => {
            return fn(client);
        }));
    }
    async #applyNetworkConditions(client) {
        if (this.#emulatedNetworkConditions === undefined) {
            return;
        }
        try {
            await client.send('Network.emulateNetworkConditions', {
                offline: this.#emulatedNetworkConditions.offline,
                latency: this.#emulatedNetworkConditions.latency,
                uploadThroughput: this.#emulatedNetworkConditions.upload,
                downloadThroughput: this.#emulatedNetworkConditions.download,
            });
        }
        catch (error) {
            if (this.#canIgnoreError(error)) {
                return;
            }
            throw error;
        }
    }
    async setUserAgent(userAgent, userAgentMetadata, platform) {
        this.#userAgent = userAgent;
        this.#userAgentMetadata = userAgentMetadata;
        this.#platform = platform;
        await this.#applyToAllClients(this.#applyUserAgent.bind(this));
    }
    async #applyUserAgent(client) {
        if (this.#userAgent === undefined) {
            return;
        }
        try {
            await client.send('Network.setUserAgentOverride', {
                userAgent: this.#userAgent,
                userAgentMetadata: this.#userAgentMetadata,
                platform: this.#platform,
            });
        }
        catch (error) {
            if (this.#canIgnoreError(error)) {
                return;
            }
            throw error;
        }
    }
    async setCacheEnabled(enabled) {
        this.#userCacheDisabled = !enabled;
        await this.#applyToAllClients(this.#applyProtocolCacheDisabled.bind(this));
    }
    async setRequestInterception(value) {
        this.#userRequestInterceptionEnabled = value;
        const enabled = this.#userRequestInterceptionEnabled || !!this.#credentials;
        if (enabled === this.#protocolRequestInterceptionEnabled) {
            return;
        }
        this.#protocolRequestInterceptionEnabled = enabled;
        await this.#applyToAllClients(this.#applyProtocolRequestInterception.bind(this));
    }
    async #applyProtocolRequestInterception(client) {
        if (this.#protocolRequestInterceptionEnabled === undefined) {
            return;
        }
        if (this.#userCacheDisabled === undefined) {
            this.#userCacheDisabled = false;
        }
        try {
            if (this.#protocolRequestInterceptionEnabled) {
                await Promise.all([
                    this.#applyProtocolCacheDisabled(client),
                    client.send('Fetch.enable', {
                        handleAuthRequests: true,
                        patterns: [{ urlPattern: '*' }],
                    }),
                ]);
            }
            else {
                await Promise.all([
                    this.#applyProtocolCacheDisabled(client),
                    client.send('Fetch.disable'),
                ]);
            }
        }
        catch (error) {
            if (this.#canIgnoreError(error)) {
                return;
            }
            throw error;
        }
    }
    async #applyProtocolCacheDisabled(client) {
        if (this.#userCacheDisabled === undefined) {
            return;
        }
        try {
            await client.send('Network.setCacheDisabled', {
                cacheDisabled: this.#userCacheDisabled,
            });
        }
        catch (error) {
            if (this.#canIgnoreError(error)) {
                return;
            }
            throw error;
        }
    }
    #onRequestWillBeSent(client, event) {
        if (this.#userRequestInterceptionEnabled &&
            !event.request.url.startsWith('data:')) {
            const { requestId: networkRequestId } = event;
            this.#networkEventManager.storeRequestWillBeSent(networkRequestId, event);
            const requestPausedEvent = this.#networkEventManager.getRequestPaused(networkRequestId);
            if (requestPausedEvent) {
                const { requestId: fetchRequestId } = requestPausedEvent;
                this.#patchRequestEventHeaders(event, requestPausedEvent);
                this.#onRequest(client, event, fetchRequestId);
                this.#networkEventManager.forgetRequestPaused(networkRequestId);
            }
            return;
        }
        this.#onRequest(client, event, undefined);
    }
    #onAuthRequired(client, event) {
        let response = 'Default';
        if (this.#attemptedAuthentications.has(event.requestId)) {
            response = 'CancelAuth';
        }
        else if (this.#credentials) {
            response = 'ProvideCredentials';
            this.#attemptedAuthentications.add(event.requestId);
        }
        const { username, password } = this.#credentials || {
            username: undefined,
            password: undefined,
        };
        client
            .send('Fetch.continueWithAuth', {
            requestId: event.requestId,
            authChallengeResponse: { response, username, password },
        })
            .catch(debugError);
    }
    #onRequestPaused(client, event) {
        if (!this.#userRequestInterceptionEnabled &&
            this.#protocolRequestInterceptionEnabled) {
            client
                .send('Fetch.continueRequest', {
                requestId: event.requestId,
            })
                .catch(debugError);
        }
        const { networkId: networkRequestId, requestId: fetchRequestId } = event;
        if (!networkRequestId) {
            this.#onRequestWithoutNetworkInstrumentation(client, event);
            return;
        }
        const requestWillBeSentEvent = (() => {
            const requestWillBeSentEvent = this.#networkEventManager.getRequestWillBeSent(networkRequestId);
            if (requestWillBeSentEvent &&
                (requestWillBeSentEvent.request.url !== event.request.url ||
                    requestWillBeSentEvent.request.method !== event.request.method)) {
                this.#networkEventManager.forgetRequestWillBeSent(networkRequestId);
                return;
            }
            return requestWillBeSentEvent;
        })();
        if (requestWillBeSentEvent) {
            this.#patchRequestEventHeaders(requestWillBeSentEvent, event);
            this.#onRequest(client, requestWillBeSentEvent, fetchRequestId);
        }
        else {
            this.#networkEventManager.storeRequestPaused(networkRequestId, event);
        }
    }
    #patchRequestEventHeaders(requestWillBeSentEvent, requestPausedEvent) {
        requestWillBeSentEvent.request.headers = {
            ...requestWillBeSentEvent.request.headers,
            ...requestPausedEvent.request.headers,
        };
    }
    #onRequestWithoutNetworkInstrumentation(client, event) {
        const frame = event.frameId
            ? this.#frameManager.frame(event.frameId)
            : null;
        const request = new CdpHTTPRequest(client, frame, event.requestId, this.#userRequestInterceptionEnabled, event, []);
        this.emit(NetworkManagerEvent.Request, request);
        void request.finalizeInterceptions();
    }
    #onRequest(client, event, fetchRequestId, fromMemoryCache = false) {
        let redirectChain = [];
        if (event.redirectResponse) {
            let redirectResponseExtraInfo = null;
            if (event.redirectHasExtraInfo) {
                redirectResponseExtraInfo = this.#networkEventManager
                    .responseExtraInfo(event.requestId)
                    .shift();
                if (!redirectResponseExtraInfo) {
                    this.#networkEventManager.queueRedirectInfo(event.requestId, {
                        event,
                        fetchRequestId,
                    });
                    return;
                }
            }
            const request = this.#networkEventManager.getRequest(event.requestId);
            if (request) {
                this.#handleRequestRedirect(client, request, event.redirectResponse, redirectResponseExtraInfo);
                redirectChain = request._redirectChain;
            }
        }
        const frame = event.frameId
            ? this.#frameManager.frame(event.frameId)
            : null;
        const request = new CdpHTTPRequest(client, frame, fetchRequestId, this.#userRequestInterceptionEnabled, event, redirectChain);
        request._fromMemoryCache = fromMemoryCache;
        this.#networkEventManager.storeRequest(event.requestId, request);
        this.emit(NetworkManagerEvent.Request, request);
        void request.finalizeInterceptions();
    }
    #onRequestServedFromCache(client, event) {
        const requestWillBeSentEvent = this.#networkEventManager.getRequestWillBeSent(event.requestId);
        let request = this.#networkEventManager.getRequest(event.requestId);
        if (request) {
            request._fromMemoryCache = true;
        }
        if (!request && requestWillBeSentEvent) {
            this.#onRequest(client, requestWillBeSentEvent, undefined, true);
            request = this.#networkEventManager.getRequest(event.requestId);
        }
        if (!request) {
            debugError(new Error(`Request ${event.requestId} was served from cache but we could not find the corresponding request object`));
            return;
        }
        this.emit(NetworkManagerEvent.RequestServedFromCache, request);
    }
    #handleRequestRedirect(_client, request, responsePayload, extraInfo) {
        const response = new CdpHTTPResponse(request, responsePayload, extraInfo);
        request._response = response;
        request._redirectChain.push(request);
        response._resolveBody(new Error('Response body is unavailable for redirect responses'));
        this.#forgetRequest(request, false);
        this.emit(NetworkManagerEvent.Response, response);
        this.emit(NetworkManagerEvent.RequestFinished, request);
    }
    #emitResponseEvent(_client, responseReceived, extraInfo) {
        const request = this.#networkEventManager.getRequest(responseReceived.requestId);
        if (!request) {
            return;
        }
        const extraInfos = this.#networkEventManager.responseExtraInfo(responseReceived.requestId);
        if (extraInfos.length) {
            debugError(new Error('Unexpected extraInfo events for request ' +
                responseReceived.requestId));
        }
        if (responseReceived.response.fromDiskCache) {
            extraInfo = null;
        }
        const response = new CdpHTTPResponse(request, responseReceived.response, extraInfo);
        request._response = response;
        this.emit(NetworkManagerEvent.Response, response);
    }
    #onResponseReceived(client, event) {
        const request = this.#networkEventManager.getRequest(event.requestId);
        let extraInfo = null;
        if (request && !request._fromMemoryCache && event.hasExtraInfo) {
            extraInfo = this.#networkEventManager
                .responseExtraInfo(event.requestId)
                .shift();
            if (!extraInfo) {
                this.#networkEventManager.queueEventGroup(event.requestId, {
                    responseReceivedEvent: event,
                });
                return;
            }
        }
        this.#emitResponseEvent(client, event, extraInfo);
    }
    #onResponseReceivedExtraInfo(client, event) {
        const redirectInfo = this.#networkEventManager.takeQueuedRedirectInfo(event.requestId);
        if (redirectInfo) {
            this.#networkEventManager.responseExtraInfo(event.requestId).push(event);
            this.#onRequest(client, redirectInfo.event, redirectInfo.fetchRequestId);
            return;
        }
        const queuedEvents = this.#networkEventManager.getQueuedEventGroup(event.requestId);
        if (queuedEvents) {
            this.#networkEventManager.forgetQueuedEventGroup(event.requestId);
            this.#emitResponseEvent(client, queuedEvents.responseReceivedEvent, event);
            if (queuedEvents.loadingFinishedEvent) {
                this.#emitLoadingFinished(client, queuedEvents.loadingFinishedEvent);
            }
            if (queuedEvents.loadingFailedEvent) {
                this.#emitLoadingFailed(client, queuedEvents.loadingFailedEvent);
            }
            return;
        }
        this.#networkEventManager.responseExtraInfo(event.requestId).push(event);
    }
    #forgetRequest(request, events) {
        const requestId = request.id;
        const interceptionId = request._interceptionId;
        this.#networkEventManager.forgetRequest(requestId);
        if (interceptionId !== undefined) {
            this.#attemptedAuthentications.delete(interceptionId);
        }
        if (events) {
            this.#networkEventManager.forget(requestId);
        }
    }
    #onLoadingFinished(client, event) {
        const queuedEvents = this.#networkEventManager.getQueuedEventGroup(event.requestId);
        if (queuedEvents) {
            queuedEvents.loadingFinishedEvent = event;
        }
        else {
            this.#emitLoadingFinished(client, event);
        }
    }
    #emitLoadingFinished(client, event) {
        const request = this.#networkEventManager.getRequest(event.requestId);
        if (!request) {
            return;
        }
        this.#adoptCdpSessionIfNeeded(client, request);
        if (request.response()) {
            request.response()?._resolveBody();
        }
        this.#forgetRequest(request, true);
        this.emit(NetworkManagerEvent.RequestFinished, request);
    }
    #onLoadingFailed(client, event) {
        const queuedEvents = this.#networkEventManager.getQueuedEventGroup(event.requestId);
        if (queuedEvents) {
            queuedEvents.loadingFailedEvent = event;
        }
        else {
            this.#emitLoadingFailed(client, event);
        }
    }
    #emitLoadingFailed(client, event) {
        const request = this.#networkEventManager.getRequest(event.requestId);
        if (!request) {
            return;
        }
        this.#adoptCdpSessionIfNeeded(client, request);
        request._failureText = event.errorText;
        const response = request.response();
        if (response) {
            response._resolveBody();
        }
        this.#forgetRequest(request, true);
        this.emit(NetworkManagerEvent.RequestFailed, request);
    }
    #adoptCdpSessionIfNeeded(client, request) {
        if (client !== request.client) {
            request.client = client;
        }
    }
}

/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const TIME_FOR_WAITING_FOR_SWAP = 100;
class FrameManager extends EventEmitter {
    #page;
    #networkManager;
    #timeoutSettings;
    #isolatedWorlds = new Set();
    #client;
    #scriptsToEvaluateOnNewDocument = new Map();
    #bindings = new Set();
    _frameTree = new FrameTree();
    #frameNavigatedReceived = new Set();
    #deviceRequestPromptManagerMap = new WeakMap();
    #frameTreeHandled;
    get timeoutSettings() {
        return this.#timeoutSettings;
    }
    get networkManager() {
        return this.#networkManager;
    }
    get client() {
        return this.#client;
    }
    constructor(client, page, timeoutSettings) {
        super();
        this.#client = client;
        this.#page = page;
        this.#networkManager = new NetworkManager(this, page.browser().isNetworkEnabled());
        this.#timeoutSettings = timeoutSettings;
        this.setupEventListeners(this.#client);
        client.once(CDPSessionEvent.Disconnected, () => {
            this.#onClientDisconnect().catch(debugError);
        });
    }
    async #onClientDisconnect() {
        const mainFrame = this._frameTree.getMainFrame();
        if (!mainFrame) {
            return;
        }
        if (!this.#page.browser().connected) {
            this.#removeFramesRecursively(mainFrame);
            return;
        }
        for (const child of mainFrame.childFrames()) {
            this.#removeFramesRecursively(child);
        }
        const swapped = Deferred.create({
            timeout: TIME_FOR_WAITING_FOR_SWAP,
            message: 'Frame was not swapped',
        });
        mainFrame.once(FrameEvent.FrameSwappedByActivation, () => {
            swapped.resolve();
        });
        try {
            await swapped.valueOrThrow();
        }
        catch {
            this.#removeFramesRecursively(mainFrame);
        }
    }
    async swapFrameTree(client) {
        this.#client = client;
        const frame = this._frameTree.getMainFrame();
        if (frame) {
            this.#frameNavigatedReceived.add(this.#client.target()._targetId);
            this._frameTree.removeFrame(frame);
            frame.updateId(this.#client.target()._targetId);
            this._frameTree.addFrame(frame);
            frame.updateClient(client);
        }
        this.setupEventListeners(client);
        client.once(CDPSessionEvent.Disconnected, () => {
            this.#onClientDisconnect().catch(debugError);
        });
        await this.initialize(client, frame);
        await this.#networkManager.addClient(client);
        if (frame) {
            frame.emit(FrameEvent.FrameSwappedByActivation, undefined);
        }
    }
    async registerSpeculativeSession(client) {
        await this.#networkManager.addClient(client);
    }
    setupEventListeners(session) {
        session.on('Page.frameAttached', async (event) => {
            await this.#frameTreeHandled?.valueOrThrow();
            this.#onFrameAttached(session, event.frameId, event.parentFrameId);
        });
        session.on('Page.frameNavigated', async (event) => {
            this.#frameNavigatedReceived.add(event.frame.id);
            await this.#frameTreeHandled?.valueOrThrow();
            void this.#onFrameNavigated(event.frame, event.type);
        });
        session.on('Page.navigatedWithinDocument', async (event) => {
            await this.#frameTreeHandled?.valueOrThrow();
            this.#onFrameNavigatedWithinDocument(event.frameId, event.url);
        });
        session.on('Page.frameDetached', async (event) => {
            await this.#frameTreeHandled?.valueOrThrow();
            this.#onFrameDetached(event.frameId, event.reason);
        });
        session.on('Page.frameStartedLoading', async (event) => {
            await this.#frameTreeHandled?.valueOrThrow();
            this.#onFrameStartedLoading(event.frameId);
        });
        session.on('Page.frameStoppedLoading', async (event) => {
            await this.#frameTreeHandled?.valueOrThrow();
            this.#onFrameStoppedLoading(event.frameId);
        });
        session.on('Runtime.executionContextCreated', async (event) => {
            await this.#frameTreeHandled?.valueOrThrow();
            this.#onExecutionContextCreated(event.context, session);
        });
        session.on('Page.lifecycleEvent', async (event) => {
            await this.#frameTreeHandled?.valueOrThrow();
            this.#onLifecycleEvent(event);
        });
    }
    async initialize(client, frame) {
        try {
            this.#frameTreeHandled?.resolve();
            this.#frameTreeHandled = Deferred.create();
            await Promise.all([
                this.#networkManager.addClient(client),
                client.send('Page.enable'),
                client.send('Page.getFrameTree').then(({ frameTree }) => {
                    this.#handleFrameTree(client, frameTree);
                    this.#frameTreeHandled?.resolve();
                }),
                client.send('Page.setLifecycleEventsEnabled', { enabled: true }),
                client.send('Runtime.enable').then(() => {
                    return this.#createIsolatedWorld(client, UTILITY_WORLD_NAME);
                }),
                ...(frame
                    ? Array.from(this.#scriptsToEvaluateOnNewDocument.values())
                    : []).map(script => {
                    return frame?.addPreloadScript(script);
                }),
                ...(frame ? Array.from(this.#bindings.values()) : []).map(binding => {
                    return frame?.addExposedFunctionBinding(binding);
                }),
            ]);
        }
        catch (error) {
            this.#frameTreeHandled?.resolve();
            if (isErrorLike$1(error) && isTargetClosedError(error)) {
                return;
            }
            throw error;
        }
    }
    page() {
        return this.#page;
    }
    mainFrame() {
        const mainFrame = this._frameTree.getMainFrame();
        assert(mainFrame, 'Requesting main frame too early!');
        return mainFrame;
    }
    frames() {
        return Array.from(this._frameTree.frames());
    }
    frame(frameId) {
        return this._frameTree.getById(frameId) || null;
    }
    async addExposedFunctionBinding(binding) {
        this.#bindings.add(binding);
        await Promise.all(this.frames().map(async (frame) => {
            return await frame.addExposedFunctionBinding(binding);
        }));
    }
    async removeExposedFunctionBinding(binding) {
        this.#bindings.delete(binding);
        await Promise.all(this.frames().map(async (frame) => {
            return await frame.removeExposedFunctionBinding(binding);
        }));
    }
    async evaluateOnNewDocument(source) {
        const { identifier } = await this.mainFrame()
            ._client()
            .send('Page.addScriptToEvaluateOnNewDocument', {
            source,
        });
        const preloadScript = new CdpPreloadScript(this.mainFrame(), identifier, source);
        this.#scriptsToEvaluateOnNewDocument.set(identifier, preloadScript);
        await Promise.all(this.frames().map(async (frame) => {
            return await frame.addPreloadScript(preloadScript);
        }));
        return { identifier };
    }
    async removeScriptToEvaluateOnNewDocument(identifier) {
        const preloadScript = this.#scriptsToEvaluateOnNewDocument.get(identifier);
        if (!preloadScript) {
            throw new Error(`Script to evaluate on new document with id ${identifier} not found`);
        }
        this.#scriptsToEvaluateOnNewDocument.delete(identifier);
        await Promise.all(this.frames().map(frame => {
            const identifier = preloadScript.getIdForFrame(frame);
            if (!identifier) {
                return;
            }
            return frame
                ._client()
                .send('Page.removeScriptToEvaluateOnNewDocument', {
                identifier,
            })
                .catch(debugError);
        }));
    }
    onAttachedToTarget(target) {
        if (target._getTargetInfo().type !== 'iframe') {
            return;
        }
        const frame = this.frame(target._getTargetInfo().targetId);
        if (frame) {
            frame.updateClient(target._session());
        }
        this.setupEventListeners(target._session());
        void this.initialize(target._session(), frame);
    }
    _deviceRequestPromptManager(client) {
        let manager = this.#deviceRequestPromptManagerMap.get(client);
        if (manager === undefined) {
            manager = new DeviceRequestPromptManager(client, this.#timeoutSettings);
            this.#deviceRequestPromptManagerMap.set(client, manager);
        }
        return manager;
    }
    #onLifecycleEvent(event) {
        const frame = this.frame(event.frameId);
        if (!frame) {
            return;
        }
        frame._onLifecycleEvent(event.loaderId, event.name);
        this.emit(FrameManagerEvent.LifecycleEvent, frame);
        frame.emit(FrameEvent.LifecycleEvent, undefined);
    }
    #onFrameStartedLoading(frameId) {
        const frame = this.frame(frameId);
        if (!frame) {
            return;
        }
        frame._onLoadingStarted();
    }
    #onFrameStoppedLoading(frameId) {
        const frame = this.frame(frameId);
        if (!frame) {
            return;
        }
        frame._onLoadingStopped();
        this.emit(FrameManagerEvent.LifecycleEvent, frame);
        frame.emit(FrameEvent.LifecycleEvent, undefined);
    }
    #handleFrameTree(session, frameTree) {
        if (frameTree.frame.parentId) {
            this.#onFrameAttached(session, frameTree.frame.id, frameTree.frame.parentId);
        }
        if (!this.#frameNavigatedReceived.has(frameTree.frame.id)) {
            void this.#onFrameNavigated(frameTree.frame, 'Navigation');
        }
        else {
            this.#frameNavigatedReceived.delete(frameTree.frame.id);
        }
        if (!frameTree.childFrames) {
            return;
        }
        for (const child of frameTree.childFrames) {
            this.#handleFrameTree(session, child);
        }
    }
    #onFrameAttached(session, frameId, parentFrameId) {
        let frame = this.frame(frameId);
        if (frame) {
            const parentFrame = this.frame(parentFrameId);
            if (session && parentFrame && frame.client !== parentFrame?.client) {
                frame.updateClient(session);
            }
            return;
        }
        frame = new CdpFrame(this, frameId, parentFrameId, session);
        this._frameTree.addFrame(frame);
        this.emit(FrameManagerEvent.FrameAttached, frame);
    }
    async #onFrameNavigated(framePayload, navigationType) {
        const frameId = framePayload.id;
        const isMainFrame = !framePayload.parentId;
        let frame = this._frameTree.getById(frameId);
        if (frame) {
            for (const child of frame.childFrames()) {
                this.#removeFramesRecursively(child);
            }
        }
        if (isMainFrame) {
            if (frame) {
                this._frameTree.removeFrame(frame);
                frame._id = frameId;
            }
            else {
                frame = new CdpFrame(this, frameId, undefined, this.#client);
            }
            this._frameTree.addFrame(frame);
        }
        frame = await this._frameTree.waitForFrame(frameId);
        frame._navigated(framePayload);
        this.emit(FrameManagerEvent.FrameNavigated, frame);
        frame.emit(FrameEvent.FrameNavigated, navigationType);
    }
    async #createIsolatedWorld(session, name) {
        const key = `${session.id()}:${name}`;
        if (this.#isolatedWorlds.has(key)) {
            return;
        }
        await session.send('Page.addScriptToEvaluateOnNewDocument', {
            source: `//# sourceURL=${PuppeteerURL.INTERNAL_URL}`,
            worldName: name,
        });
        await Promise.all(this.frames()
            .filter(frame => {
            return frame.client === session;
        })
            .map(frame => {
            return session
                .send('Page.createIsolatedWorld', {
                frameId: frame._id,
                worldName: name,
                grantUniveralAccess: true,
            })
                .catch(debugError);
        }));
        this.#isolatedWorlds.add(key);
    }
    #onFrameNavigatedWithinDocument(frameId, url) {
        const frame = this.frame(frameId);
        if (!frame) {
            return;
        }
        frame._navigatedWithinDocument(url);
        this.emit(FrameManagerEvent.FrameNavigatedWithinDocument, frame);
        frame.emit(FrameEvent.FrameNavigatedWithinDocument, undefined);
        this.emit(FrameManagerEvent.FrameNavigated, frame);
        frame.emit(FrameEvent.FrameNavigated, 'Navigation');
    }
    #onFrameDetached(frameId, reason) {
        const frame = this.frame(frameId);
        if (!frame) {
            return;
        }
        switch (reason) {
            case 'remove':
                this.#removeFramesRecursively(frame);
                break;
            case 'swap':
                this.emit(FrameManagerEvent.FrameSwapped, frame);
                frame.emit(FrameEvent.FrameSwapped, undefined);
                break;
        }
    }
    #onExecutionContextCreated(contextPayload, session) {
        const auxData = contextPayload.auxData;
        const frameId = auxData && auxData.frameId;
        const frame = typeof frameId === 'string' ? this.frame(frameId) : undefined;
        let world;
        if (frame) {
            if (frame.client !== session) {
                return;
            }
            if (contextPayload.auxData && contextPayload.auxData['isDefault']) {
                world = frame.worlds[MAIN_WORLD];
            }
            else if (contextPayload.name === UTILITY_WORLD_NAME) {
                world = frame.worlds[PUPPETEER_WORLD];
            }
        }
        if (!world) {
            return;
        }
        const context = new ExecutionContext(frame?.client || this.#client, contextPayload, world);
        world.setContext(context);
    }
    #removeFramesRecursively(frame) {
        for (const child of frame.childFrames()) {
            this.#removeFramesRecursively(child);
        }
        frame[disposeSymbol]();
        this._frameTree.removeFrame(frame);
        this.emit(FrameManagerEvent.FrameDetached, frame);
        frame.emit(FrameEvent.FrameDetached, frame);
    }
}

/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const _keyDefinitions = {
    '0': { keyCode: 48, key: '0', code: 'Digit0' },
    '1': { keyCode: 49, key: '1', code: 'Digit1' },
    '2': { keyCode: 50, key: '2', code: 'Digit2' },
    '3': { keyCode: 51, key: '3', code: 'Digit3' },
    '4': { keyCode: 52, key: '4', code: 'Digit4' },
    '5': { keyCode: 53, key: '5', code: 'Digit5' },
    '6': { keyCode: 54, key: '6', code: 'Digit6' },
    '7': { keyCode: 55, key: '7', code: 'Digit7' },
    '8': { keyCode: 56, key: '8', code: 'Digit8' },
    '9': { keyCode: 57, key: '9', code: 'Digit9' },
    Power: { key: 'Power', code: 'Power' },
    Eject: { key: 'Eject', code: 'Eject' },
    Abort: { keyCode: 3, code: 'Abort', key: 'Cancel' },
    Help: { keyCode: 6, code: 'Help', key: 'Help' },
    Backspace: { keyCode: 8, code: 'Backspace', key: 'Backspace' },
    Tab: { keyCode: 9, code: 'Tab', key: 'Tab' },
    Numpad5: {
        keyCode: 12,
        shiftKeyCode: 101,
        key: 'Clear',
        code: 'Numpad5',
        shiftKey: '5',
        location: 3,
    },
    NumpadEnter: {
        keyCode: 13,
        code: 'NumpadEnter',
        key: 'Enter',
        text: '\r',
        location: 3,
    },
    Enter: { keyCode: 13, code: 'Enter', key: 'Enter', text: '\r' },
    '\r': { keyCode: 13, code: 'Enter', key: 'Enter', text: '\r' },
    '\n': { keyCode: 13, code: 'Enter', key: 'Enter', text: '\r' },
    ShiftLeft: { keyCode: 16, code: 'ShiftLeft', key: 'Shift', location: 1 },
    ShiftRight: { keyCode: 16, code: 'ShiftRight', key: 'Shift', location: 2 },
    ControlLeft: {
        keyCode: 17,
        code: 'ControlLeft',
        key: 'Control',
        location: 1,
    },
    ControlRight: {
        keyCode: 17,
        code: 'ControlRight',
        key: 'Control',
        location: 2,
    },
    AltLeft: { keyCode: 18, code: 'AltLeft', key: 'Alt', location: 1 },
    AltRight: { keyCode: 18, code: 'AltRight', key: 'Alt', location: 2 },
    Pause: { keyCode: 19, code: 'Pause', key: 'Pause' },
    CapsLock: { keyCode: 20, code: 'CapsLock', key: 'CapsLock' },
    Escape: { keyCode: 27, code: 'Escape', key: 'Escape' },
    Convert: { keyCode: 28, code: 'Convert', key: 'Convert' },
    NonConvert: { keyCode: 29, code: 'NonConvert', key: 'NonConvert' },
    Space: { keyCode: 32, code: 'Space', key: ' ' },
    Numpad9: {
        keyCode: 33,
        shiftKeyCode: 105,
        key: 'PageUp',
        code: 'Numpad9',
        shiftKey: '9',
        location: 3,
    },
    PageUp: { keyCode: 33, code: 'PageUp', key: 'PageUp' },
    Numpad3: {
        keyCode: 34,
        shiftKeyCode: 99,
        key: 'PageDown',
        code: 'Numpad3',
        shiftKey: '3',
        location: 3,
    },
    PageDown: { keyCode: 34, code: 'PageDown', key: 'PageDown' },
    End: { keyCode: 35, code: 'End', key: 'End' },
    Numpad1: {
        keyCode: 35,
        shiftKeyCode: 97,
        key: 'End',
        code: 'Numpad1',
        shiftKey: '1',
        location: 3,
    },
    Home: { keyCode: 36, code: 'Home', key: 'Home' },
    Numpad7: {
        keyCode: 36,
        shiftKeyCode: 103,
        key: 'Home',
        code: 'Numpad7',
        shiftKey: '7',
        location: 3,
    },
    ArrowLeft: { keyCode: 37, code: 'ArrowLeft', key: 'ArrowLeft' },
    Numpad4: {
        keyCode: 37,
        shiftKeyCode: 100,
        key: 'ArrowLeft',
        code: 'Numpad4',
        shiftKey: '4',
        location: 3,
    },
    Numpad8: {
        keyCode: 38,
        shiftKeyCode: 104,
        key: 'ArrowUp',
        code: 'Numpad8',
        shiftKey: '8',
        location: 3,
    },
    ArrowUp: { keyCode: 38, code: 'ArrowUp', key: 'ArrowUp' },
    ArrowRight: { keyCode: 39, code: 'ArrowRight', key: 'ArrowRight' },
    Numpad6: {
        keyCode: 39,
        shiftKeyCode: 102,
        key: 'ArrowRight',
        code: 'Numpad6',
        shiftKey: '6',
        location: 3,
    },
    Numpad2: {
        keyCode: 40,
        shiftKeyCode: 98,
        key: 'ArrowDown',
        code: 'Numpad2',
        shiftKey: '2',
        location: 3,
    },
    ArrowDown: { keyCode: 40, code: 'ArrowDown', key: 'ArrowDown' },
    Select: { keyCode: 41, code: 'Select', key: 'Select' },
    Open: { keyCode: 43, code: 'Open', key: 'Execute' },
    PrintScreen: { keyCode: 44, code: 'PrintScreen', key: 'PrintScreen' },
    Insert: { keyCode: 45, code: 'Insert', key: 'Insert' },
    Numpad0: {
        keyCode: 45,
        shiftKeyCode: 96,
        key: 'Insert',
        code: 'Numpad0',
        shiftKey: '0',
        location: 3,
    },
    Delete: { keyCode: 46, code: 'Delete', key: 'Delete' },
    NumpadDecimal: {
        keyCode: 46,
        shiftKeyCode: 110,
        code: 'NumpadDecimal',
        key: '\u0000',
        shiftKey: '.',
        location: 3,
    },
    Digit0: { keyCode: 48, code: 'Digit0', shiftKey: ')', key: '0' },
    Digit1: { keyCode: 49, code: 'Digit1', shiftKey: '!', key: '1' },
    Digit2: { keyCode: 50, code: 'Digit2', shiftKey: '@', key: '2' },
    Digit3: { keyCode: 51, code: 'Digit3', shiftKey: '#', key: '3' },
    Digit4: { keyCode: 52, code: 'Digit4', shiftKey: '$', key: '4' },
    Digit5: { keyCode: 53, code: 'Digit5', shiftKey: '%', key: '5' },
    Digit6: { keyCode: 54, code: 'Digit6', shiftKey: '^', key: '6' },
    Digit7: { keyCode: 55, code: 'Digit7', shiftKey: '&', key: '7' },
    Digit8: { keyCode: 56, code: 'Digit8', shiftKey: '*', key: '8' },
    Digit9: { keyCode: 57, code: 'Digit9', shiftKey: '(', key: '9' },
    KeyA: { keyCode: 65, code: 'KeyA', shiftKey: 'A', key: 'a' },
    KeyB: { keyCode: 66, code: 'KeyB', shiftKey: 'B', key: 'b' },
    KeyC: { keyCode: 67, code: 'KeyC', shiftKey: 'C', key: 'c' },
    KeyD: { keyCode: 68, code: 'KeyD', shiftKey: 'D', key: 'd' },
    KeyE: { keyCode: 69, code: 'KeyE', shiftKey: 'E', key: 'e' },
    KeyF: { keyCode: 70, code: 'KeyF', shiftKey: 'F', key: 'f' },
    KeyG: { keyCode: 71, code: 'KeyG', shiftKey: 'G', key: 'g' },
    KeyH: { keyCode: 72, code: 'KeyH', shiftKey: 'H', key: 'h' },
    KeyI: { keyCode: 73, code: 'KeyI', shiftKey: 'I', key: 'i' },
    KeyJ: { keyCode: 74, code: 'KeyJ', shiftKey: 'J', key: 'j' },
    KeyK: { keyCode: 75, code: 'KeyK', shiftKey: 'K', key: 'k' },
    KeyL: { keyCode: 76, code: 'KeyL', shiftKey: 'L', key: 'l' },
    KeyM: { keyCode: 77, code: 'KeyM', shiftKey: 'M', key: 'm' },
    KeyN: { keyCode: 78, code: 'KeyN', shiftKey: 'N', key: 'n' },
    KeyO: { keyCode: 79, code: 'KeyO', shiftKey: 'O', key: 'o' },
    KeyP: { keyCode: 80, code: 'KeyP', shiftKey: 'P', key: 'p' },
    KeyQ: { keyCode: 81, code: 'KeyQ', shiftKey: 'Q', key: 'q' },
    KeyR: { keyCode: 82, code: 'KeyR', shiftKey: 'R', key: 'r' },
    KeyS: { keyCode: 83, code: 'KeyS', shiftKey: 'S', key: 's' },
    KeyT: { keyCode: 84, code: 'KeyT', shiftKey: 'T', key: 't' },
    KeyU: { keyCode: 85, code: 'KeyU', shiftKey: 'U', key: 'u' },
    KeyV: { keyCode: 86, code: 'KeyV', shiftKey: 'V', key: 'v' },
    KeyW: { keyCode: 87, code: 'KeyW', shiftKey: 'W', key: 'w' },
    KeyX: { keyCode: 88, code: 'KeyX', shiftKey: 'X', key: 'x' },
    KeyY: { keyCode: 89, code: 'KeyY', shiftKey: 'Y', key: 'y' },
    KeyZ: { keyCode: 90, code: 'KeyZ', shiftKey: 'Z', key: 'z' },
    MetaLeft: { keyCode: 91, code: 'MetaLeft', key: 'Meta', location: 1 },
    MetaRight: { keyCode: 92, code: 'MetaRight', key: 'Meta', location: 2 },
    ContextMenu: { keyCode: 93, code: 'ContextMenu', key: 'ContextMenu' },
    NumpadMultiply: {
        keyCode: 106,
        code: 'NumpadMultiply',
        key: '*',
        location: 3,
    },
    NumpadAdd: { keyCode: 107, code: 'NumpadAdd', key: '+', location: 3 },
    NumpadSubtract: {
        keyCode: 109,
        code: 'NumpadSubtract',
        key: '-',
        location: 3,
    },
    NumpadDivide: { keyCode: 111, code: 'NumpadDivide', key: '/', location: 3 },
    F1: { keyCode: 112, code: 'F1', key: 'F1' },
    F2: { keyCode: 113, code: 'F2', key: 'F2' },
    F3: { keyCode: 114, code: 'F3', key: 'F3' },
    F4: { keyCode: 115, code: 'F4', key: 'F4' },
    F5: { keyCode: 116, code: 'F5', key: 'F5' },
    F6: { keyCode: 117, code: 'F6', key: 'F6' },
    F7: { keyCode: 118, code: 'F7', key: 'F7' },
    F8: { keyCode: 119, code: 'F8', key: 'F8' },
    F9: { keyCode: 120, code: 'F9', key: 'F9' },
    F10: { keyCode: 121, code: 'F10', key: 'F10' },
    F11: { keyCode: 122, code: 'F11', key: 'F11' },
    F12: { keyCode: 123, code: 'F12', key: 'F12' },
    F13: { keyCode: 124, code: 'F13', key: 'F13' },
    F14: { keyCode: 125, code: 'F14', key: 'F14' },
    F15: { keyCode: 126, code: 'F15', key: 'F15' },
    F16: { keyCode: 127, code: 'F16', key: 'F16' },
    F17: { keyCode: 128, code: 'F17', key: 'F17' },
    F18: { keyCode: 129, code: 'F18', key: 'F18' },
    F19: { keyCode: 130, code: 'F19', key: 'F19' },
    F20: { keyCode: 131, code: 'F20', key: 'F20' },
    F21: { keyCode: 132, code: 'F21', key: 'F21' },
    F22: { keyCode: 133, code: 'F22', key: 'F22' },
    F23: { keyCode: 134, code: 'F23', key: 'F23' },
    F24: { keyCode: 135, code: 'F24', key: 'F24' },
    NumLock: { keyCode: 144, code: 'NumLock', key: 'NumLock' },
    ScrollLock: { keyCode: 145, code: 'ScrollLock', key: 'ScrollLock' },
    AudioVolumeMute: {
        keyCode: 173,
        code: 'AudioVolumeMute',
        key: 'AudioVolumeMute',
    },
    AudioVolumeDown: {
        keyCode: 174,
        code: 'AudioVolumeDown',
        key: 'AudioVolumeDown',
    },
    AudioVolumeUp: { keyCode: 175, code: 'AudioVolumeUp', key: 'AudioVolumeUp' },
    MediaTrackNext: {
        keyCode: 176,
        code: 'MediaTrackNext',
        key: 'MediaTrackNext',
    },
    MediaTrackPrevious: {
        keyCode: 177,
        code: 'MediaTrackPrevious',
        key: 'MediaTrackPrevious',
    },
    MediaStop: { keyCode: 178, code: 'MediaStop', key: 'MediaStop' },
    MediaPlayPause: {
        keyCode: 179,
        code: 'MediaPlayPause',
        key: 'MediaPlayPause',
    },
    Semicolon: { keyCode: 186, code: 'Semicolon', shiftKey: ':', key: ';' },
    Equal: { keyCode: 187, code: 'Equal', shiftKey: '+', key: '=' },
    NumpadEqual: { keyCode: 187, code: 'NumpadEqual', key: '=', location: 3 },
    Comma: { keyCode: 188, code: 'Comma', shiftKey: '<', key: ',' },
    Minus: { keyCode: 189, code: 'Minus', shiftKey: '_', key: '-' },
    Period: { keyCode: 190, code: 'Period', shiftKey: '>', key: '.' },
    Slash: { keyCode: 191, code: 'Slash', shiftKey: '?', key: '/' },
    Backquote: { keyCode: 192, code: 'Backquote', shiftKey: '~', key: '`' },
    BracketLeft: { keyCode: 219, code: 'BracketLeft', shiftKey: '{', key: '[' },
    Backslash: { keyCode: 220, code: 'Backslash', shiftKey: '|', key: '\\' },
    BracketRight: { keyCode: 221, code: 'BracketRight', shiftKey: '}', key: ']' },
    Quote: { keyCode: 222, code: 'Quote', shiftKey: '"', key: "'" },
    AltGraph: { keyCode: 225, code: 'AltGraph', key: 'AltGraph' },
    Props: { keyCode: 247, code: 'Props', key: 'CrSel' },
    Cancel: { keyCode: 3, key: 'Cancel', code: 'Abort' },
    Clear: { keyCode: 12, key: 'Clear', code: 'Numpad5', location: 3 },
    Shift: { keyCode: 16, key: 'Shift', code: 'ShiftLeft', location: 1 },
    Control: { keyCode: 17, key: 'Control', code: 'ControlLeft', location: 1 },
    Alt: { keyCode: 18, key: 'Alt', code: 'AltLeft', location: 1 },
    Accept: { keyCode: 30, key: 'Accept' },
    ModeChange: { keyCode: 31, key: 'ModeChange' },
    ' ': { keyCode: 32, key: ' ', code: 'Space' },
    Print: { keyCode: 42, key: 'Print' },
    Execute: { keyCode: 43, key: 'Execute', code: 'Open' },
    '\u0000': { keyCode: 46, key: '\u0000', code: 'NumpadDecimal', location: 3 },
    a: { keyCode: 65, key: 'a', code: 'KeyA' },
    b: { keyCode: 66, key: 'b', code: 'KeyB' },
    c: { keyCode: 67, key: 'c', code: 'KeyC' },
    d: { keyCode: 68, key: 'd', code: 'KeyD' },
    e: { keyCode: 69, key: 'e', code: 'KeyE' },
    f: { keyCode: 70, key: 'f', code: 'KeyF' },
    g: { keyCode: 71, key: 'g', code: 'KeyG' },
    h: { keyCode: 72, key: 'h', code: 'KeyH' },
    i: { keyCode: 73, key: 'i', code: 'KeyI' },
    j: { keyCode: 74, key: 'j', code: 'KeyJ' },
    k: { keyCode: 75, key: 'k', code: 'KeyK' },
    l: { keyCode: 76, key: 'l', code: 'KeyL' },
    m: { keyCode: 77, key: 'm', code: 'KeyM' },
    n: { keyCode: 78, key: 'n', code: 'KeyN' },
    o: { keyCode: 79, key: 'o', code: 'KeyO' },
    p: { keyCode: 80, key: 'p', code: 'KeyP' },
    q: { keyCode: 81, key: 'q', code: 'KeyQ' },
    r: { keyCode: 82, key: 'r', code: 'KeyR' },
    s: { keyCode: 83, key: 's', code: 'KeyS' },
    t: { keyCode: 84, key: 't', code: 'KeyT' },
    u: { keyCode: 85, key: 'u', code: 'KeyU' },
    v: { keyCode: 86, key: 'v', code: 'KeyV' },
    w: { keyCode: 87, key: 'w', code: 'KeyW' },
    x: { keyCode: 88, key: 'x', code: 'KeyX' },
    y: { keyCode: 89, key: 'y', code: 'KeyY' },
    z: { keyCode: 90, key: 'z', code: 'KeyZ' },
    Meta: { keyCode: 91, key: 'Meta', code: 'MetaLeft', location: 1 },
    '*': { keyCode: 106, key: '*', code: 'NumpadMultiply', location: 3 },
    '+': { keyCode: 107, key: '+', code: 'NumpadAdd', location: 3 },
    '-': { keyCode: 109, key: '-', code: 'NumpadSubtract', location: 3 },
    '/': { keyCode: 111, key: '/', code: 'NumpadDivide', location: 3 },
    ';': { keyCode: 186, key: ';', code: 'Semicolon' },
    '=': { keyCode: 187, key: '=', code: 'Equal' },
    ',': { keyCode: 188, key: ',', code: 'Comma' },
    '.': { keyCode: 190, key: '.', code: 'Period' },
    '`': { keyCode: 192, key: '`', code: 'Backquote' },
    '[': { keyCode: 219, key: '[', code: 'BracketLeft' },
    '\\': { keyCode: 220, key: '\\', code: 'Backslash' },
    ']': { keyCode: 221, key: ']', code: 'BracketRight' },
    "'": { keyCode: 222, key: "'", code: 'Quote' },
    Attn: { keyCode: 246, key: 'Attn' },
    CrSel: { keyCode: 247, key: 'CrSel', code: 'Props' },
    ExSel: { keyCode: 248, key: 'ExSel' },
    EraseEof: { keyCode: 249, key: 'EraseEof' },
    Play: { keyCode: 250, key: 'Play' },
    ZoomOut: { keyCode: 251, key: 'ZoomOut' },
    ')': { keyCode: 48, key: ')', code: 'Digit0' },
    '!': { keyCode: 49, key: '!', code: 'Digit1' },
    '@': { keyCode: 50, key: '@', code: 'Digit2' },
    '#': { keyCode: 51, key: '#', code: 'Digit3' },
    $: { keyCode: 52, key: '$', code: 'Digit4' },
    '%': { keyCode: 53, key: '%', code: 'Digit5' },
    '^': { keyCode: 54, key: '^', code: 'Digit6' },
    '&': { keyCode: 55, key: '&', code: 'Digit7' },
    '(': { keyCode: 57, key: '(', code: 'Digit9' },
    A: { keyCode: 65, key: 'A', code: 'KeyA' },
    B: { keyCode: 66, key: 'B', code: 'KeyB' },
    C: { keyCode: 67, key: 'C', code: 'KeyC' },
    D: { keyCode: 68, key: 'D', code: 'KeyD' },
    E: { keyCode: 69, key: 'E', code: 'KeyE' },
    F: { keyCode: 70, key: 'F', code: 'KeyF' },
    G: { keyCode: 71, key: 'G', code: 'KeyG' },
    H: { keyCode: 72, key: 'H', code: 'KeyH' },
    I: { keyCode: 73, key: 'I', code: 'KeyI' },
    J: { keyCode: 74, key: 'J', code: 'KeyJ' },
    K: { keyCode: 75, key: 'K', code: 'KeyK' },
    L: { keyCode: 76, key: 'L', code: 'KeyL' },
    M: { keyCode: 77, key: 'M', code: 'KeyM' },
    N: { keyCode: 78, key: 'N', code: 'KeyN' },
    O: { keyCode: 79, key: 'O', code: 'KeyO' },
    P: { keyCode: 80, key: 'P', code: 'KeyP' },
    Q: { keyCode: 81, key: 'Q', code: 'KeyQ' },
    R: { keyCode: 82, key: 'R', code: 'KeyR' },
    S: { keyCode: 83, key: 'S', code: 'KeyS' },
    T: { keyCode: 84, key: 'T', code: 'KeyT' },
    U: { keyCode: 85, key: 'U', code: 'KeyU' },
    V: { keyCode: 86, key: 'V', code: 'KeyV' },
    W: { keyCode: 87, key: 'W', code: 'KeyW' },
    X: { keyCode: 88, key: 'X', code: 'KeyX' },
    Y: { keyCode: 89, key: 'Y', code: 'KeyY' },
    Z: { keyCode: 90, key: 'Z', code: 'KeyZ' },
    ':': { keyCode: 186, key: ':', code: 'Semicolon' },
    '<': { keyCode: 188, key: '<', code: 'Comma' },
    _: { keyCode: 189, key: '_', code: 'Minus' },
    '>': { keyCode: 190, key: '>', code: 'Period' },
    '?': { keyCode: 191, key: '?', code: 'Slash' },
    '~': { keyCode: 192, key: '~', code: 'Backquote' },
    '{': { keyCode: 219, key: '{', code: 'BracketLeft' },
    '|': { keyCode: 220, key: '|', code: 'Backslash' },
    '}': { keyCode: 221, key: '}', code: 'BracketRight' },
    '"': { keyCode: 222, key: '"', code: 'Quote' },
    SoftLeft: { key: 'SoftLeft', code: 'SoftLeft', location: 4 },
    SoftRight: { key: 'SoftRight', code: 'SoftRight', location: 4 },
    Camera: { keyCode: 44, key: 'Camera', code: 'Camera', location: 4 },
    Call: { key: 'Call', code: 'Call', location: 4 },
    EndCall: { keyCode: 95, key: 'EndCall', code: 'EndCall', location: 4 },
    VolumeDown: {
        keyCode: 182,
        key: 'VolumeDown',
        code: 'VolumeDown',
        location: 4,
    },
    VolumeUp: { keyCode: 183, key: 'VolumeUp', code: 'VolumeUp', location: 4 },
};

/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class CdpKeyboard extends Keyboard {
    #client;
    #pressedKeys = new Set();
    _modifiers = 0;
    constructor(client) {
        super();
        this.#client = client;
    }
    updateClient(client) {
        this.#client = client;
    }
    async down(key, options = {
        text: undefined,
        commands: [],
    }) {
        const description = this.#keyDescriptionForString(key);
        const autoRepeat = this.#pressedKeys.has(description.code);
        this.#pressedKeys.add(description.code);
        this._modifiers |= this.#modifierBit(description.key);
        const text = options.text === undefined ? description.text : options.text;
        await this.#client.send('Input.dispatchKeyEvent', {
            type: text ? 'keyDown' : 'rawKeyDown',
            modifiers: this._modifiers,
            windowsVirtualKeyCode: description.keyCode,
            code: description.code,
            key: description.key,
            text: text,
            unmodifiedText: text,
            autoRepeat,
            location: description.location,
            isKeypad: description.location === 3,
            commands: options.commands,
        });
    }
    #modifierBit(key) {
        if (key === 'Alt') {
            return 1;
        }
        if (key === 'Control') {
            return 2;
        }
        if (key === 'Meta') {
            return 4;
        }
        if (key === 'Shift') {
            return 8;
        }
        return 0;
    }
    #keyDescriptionForString(keyString) {
        const shift = this._modifiers & 8;
        const description = {
            key: '',
            keyCode: 0,
            code: '',
            text: '',
            location: 0,
        };
        const definition = _keyDefinitions[keyString];
        assert(definition, `Unknown key: "${keyString}"`);
        if (definition.key) {
            description.key = definition.key;
        }
        if (shift && definition.shiftKey) {
            description.key = definition.shiftKey;
        }
        if (definition.keyCode) {
            description.keyCode = definition.keyCode;
        }
        if (shift && definition.shiftKeyCode) {
            description.keyCode = definition.shiftKeyCode;
        }
        if (definition.code) {
            description.code = definition.code;
        }
        if (definition.location) {
            description.location = definition.location;
        }
        if (description.key.length === 1) {
            description.text = description.key;
        }
        if (definition.text) {
            description.text = definition.text;
        }
        if (shift && definition.shiftText) {
            description.text = definition.shiftText;
        }
        if (this._modifiers & -9) {
            description.text = '';
        }
        return description;
    }
    async up(key) {
        const description = this.#keyDescriptionForString(key);
        this._modifiers &= ~this.#modifierBit(description.key);
        this.#pressedKeys.delete(description.code);
        await this.#client.send('Input.dispatchKeyEvent', {
            type: 'keyUp',
            modifiers: this._modifiers,
            key: description.key,
            windowsVirtualKeyCode: description.keyCode,
            code: description.code,
            location: description.location,
        });
    }
    async sendCharacter(char) {
        await this.#client.send('Input.insertText', { text: char });
    }
    charIsKey(char) {
        return !!_keyDefinitions[char];
    }
    async type(text, options = {}) {
        const delay = options.delay || undefined;
        for (const char of text) {
            if (this.charIsKey(char)) {
                await this.press(char, { delay });
            }
            else {
                if (delay) {
                    await new Promise(f => {
                        return setTimeout(f, delay);
                    });
                }
                await this.sendCharacter(char);
            }
        }
    }
    async press(key, options = {}) {
        const { delay = null } = options;
        await this.down(key, options);
        if (delay) {
            await new Promise(f => {
                return setTimeout(f, options.delay);
            });
        }
        await this.up(key);
    }
}
const getFlag = (button) => {
    switch (button) {
        case MouseButton.Left:
            return 1 ;
        case MouseButton.Right:
            return 2 ;
        case MouseButton.Middle:
            return 4 ;
        case MouseButton.Back:
            return 8 ;
        case MouseButton.Forward:
            return 16 ;
    }
};
const getButtonFromPressedButtons = (buttons) => {
    if (buttons & 1 ) {
        return MouseButton.Left;
    }
    else if (buttons & 2 ) {
        return MouseButton.Right;
    }
    else if (buttons & 4 ) {
        return MouseButton.Middle;
    }
    else if (buttons & 8 ) {
        return MouseButton.Back;
    }
    else if (buttons & 16 ) {
        return MouseButton.Forward;
    }
    return 'none';
};
class CdpMouse extends Mouse {
    #client;
    #keyboard;
    constructor(client, keyboard) {
        super();
        this.#client = client;
        this.#keyboard = keyboard;
    }
    updateClient(client) {
        this.#client = client;
    }
    #_state = {
        position: { x: 0, y: 0 },
        buttons: 0 ,
    };
    get #state() {
        return Object.assign({ ...this.#_state }, ...this.#transactions);
    }
    #transactions = [];
    #createTransaction() {
        const transaction = {};
        this.#transactions.push(transaction);
        const popTransaction = () => {
            this.#transactions.splice(this.#transactions.indexOf(transaction), 1);
        };
        return {
            update: (updates) => {
                Object.assign(transaction, updates);
            },
            commit: () => {
                this.#_state = { ...this.#_state, ...transaction };
                popTransaction();
            },
            rollback: popTransaction,
        };
    }
    async #withTransaction(action) {
        const { update, commit, rollback } = this.#createTransaction();
        try {
            await action(update);
            commit();
        }
        catch (error) {
            rollback();
            throw error;
        }
    }
    async reset() {
        const actions = [];
        for (const [flag, button] of [
            [1 , MouseButton.Left],
            [4 , MouseButton.Middle],
            [2 , MouseButton.Right],
            [16 , MouseButton.Forward],
            [8 , MouseButton.Back],
        ]) {
            if (this.#state.buttons & flag) {
                actions.push(this.up({ button: button }));
            }
        }
        if (this.#state.position.x !== 0 || this.#state.position.y !== 0) {
            actions.push(this.move(0, 0));
        }
        await Promise.all(actions);
    }
    async move(x, y, options = {}) {
        const { steps = 1 } = options;
        const from = this.#state.position;
        const to = { x, y };
        for (let i = 1; i <= steps; i++) {
            await this.#withTransaction(updateState => {
                updateState({
                    position: {
                        x: from.x + (to.x - from.x) * (i / steps),
                        y: from.y + (to.y - from.y) * (i / steps),
                    },
                });
                const { buttons, position } = this.#state;
                return this.#client.send('Input.dispatchMouseEvent', {
                    type: 'mouseMoved',
                    modifiers: this.#keyboard._modifiers,
                    buttons,
                    button: getButtonFromPressedButtons(buttons),
                    ...position,
                });
            });
        }
    }
    async down(options = {}) {
        const { button = MouseButton.Left, clickCount = 1 } = options;
        const flag = getFlag(button);
        if (!flag) {
            throw new Error(`Unsupported mouse button: ${button}`);
        }
        if (this.#state.buttons & flag) {
            throw new Error(`'${button}' is already pressed.`);
        }
        await this.#withTransaction(updateState => {
            updateState({
                buttons: this.#state.buttons | flag,
            });
            const { buttons, position } = this.#state;
            return this.#client.send('Input.dispatchMouseEvent', {
                type: 'mousePressed',
                modifiers: this.#keyboard._modifiers,
                clickCount,
                buttons,
                button,
                ...position,
            });
        });
    }
    async up(options = {}) {
        const { button = MouseButton.Left, clickCount = 1 } = options;
        const flag = getFlag(button);
        if (!flag) {
            throw new Error(`Unsupported mouse button: ${button}`);
        }
        if (!(this.#state.buttons & flag)) {
            throw new Error(`'${button}' is not pressed.`);
        }
        await this.#withTransaction(updateState => {
            updateState({
                buttons: this.#state.buttons & ~flag,
            });
            const { buttons, position } = this.#state;
            return this.#client.send('Input.dispatchMouseEvent', {
                type: 'mouseReleased',
                modifiers: this.#keyboard._modifiers,
                clickCount,
                buttons,
                button,
                ...position,
            });
        });
    }
    async click(x, y, options = {}) {
        const { delay, count = 1, clickCount = count } = options;
        if (count < 1) {
            throw new Error('Click must occur a positive number of times.');
        }
        const actions = [this.move(x, y)];
        if (clickCount === count) {
            for (let i = 1; i < count; ++i) {
                actions.push(this.down({ ...options, clickCount: i }), this.up({ ...options, clickCount: i }));
            }
        }
        actions.push(this.down({ ...options, clickCount }));
        if (typeof delay === 'number') {
            await Promise.all(actions);
            actions.length = 0;
            await new Promise(resolve => {
                setTimeout(resolve, delay);
            });
        }
        actions.push(this.up({ ...options, clickCount }));
        await Promise.all(actions);
    }
    async wheel(options = {}) {
        const { deltaX = 0, deltaY = 0 } = options;
        const { position, buttons } = this.#state;
        await this.#client.send('Input.dispatchMouseEvent', {
            type: 'mouseWheel',
            pointerType: 'mouse',
            modifiers: this.#keyboard._modifiers,
            deltaY,
            deltaX,
            buttons,
            ...position,
        });
    }
    async drag(start, target) {
        const promise = new Promise(resolve => {
            this.#client.once('Input.dragIntercepted', event => {
                return resolve(event.data);
            });
        });
        await this.move(start.x, start.y);
        await this.down();
        await this.move(target.x, target.y);
        return await promise;
    }
    async dragEnter(target, data) {
        await this.#client.send('Input.dispatchDragEvent', {
            type: 'dragEnter',
            x: target.x,
            y: target.y,
            modifiers: this.#keyboard._modifiers,
            data,
        });
    }
    async dragOver(target, data) {
        await this.#client.send('Input.dispatchDragEvent', {
            type: 'dragOver',
            x: target.x,
            y: target.y,
            modifiers: this.#keyboard._modifiers,
            data,
        });
    }
    async drop(target, data) {
        await this.#client.send('Input.dispatchDragEvent', {
            type: 'drop',
            x: target.x,
            y: target.y,
            modifiers: this.#keyboard._modifiers,
            data,
        });
    }
    async dragAndDrop(start, target, options = {}) {
        const { delay = null } = options;
        const data = await this.drag(start, target);
        await this.dragEnter(target, data);
        await this.dragOver(target, data);
        if (delay) {
            await new Promise(resolve => {
                return setTimeout(resolve, delay);
            });
        }
        await this.drop(target, data);
        await this.up();
    }
}
class CdpTouchHandle {
    #started = false;
    #touchScreen;
    #touchPoint;
    #client;
    #keyboard;
    constructor(client, touchScreen, keyboard, touchPoint) {
        this.#client = client;
        this.#touchScreen = touchScreen;
        this.#keyboard = keyboard;
        this.#touchPoint = touchPoint;
    }
    updateClient(client) {
        this.#client = client;
    }
    async start() {
        if (this.#started) {
            throw new TouchError('Touch has already started');
        }
        await this.#client.send('Input.dispatchTouchEvent', {
            type: 'touchStart',
            touchPoints: [this.#touchPoint],
            modifiers: this.#keyboard._modifiers,
        });
        this.#started = true;
    }
    move(x, y) {
        this.#touchPoint.x = Math.round(x);
        this.#touchPoint.y = Math.round(y);
        return this.#client.send('Input.dispatchTouchEvent', {
            type: 'touchMove',
            touchPoints: [this.#touchPoint],
            modifiers: this.#keyboard._modifiers,
        });
    }
    async end() {
        await this.#client.send('Input.dispatchTouchEvent', {
            type: 'touchEnd',
            touchPoints: [this.#touchPoint],
            modifiers: this.#keyboard._modifiers,
        });
        this.#touchScreen.removeHandle(this);
    }
}
class CdpTouchscreen extends Touchscreen {
    #client;
    #keyboard;
    constructor(client, keyboard) {
        super();
        this.#client = client;
        this.#keyboard = keyboard;
    }
    updateClient(client) {
        this.#client = client;
        this.touches.forEach(t => {
            t.updateClient(client);
        });
    }
    async touchStart(x, y) {
        const id = this.idGenerator();
        const touchPoint = {
            x: Math.round(x),
            y: Math.round(y),
            radiusX: 0.5,
            radiusY: 0.5,
            force: 0.5,
            id,
        };
        const touch = new CdpTouchHandle(this.#client, this, this.#keyboard, touchPoint);
        await touch.start();
        this.touches.push(touch);
        return touch;
    }
}

class Tracing {
    #client;
    #recording = false;
    #path;
    constructor(client) {
        this.#client = client;
    }
    updateClient(client) {
        this.#client = client;
    }
    async start(options = {}) {
        assert(!this.#recording, 'Cannot start recording trace while already recording trace.');
        const defaultCategories = [
            '-*',
            'devtools.timeline',
            'v8.execute',
            'disabled-by-default-devtools.timeline',
            'disabled-by-default-devtools.timeline.frame',
            'toplevel',
            'blink.console',
            'blink.user_timing',
            'latencyInfo',
            'disabled-by-default-devtools.timeline.stack',
            'disabled-by-default-v8.cpu_profiler',
        ];
        const { path, screenshots = false, categories = defaultCategories } = options;
        if (screenshots) {
            categories.push('disabled-by-default-devtools.screenshot');
        }
        const excludedCategories = categories
            .filter(cat => {
            return cat.startsWith('-');
        })
            .map(cat => {
            return cat.slice(1);
        });
        const includedCategories = categories.filter(cat => {
            return !cat.startsWith('-');
        });
        this.#path = path;
        this.#recording = true;
        await this.#client.send('Tracing.start', {
            transferMode: 'ReturnAsStream',
            traceConfig: {
                excludedCategories,
                includedCategories,
            },
        });
    }
    async stop() {
        const contentDeferred = Deferred.create();
        this.#client.once('Tracing.tracingComplete', async (event) => {
            try {
                assert(event.stream, 'Missing "stream"');
                const readable = await getReadableFromProtocolStream(this.#client, event.stream);
                const typedArray = await getReadableAsTypedArray(readable, this.#path);
                contentDeferred.resolve(typedArray ?? undefined);
            }
            catch (error) {
                if (isErrorLike$1(error)) {
                    contentDeferred.reject(error);
                }
                else {
                    contentDeferred.reject(new Error(`Unknown error: ${error}`));
                }
            }
        });
        await this.#client.send('Tracing.end');
        this.#recording = false;
        return await contentDeferred.valueOrThrow();
    }
}

class CdpWebWorker extends WebWorker {
    #world;
    #client;
    #id;
    #targetType;
    constructor(client, url, targetId, targetType, consoleAPICalled, exceptionThrown, networkManager) {
        super(url);
        this.#id = targetId;
        this.#client = client;
        this.#targetType = targetType;
        this.#world = new IsolatedWorld(this, new TimeoutSettings());
        this.#client.once('Runtime.executionContextCreated', async (event) => {
            this.#world.setContext(new ExecutionContext(client, event.context, this.#world));
        });
        this.#world.emitter.on('consoleapicalled', async (event) => {
            try {
                return consoleAPICalled(event.type, event.args.map((object) => {
                    return new CdpJSHandle(this.#world, object);
                }), event.stackTrace);
            }
            catch (err) {
                debugError(err);
            }
        });
        this.#client.on('Runtime.exceptionThrown', exceptionThrown);
        this.#client.once(CDPSessionEvent.Disconnected, () => {
            this.#world.dispose();
        });
        networkManager?.addClient(this.#client).catch(debugError);
        this.#client.send('Runtime.enable').catch(debugError);
    }
    mainRealm() {
        return this.#world;
    }
    get client() {
        return this.#client;
    }
    async close() {
        switch (this.#targetType) {
            case TargetType.SERVICE_WORKER:
            case TargetType.SHARED_WORKER: {
                await this.client.connection()?.send('Target.closeTarget', {
                    targetId: this.#id,
                });
                await this.client.connection()?.send('Target.detachFromTarget', {
                    sessionId: this.client.id(),
                });
                break;
            }
            default:
                await this.evaluate(() => {
                    self.close();
                });
        }
    }
}

/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var __addDisposableResource$2 = (undefined && undefined.__addDisposableResource) || function (env, value, async) {
    if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
        var dispose, inner;
        if (async) {
            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
            if (async) inner = dispose;
        }
        if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
        if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };
        env.stack.push({ value: value, dispose: dispose, async: async });
    }
    else if (async) {
        env.stack.push({ async: true });
    }
    return value;
};
var __disposeResources$2 = (undefined && undefined.__disposeResources) || (function (SuppressedError) {
    return function (env) {
        function fail(e) {
            env.error = env.hasError ? new SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
            env.hasError = true;
        }
        var r, s = 0;
        function next() {
            while (r = env.stack.pop()) {
                try {
                    if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
                    if (r.dispose) {
                        var result = r.dispose.call(r.value);
                        if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
                    }
                    else s |= 1;
                }
                catch (e) {
                    fail(e);
                }
            }
            if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
            if (env.hasError) throw env.error;
        }
        return next();
    };
})(typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
});
function convertConsoleMessageLevel(method) {
    switch (method) {
        case 'warning':
            return 'warn';
        default:
            return method;
    }
}
class CdpPage extends Page {
    static async _create(client, target, defaultViewport) {
        const page = new CdpPage(client, target);
        await page.#initialize();
        if (defaultViewport) {
            try {
                await page.setViewport(defaultViewport);
            }
            catch (err) {
                if (isErrorLike$1(err) && isTargetClosedError(err)) {
                    debugError(err);
                }
                else {
                    throw err;
                }
            }
        }
        return page;
    }
    #closed = false;
    #targetManager;
    #primaryTargetClient;
    #primaryTarget;
    #tabTargetClient;
    #tabTarget;
    #keyboard;
    #mouse;
    #touchscreen;
    #frameManager;
    #emulationManager;
    #tracing;
    #bindings = new Map();
    #exposedFunctions = new Map();
    #coverage;
    #viewport;
    #workers = new Map();
    #fileChooserDeferreds = new Set();
    #sessionCloseDeferred = Deferred.create();
    #serviceWorkerBypassed = false;
    #userDragInterceptionEnabled = false;
    constructor(client, target) {
        super();
        this.#primaryTargetClient = client;
        this.#tabTargetClient = client.parentSession();
        assert(this.#tabTargetClient, 'Tab target session is not defined.');
        this.#tabTarget = this.#tabTargetClient.target();
        assert(this.#tabTarget, 'Tab target is not defined.');
        this.#primaryTarget = target;
        this.#targetManager = target._targetManager();
        this.#keyboard = new CdpKeyboard(client);
        this.#mouse = new CdpMouse(client, this.#keyboard);
        this.#touchscreen = new CdpTouchscreen(client, this.#keyboard);
        this.#frameManager = new FrameManager(client, this, this._timeoutSettings);
        this.#emulationManager = new EmulationManager(client);
        this.#tracing = new Tracing(client);
        this.#coverage = new Coverage(client);
        this.#viewport = null;
        const frameManagerEmitter = new EventEmitter(this.#frameManager);
        frameManagerEmitter.on(FrameManagerEvent.FrameAttached, frame => {
            this.emit("frameattached" , frame);
        });
        frameManagerEmitter.on(FrameManagerEvent.FrameDetached, frame => {
            this.emit("framedetached" , frame);
        });
        frameManagerEmitter.on(FrameManagerEvent.FrameNavigated, frame => {
            this.emit("framenavigated" , frame);
        });
        frameManagerEmitter.on(FrameManagerEvent.ConsoleApiCalled, ([world, event]) => {
            this.#onConsoleAPI(world, event);
        });
        frameManagerEmitter.on(FrameManagerEvent.BindingCalled, ([world, event]) => {
            void this.#onBindingCalled(world, event);
        });
        const networkManagerEmitter = new EventEmitter(this.#frameManager.networkManager);
        networkManagerEmitter.on(NetworkManagerEvent.Request, request => {
            this.emit("request" , request);
        });
        networkManagerEmitter.on(NetworkManagerEvent.RequestServedFromCache, request => {
            this.emit("requestservedfromcache" , request);
        });
        networkManagerEmitter.on(NetworkManagerEvent.Response, response => {
            this.emit("response" , response);
        });
        networkManagerEmitter.on(NetworkManagerEvent.RequestFailed, request => {
            this.emit("requestfailed" , request);
        });
        networkManagerEmitter.on(NetworkManagerEvent.RequestFinished, request => {
            this.emit("requestfinished" , request);
        });
        this.#tabTargetClient.on(CDPSessionEvent.Swapped, this.#onActivation.bind(this));
        this.#tabTargetClient.on(CDPSessionEvent.Ready, this.#onSecondaryTarget.bind(this));
        this.#targetManager.on("targetGone" , this.#onDetachedFromTarget);
        this.#tabTarget._isClosedDeferred
            .valueOrThrow()
            .then(() => {
            this.#targetManager.off("targetGone" , this.#onDetachedFromTarget);
            this.emit("close" , undefined);
            this.#closed = true;
        })
            .catch(debugError);
        this.#setupPrimaryTargetListeners();
        this.#attachExistingTargets();
    }
    #attachExistingTargets() {
        const queue = [];
        for (const childTarget of this.#targetManager.getChildTargets(this.#primaryTarget)) {
            queue.push(childTarget);
        }
        let idx = 0;
        while (idx < queue.length) {
            const next = queue[idx];
            idx++;
            const session = next._session();
            if (session) {
                this.#onAttachedToTarget(session);
            }
            for (const childTarget of this.#targetManager.getChildTargets(next)) {
                queue.push(childTarget);
            }
        }
    }
    async #onActivation(newSession) {
        assert(newSession instanceof CdpCDPSession, 'CDPSession is not instance of CdpCDPSession');
        this.#primaryTargetClient = newSession;
        this.#primaryTarget = newSession.target();
        assert(this.#primaryTarget, 'Missing target on swap');
        this.#keyboard.updateClient(newSession);
        this.#mouse.updateClient(newSession);
        this.#touchscreen.updateClient(newSession);
        this.#emulationManager.updateClient(newSession);
        this.#tracing.updateClient(newSession);
        this.#coverage.updateClient(newSession);
        await this.#frameManager.swapFrameTree(newSession);
        this.#setupPrimaryTargetListeners();
    }
    async #onSecondaryTarget(session) {
        assert(session instanceof CdpCDPSession);
        if (session.target()._subtype() !== 'prerender') {
            return;
        }
        this.#frameManager.registerSpeculativeSession(session).catch(debugError);
        this.#emulationManager
            .registerSpeculativeSession(session)
            .catch(debugError);
    }
    #setupPrimaryTargetListeners() {
        const clientEmitter = new EventEmitter(this.#primaryTargetClient);
        clientEmitter.on(CDPSessionEvent.Ready, this.#onAttachedToTarget);
        clientEmitter.on(CDPSessionEvent.Disconnected, () => {
            this.#sessionCloseDeferred.reject(new TargetCloseError('Target closed'));
        });
        clientEmitter.on('Page.domContentEventFired', () => {
            this.emit("domcontentloaded" , undefined);
        });
        clientEmitter.on('Page.loadEventFired', () => {
            this.emit("load" , undefined);
        });
        clientEmitter.on('Page.javascriptDialogOpening', this.#onDialog.bind(this));
        clientEmitter.on('Runtime.exceptionThrown', this.#handleException.bind(this));
        clientEmitter.on('Inspector.targetCrashed', this.#onTargetCrashed.bind(this));
        clientEmitter.on('Performance.metrics', this.#emitMetrics.bind(this));
        clientEmitter.on('Log.entryAdded', this.#onLogEntryAdded.bind(this));
        clientEmitter.on('Page.fileChooserOpened', this.#onFileChooser.bind(this));
    }
    #onDetachedFromTarget = (target) => {
        const sessionId = target._session()?.id();
        const worker = this.#workers.get(sessionId);
        if (!worker) {
            return;
        }
        this.#workers.delete(sessionId);
        this.emit("workerdestroyed" , worker);
    };
    #onAttachedToTarget = (session) => {
        assert(session instanceof CdpCDPSession);
        this.#frameManager.onAttachedToTarget(session.target());
        if (session.target()._getTargetInfo().type === 'worker') {
            const worker = new CdpWebWorker(session, session.target().url(), session.target()._targetId, session.target().type(), this.#addConsoleMessage.bind(this), this.#handleException.bind(this), this.#frameManager.networkManager);
            this.#workers.set(session.id(), worker);
            this.emit("workercreated" , worker);
        }
        session.on(CDPSessionEvent.Ready, this.#onAttachedToTarget);
    };
    async #initialize() {
        try {
            await Promise.all([
                this.#frameManager.initialize(this.#primaryTargetClient),
                this.#primaryTargetClient.send('Performance.enable'),
                this.#primaryTargetClient.send('Log.enable'),
            ]);
        }
        catch (err) {
            if (isErrorLike$1(err) && isTargetClosedError(err)) {
                debugError(err);
            }
            else {
                throw err;
            }
        }
    }
    async resize(params) {
        const { windowId } = await this.#primaryTargetClient.send('Browser.getWindowForTarget');
        await this.#primaryTargetClient.send('Browser.setContentsSize', {
            windowId,
            width: params.contentWidth,
            height: params.contentHeight,
        });
    }
    async #onFileChooser(event) {
        const env_1 = { stack: [], error: void 0, hasError: false };
        try {
            if (!this.#fileChooserDeferreds.size) {
                return;
            }
            const frame = this.#frameManager.frame(event.frameId);
            assert(frame, 'This should never happen.');
            const handle = __addDisposableResource$2(env_1, (await frame.worlds[MAIN_WORLD].adoptBackendNode(event.backendNodeId)), false);
            const fileChooser = new FileChooser(handle.move(), event.mode !== 'selectSingle');
            for (const promise of this.#fileChooserDeferreds) {
                promise.resolve(fileChooser);
            }
            this.#fileChooserDeferreds.clear();
        }
        catch (e_1) {
            env_1.error = e_1;
            env_1.hasError = true;
        }
        finally {
            __disposeResources$2(env_1);
        }
    }
    _client() {
        return this.#primaryTargetClient;
    }
    isServiceWorkerBypassed() {
        return this.#serviceWorkerBypassed;
    }
    isDragInterceptionEnabled() {
        return this.#userDragInterceptionEnabled;
    }
    isJavaScriptEnabled() {
        return this.#emulationManager.javascriptEnabled;
    }
    async waitForFileChooser(options = {}) {
        const needsEnable = this.#fileChooserDeferreds.size === 0;
        const { timeout = this._timeoutSettings.timeout() } = options;
        const deferred = Deferred.create({
            message: `Waiting for \`FileChooser\` failed: ${timeout}ms exceeded`,
            timeout,
        });
        if (options.signal) {
            options.signal.addEventListener('abort', () => {
                deferred.reject(options.signal?.reason);
            }, { once: true });
        }
        this.#fileChooserDeferreds.add(deferred);
        let enablePromise;
        if (needsEnable) {
            enablePromise = this.#primaryTargetClient.send('Page.setInterceptFileChooserDialog', {
                enabled: true,
            });
        }
        try {
            const [result] = await Promise.all([
                deferred.valueOrThrow(),
                enablePromise,
            ]);
            return result;
        }
        catch (error) {
            this.#fileChooserDeferreds.delete(deferred);
            throw error;
        }
    }
    async setGeolocation(options) {
        return await this.#emulationManager.setGeolocation(options);
    }
    target() {
        return this.#primaryTarget;
    }
    browser() {
        return this.#primaryTarget.browser();
    }
    browserContext() {
        return this.#primaryTarget.browserContext();
    }
    #onTargetCrashed() {
        this.emit("error" , new Error('Page crashed!'));
    }
    #onLogEntryAdded(event) {
        const { level, text, args, source, url, lineNumber } = event.entry;
        if (args) {
            args.map(arg => {
                void releaseObject(this.#primaryTargetClient, arg);
            });
        }
        if (source !== 'worker') {
            this.emit("console" , new ConsoleMessage(convertConsoleMessageLevel(level), text, [], [{ url, lineNumber }]));
        }
    }
    mainFrame() {
        return this.#frameManager.mainFrame();
    }
    get keyboard() {
        return this.#keyboard;
    }
    get touchscreen() {
        return this.#touchscreen;
    }
    get coverage() {
        return this.#coverage;
    }
    get tracing() {
        return this.#tracing;
    }
    frames() {
        return this.#frameManager.frames();
    }
    workers() {
        return Array.from(this.#workers.values());
    }
    async setRequestInterception(value) {
        return await this.#frameManager.networkManager.setRequestInterception(value);
    }
    async setBypassServiceWorker(bypass) {
        this.#serviceWorkerBypassed = bypass;
        return await this.#primaryTargetClient.send('Network.setBypassServiceWorker', { bypass });
    }
    async setDragInterception(enabled) {
        this.#userDragInterceptionEnabled = enabled;
        return await this.#primaryTargetClient.send('Input.setInterceptDrags', {
            enabled,
        });
    }
    async setOfflineMode(enabled) {
        return await this.#frameManager.networkManager.setOfflineMode(enabled);
    }
    async emulateNetworkConditions(networkConditions) {
        return await this.#frameManager.networkManager.emulateNetworkConditions(networkConditions);
    }
    setDefaultNavigationTimeout(timeout) {
        this._timeoutSettings.setDefaultNavigationTimeout(timeout);
    }
    setDefaultTimeout(timeout) {
        this._timeoutSettings.setDefaultTimeout(timeout);
    }
    getDefaultTimeout() {
        return this._timeoutSettings.timeout();
    }
    getDefaultNavigationTimeout() {
        return this._timeoutSettings.navigationTimeout();
    }
    async queryObjects(prototypeHandle) {
        assert(!prototypeHandle.disposed, 'Prototype JSHandle is disposed!');
        assert(prototypeHandle.id, 'Prototype JSHandle must not be referencing primitive value');
        const response = await this.mainFrame().client.send('Runtime.queryObjects', {
            prototypeObjectId: prototypeHandle.id,
        });
        return this.mainFrame()
            .mainRealm()
            .createCdpHandle(response.objects);
    }
    async cookies(...urls) {
        const originalCookies = (await this.#primaryTargetClient.send('Network.getCookies', {
            urls: urls.length ? urls : [this.url()],
        })).cookies;
        const unsupportedCookieAttributes = ['sourcePort'];
        const filterUnsupportedAttributes = (cookie) => {
            for (const attr of unsupportedCookieAttributes) {
                delete cookie[attr];
            }
            return cookie;
        };
        return originalCookies.map(filterUnsupportedAttributes).map(cookie => {
            return {
                ...cookie,
                partitionKey: cookie.partitionKey
                    ? cookie.partitionKey.topLevelSite
                    : undefined,
            };
        });
    }
    async deleteCookie(...cookies) {
        const pageURL = this.url();
        for (const cookie of cookies) {
            const item = {
                ...cookie,
                partitionKey: convertCookiesPartitionKeyFromPuppeteerToCdp(cookie.partitionKey),
            };
            if (!cookie.url && pageURL.startsWith('http')) {
                item.url = pageURL;
            }
            await this.#primaryTargetClient.send('Network.deleteCookies', item);
            if (pageURL.startsWith('http') && !item.partitionKey) {
                const url = new URL(pageURL);
                await this.#primaryTargetClient.send('Network.deleteCookies', {
                    ...item,
                    partitionKey: {
                        topLevelSite: url.origin.replace(`:${url.port}`, ''),
                        hasCrossSiteAncestor: false,
                    },
                });
            }
        }
    }
    async setCookie(...cookies) {
        const pageURL = this.url();
        const startsWithHTTP = pageURL.startsWith('http');
        const items = cookies.map(cookie => {
            const item = Object.assign({}, cookie);
            if (!item.url && startsWithHTTP) {
                item.url = pageURL;
            }
            assert(item.url !== 'about:blank', `Blank page can not have cookie "${item.name}"`);
            assert(!String.prototype.startsWith.call(item.url || '', 'data:'), `Data URL page can not have cookie "${item.name}"`);
            return item;
        });
        await this.deleteCookie(...items);
        if (items.length) {
            await this.#primaryTargetClient.send('Network.setCookies', {
                cookies: items.map(cookieParam => {
                    return {
                        ...cookieParam,
                        partitionKey: convertCookiesPartitionKeyFromPuppeteerToCdp(cookieParam.partitionKey),
                    };
                }),
            });
        }
    }
    async exposeFunction(name,
    pptrFunction) {
        if (this.#bindings.has(name)) {
            throw new Error(`Failed to add page binding with name ${name}: window['${name}'] already exists!`);
        }
        const source = pageBindingInitString('exposedFun', name);
        let binding;
        switch (typeof pptrFunction) {
            case 'function':
                binding = new Binding(name, pptrFunction, source);
                break;
            default:
                binding = new Binding(name, pptrFunction.default, source);
                break;
        }
        this.#bindings.set(name, binding);
        const [{ identifier }] = await Promise.all([
            this.#frameManager.evaluateOnNewDocument(source),
            this.#frameManager.addExposedFunctionBinding(binding),
        ]);
        this.#exposedFunctions.set(name, identifier);
    }
    async removeExposedFunction(name) {
        const exposedFunctionId = this.#exposedFunctions.get(name);
        if (!exposedFunctionId) {
            throw new Error(`Function with name "${name}" does not exist`);
        }
        const binding = this.#bindings.get(name);
        this.#exposedFunctions.delete(name);
        this.#bindings.delete(name);
        await Promise.all([
            this.#frameManager.removeScriptToEvaluateOnNewDocument(exposedFunctionId),
            this.#frameManager.removeExposedFunctionBinding(binding),
        ]);
    }
    async authenticate(credentials) {
        return await this.#frameManager.networkManager.authenticate(credentials);
    }
    async setExtraHTTPHeaders(headers) {
        return await this.#frameManager.networkManager.setExtraHTTPHeaders(headers);
    }
    async setUserAgent(userAgentOrOptions, userAgentMetadata) {
        if (typeof userAgentOrOptions === 'string') {
            return await this.#frameManager.networkManager.setUserAgent(userAgentOrOptions, userAgentMetadata);
        }
        else {
            const userAgent = userAgentOrOptions.userAgent ?? (await this.browser().userAgent());
            return await this.#frameManager.networkManager.setUserAgent(userAgent, userAgentOrOptions.userAgentMetadata, userAgentOrOptions.platform);
        }
    }
    async metrics() {
        const response = await this.#primaryTargetClient.send('Performance.getMetrics');
        return this.#buildMetricsObject(response.metrics);
    }
    #emitMetrics(event) {
        this.emit("metrics" , {
            title: event.title,
            metrics: this.#buildMetricsObject(event.metrics),
        });
    }
    #buildMetricsObject(metrics) {
        const result = {};
        for (const metric of metrics || []) {
            if (supportedMetrics.has(metric.name)) {
                result[metric.name] = metric.value;
            }
        }
        return result;
    }
    #handleException(exception) {
        this.emit("pageerror" , createClientError(exception.exceptionDetails));
    }
    #onConsoleAPI(world, event) {
        const values = event.args.map(arg => {
            return world.createCdpHandle(arg);
        });
        this.#addConsoleMessage(convertConsoleMessageLevel(event.type), values, event.stackTrace);
    }
    async #onBindingCalled(world, event) {
        let payload;
        try {
            payload = JSON.parse(event.payload);
        }
        catch {
            return;
        }
        const { type, name, seq, args, isTrivial } = payload;
        if (type !== 'exposedFun') {
            return;
        }
        const context = world.context;
        if (!context) {
            return;
        }
        const binding = this.#bindings.get(name);
        await binding?.run(context, seq, args, isTrivial);
    }
    #addConsoleMessage(eventType, args, stackTrace) {
        if (!this.listenerCount("console" )) {
            args.forEach(arg => {
                return arg.dispose();
            });
            return;
        }
        const textTokens = [];
        for (const arg of args) {
            const remoteObject = arg.remoteObject();
            if (remoteObject.objectId) {
                textTokens.push(arg.toString());
            }
            else {
                textTokens.push(valueFromRemoteObject(remoteObject));
            }
        }
        const stackTraceLocations = [];
        if (stackTrace) {
            for (const callFrame of stackTrace.callFrames) {
                stackTraceLocations.push({
                    url: callFrame.url,
                    lineNumber: callFrame.lineNumber,
                    columnNumber: callFrame.columnNumber,
                });
            }
        }
        const message = new ConsoleMessage(convertConsoleMessageLevel(eventType), textTokens.join(' '), args, stackTraceLocations);
        this.emit("console" , message);
    }
    #onDialog(event) {
        const type = validateDialogType(event.type);
        const dialog = new CdpDialog(this.#primaryTargetClient, type, event.message, event.defaultPrompt);
        this.emit("dialog" , dialog);
    }
    async reload(options) {
        const [result] = await Promise.all([
            this.waitForNavigation({
                ...options,
                ignoreSameDocumentNavigation: true,
            }),
            this.#primaryTargetClient.send('Page.reload'),
        ]);
        return result;
    }
    async createCDPSession() {
        return await this.target().createCDPSession();
    }
    async goBack(options = {}) {
        return await this.#go(-1, options);
    }
    async goForward(options = {}) {
        return await this.#go(1, options);
    }
    async #go(delta, options) {
        const history = await this.#primaryTargetClient.send('Page.getNavigationHistory');
        const entry = history.entries[history.currentIndex + delta];
        if (!entry) {
            throw new Error('History entry to navigate to not found.');
        }
        const result = await Promise.all([
            this.waitForNavigation(options),
            this.#primaryTargetClient.send('Page.navigateToHistoryEntry', {
                entryId: entry.id,
            }),
        ]);
        return result[0];
    }
    async bringToFront() {
        await this.#primaryTargetClient.send('Page.bringToFront');
    }
    async setJavaScriptEnabled(enabled) {
        return await this.#emulationManager.setJavaScriptEnabled(enabled);
    }
    async setBypassCSP(enabled) {
        await this.#primaryTargetClient.send('Page.setBypassCSP', { enabled });
    }
    async emulateMediaType(type) {
        return await this.#emulationManager.emulateMediaType(type);
    }
    async emulateCPUThrottling(factor) {
        return await this.#emulationManager.emulateCPUThrottling(factor);
    }
    async emulateMediaFeatures(features) {
        return await this.#emulationManager.emulateMediaFeatures(features);
    }
    async emulateTimezone(timezoneId) {
        return await this.#emulationManager.emulateTimezone(timezoneId);
    }
    async emulateIdleState(overrides) {
        return await this.#emulationManager.emulateIdleState(overrides);
    }
    async emulateVisionDeficiency(type) {
        return await this.#emulationManager.emulateVisionDeficiency(type);
    }
    async setViewport(viewport) {
        const needsReload = await this.#emulationManager.emulateViewport(viewport);
        this.#viewport = viewport;
        if (needsReload) {
            await this.reload();
        }
    }
    viewport() {
        return this.#viewport;
    }
    async evaluateOnNewDocument(pageFunction, ...args) {
        const source = evaluationString(pageFunction, ...args);
        return await this.#frameManager.evaluateOnNewDocument(source);
    }
    async removeScriptToEvaluateOnNewDocument(identifier) {
        return await this.#frameManager.removeScriptToEvaluateOnNewDocument(identifier);
    }
    async setCacheEnabled(enabled = true) {
        await this.#frameManager.networkManager.setCacheEnabled(enabled);
    }
    async _screenshot(options) {
        const env_2 = { stack: [], error: void 0, hasError: false };
        try {
            const { fromSurface, omitBackground, optimizeForSpeed, quality, clip: userClip, type, captureBeyondViewport, } = options;
            const stack = __addDisposableResource$2(env_2, new AsyncDisposableStack(), true);
            if (omitBackground && (type === 'png' || type === 'webp')) {
                await this.#emulationManager.setTransparentBackgroundColor();
                stack.defer(async () => {
                    await this.#emulationManager
                        .resetDefaultBackgroundColor()
                        .catch(debugError);
                });
            }
            let clip = userClip;
            if (clip && !captureBeyondViewport) {
                const viewport = await this.mainFrame()
                    .isolatedRealm()
                    .evaluate(() => {
                    const { height, pageLeft: x, pageTop: y, width, } = window.visualViewport;
                    return { x, y, height, width };
                });
                clip = getIntersectionRect(clip, viewport);
            }
            const { data } = await this.#primaryTargetClient.send('Page.captureScreenshot', {
                format: type,
                optimizeForSpeed,
                fromSurface,
                ...(quality !== undefined ? { quality: Math.round(quality) } : {}),
                ...(clip ? { clip: { ...clip, scale: clip.scale ?? 1 } } : {}),
                captureBeyondViewport,
            });
            return data;
        }
        catch (e_2) {
            env_2.error = e_2;
            env_2.hasError = true;
        }
        finally {
            const result_1 = __disposeResources$2(env_2);
            if (result_1)
                await result_1;
        }
    }
    async createPDFStream(options = {}) {
        const { timeout: ms = this._timeoutSettings.timeout() } = options;
        const { landscape, displayHeaderFooter, headerTemplate, footerTemplate, printBackground, scale, width: paperWidth, height: paperHeight, margin, pageRanges, preferCSSPageSize, omitBackground, tagged: generateTaggedPDF, outline: generateDocumentOutline, waitForFonts, } = parsePDFOptions(options);
        if (omitBackground) {
            await this.#emulationManager.setTransparentBackgroundColor();
        }
        if (waitForFonts) {
            await firstValueFrom(from(this.mainFrame()
                .isolatedRealm()
                .evaluate(() => {
                return document.fonts.ready;
            })).pipe(raceWith(timeout(ms))));
        }
        const printCommandPromise = this.#primaryTargetClient.send('Page.printToPDF', {
            transferMode: 'ReturnAsStream',
            landscape,
            displayHeaderFooter,
            headerTemplate,
            footerTemplate,
            printBackground,
            scale,
            paperWidth,
            paperHeight,
            marginTop: margin.top,
            marginBottom: margin.bottom,
            marginLeft: margin.left,
            marginRight: margin.right,
            pageRanges,
            preferCSSPageSize,
            generateTaggedPDF,
            generateDocumentOutline,
        });
        const result = await firstValueFrom(from(printCommandPromise).pipe(raceWith(timeout(ms))));
        if (omitBackground) {
            await this.#emulationManager.resetDefaultBackgroundColor();
        }
        assert(result.stream, '`stream` is missing from `Page.printToPDF');
        return await getReadableFromProtocolStream(this.#primaryTargetClient, result.stream);
    }
    async pdf(options = {}) {
        const { path = undefined } = options;
        const readable = await this.createPDFStream(options);
        const typedArray = await getReadableAsTypedArray(readable, path);
        assert(typedArray, 'Could not create typed array');
        return typedArray;
    }
    async close(options = { runBeforeUnload: undefined }) {
        const env_3 = { stack: [], error: void 0, hasError: false };
        try {
            const _guard = __addDisposableResource$2(env_3, await this.browserContext().waitForScreenshotOperations(), false);
            const connection = this.#primaryTargetClient.connection();
            assert(connection, 'Connection closed. Most likely the page has been closed.');
            const runBeforeUnload = !!options.runBeforeUnload;
            if (runBeforeUnload) {
                await this.#primaryTargetClient.send('Page.close');
            }
            else {
                await connection.send('Target.closeTarget', {
                    targetId: this.#primaryTarget._targetId,
                });
                await this.#tabTarget._isClosedDeferred.valueOrThrow();
            }
        }
        catch (e_3) {
            env_3.error = e_3;
            env_3.hasError = true;
        }
        finally {
            __disposeResources$2(env_3);
        }
    }
    isClosed() {
        return this.#closed;
    }
    get mouse() {
        return this.#mouse;
    }
    async waitForDevicePrompt(options = {}) {
        return await this.mainFrame().waitForDevicePrompt(options);
    }
}
const supportedMetrics = new Set([
    'Timestamp',
    'Documents',
    'Frames',
    'JSEventListeners',
    'Nodes',
    'LayoutCount',
    'RecalcStyleCount',
    'LayoutDuration',
    'RecalcStyleDuration',
    'ScriptDuration',
    'TaskDuration',
    'JSHeapUsedSize',
    'JSHeapTotalSize',
]);
function getIntersectionRect(clip, viewport) {
    const x = Math.max(clip.x, viewport.x);
    const y = Math.max(clip.y, viewport.y);
    return {
        x,
        y,
        width: Math.max(Math.min(clip.x + clip.width, viewport.x + viewport.width) - x, 0),
        height: Math.max(Math.min(clip.y + clip.height, viewport.y + viewport.height) - y, 0),
    };
}
function convertCookiesPartitionKeyFromPuppeteerToCdp(partitionKey) {
    if (partitionKey === undefined) {
        return undefined;
    }
    if (typeof partitionKey === 'string') {
        return {
            topLevelSite: partitionKey,
            hasCrossSiteAncestor: false,
        };
    }
    return {
        topLevelSite: partitionKey.sourceOrigin,
        hasCrossSiteAncestor: partitionKey.hasCrossSiteAncestor ?? false,
    };
}

/**
 * @license
 * Copyright 2024 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var __addDisposableResource$1 = (undefined && undefined.__addDisposableResource) || function (env, value, async) {
    if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
        var dispose, inner;
        if (async) {
            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
            if (async) inner = dispose;
        }
        if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
        if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };
        env.stack.push({ value: value, dispose: dispose, async: async });
    }
    else if (async) {
        env.stack.push({ async: true });
    }
    return value;
};
var __disposeResources$1 = (undefined && undefined.__disposeResources) || (function (SuppressedError) {
    return function (env) {
        function fail(e) {
            env.error = env.hasError ? new SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
            env.hasError = true;
        }
        var r, s = 0;
        function next() {
            while (r = env.stack.pop()) {
                try {
                    if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
                    if (r.dispose) {
                        var result = r.dispose.call(r.value);
                        if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
                    }
                    else s |= 1;
                }
                catch (e) {
                    fail(e);
                }
            }
            if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
            if (env.hasError) throw env.error;
        }
        return next();
    };
})(typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
});
class CdpBrowserContext extends BrowserContext {
    #connection;
    #browser;
    #id;
    constructor(connection, browser, contextId) {
        super();
        this.#connection = connection;
        this.#browser = browser;
        this.#id = contextId;
    }
    get id() {
        return this.#id;
    }
    targets() {
        return this.#browser.targets().filter(target => {
            return target.browserContext() === this;
        });
    }
    async pages() {
        const pages = await Promise.all(this.targets()
            .filter(target => {
            return (target.type() === 'page' ||
                (target.type() === 'other' &&
                    this.#browser._getIsPageTargetCallback()?.(target)));
        })
            .map(target => {
            return target.page();
        }));
        return pages.filter((page) => {
            return !!page;
        });
    }
    async overridePermissions(origin, permissions) {
        const protocolPermissions = permissions.map(permission => {
            const protocolPermission = WEB_PERMISSION_TO_PROTOCOL_PERMISSION.get(permission);
            if (!protocolPermission) {
                throw new Error('Unknown permission: ' + permission);
            }
            return protocolPermission;
        });
        await this.#connection.send('Browser.grantPermissions', {
            origin,
            browserContextId: this.#id || undefined,
            permissions: protocolPermissions,
        });
    }
    async clearPermissionOverrides() {
        await this.#connection.send('Browser.resetPermissions', {
            browserContextId: this.#id || undefined,
        });
    }
    async newPage() {
        const env_1 = { stack: [], error: void 0, hasError: false };
        try {
            const _guard = __addDisposableResource$1(env_1, await this.waitForScreenshotOperations(), false);
            return await this.#browser._createPageInContext(this.#id);
        }
        catch (e_1) {
            env_1.error = e_1;
            env_1.hasError = true;
        }
        finally {
            __disposeResources$1(env_1);
        }
    }
    browser() {
        return this.#browser;
    }
    async close() {
        assert(this.#id, 'Default BrowserContext cannot be closed!');
        await this.#browser._disposeContext(this.#id);
    }
    async cookies() {
        const { cookies } = await this.#connection.send('Storage.getCookies', {
            browserContextId: this.#id,
        });
        return cookies.map(cookie => {
            return {
                ...cookie,
                partitionKey: cookie.partitionKey
                    ? {
                        sourceOrigin: cookie.partitionKey.topLevelSite,
                        hasCrossSiteAncestor: cookie.partitionKey.hasCrossSiteAncestor,
                    }
                    : undefined,
            };
        });
    }
    async setCookie(...cookies) {
        return await this.#connection.send('Storage.setCookies', {
            browserContextId: this.#id,
            cookies: cookies.map(cookie => {
                return {
                    ...cookie,
                    partitionKey: convertCookiesPartitionKeyFromPuppeteerToCdp(cookie.partitionKey),
                };
            }),
        });
    }
    async setDownloadBehavior(downloadBehavior) {
        await this.#connection.send('Browser.setDownloadBehavior', {
            behavior: downloadBehavior.policy,
            downloadPath: downloadBehavior.downloadPath,
            browserContextId: this.#id,
        });
    }
}

/**
 * @license
 * Copyright 2019 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var InitializationStatus;
(function (InitializationStatus) {
    InitializationStatus["SUCCESS"] = "success";
    InitializationStatus["ABORTED"] = "aborted";
})(InitializationStatus || (InitializationStatus = {}));
class CdpTarget extends Target {
    #browserContext;
    #session;
    #targetInfo;
    #targetManager;
    #sessionFactory;
    #childTargets = new Set();
    _initializedDeferred = Deferred.create();
    _isClosedDeferred = Deferred.create();
    _targetId;
    constructor(targetInfo, session, browserContext, targetManager, sessionFactory) {
        super();
        this.#session = session;
        this.#targetManager = targetManager;
        this.#targetInfo = targetInfo;
        this.#browserContext = browserContext;
        this._targetId = targetInfo.targetId;
        this.#sessionFactory = sessionFactory;
        if (this.#session) {
            this.#session.setTarget(this);
        }
    }
    async asPage() {
        const session = this._session();
        if (!session) {
            return await this.createCDPSession().then(client => {
                return CdpPage._create(client, this, null);
            });
        }
        return await CdpPage._create(session, this, null);
    }
    _subtype() {
        return this.#targetInfo.subtype;
    }
    _session() {
        return this.#session;
    }
    _addChildTarget(target) {
        this.#childTargets.add(target);
    }
    _removeChildTarget(target) {
        this.#childTargets.delete(target);
    }
    _childTargets() {
        return this.#childTargets;
    }
    _sessionFactory() {
        if (!this.#sessionFactory) {
            throw new Error('sessionFactory is not initialized');
        }
        return this.#sessionFactory;
    }
    createCDPSession() {
        if (!this.#sessionFactory) {
            throw new Error('sessionFactory is not initialized');
        }
        return this.#sessionFactory(false).then(session => {
            session.setTarget(this);
            return session;
        });
    }
    url() {
        return this.#targetInfo.url;
    }
    type() {
        const type = this.#targetInfo.type;
        switch (type) {
            case 'page':
                return TargetType.PAGE;
            case 'background_page':
                return TargetType.BACKGROUND_PAGE;
            case 'service_worker':
                return TargetType.SERVICE_WORKER;
            case 'shared_worker':
                return TargetType.SHARED_WORKER;
            case 'browser':
                return TargetType.BROWSER;
            case 'webview':
                return TargetType.WEBVIEW;
            case 'tab':
                return TargetType.TAB;
            default:
                return TargetType.OTHER;
        }
    }
    _targetManager() {
        if (!this.#targetManager) {
            throw new Error('targetManager is not initialized');
        }
        return this.#targetManager;
    }
    _getTargetInfo() {
        return this.#targetInfo;
    }
    browser() {
        if (!this.#browserContext) {
            throw new Error('browserContext is not initialized');
        }
        return this.#browserContext.browser();
    }
    browserContext() {
        if (!this.#browserContext) {
            throw new Error('browserContext is not initialized');
        }
        return this.#browserContext;
    }
    opener() {
        const { openerId } = this.#targetInfo;
        if (!openerId) {
            return;
        }
        return this.browser()
            .targets()
            .find(target => {
            return target._targetId === openerId;
        });
    }
    _targetInfoChanged(targetInfo) {
        this.#targetInfo = targetInfo;
        this._checkIfInitialized();
    }
    _initialize() {
        this._initializedDeferred.resolve(InitializationStatus.SUCCESS);
    }
    _isTargetExposed() {
        return this.type() !== TargetType.TAB && !this._subtype();
    }
    _checkIfInitialized() {
        if (!this._initializedDeferred.resolved()) {
            this._initializedDeferred.resolve(InitializationStatus.SUCCESS);
        }
    }
}
class PageTarget extends CdpTarget {
    #defaultViewport;
    pagePromise;
    constructor(targetInfo, session, browserContext, targetManager, sessionFactory, defaultViewport) {
        super(targetInfo, session, browserContext, targetManager, sessionFactory);
        this.#defaultViewport = defaultViewport ?? undefined;
    }
    _initialize() {
        this._initializedDeferred
            .valueOrThrow()
            .then(async (result) => {
            if (result === InitializationStatus.ABORTED) {
                return;
            }
            const opener = this.opener();
            if (!(opener instanceof PageTarget)) {
                return;
            }
            if (!opener || !opener.pagePromise || this.type() !== 'page') {
                return true;
            }
            const openerPage = await opener.pagePromise;
            if (!openerPage.listenerCount("popup" )) {
                return true;
            }
            const popupPage = await this.page();
            openerPage.emit("popup" , popupPage);
            return true;
        })
            .catch(debugError);
        this._checkIfInitialized();
    }
    async page() {
        if (!this.pagePromise) {
            const session = this._session();
            this.pagePromise = (session
                ? Promise.resolve(session)
                : this._sessionFactory()( false)).then(client => {
                return CdpPage._create(client, this, this.#defaultViewport ?? null);
            });
        }
        return (await this.pagePromise) ?? null;
    }
    _checkIfInitialized() {
        if (this._initializedDeferred.resolved()) {
            return;
        }
        if (this._getTargetInfo().url !== '') {
            this._initializedDeferred.resolve(InitializationStatus.SUCCESS);
        }
    }
}
class DevToolsTarget extends PageTarget {
}
class WorkerTarget extends CdpTarget {
    #workerPromise;
    async worker() {
        if (!this.#workerPromise) {
            const session = this._session();
            this.#workerPromise = (session
                ? Promise.resolve(session)
                : this._sessionFactory()( false)).then(client => {
                return new CdpWebWorker(client, this._getTargetInfo().url, this._targetId, this.type(), () => { } , () => { } , undefined );
            });
        }
        return await this.#workerPromise;
    }
}
class OtherTarget extends CdpTarget {
}

/**
 * @license
 * Copyright 2022 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
function isPageTargetBecomingPrimary(target, newTargetInfo) {
    return Boolean(target._subtype()) && !newTargetInfo.subtype;
}
class TargetManager extends EventEmitter {
    #connection;
    #discoveredTargetsByTargetId = new Map();
    #attachedTargetsByTargetId = new Map();
    #attachedTargetsBySessionId = new Map();
    #ignoredTargets = new Set();
    #targetFilterCallback;
    #targetFactory;
    #attachedToTargetListenersBySession = new WeakMap();
    #detachedFromTargetListenersBySession = new WeakMap();
    #initializeDeferred = Deferred.create();
    #targetsIdsForInit = new Set();
    #waitForInitiallyDiscoveredTargets = true;
    #discoveryFilter = [{}];
    constructor(connection, targetFactory, targetFilterCallback, waitForInitiallyDiscoveredTargets = true) {
        super();
        this.#connection = connection;
        this.#targetFilterCallback = targetFilterCallback;
        this.#targetFactory = targetFactory;
        this.#waitForInitiallyDiscoveredTargets = waitForInitiallyDiscoveredTargets;
        this.#connection.on('Target.targetCreated', this.#onTargetCreated);
        this.#connection.on('Target.targetDestroyed', this.#onTargetDestroyed);
        this.#connection.on('Target.targetInfoChanged', this.#onTargetInfoChanged);
        this.#connection.on(CDPSessionEvent.SessionDetached, this.#onSessionDetached);
        this.#setupAttachmentListeners(this.#connection);
    }
    #storeExistingTargetsForInit = () => {
        if (!this.#waitForInitiallyDiscoveredTargets) {
            return;
        }
        for (const [targetId, targetInfo,] of this.#discoveredTargetsByTargetId.entries()) {
            const targetForFilter = new CdpTarget(targetInfo, undefined, undefined, this, undefined);
            const isPageOrFrame = targetInfo.type === 'page' || targetInfo.type === 'iframe';
            const isExtension = targetInfo.url.startsWith('chrome-extension://');
            if ((!this.#targetFilterCallback ||
                this.#targetFilterCallback(targetForFilter)) &&
                isPageOrFrame &&
                !isExtension) {
                this.#targetsIdsForInit.add(targetId);
            }
        }
    };
    async initialize() {
        await this.#connection.send('Target.setDiscoverTargets', {
            discover: true,
            filter: this.#discoveryFilter,
        });
        this.#storeExistingTargetsForInit();
        await this.#connection.send('Target.setAutoAttach', {
            waitForDebuggerOnStart: true,
            flatten: true,
            autoAttach: true,
            filter: [
                {
                    type: 'page',
                    exclude: true,
                },
                ...this.#discoveryFilter,
            ],
        });
        this.#finishInitializationIfReady();
        await this.#initializeDeferred.valueOrThrow();
    }
    getChildTargets(target) {
        return target._childTargets();
    }
    dispose() {
        this.#connection.off('Target.targetCreated', this.#onTargetCreated);
        this.#connection.off('Target.targetDestroyed', this.#onTargetDestroyed);
        this.#connection.off('Target.targetInfoChanged', this.#onTargetInfoChanged);
        this.#connection.off(CDPSessionEvent.SessionDetached, this.#onSessionDetached);
        this.#removeAttachmentListeners(this.#connection);
    }
    getAvailableTargets() {
        return this.#attachedTargetsByTargetId;
    }
    #setupAttachmentListeners(session) {
        const listener = (event) => {
            void this.#onAttachedToTarget(session, event);
        };
        assert(!this.#attachedToTargetListenersBySession.has(session));
        this.#attachedToTargetListenersBySession.set(session, listener);
        session.on('Target.attachedToTarget', listener);
        const detachedListener = (event) => {
            return this.#onDetachedFromTarget(session, event);
        };
        assert(!this.#detachedFromTargetListenersBySession.has(session));
        this.#detachedFromTargetListenersBySession.set(session, detachedListener);
        session.on('Target.detachedFromTarget', detachedListener);
    }
    #removeAttachmentListeners(session) {
        const listener = this.#attachedToTargetListenersBySession.get(session);
        if (listener) {
            session.off('Target.attachedToTarget', listener);
            this.#attachedToTargetListenersBySession.delete(session);
        }
        if (this.#detachedFromTargetListenersBySession.has(session)) {
            session.off('Target.detachedFromTarget', this.#detachedFromTargetListenersBySession.get(session));
            this.#detachedFromTargetListenersBySession.delete(session);
        }
    }
    #onSessionDetached = (session) => {
        this.#removeAttachmentListeners(session);
    };
    #onTargetCreated = async (event) => {
        this.#discoveredTargetsByTargetId.set(event.targetInfo.targetId, event.targetInfo);
        this.emit("targetDiscovered" , event.targetInfo);
        if (event.targetInfo.type === 'browser' && event.targetInfo.attached) {
            if (this.#attachedTargetsByTargetId.has(event.targetInfo.targetId)) {
                return;
            }
            const target = this.#targetFactory(event.targetInfo, undefined);
            target._initialize();
            this.#attachedTargetsByTargetId.set(event.targetInfo.targetId, target);
        }
    };
    #onTargetDestroyed = (event) => {
        const targetInfo = this.#discoveredTargetsByTargetId.get(event.targetId);
        this.#discoveredTargetsByTargetId.delete(event.targetId);
        this.#finishInitializationIfReady(event.targetId);
        if (targetInfo?.type === 'service_worker' &&
            this.#attachedTargetsByTargetId.has(event.targetId)) {
            const target = this.#attachedTargetsByTargetId.get(event.targetId);
            if (target) {
                this.emit("targetGone" , target);
                this.#attachedTargetsByTargetId.delete(event.targetId);
            }
        }
    };
    #onTargetInfoChanged = (event) => {
        this.#discoveredTargetsByTargetId.set(event.targetInfo.targetId, event.targetInfo);
        if (this.#ignoredTargets.has(event.targetInfo.targetId) ||
            !this.#attachedTargetsByTargetId.has(event.targetInfo.targetId) ||
            !event.targetInfo.attached) {
            return;
        }
        const target = this.#attachedTargetsByTargetId.get(event.targetInfo.targetId);
        if (!target) {
            return;
        }
        const previousURL = target.url();
        const wasInitialized = target._initializedDeferred.value() === InitializationStatus.SUCCESS;
        if (isPageTargetBecomingPrimary(target, event.targetInfo)) {
            const session = target?._session();
            assert(session, 'Target that is being activated is missing a CDPSession.');
            session.parentSession()?.emit(CDPSessionEvent.Swapped, session);
        }
        target._targetInfoChanged(event.targetInfo);
        if (wasInitialized && previousURL !== target.url()) {
            this.emit("targetChanged" , {
                target,
                wasInitialized,
                previousURL,
            });
        }
    };
    #onAttachedToTarget = async (parentSession, event) => {
        const targetInfo = event.targetInfo;
        const session = this.#connection._session(event.sessionId);
        if (!session) {
            throw new Error(`Session ${event.sessionId} was not created.`);
        }
        const silentDetach = async () => {
            await session.send('Runtime.runIfWaitingForDebugger').catch(debugError);
            await parentSession
                .send('Target.detachFromTarget', {
                sessionId: session.id(),
            })
                .catch(debugError);
        };
        if (!this.#connection.isAutoAttached(targetInfo.targetId)) {
            return;
        }
        if (targetInfo.type === 'service_worker') {
            this.#finishInitializationIfReady(targetInfo.targetId);
            await silentDetach();
            if (this.#attachedTargetsByTargetId.has(targetInfo.targetId)) {
                return;
            }
            const target = this.#targetFactory(targetInfo);
            target._initialize();
            this.#attachedTargetsByTargetId.set(targetInfo.targetId, target);
            this.emit("targetAvailable" , target);
            return;
        }
        const isExistingTarget = this.#attachedTargetsByTargetId.has(targetInfo.targetId);
        const target = isExistingTarget
            ? this.#attachedTargetsByTargetId.get(targetInfo.targetId)
            : this.#targetFactory(targetInfo, session, parentSession instanceof CdpCDPSession ? parentSession : undefined);
        if (this.#targetFilterCallback && !this.#targetFilterCallback(target)) {
            this.#ignoredTargets.add(targetInfo.targetId);
            this.#finishInitializationIfReady(targetInfo.targetId);
            await silentDetach();
            return;
        }
        this.#setupAttachmentListeners(session);
        if (isExistingTarget) {
            session.setTarget(target);
            this.#attachedTargetsBySessionId.set(session.id(), this.#attachedTargetsByTargetId.get(targetInfo.targetId));
        }
        else {
            target._initialize();
            this.#attachedTargetsByTargetId.set(targetInfo.targetId, target);
            this.#attachedTargetsBySessionId.set(session.id(), target);
        }
        const parentTarget = parentSession instanceof CDPSession
            ? parentSession.target()
            : null;
        parentTarget?._addChildTarget(target);
        parentSession.emit(CDPSessionEvent.Ready, session);
        this.#targetsIdsForInit.delete(target._targetId);
        if (!isExistingTarget) {
            this.emit("targetAvailable" , target);
        }
        this.#finishInitializationIfReady();
        await Promise.all([
            session.send('Target.setAutoAttach', {
                waitForDebuggerOnStart: true,
                flatten: true,
                autoAttach: true,
                filter: this.#discoveryFilter,
            }),
            session.send('Runtime.runIfWaitingForDebugger'),
        ]).catch(debugError);
    };
    #finishInitializationIfReady(targetId) {
        if (targetId !== undefined) {
            this.#targetsIdsForInit.delete(targetId);
        }
        if (this.#targetsIdsForInit.size === 0) {
            this.#initializeDeferred.resolve();
        }
    }
    #onDetachedFromTarget = (parentSession, event) => {
        const target = this.#attachedTargetsBySessionId.get(event.sessionId);
        this.#attachedTargetsBySessionId.delete(event.sessionId);
        if (!target) {
            return;
        }
        if (parentSession instanceof CDPSession) {
            parentSession.target()._removeChildTarget(target);
        }
        this.#attachedTargetsByTargetId.delete(target._targetId);
        this.emit("targetGone" , target);
    };
}

/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class CdpBrowser extends Browser$1 {
    protocol = 'cdp';
    static async _create(connection, contextIds, acceptInsecureCerts, defaultViewport, downloadBehavior, process, closeCallback, targetFilterCallback, isPageTargetCallback, waitForInitiallyDiscoveredTargets = true, networkEnabled = true, handleDevToolsAsPage = false) {
        const browser = new CdpBrowser(connection, contextIds, defaultViewport, process, closeCallback, targetFilterCallback, isPageTargetCallback, waitForInitiallyDiscoveredTargets, networkEnabled, handleDevToolsAsPage);
        if (acceptInsecureCerts) {
            await connection.send('Security.setIgnoreCertificateErrors', {
                ignore: true,
            });
        }
        await browser._attach(downloadBehavior);
        return browser;
    }
    #defaultViewport;
    #process;
    #connection;
    #closeCallback;
    #targetFilterCallback;
    #isPageTargetCallback;
    #defaultContext;
    #contexts = new Map();
    #networkEnabled = true;
    #targetManager;
    #handleDevToolsAsPage = false;
    constructor(connection, contextIds, defaultViewport, process, closeCallback, targetFilterCallback, isPageTargetCallback, waitForInitiallyDiscoveredTargets = true, networkEnabled = true, handleDevToolsAsPage = false) {
        super();
        this.#networkEnabled = networkEnabled;
        this.#defaultViewport = defaultViewport;
        this.#process = process;
        this.#connection = connection;
        this.#closeCallback = closeCallback || (() => { });
        this.#targetFilterCallback =
            targetFilterCallback ||
                (() => {
                    return true;
                });
        this.#handleDevToolsAsPage = handleDevToolsAsPage;
        this.#setIsPageTargetCallback(isPageTargetCallback);
        this.#targetManager = new TargetManager(connection, this.#createTarget, this.#targetFilterCallback, waitForInitiallyDiscoveredTargets);
        this.#defaultContext = new CdpBrowserContext(this.#connection, this);
        for (const contextId of contextIds) {
            this.#contexts.set(contextId, new CdpBrowserContext(this.#connection, this, contextId));
        }
    }
    #emitDisconnected = () => {
        this.emit("disconnected" , undefined);
    };
    async _attach(downloadBehavior) {
        this.#connection.on(CDPSessionEvent.Disconnected, this.#emitDisconnected);
        if (downloadBehavior) {
            await this.#defaultContext.setDownloadBehavior(downloadBehavior);
        }
        this.#targetManager.on("targetAvailable" , this.#onAttachedToTarget);
        this.#targetManager.on("targetGone" , this.#onDetachedFromTarget);
        this.#targetManager.on("targetChanged" , this.#onTargetChanged);
        this.#targetManager.on("targetDiscovered" , this.#onTargetDiscovered);
        await this.#targetManager.initialize();
    }
    _detach() {
        this.#connection.off(CDPSessionEvent.Disconnected, this.#emitDisconnected);
        this.#targetManager.off("targetAvailable" , this.#onAttachedToTarget);
        this.#targetManager.off("targetGone" , this.#onDetachedFromTarget);
        this.#targetManager.off("targetChanged" , this.#onTargetChanged);
        this.#targetManager.off("targetDiscovered" , this.#onTargetDiscovered);
    }
    process() {
        return this.#process ?? null;
    }
    _targetManager() {
        return this.#targetManager;
    }
    #setIsPageTargetCallback(isPageTargetCallback) {
        this.#isPageTargetCallback =
            isPageTargetCallback ||
                ((target) => {
                    return (target.type() === 'page' ||
                        target.type() === 'background_page' ||
                        target.type() === 'webview' ||
                        (this.#handleDevToolsAsPage &&
                            target.type() === 'other' &&
                            target.url().startsWith('devtools://')));
                });
    }
    _getIsPageTargetCallback() {
        return this.#isPageTargetCallback;
    }
    async createBrowserContext(options = {}) {
        const { proxyServer, proxyBypassList, downloadBehavior } = options;
        const { browserContextId } = await this.#connection.send('Target.createBrowserContext', {
            proxyServer,
            proxyBypassList: proxyBypassList && proxyBypassList.join(','),
        });
        const context = new CdpBrowserContext(this.#connection, this, browserContextId);
        if (downloadBehavior) {
            await context.setDownloadBehavior(downloadBehavior);
        }
        this.#contexts.set(browserContextId, context);
        return context;
    }
    browserContexts() {
        return [this.#defaultContext, ...Array.from(this.#contexts.values())];
    }
    defaultBrowserContext() {
        return this.#defaultContext;
    }
    async _disposeContext(contextId) {
        if (!contextId) {
            return;
        }
        await this.#connection.send('Target.disposeBrowserContext', {
            browserContextId: contextId,
        });
        this.#contexts.delete(contextId);
    }
    #createTarget = (targetInfo, session) => {
        const { browserContextId } = targetInfo;
        const context = browserContextId && this.#contexts.has(browserContextId)
            ? this.#contexts.get(browserContextId)
            : this.#defaultContext;
        if (!context) {
            throw new Error('Missing browser context');
        }
        const createSession = (isAutoAttachEmulated) => {
            return this.#connection._createSession(targetInfo, isAutoAttachEmulated);
        };
        const otherTarget = new OtherTarget(targetInfo, session, context, this.#targetManager, createSession);
        if (targetInfo.url?.startsWith('devtools://')) {
            return new DevToolsTarget(targetInfo, session, context, this.#targetManager, createSession, this.#defaultViewport ?? null);
        }
        if (this.#isPageTargetCallback(otherTarget)) {
            return new PageTarget(targetInfo, session, context, this.#targetManager, createSession, this.#defaultViewport ?? null);
        }
        if (targetInfo.type === 'service_worker' ||
            targetInfo.type === 'shared_worker') {
            return new WorkerTarget(targetInfo, session, context, this.#targetManager, createSession);
        }
        return otherTarget;
    };
    #onAttachedToTarget = async (target) => {
        if (target._isTargetExposed() &&
            (await target._initializedDeferred.valueOrThrow()) ===
                InitializationStatus.SUCCESS) {
            this.emit("targetcreated" , target);
            target.browserContext().emit("targetcreated" , target);
        }
    };
    #onDetachedFromTarget = async (target) => {
        target._initializedDeferred.resolve(InitializationStatus.ABORTED);
        target._isClosedDeferred.resolve();
        if (target._isTargetExposed() &&
            (await target._initializedDeferred.valueOrThrow()) ===
                InitializationStatus.SUCCESS) {
            this.emit("targetdestroyed" , target);
            target.browserContext().emit("targetdestroyed" , target);
        }
    };
    #onTargetChanged = ({ target }) => {
        this.emit("targetchanged" , target);
        target.browserContext().emit("targetchanged" , target);
    };
    #onTargetDiscovered = (targetInfo) => {
        this.emit("targetdiscovered" , targetInfo);
    };
    wsEndpoint() {
        return this.#connection.url();
    }
    async newPage() {
        return await this.#defaultContext.newPage();
    }
    async _createPageInContext(contextId) {
        const { targetId } = await this.#connection.send('Target.createTarget', {
            url: 'about:blank',
            browserContextId: contextId || undefined,
        });
        const target = (await this.waitForTarget(t => {
            return t._targetId === targetId;
        }));
        if (!target) {
            throw new Error(`Missing target for page (id = ${targetId})`);
        }
        const initialized = (await target._initializedDeferred.valueOrThrow()) ===
            InitializationStatus.SUCCESS;
        if (!initialized) {
            throw new Error(`Failed to create target for page (id = ${targetId})`);
        }
        const page = await target.page();
        if (!page) {
            throw new Error(`Failed to create a page for context (id = ${contextId})`);
        }
        return page;
    }
    async installExtension(path) {
        const { id } = await this.#connection.send('Extensions.loadUnpacked', { path });
        return id;
    }
    uninstallExtension(id) {
        return this.#connection.send('Extensions.uninstall', { id });
    }
    targets() {
        return Array.from(this.#targetManager.getAvailableTargets().values()).filter(target => {
            return (target._isTargetExposed() &&
                target._initializedDeferred.value() === InitializationStatus.SUCCESS);
        });
    }
    target() {
        const browserTarget = this.targets().find(target => {
            return target.type() === 'browser';
        });
        if (!browserTarget) {
            throw new Error('Browser target is not found');
        }
        return browserTarget;
    }
    async version() {
        const version = await this.#getVersion();
        return version.product;
    }
    async userAgent() {
        const version = await this.#getVersion();
        return version.userAgent;
    }
    async close() {
        await this.#closeCallback.call(null);
        await this.disconnect();
    }
    disconnect() {
        this.#targetManager.dispose();
        this.#connection.dispose();
        this._detach();
        return Promise.resolve();
    }
    get connected() {
        return !this.#connection._closed;
    }
    #getVersion() {
        return this.#connection.send('Browser.getVersion');
    }
    get debugInfo() {
        return {
            pendingProtocolErrors: this.#connection.getPendingProtocolErrors(),
        };
    }
    isNetworkEnabled() {
        return this.#networkEnabled;
    }
}

/**
 * @license
 * Copyright 2020 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
async function _connectToCdpBrowser(connectionTransport, url, options) {
    const { acceptInsecureCerts = false, networkEnabled = true, defaultViewport = DEFAULT_VIEWPORT, downloadBehavior, targetFilter, _isPageTarget: isPageTarget, slowMo = 0, protocolTimeout, handleDevToolsAsPage, } = options;
    const connection = new Connection(url, connectionTransport, slowMo, protocolTimeout);
    const { browserContextIds } = await connection.send('Target.getBrowserContexts');
    const browser = await CdpBrowser._create(connection, browserContextIds, acceptInsecureCerts, defaultViewport, downloadBehavior, undefined, () => {
        return connection.send('Browser.close').catch(debugError);
    }, targetFilter, isPageTarget, undefined, networkEnabled, handleDevToolsAsPage);
    return browser;
}

/**
 * @license
 * Copyright 2021 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const PredefinedNetworkConditions = Object.freeze({
    'Slow 3G': {
        download: ((500 * 1000) / 8) * 0.8,
        upload: ((500 * 1000) / 8) * 0.8,
        latency: 400 * 5,
    },
    'Fast 3G': {
        download: ((1.6 * 1000 * 1000) / 8) * 0.9,
        upload: ((750 * 1000) / 8) * 0.9,
        latency: 150 * 3.75,
    },
    'Slow 4G': {
        download: ((1.6 * 1000 * 1000) / 8) * 0.9,
        upload: ((750 * 1000) / 8) * 0.9,
        latency: 150 * 3.75,
    },
    'Fast 4G': {
        download: ((9 * 1000 * 1000) / 8) * 0.9,
        upload: ((1.5 * 1000 * 1000) / 8) * 0.9,
        latency: 60 * 2.75,
    },
});

class BrowserWebSocketTransport {
    static create(url) {
        return new Promise((resolve, reject) => {
            const ws = new WebSocket(url);
            ws.addEventListener('open', () => {
                return resolve(new BrowserWebSocketTransport(ws));
            });
            ws.addEventListener('error', reject);
        });
    }
    #ws;
    onmessage;
    onclose;
    constructor(ws) {
        this.#ws = ws;
        this.#ws.addEventListener('message', event => {
            if (this.onmessage) {
                this.onmessage.call(null, event.data);
            }
        });
        this.#ws.addEventListener('close', () => {
            if (this.onclose) {
                this.onclose.call(null);
            }
        });
        this.#ws.addEventListener('error', () => { });
    }
    send(message) {
        this.#ws.send(message);
    }
    close() {
        this.#ws.close();
    }
}

var BrowserWebSocketTransport$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	BrowserWebSocketTransport: BrowserWebSocketTransport
});

/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const knownDevices = [
    {
        name: 'Blackberry PlayBook',
        userAgent: 'Mozilla/5.0 (PlayBook; U; RIM Tablet OS 2.1.0; en-US) AppleWebKit/536.2+ (KHTML like Gecko) Version/7.2.1.0 Safari/536.2+',
        viewport: {
            width: 600,
            height: 1024,
            deviceScaleFactor: 1,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'Blackberry PlayBook landscape',
        userAgent: 'Mozilla/5.0 (PlayBook; U; RIM Tablet OS 2.1.0; en-US) AppleWebKit/536.2+ (KHTML like Gecko) Version/7.2.1.0 Safari/536.2+',
        viewport: {
            width: 1024,
            height: 600,
            deviceScaleFactor: 1,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'BlackBerry Z30',
        userAgent: 'Mozilla/5.0 (BB10; Touch) AppleWebKit/537.10+ (KHTML, like Gecko) Version/10.0.9.2372 Mobile Safari/537.10+',
        viewport: {
            width: 360,
            height: 640,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'BlackBerry Z30 landscape',
        userAgent: 'Mozilla/5.0 (BB10; Touch) AppleWebKit/537.10+ (KHTML, like Gecko) Version/10.0.9.2372 Mobile Safari/537.10+',
        viewport: {
            width: 640,
            height: 360,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'Galaxy Note 3',
        userAgent: 'Mozilla/5.0 (Linux; U; Android 4.3; en-us; SM-N900T Build/JSS15J) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30',
        viewport: {
            width: 360,
            height: 640,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'Galaxy Note 3 landscape',
        userAgent: 'Mozilla/5.0 (Linux; U; Android 4.3; en-us; SM-N900T Build/JSS15J) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30',
        viewport: {
            width: 640,
            height: 360,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'Galaxy Note II',
        userAgent: 'Mozilla/5.0 (Linux; U; Android 4.1; en-us; GT-N7100 Build/JRO03C) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30',
        viewport: {
            width: 360,
            height: 640,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'Galaxy Note II landscape',
        userAgent: 'Mozilla/5.0 (Linux; U; Android 4.1; en-us; GT-N7100 Build/JRO03C) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30',
        viewport: {
            width: 640,
            height: 360,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'Galaxy S III',
        userAgent: 'Mozilla/5.0 (Linux; U; Android 4.0; en-us; GT-I9300 Build/IMM76D) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30',
        viewport: {
            width: 360,
            height: 640,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'Galaxy S III landscape',
        userAgent: 'Mozilla/5.0 (Linux; U; Android 4.0; en-us; GT-I9300 Build/IMM76D) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30',
        viewport: {
            width: 640,
            height: 360,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'Galaxy S5',
        userAgent: 'Mozilla/5.0 (Linux; Android 5.0; SM-G900P Build/LRX21T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
        viewport: {
            width: 360,
            height: 640,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'Galaxy S5 landscape',
        userAgent: 'Mozilla/5.0 (Linux; Android 5.0; SM-G900P Build/LRX21T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
        viewport: {
            width: 640,
            height: 360,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'Galaxy S8',
        userAgent: 'Mozilla/5.0 (Linux; Android 7.0; SM-G950U Build/NRD90M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.84 Mobile Safari/537.36',
        viewport: {
            width: 360,
            height: 740,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'Galaxy S8 landscape',
        userAgent: 'Mozilla/5.0 (Linux; Android 7.0; SM-G950U Build/NRD90M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.84 Mobile Safari/537.36',
        viewport: {
            width: 740,
            height: 360,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'Galaxy S9+',
        userAgent: 'Mozilla/5.0 (Linux; Android 8.0.0; SM-G965U Build/R16NW) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.111 Mobile Safari/537.36',
        viewport: {
            width: 320,
            height: 658,
            deviceScaleFactor: 4.5,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'Galaxy S9+ landscape',
        userAgent: 'Mozilla/5.0 (Linux; Android 8.0.0; SM-G965U Build/R16NW) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.111 Mobile Safari/537.36',
        viewport: {
            width: 658,
            height: 320,
            deviceScaleFactor: 4.5,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'Galaxy Tab S4',
        userAgent: 'Mozilla/5.0 (Linux; Android 8.1.0; SM-T837A) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.80 Safari/537.36',
        viewport: {
            width: 712,
            height: 1138,
            deviceScaleFactor: 2.25,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'Galaxy Tab S4 landscape',
        userAgent: 'Mozilla/5.0 (Linux; Android 8.1.0; SM-T837A) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.80 Safari/537.36',
        viewport: {
            width: 1138,
            height: 712,
            deviceScaleFactor: 2.25,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'iPad',
        userAgent: 'Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1',
        viewport: {
            width: 768,
            height: 1024,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'iPad landscape',
        userAgent: 'Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1',
        viewport: {
            width: 1024,
            height: 768,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'iPad (gen 6)',
        userAgent: 'Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1',
        viewport: {
            width: 768,
            height: 1024,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'iPad (gen 6) landscape',
        userAgent: 'Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1',
        viewport: {
            width: 1024,
            height: 768,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'iPad (gen 7)',
        userAgent: 'Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1',
        viewport: {
            width: 810,
            height: 1080,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'iPad (gen 7) landscape',
        userAgent: 'Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1',
        viewport: {
            width: 1080,
            height: 810,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'iPad Mini',
        userAgent: 'Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1',
        viewport: {
            width: 768,
            height: 1024,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'iPad Mini landscape',
        userAgent: 'Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1',
        viewport: {
            width: 1024,
            height: 768,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'iPad Pro',
        userAgent: 'Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1',
        viewport: {
            width: 1024,
            height: 1366,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'iPad Pro landscape',
        userAgent: 'Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1',
        viewport: {
            width: 1366,
            height: 1024,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'iPad Pro 11',
        userAgent: 'Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1',
        viewport: {
            width: 834,
            height: 1194,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'iPad Pro 11 landscape',
        userAgent: 'Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1',
        viewport: {
            width: 1194,
            height: 834,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'iPhone 4',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 7_1_2 like Mac OS X) AppleWebKit/537.51.2 (KHTML, like Gecko) Version/7.0 Mobile/11D257 Safari/9537.53',
        viewport: {
            width: 320,
            height: 480,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'iPhone 4 landscape',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 7_1_2 like Mac OS X) AppleWebKit/537.51.2 (KHTML, like Gecko) Version/7.0 Mobile/11D257 Safari/9537.53',
        viewport: {
            width: 480,
            height: 320,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'iPhone 5',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1',
        viewport: {
            width: 320,
            height: 568,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'iPhone 5 landscape',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1',
        viewport: {
            width: 568,
            height: 320,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'iPhone 6',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1',
        viewport: {
            width: 375,
            height: 667,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'iPhone 6 landscape',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1',
        viewport: {
            width: 667,
            height: 375,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'iPhone 6 Plus',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1',
        viewport: {
            width: 414,
            height: 736,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'iPhone 6 Plus landscape',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1',
        viewport: {
            width: 736,
            height: 414,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'iPhone 7',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1',
        viewport: {
            width: 375,
            height: 667,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'iPhone 7 landscape',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1',
        viewport: {
            width: 667,
            height: 375,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'iPhone 7 Plus',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1',
        viewport: {
            width: 414,
            height: 736,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'iPhone 7 Plus landscape',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1',
        viewport: {
            width: 736,
            height: 414,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'iPhone 8',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1',
        viewport: {
            width: 375,
            height: 667,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'iPhone 8 landscape',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1',
        viewport: {
            width: 667,
            height: 375,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'iPhone 8 Plus',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1',
        viewport: {
            width: 414,
            height: 736,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'iPhone 8 Plus landscape',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1',
        viewport: {
            width: 736,
            height: 414,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'iPhone SE',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1',
        viewport: {
            width: 320,
            height: 568,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'iPhone SE landscape',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1',
        viewport: {
            width: 568,
            height: 320,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'iPhone X',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1',
        viewport: {
            width: 375,
            height: 812,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'iPhone X landscape',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1',
        viewport: {
            width: 812,
            height: 375,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'iPhone XR',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 12_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.0 Mobile/15E148 Safari/604.1',
        viewport: {
            width: 414,
            height: 896,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'iPhone XR landscape',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 12_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.0 Mobile/15E148 Safari/604.1',
        viewport: {
            width: 896,
            height: 414,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'iPhone 11',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1',
        viewport: {
            width: 414,
            height: 828,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'iPhone 11 landscape',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1',
        viewport: {
            width: 828,
            height: 414,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'iPhone 11 Pro',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1',
        viewport: {
            width: 375,
            height: 812,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'iPhone 11 Pro landscape',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1',
        viewport: {
            width: 812,
            height: 375,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'iPhone 11 Pro Max',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1',
        viewport: {
            width: 414,
            height: 896,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'iPhone 11 Pro Max landscape',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1',
        viewport: {
            width: 896,
            height: 414,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'iPhone 12',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1',
        viewport: {
            width: 390,
            height: 844,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'iPhone 12 landscape',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1',
        viewport: {
            width: 844,
            height: 390,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'iPhone 12 Pro',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1',
        viewport: {
            width: 390,
            height: 844,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'iPhone 12 Pro landscape',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1',
        viewport: {
            width: 844,
            height: 390,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'iPhone 12 Pro Max',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1',
        viewport: {
            width: 428,
            height: 926,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'iPhone 12 Pro Max landscape',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1',
        viewport: {
            width: 926,
            height: 428,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'iPhone 12 Mini',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1',
        viewport: {
            width: 375,
            height: 812,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'iPhone 12 Mini landscape',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1',
        viewport: {
            width: 812,
            height: 375,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'iPhone 13',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1',
        viewport: {
            width: 390,
            height: 844,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'iPhone 13 landscape',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1',
        viewport: {
            width: 844,
            height: 390,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'iPhone 13 Pro',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1',
        viewport: {
            width: 390,
            height: 844,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'iPhone 13 Pro landscape',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1',
        viewport: {
            width: 844,
            height: 390,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'iPhone 13 Pro Max',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1',
        viewport: {
            width: 428,
            height: 926,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'iPhone 13 Pro Max landscape',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1',
        viewport: {
            width: 926,
            height: 428,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'iPhone 13 Mini',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1',
        viewport: {
            width: 375,
            height: 812,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'iPhone 13 Mini landscape',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1',
        viewport: {
            width: 812,
            height: 375,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'iPhone 14',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1',
        viewport: {
            width: 390,
            height: 663,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'iPhone 14 landscape',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1',
        viewport: {
            width: 750,
            height: 340,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'iPhone 14 Plus',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1',
        viewport: {
            width: 428,
            height: 745,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'iPhone 14 Plus landscape',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1',
        viewport: {
            width: 832,
            height: 378,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'iPhone 14 Pro',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1',
        viewport: {
            width: 393,
            height: 659,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'iPhone 14 Pro landscape',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1',
        viewport: {
            width: 734,
            height: 343,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'iPhone 14 Pro Max',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1',
        viewport: {
            width: 430,
            height: 739,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'iPhone 14 Pro Max landscape',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1',
        viewport: {
            width: 814,
            height: 380,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'iPhone 15',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.5 Mobile/15E148 Safari/604.1',
        viewport: {
            width: 393,
            height: 659,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'iPhone 15 landscape',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.5 Mobile/15E148 Safari/604.1',
        viewport: {
            width: 734,
            height: 343,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'iPhone 15 Plus',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.5 Mobile/15E148 Safari/604.1',
        viewport: {
            width: 430,
            height: 739,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'iPhone 15 Plus landscape',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.5 Mobile/15E148 Safari/604.1',
        viewport: {
            width: 814,
            height: 380,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'iPhone 15 Pro',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.5 Mobile/15E148 Safari/604.1',
        viewport: {
            width: 393,
            height: 659,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'iPhone 15 Pro landscape',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.5 Mobile/15E148 Safari/604.1',
        viewport: {
            width: 734,
            height: 343,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'iPhone 15 Pro Max',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.5 Mobile/15E148 Safari/604.1',
        viewport: {
            width: 430,
            height: 739,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'iPhone 15 Pro Max landscape',
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.5 Mobile/15E148 Safari/604.1',
        viewport: {
            width: 814,
            height: 380,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'JioPhone 2',
        userAgent: 'Mozilla/5.0 (Mobile; LYF/F300B/LYF-F300B-001-01-15-130718-i;Android; rv:48.0) Gecko/48.0 Firefox/48.0 KAIOS/2.5',
        viewport: {
            width: 240,
            height: 320,
            deviceScaleFactor: 1,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'JioPhone 2 landscape',
        userAgent: 'Mozilla/5.0 (Mobile; LYF/F300B/LYF-F300B-001-01-15-130718-i;Android; rv:48.0) Gecko/48.0 Firefox/48.0 KAIOS/2.5',
        viewport: {
            width: 320,
            height: 240,
            deviceScaleFactor: 1,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'Kindle Fire HDX',
        userAgent: 'Mozilla/5.0 (Linux; U; en-us; KFAPWI Build/JDQ39) AppleWebKit/535.19 (KHTML, like Gecko) Silk/3.13 Safari/535.19 Silk-Accelerated=true',
        viewport: {
            width: 800,
            height: 1280,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'Kindle Fire HDX landscape',
        userAgent: 'Mozilla/5.0 (Linux; U; en-us; KFAPWI Build/JDQ39) AppleWebKit/535.19 (KHTML, like Gecko) Silk/3.13 Safari/535.19 Silk-Accelerated=true',
        viewport: {
            width: 1280,
            height: 800,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'LG Optimus L70',
        userAgent: 'Mozilla/5.0 (Linux; U; Android 4.4.2; en-us; LGMS323 Build/KOT49I.MS32310c) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/75.0.3765.0 Mobile Safari/537.36',
        viewport: {
            width: 384,
            height: 640,
            deviceScaleFactor: 1.25,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'LG Optimus L70 landscape',
        userAgent: 'Mozilla/5.0 (Linux; U; Android 4.4.2; en-us; LGMS323 Build/KOT49I.MS32310c) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/75.0.3765.0 Mobile Safari/537.36',
        viewport: {
            width: 640,
            height: 384,
            deviceScaleFactor: 1.25,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'Microsoft Lumia 550',
        userAgent: 'Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 550) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Mobile Safari/537.36 Edge/14.14263',
        viewport: {
            width: 640,
            height: 360,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'Microsoft Lumia 950',
        userAgent: 'Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 950) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Mobile Safari/537.36 Edge/14.14263',
        viewport: {
            width: 360,
            height: 640,
            deviceScaleFactor: 4,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'Microsoft Lumia 950 landscape',
        userAgent: 'Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 950) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Mobile Safari/537.36 Edge/14.14263',
        viewport: {
            width: 640,
            height: 360,
            deviceScaleFactor: 4,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'Nexus 10',
        userAgent: 'Mozilla/5.0 (Linux; Android 6.0.1; Nexus 10 Build/MOB31T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Safari/537.36',
        viewport: {
            width: 800,
            height: 1280,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'Nexus 10 landscape',
        userAgent: 'Mozilla/5.0 (Linux; Android 6.0.1; Nexus 10 Build/MOB31T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Safari/537.36',
        viewport: {
            width: 1280,
            height: 800,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'Nexus 4',
        userAgent: 'Mozilla/5.0 (Linux; Android 4.4.2; Nexus 4 Build/KOT49H) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
        viewport: {
            width: 384,
            height: 640,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'Nexus 4 landscape',
        userAgent: 'Mozilla/5.0 (Linux; Android 4.4.2; Nexus 4 Build/KOT49H) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
        viewport: {
            width: 640,
            height: 384,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'Nexus 5',
        userAgent: 'Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
        viewport: {
            width: 360,
            height: 640,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'Nexus 5 landscape',
        userAgent: 'Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
        viewport: {
            width: 640,
            height: 360,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'Nexus 5X',
        userAgent: 'Mozilla/5.0 (Linux; Android 8.0.0; Nexus 5X Build/OPR4.170623.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
        viewport: {
            width: 412,
            height: 732,
            deviceScaleFactor: 2.625,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'Nexus 5X landscape',
        userAgent: 'Mozilla/5.0 (Linux; Android 8.0.0; Nexus 5X Build/OPR4.170623.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
        viewport: {
            width: 732,
            height: 412,
            deviceScaleFactor: 2.625,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'Nexus 6',
        userAgent: 'Mozilla/5.0 (Linux; Android 7.1.1; Nexus 6 Build/N6F26U) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
        viewport: {
            width: 412,
            height: 732,
            deviceScaleFactor: 3.5,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'Nexus 6 landscape',
        userAgent: 'Mozilla/5.0 (Linux; Android 7.1.1; Nexus 6 Build/N6F26U) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
        viewport: {
            width: 732,
            height: 412,
            deviceScaleFactor: 3.5,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'Nexus 6P',
        userAgent: 'Mozilla/5.0 (Linux; Android 8.0.0; Nexus 6P Build/OPP3.170518.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
        viewport: {
            width: 412,
            height: 732,
            deviceScaleFactor: 3.5,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'Nexus 6P landscape',
        userAgent: 'Mozilla/5.0 (Linux; Android 8.0.0; Nexus 6P Build/OPP3.170518.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
        viewport: {
            width: 732,
            height: 412,
            deviceScaleFactor: 3.5,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'Nexus 7',
        userAgent: 'Mozilla/5.0 (Linux; Android 6.0.1; Nexus 7 Build/MOB30X) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Safari/537.36',
        viewport: {
            width: 600,
            height: 960,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'Nexus 7 landscape',
        userAgent: 'Mozilla/5.0 (Linux; Android 6.0.1; Nexus 7 Build/MOB30X) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Safari/537.36',
        viewport: {
            width: 960,
            height: 600,
            deviceScaleFactor: 2,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'Nokia Lumia 520',
        userAgent: 'Mozilla/5.0 (compatible; MSIE 10.0; Windows Phone 8.0; Trident/6.0; IEMobile/10.0; ARM; Touch; NOKIA; Lumia 520)',
        viewport: {
            width: 320,
            height: 533,
            deviceScaleFactor: 1.5,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'Nokia Lumia 520 landscape',
        userAgent: 'Mozilla/5.0 (compatible; MSIE 10.0; Windows Phone 8.0; Trident/6.0; IEMobile/10.0; ARM; Touch; NOKIA; Lumia 520)',
        viewport: {
            width: 533,
            height: 320,
            deviceScaleFactor: 1.5,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'Nokia N9',
        userAgent: 'Mozilla/5.0 (MeeGo; NokiaN9) AppleWebKit/534.13 (KHTML, like Gecko) NokiaBrowser/8.5.0 Mobile Safari/534.13',
        viewport: {
            width: 480,
            height: 854,
            deviceScaleFactor: 1,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'Nokia N9 landscape',
        userAgent: 'Mozilla/5.0 (MeeGo; NokiaN9) AppleWebKit/534.13 (KHTML, like Gecko) NokiaBrowser/8.5.0 Mobile Safari/534.13',
        viewport: {
            width: 854,
            height: 480,
            deviceScaleFactor: 1,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'Pixel 2',
        userAgent: 'Mozilla/5.0 (Linux; Android 8.0; Pixel 2 Build/OPD3.170816.012) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
        viewport: {
            width: 411,
            height: 731,
            deviceScaleFactor: 2.625,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'Pixel 2 landscape',
        userAgent: 'Mozilla/5.0 (Linux; Android 8.0; Pixel 2 Build/OPD3.170816.012) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
        viewport: {
            width: 731,
            height: 411,
            deviceScaleFactor: 2.625,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'Pixel 2 XL',
        userAgent: 'Mozilla/5.0 (Linux; Android 8.0.0; Pixel 2 XL Build/OPD1.170816.004) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
        viewport: {
            width: 411,
            height: 823,
            deviceScaleFactor: 3.5,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'Pixel 2 XL landscape',
        userAgent: 'Mozilla/5.0 (Linux; Android 8.0.0; Pixel 2 XL Build/OPD1.170816.004) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
        viewport: {
            width: 823,
            height: 411,
            deviceScaleFactor: 3.5,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'Pixel 3',
        userAgent: 'Mozilla/5.0 (Linux; Android 9; Pixel 3 Build/PQ1A.181105.017.A1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.158 Mobile Safari/537.36',
        viewport: {
            width: 393,
            height: 786,
            deviceScaleFactor: 2.75,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'Pixel 3 landscape',
        userAgent: 'Mozilla/5.0 (Linux; Android 9; Pixel 3 Build/PQ1A.181105.017.A1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.158 Mobile Safari/537.36',
        viewport: {
            width: 786,
            height: 393,
            deviceScaleFactor: 2.75,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'Pixel 4',
        userAgent: 'Mozilla/5.0 (Linux; Android 10; Pixel 4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.138 Mobile Safari/537.36',
        viewport: {
            width: 353,
            height: 745,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'Pixel 4 landscape',
        userAgent: 'Mozilla/5.0 (Linux; Android 10; Pixel 4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.138 Mobile Safari/537.36',
        viewport: {
            width: 745,
            height: 353,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'Pixel 4a (5G)',
        userAgent: 'Mozilla/5.0 (Linux; Android 11; Pixel 4a (5G)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36',
        viewport: {
            width: 353,
            height: 745,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'Pixel 4a (5G) landscape',
        userAgent: 'Mozilla/5.0 (Linux; Android 11; Pixel 4a (5G)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36',
        viewport: {
            width: 745,
            height: 353,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'Pixel 5',
        userAgent: 'Mozilla/5.0 (Linux; Android 11; Pixel 5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36',
        viewport: {
            width: 393,
            height: 851,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'Pixel 5 landscape',
        userAgent: 'Mozilla/5.0 (Linux; Android 11; Pixel 5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36',
        viewport: {
            width: 851,
            height: 393,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
    {
        name: 'Moto G4',
        userAgent: 'Mozilla/5.0 (Linux; Android 7.0; Moto G (4)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36',
        viewport: {
            width: 360,
            height: 640,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: false,
        },
    },
    {
        name: 'Moto G4 landscape',
        userAgent: 'Mozilla/5.0 (Linux; Android 7.0; Moto G (4)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36',
        viewport: {
            width: 640,
            height: 360,
            deviceScaleFactor: 3,
            isMobile: true,
            hasTouch: true,
            isLandscape: true,
        },
    },
];
const knownDevicesByName = {};
for (const device of knownDevices) {
    knownDevicesByName[device.name] = device;
}
Object.freeze(knownDevicesByName);

/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
async function _connectToBiDiBrowser(connectionTransport, url, options) {
    const { acceptInsecureCerts = false, networkEnabled = true, defaultViewport = DEFAULT_VIEWPORT, } = options;
    const { bidiConnection, cdpConnection, closeCallback } = await getBiDiConnection(connectionTransport, url, options);
    const BiDi = await import( '../../../node_modules/puppeteer-core/lib/esm/puppeteer/bidi/bidi.js');
    const bidiBrowser = await BiDi.BidiBrowser.create({
        connection: bidiConnection,
        cdpConnection,
        closeCallback,
        process: undefined,
        defaultViewport: defaultViewport,
        acceptInsecureCerts: acceptInsecureCerts,
        networkEnabled,
        capabilities: options.capabilities,
    });
    return bidiBrowser;
}
async function getBiDiConnection(connectionTransport, url, options) {
    const BiDi = await import( '../../../node_modules/puppeteer-core/lib/esm/puppeteer/bidi/bidi.js');
    const { slowMo = 0, protocolTimeout } = options;
    const pureBidiConnection = new BiDi.BidiConnection(url, connectionTransport, slowMo, protocolTimeout);
    try {
        const result = await pureBidiConnection.send('session.status', {});
        if ('type' in result && result.type === 'success') {
            return {
                bidiConnection: pureBidiConnection,
                closeCallback: async () => {
                    await pureBidiConnection.send('browser.close', {}).catch(debugError);
                },
            };
        }
    }
    catch (e) {
        if (!(e instanceof ProtocolError)) {
            throw e;
        }
    }
    pureBidiConnection.unbind();
    const cdpConnection = new Connection(url, connectionTransport, slowMo, protocolTimeout,
     true);
    const version = await cdpConnection.send('Browser.getVersion');
    if (version.product.toLowerCase().includes('firefox')) {
        throw new UnsupportedOperation('Firefox is not supported in BiDi over CDP mode.');
    }
    const bidiOverCdpConnection = await BiDi.connectBidiOverCdp(cdpConnection);
    return {
        cdpConnection,
        bidiConnection: bidiOverCdpConnection,
        closeCallback: async () => {
            await cdpConnection.send('Browser.close').catch(debugError);
        },
    };
}

/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const getWebSocketTransportClass = async () => {
    return isNode
        ? (await Promise.resolve().then(function () { return NodeWebSocketTransport$1; })).NodeWebSocketTransport
        : (await Promise.resolve().then(function () { return BrowserWebSocketTransport$1; }))
            .BrowserWebSocketTransport;
};
async function _connectToBrowser(options) {
    const { connectionTransport, endpointUrl } = await getConnectionTransport(options);
    if (options.protocol === 'webDriverBiDi') {
        const bidiBrowser = await _connectToBiDiBrowser(connectionTransport, endpointUrl, options);
        return bidiBrowser;
    }
    else {
        const cdpBrowser = await _connectToCdpBrowser(connectionTransport, endpointUrl, options);
        return cdpBrowser;
    }
}
async function getConnectionTransport(options) {
    const { browserWSEndpoint, browserURL, transport, headers = {} } = options;
    assert(Number(!!browserWSEndpoint) + Number(!!browserURL) + Number(!!transport) ===
        1, 'Exactly one of browserWSEndpoint, browserURL or transport must be passed to puppeteer.connect');
    if (transport) {
        return { connectionTransport: transport, endpointUrl: '' };
    }
    else if (browserWSEndpoint) {
        const WebSocketClass = await getWebSocketTransportClass();
        const connectionTransport = await WebSocketClass.create(browserWSEndpoint, headers);
        return {
            connectionTransport: connectionTransport,
            endpointUrl: browserWSEndpoint,
        };
    }
    else if (browserURL) {
        const connectionURL = await getWSEndpoint(browserURL);
        const WebSocketClass = await getWebSocketTransportClass();
        const connectionTransport = await WebSocketClass.create(connectionURL);
        return {
            connectionTransport: connectionTransport,
            endpointUrl: connectionURL,
        };
    }
    throw new Error('Invalid connection options');
}
async function getWSEndpoint(browserURL) {
    const endpointURL = new URL('/json/version', browserURL);
    try {
        const result = await globalThis.fetch(endpointURL.toString(), {
            method: 'GET',
        });
        if (!result.ok) {
            throw new Error(`HTTP ${result.statusText}`);
        }
        const data = await result.json();
        return data.webSocketDebuggerUrl;
    }
    catch (error) {
        if (isErrorLike$1(error)) {
            error.message =
                `Failed to fetch browser webSocket URL from ${endpointURL}: ` +
                    error.message;
        }
        throw error;
    }
}

/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class Puppeteer {
    static customQueryHandlers = customQueryHandlers;
    static registerCustomQueryHandler(name, queryHandler) {
        return this.customQueryHandlers.register(name, queryHandler);
    }
    static unregisterCustomQueryHandler(name) {
        return this.customQueryHandlers.unregister(name);
    }
    static customQueryHandlerNames() {
        return this.customQueryHandlers.names();
    }
    static clearCustomQueryHandlers() {
        return this.customQueryHandlers.clear();
    }
    _isPuppeteerCore;
    _changedBrowsers = false;
    constructor(settings) {
        this._isPuppeteerCore = settings.isPuppeteerCore;
        this.connect = this.connect.bind(this);
    }
    connect(options) {
        return _connectToBrowser(options);
    }
}

/**
 * @license
 * Copyright 2020 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const PUPPETEER_REVISIONS = Object.freeze({
    chrome: '141.0.7390.78',
    'chrome-headless-shell': '141.0.7390.78',
    firefox: 'stable_144.0',
});

/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var Browser;
(function (Browser) {
    Browser["CHROME"] = "chrome";
    Browser["CHROMEHEADLESSSHELL"] = "chrome-headless-shell";
    Browser["CHROMIUM"] = "chromium";
    Browser["FIREFOX"] = "firefox";
    Browser["CHROMEDRIVER"] = "chromedriver";
})(Browser || (Browser = {}));
var BrowserPlatform;
(function (BrowserPlatform) {
    BrowserPlatform["LINUX"] = "linux";
    BrowserPlatform["LINUX_ARM"] = "linux_arm";
    BrowserPlatform["MAC"] = "mac";
    BrowserPlatform["MAC_ARM"] = "mac_arm";
    BrowserPlatform["WIN32"] = "win32";
    BrowserPlatform["WIN64"] = "win64";
})(BrowserPlatform || (BrowserPlatform = {}));
var BrowserTag;
(function (BrowserTag) {
    BrowserTag["CANARY"] = "canary";
    BrowserTag["NIGHTLY"] = "nightly";
    BrowserTag["BETA"] = "beta";
    BrowserTag["DEV"] = "dev";
    BrowserTag["DEVEDITION"] = "devedition";
    BrowserTag["STABLE"] = "stable";
    BrowserTag["ESR"] = "esr";
    BrowserTag["LATEST"] = "latest";
})(BrowserTag || (BrowserTag = {}));
var ChromeReleaseChannel;
(function (ChromeReleaseChannel) {
    ChromeReleaseChannel["STABLE"] = "stable";
    ChromeReleaseChannel["DEV"] = "dev";
    ChromeReleaseChannel["CANARY"] = "canary";
    ChromeReleaseChannel["BETA"] = "beta";
})(ChromeReleaseChannel || (ChromeReleaseChannel = {}));

var re = {exports: {}};

var constants$4;
var hasRequiredConstants$4;

function requireConstants$4 () {
	if (hasRequiredConstants$4) return constants$4;
	hasRequiredConstants$4 = 1;
	const SEMVER_SPEC_VERSION = '2.0.0';
	const MAX_LENGTH = 256;
	const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
	 9007199254740991;
	const MAX_SAFE_COMPONENT_LENGTH = 16;
	const MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
	const RELEASE_TYPES = [
	  'major',
	  'premajor',
	  'minor',
	  'preminor',
	  'patch',
	  'prepatch',
	  'prerelease',
	];
	constants$4 = {
	  MAX_LENGTH,
	  MAX_SAFE_COMPONENT_LENGTH,
	  MAX_SAFE_BUILD_LENGTH,
	  MAX_SAFE_INTEGER,
	  RELEASE_TYPES,
	  SEMVER_SPEC_VERSION,
	  FLAG_INCLUDE_PRERELEASE: 0b001,
	  FLAG_LOOSE: 0b010,
	};
	return constants$4;
}

var debug_1;
var hasRequiredDebug$1;

function requireDebug$1 () {
	if (hasRequiredDebug$1) return debug_1;
	hasRequiredDebug$1 = 1;
	const debug = (
	  typeof process === 'object' &&
	  process.env &&
	  process.env.NODE_DEBUG &&
	  /\bsemver\b/i.test(process.env.NODE_DEBUG)
	) ? (...args) => console.error('SEMVER', ...args)
	  : () => {};
	debug_1 = debug;
	return debug_1;
}

var hasRequiredRe;

function requireRe () {
	if (hasRequiredRe) return re.exports;
	hasRequiredRe = 1;
	(function (module, exports) {
		const {
		  MAX_SAFE_COMPONENT_LENGTH,
		  MAX_SAFE_BUILD_LENGTH,
		  MAX_LENGTH,
		} = requireConstants$4();
		const debug = requireDebug$1();
		exports = module.exports = {};
		const re = exports.re = [];
		const safeRe = exports.safeRe = [];
		const src = exports.src = [];
		const safeSrc = exports.safeSrc = [];
		const t = exports.t = {};
		let R = 0;
		const LETTERDASHNUMBER = '[a-zA-Z0-9-]';
		const safeRegexReplacements = [
		  ['\\s', 1],
		  ['\\d', MAX_LENGTH],
		  [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH],
		];
		const makeSafeRegex = (value) => {
		  for (const [token, max] of safeRegexReplacements) {
		    value = value
		      .split(`${token}*`).join(`${token}{0,${max}}`)
		      .split(`${token}+`).join(`${token}{1,${max}}`);
		  }
		  return value
		};
		const createToken = (name, value, isGlobal) => {
		  const safe = makeSafeRegex(value);
		  const index = R++;
		  debug(name, index, value);
		  t[name] = index;
		  src[index] = value;
		  safeSrc[index] = safe;
		  re[index] = new RegExp(value, isGlobal ? 'g' : undefined);
		  safeRe[index] = new RegExp(safe, isGlobal ? 'g' : undefined);
		};
		createToken('NUMERICIDENTIFIER', '0|[1-9]\\d*');
		createToken('NUMERICIDENTIFIERLOOSE', '\\d+');
		createToken('NONNUMERICIDENTIFIER', `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
		createToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\.` +
		                   `(${src[t.NUMERICIDENTIFIER]})\\.` +
		                   `(${src[t.NUMERICIDENTIFIER]})`);
		createToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
		                        `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
		                        `(${src[t.NUMERICIDENTIFIERLOOSE]})`);
		createToken('PRERELEASEIDENTIFIER', `(?:${src[t.NONNUMERICIDENTIFIER]
		}|${src[t.NUMERICIDENTIFIER]})`);
		createToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NONNUMERICIDENTIFIER]
		}|${src[t.NUMERICIDENTIFIERLOOSE]})`);
		createToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]
		}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
		createToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]
		}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
		createToken('BUILDIDENTIFIER', `${LETTERDASHNUMBER}+`);
		createToken('BUILD', `(?:\\+(${src[t.BUILDIDENTIFIER]
		}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
		createToken('FULLPLAIN', `v?${src[t.MAINVERSION]
		}${src[t.PRERELEASE]}?${
		  src[t.BUILD]}?`);
		createToken('FULL', `^${src[t.FULLPLAIN]}$`);
		createToken('LOOSEPLAIN', `[v=\\s]*${src[t.MAINVERSIONLOOSE]
		}${src[t.PRERELEASELOOSE]}?${
		  src[t.BUILD]}?`);
		createToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`);
		createToken('GTLT', '((?:<|>)?=?)');
		createToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
		createToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
		createToken('XRANGEPLAIN', `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})` +
		                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
		                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
		                   `(?:${src[t.PRERELEASE]})?${
		                     src[t.BUILD]}?` +
		                   `)?)?`);
		createToken('XRANGEPLAINLOOSE', `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` +
		                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
		                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
		                        `(?:${src[t.PRERELEASELOOSE]})?${
		                          src[t.BUILD]}?` +
		                        `)?)?`);
		createToken('XRANGE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
		createToken('XRANGELOOSE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
		createToken('COERCEPLAIN', `${'(^|[^\\d])' +
		              '(\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` +
		              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +
		              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
		createToken('COERCE', `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
		createToken('COERCEFULL', src[t.COERCEPLAIN] +
		              `(?:${src[t.PRERELEASE]})?` +
		              `(?:${src[t.BUILD]})?` +
		              `(?:$|[^\\d])`);
		createToken('COERCERTL', src[t.COERCE], true);
		createToken('COERCERTLFULL', src[t.COERCEFULL], true);
		createToken('LONETILDE', '(?:~>?)');
		createToken('TILDETRIM', `(\\s*)${src[t.LONETILDE]}\\s+`, true);
		exports.tildeTrimReplace = '$1~';
		createToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
		createToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
		createToken('LONECARET', '(?:\\^)');
		createToken('CARETTRIM', `(\\s*)${src[t.LONECARET]}\\s+`, true);
		exports.caretTrimReplace = '$1^';
		createToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
		createToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
		createToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
		createToken('COMPARATOR', `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
		createToken('COMPARATORTRIM', `(\\s*)${src[t.GTLT]
		}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
		exports.comparatorTrimReplace = '$1$2$3';
		createToken('HYPHENRANGE', `^\\s*(${src[t.XRANGEPLAIN]})` +
		                   `\\s+-\\s+` +
		                   `(${src[t.XRANGEPLAIN]})` +
		                   `\\s*$`);
		createToken('HYPHENRANGELOOSE', `^\\s*(${src[t.XRANGEPLAINLOOSE]})` +
		                        `\\s+-\\s+` +
		                        `(${src[t.XRANGEPLAINLOOSE]})` +
		                        `\\s*$`);
		createToken('STAR', '(<|>)?=?\\s*\\*');
		createToken('GTE0', '^\\s*>=\\s*0\\.0\\.0\\s*$');
		createToken('GTE0PRE', '^\\s*>=\\s*0\\.0\\.0-0\\s*$'); 
	} (re, re.exports));
	return re.exports;
}

var parseOptions_1;
var hasRequiredParseOptions;

function requireParseOptions () {
	if (hasRequiredParseOptions) return parseOptions_1;
	hasRequiredParseOptions = 1;
	const looseOption = Object.freeze({ loose: true });
	const emptyOpts = Object.freeze({ });
	const parseOptions = options => {
	  if (!options) {
	    return emptyOpts
	  }
	  if (typeof options !== 'object') {
	    return looseOption
	  }
	  return options
	};
	parseOptions_1 = parseOptions;
	return parseOptions_1;
}

var identifiers;
var hasRequiredIdentifiers;

function requireIdentifiers () {
	if (hasRequiredIdentifiers) return identifiers;
	hasRequiredIdentifiers = 1;
	const numeric = /^[0-9]+$/;
	const compareIdentifiers = (a, b) => {
	  if (typeof a === 'number' && typeof b === 'number') {
	    return a === b ? 0 : a < b ? -1 : 1
	  }
	  const anum = numeric.test(a);
	  const bnum = numeric.test(b);
	  if (anum && bnum) {
	    a = +a;
	    b = +b;
	  }
	  return a === b ? 0
	    : (anum && !bnum) ? -1
	    : (bnum && !anum) ? 1
	    : a < b ? -1
	    : 1
	};
	const rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
	identifiers = {
	  compareIdentifiers,
	  rcompareIdentifiers,
	};
	return identifiers;
}

var semver$2;
var hasRequiredSemver$1;

function requireSemver$1 () {
	if (hasRequiredSemver$1) return semver$2;
	hasRequiredSemver$1 = 1;
	const debug = requireDebug$1();
	const { MAX_LENGTH, MAX_SAFE_INTEGER } = requireConstants$4();
	const { safeRe: re, t } = requireRe();
	const parseOptions = requireParseOptions();
	const { compareIdentifiers } = requireIdentifiers();
	class SemVer {
	  constructor (version, options) {
	    options = parseOptions(options);
	    if (version instanceof SemVer) {
	      if (version.loose === !!options.loose &&
	        version.includePrerelease === !!options.includePrerelease) {
	        return version
	      } else {
	        version = version.version;
	      }
	    } else if (typeof version !== 'string') {
	      throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`)
	    }
	    if (version.length > MAX_LENGTH) {
	      throw new TypeError(
	        `version is longer than ${MAX_LENGTH} characters`
	      )
	    }
	    debug('SemVer', version, options);
	    this.options = options;
	    this.loose = !!options.loose;
	    this.includePrerelease = !!options.includePrerelease;
	    const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
	    if (!m) {
	      throw new TypeError(`Invalid Version: ${version}`)
	    }
	    this.raw = version;
	    this.major = +m[1];
	    this.minor = +m[2];
	    this.patch = +m[3];
	    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
	      throw new TypeError('Invalid major version')
	    }
	    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
	      throw new TypeError('Invalid minor version')
	    }
	    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
	      throw new TypeError('Invalid patch version')
	    }
	    if (!m[4]) {
	      this.prerelease = [];
	    } else {
	      this.prerelease = m[4].split('.').map((id) => {
	        if (/^[0-9]+$/.test(id)) {
	          const num = +id;
	          if (num >= 0 && num < MAX_SAFE_INTEGER) {
	            return num
	          }
	        }
	        return id
	      });
	    }
	    this.build = m[5] ? m[5].split('.') : [];
	    this.format();
	  }
	  format () {
	    this.version = `${this.major}.${this.minor}.${this.patch}`;
	    if (this.prerelease.length) {
	      this.version += `-${this.prerelease.join('.')}`;
	    }
	    return this.version
	  }
	  toString () {
	    return this.version
	  }
	  compare (other) {
	    debug('SemVer.compare', this.version, this.options, other);
	    if (!(other instanceof SemVer)) {
	      if (typeof other === 'string' && other === this.version) {
	        return 0
	      }
	      other = new SemVer(other, this.options);
	    }
	    if (other.version === this.version) {
	      return 0
	    }
	    return this.compareMain(other) || this.comparePre(other)
	  }
	  compareMain (other) {
	    if (!(other instanceof SemVer)) {
	      other = new SemVer(other, this.options);
	    }
	    if (this.major < other.major) {
	      return -1
	    }
	    if (this.major > other.major) {
	      return 1
	    }
	    if (this.minor < other.minor) {
	      return -1
	    }
	    if (this.minor > other.minor) {
	      return 1
	    }
	    if (this.patch < other.patch) {
	      return -1
	    }
	    if (this.patch > other.patch) {
	      return 1
	    }
	    return 0
	  }
	  comparePre (other) {
	    if (!(other instanceof SemVer)) {
	      other = new SemVer(other, this.options);
	    }
	    if (this.prerelease.length && !other.prerelease.length) {
	      return -1
	    } else if (!this.prerelease.length && other.prerelease.length) {
	      return 1
	    } else if (!this.prerelease.length && !other.prerelease.length) {
	      return 0
	    }
	    let i = 0;
	    do {
	      const a = this.prerelease[i];
	      const b = other.prerelease[i];
	      debug('prerelease compare', i, a, b);
	      if (a === undefined && b === undefined) {
	        return 0
	      } else if (b === undefined) {
	        return 1
	      } else if (a === undefined) {
	        return -1
	      } else if (a === b) {
	        continue
	      } else {
	        return compareIdentifiers(a, b)
	      }
	    } while (++i)
	  }
	  compareBuild (other) {
	    if (!(other instanceof SemVer)) {
	      other = new SemVer(other, this.options);
	    }
	    let i = 0;
	    do {
	      const a = this.build[i];
	      const b = other.build[i];
	      debug('build compare', i, a, b);
	      if (a === undefined && b === undefined) {
	        return 0
	      } else if (b === undefined) {
	        return 1
	      } else if (a === undefined) {
	        return -1
	      } else if (a === b) {
	        continue
	      } else {
	        return compareIdentifiers(a, b)
	      }
	    } while (++i)
	  }
	  inc (release, identifier, identifierBase) {
	    if (release.startsWith('pre')) {
	      if (!identifier && identifierBase === false) {
	        throw new Error('invalid increment argument: identifier is empty')
	      }
	      if (identifier) {
	        const match = `-${identifier}`.match(this.options.loose ? re[t.PRERELEASELOOSE] : re[t.PRERELEASE]);
	        if (!match || match[1] !== identifier) {
	          throw new Error(`invalid identifier: ${identifier}`)
	        }
	      }
	    }
	    switch (release) {
	      case 'premajor':
	        this.prerelease.length = 0;
	        this.patch = 0;
	        this.minor = 0;
	        this.major++;
	        this.inc('pre', identifier, identifierBase);
	        break
	      case 'preminor':
	        this.prerelease.length = 0;
	        this.patch = 0;
	        this.minor++;
	        this.inc('pre', identifier, identifierBase);
	        break
	      case 'prepatch':
	        this.prerelease.length = 0;
	        this.inc('patch', identifier, identifierBase);
	        this.inc('pre', identifier, identifierBase);
	        break
	      case 'prerelease':
	        if (this.prerelease.length === 0) {
	          this.inc('patch', identifier, identifierBase);
	        }
	        this.inc('pre', identifier, identifierBase);
	        break
	      case 'release':
	        if (this.prerelease.length === 0) {
	          throw new Error(`version ${this.raw} is not a prerelease`)
	        }
	        this.prerelease.length = 0;
	        break
	      case 'major':
	        if (
	          this.minor !== 0 ||
	          this.patch !== 0 ||
	          this.prerelease.length === 0
	        ) {
	          this.major++;
	        }
	        this.minor = 0;
	        this.patch = 0;
	        this.prerelease = [];
	        break
	      case 'minor':
	        if (this.patch !== 0 || this.prerelease.length === 0) {
	          this.minor++;
	        }
	        this.patch = 0;
	        this.prerelease = [];
	        break
	      case 'patch':
	        if (this.prerelease.length === 0) {
	          this.patch++;
	        }
	        this.prerelease = [];
	        break
	      case 'pre': {
	        const base = Number(identifierBase) ? 1 : 0;
	        if (this.prerelease.length === 0) {
	          this.prerelease = [base];
	        } else {
	          let i = this.prerelease.length;
	          while (--i >= 0) {
	            if (typeof this.prerelease[i] === 'number') {
	              this.prerelease[i]++;
	              i = -2;
	            }
	          }
	          if (i === -1) {
	            if (identifier === this.prerelease.join('.') && identifierBase === false) {
	              throw new Error('invalid increment argument: identifier already exists')
	            }
	            this.prerelease.push(base);
	          }
	        }
	        if (identifier) {
	          let prerelease = [identifier, base];
	          if (identifierBase === false) {
	            prerelease = [identifier];
	          }
	          if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
	            if (isNaN(this.prerelease[1])) {
	              this.prerelease = prerelease;
	            }
	          } else {
	            this.prerelease = prerelease;
	          }
	        }
	        break
	      }
	      default:
	        throw new Error(`invalid increment argument: ${release}`)
	    }
	    this.raw = this.format();
	    if (this.build.length) {
	      this.raw += `+${this.build.join('.')}`;
	    }
	    return this
	  }
	}
	semver$2 = SemVer;
	return semver$2;
}

var parse_1;
var hasRequiredParse;

function requireParse () {
	if (hasRequiredParse) return parse_1;
	hasRequiredParse = 1;
	const SemVer = requireSemver$1();
	const parse = (version, options, throwErrors = false) => {
	  if (version instanceof SemVer) {
	    return version
	  }
	  try {
	    return new SemVer(version, options)
	  } catch (er) {
	    if (!throwErrors) {
	      return null
	    }
	    throw er
	  }
	};
	parse_1 = parse;
	return parse_1;
}

var valid_1;
var hasRequiredValid$1;

function requireValid$1 () {
	if (hasRequiredValid$1) return valid_1;
	hasRequiredValid$1 = 1;
	const parse = requireParse();
	const valid = (version, options) => {
	  const v = parse(version, options);
	  return v ? v.version : null
	};
	valid_1 = valid;
	return valid_1;
}

var clean_1;
var hasRequiredClean;

function requireClean () {
	if (hasRequiredClean) return clean_1;
	hasRequiredClean = 1;
	const parse = requireParse();
	const clean = (version, options) => {
	  const s = parse(version.trim().replace(/^[=v]+/, ''), options);
	  return s ? s.version : null
	};
	clean_1 = clean;
	return clean_1;
}

var inc_1;
var hasRequiredInc;

function requireInc () {
	if (hasRequiredInc) return inc_1;
	hasRequiredInc = 1;
	const SemVer = requireSemver$1();
	const inc = (version, release, options, identifier, identifierBase) => {
	  if (typeof (options) === 'string') {
	    identifierBase = identifier;
	    identifier = options;
	    options = undefined;
	  }
	  try {
	    return new SemVer(
	      version instanceof SemVer ? version.version : version,
	      options
	    ).inc(release, identifier, identifierBase).version
	  } catch (er) {
	    return null
	  }
	};
	inc_1 = inc;
	return inc_1;
}

var diff_1;
var hasRequiredDiff;

function requireDiff () {
	if (hasRequiredDiff) return diff_1;
	hasRequiredDiff = 1;
	const parse = requireParse();
	const diff = (version1, version2) => {
	  const v1 = parse(version1, null, true);
	  const v2 = parse(version2, null, true);
	  const comparison = v1.compare(v2);
	  if (comparison === 0) {
	    return null
	  }
	  const v1Higher = comparison > 0;
	  const highVersion = v1Higher ? v1 : v2;
	  const lowVersion = v1Higher ? v2 : v1;
	  const highHasPre = !!highVersion.prerelease.length;
	  const lowHasPre = !!lowVersion.prerelease.length;
	  if (lowHasPre && !highHasPre) {
	    if (!lowVersion.patch && !lowVersion.minor) {
	      return 'major'
	    }
	    if (lowVersion.compareMain(highVersion) === 0) {
	      if (lowVersion.minor && !lowVersion.patch) {
	        return 'minor'
	      }
	      return 'patch'
	    }
	  }
	  const prefix = highHasPre ? 'pre' : '';
	  if (v1.major !== v2.major) {
	    return prefix + 'major'
	  }
	  if (v1.minor !== v2.minor) {
	    return prefix + 'minor'
	  }
	  if (v1.patch !== v2.patch) {
	    return prefix + 'patch'
	  }
	  return 'prerelease'
	};
	diff_1 = diff;
	return diff_1;
}

var major_1;
var hasRequiredMajor;

function requireMajor () {
	if (hasRequiredMajor) return major_1;
	hasRequiredMajor = 1;
	const SemVer = requireSemver$1();
	const major = (a, loose) => new SemVer(a, loose).major;
	major_1 = major;
	return major_1;
}

var minor_1;
var hasRequiredMinor;

function requireMinor () {
	if (hasRequiredMinor) return minor_1;
	hasRequiredMinor = 1;
	const SemVer = requireSemver$1();
	const minor = (a, loose) => new SemVer(a, loose).minor;
	minor_1 = minor;
	return minor_1;
}

var patch_1;
var hasRequiredPatch;

function requirePatch () {
	if (hasRequiredPatch) return patch_1;
	hasRequiredPatch = 1;
	const SemVer = requireSemver$1();
	const patch = (a, loose) => new SemVer(a, loose).patch;
	patch_1 = patch;
	return patch_1;
}

var prerelease_1;
var hasRequiredPrerelease;

function requirePrerelease () {
	if (hasRequiredPrerelease) return prerelease_1;
	hasRequiredPrerelease = 1;
	const parse = requireParse();
	const prerelease = (version, options) => {
	  const parsed = parse(version, options);
	  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null
	};
	prerelease_1 = prerelease;
	return prerelease_1;
}

var compare_1;
var hasRequiredCompare;

function requireCompare () {
	if (hasRequiredCompare) return compare_1;
	hasRequiredCompare = 1;
	const SemVer = requireSemver$1();
	const compare = (a, b, loose) =>
	  new SemVer(a, loose).compare(new SemVer(b, loose));
	compare_1 = compare;
	return compare_1;
}

var rcompare_1;
var hasRequiredRcompare;

function requireRcompare () {
	if (hasRequiredRcompare) return rcompare_1;
	hasRequiredRcompare = 1;
	const compare = requireCompare();
	const rcompare = (a, b, loose) => compare(b, a, loose);
	rcompare_1 = rcompare;
	return rcompare_1;
}

var compareLoose_1;
var hasRequiredCompareLoose;

function requireCompareLoose () {
	if (hasRequiredCompareLoose) return compareLoose_1;
	hasRequiredCompareLoose = 1;
	const compare = requireCompare();
	const compareLoose = (a, b) => compare(a, b, true);
	compareLoose_1 = compareLoose;
	return compareLoose_1;
}

var compareBuild_1;
var hasRequiredCompareBuild;

function requireCompareBuild () {
	if (hasRequiredCompareBuild) return compareBuild_1;
	hasRequiredCompareBuild = 1;
	const SemVer = requireSemver$1();
	const compareBuild = (a, b, loose) => {
	  const versionA = new SemVer(a, loose);
	  const versionB = new SemVer(b, loose);
	  return versionA.compare(versionB) || versionA.compareBuild(versionB)
	};
	compareBuild_1 = compareBuild;
	return compareBuild_1;
}

var sort_1;
var hasRequiredSort;

function requireSort () {
	if (hasRequiredSort) return sort_1;
	hasRequiredSort = 1;
	const compareBuild = requireCompareBuild();
	const sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
	sort_1 = sort;
	return sort_1;
}

var rsort_1;
var hasRequiredRsort;

function requireRsort () {
	if (hasRequiredRsort) return rsort_1;
	hasRequiredRsort = 1;
	const compareBuild = requireCompareBuild();
	const rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
	rsort_1 = rsort;
	return rsort_1;
}

var gt_1;
var hasRequiredGt;

function requireGt () {
	if (hasRequiredGt) return gt_1;
	hasRequiredGt = 1;
	const compare = requireCompare();
	const gt = (a, b, loose) => compare(a, b, loose) > 0;
	gt_1 = gt;
	return gt_1;
}

var lt_1;
var hasRequiredLt;

function requireLt () {
	if (hasRequiredLt) return lt_1;
	hasRequiredLt = 1;
	const compare = requireCompare();
	const lt = (a, b, loose) => compare(a, b, loose) < 0;
	lt_1 = lt;
	return lt_1;
}

var eq_1;
var hasRequiredEq;

function requireEq () {
	if (hasRequiredEq) return eq_1;
	hasRequiredEq = 1;
	const compare = requireCompare();
	const eq = (a, b, loose) => compare(a, b, loose) === 0;
	eq_1 = eq;
	return eq_1;
}

var neq_1;
var hasRequiredNeq;

function requireNeq () {
	if (hasRequiredNeq) return neq_1;
	hasRequiredNeq = 1;
	const compare = requireCompare();
	const neq = (a, b, loose) => compare(a, b, loose) !== 0;
	neq_1 = neq;
	return neq_1;
}

var gte_1;
var hasRequiredGte;

function requireGte () {
	if (hasRequiredGte) return gte_1;
	hasRequiredGte = 1;
	const compare = requireCompare();
	const gte = (a, b, loose) => compare(a, b, loose) >= 0;
	gte_1 = gte;
	return gte_1;
}

var lte_1;
var hasRequiredLte;

function requireLte () {
	if (hasRequiredLte) return lte_1;
	hasRequiredLte = 1;
	const compare = requireCompare();
	const lte = (a, b, loose) => compare(a, b, loose) <= 0;
	lte_1 = lte;
	return lte_1;
}

var cmp_1;
var hasRequiredCmp;

function requireCmp () {
	if (hasRequiredCmp) return cmp_1;
	hasRequiredCmp = 1;
	const eq = requireEq();
	const neq = requireNeq();
	const gt = requireGt();
	const gte = requireGte();
	const lt = requireLt();
	const lte = requireLte();
	const cmp = (a, op, b, loose) => {
	  switch (op) {
	    case '===':
	      if (typeof a === 'object') {
	        a = a.version;
	      }
	      if (typeof b === 'object') {
	        b = b.version;
	      }
	      return a === b
	    case '!==':
	      if (typeof a === 'object') {
	        a = a.version;
	      }
	      if (typeof b === 'object') {
	        b = b.version;
	      }
	      return a !== b
	    case '':
	    case '=':
	    case '==':
	      return eq(a, b, loose)
	    case '!=':
	      return neq(a, b, loose)
	    case '>':
	      return gt(a, b, loose)
	    case '>=':
	      return gte(a, b, loose)
	    case '<':
	      return lt(a, b, loose)
	    case '<=':
	      return lte(a, b, loose)
	    default:
	      throw new TypeError(`Invalid operator: ${op}`)
	  }
	};
	cmp_1 = cmp;
	return cmp_1;
}

var coerce_1;
var hasRequiredCoerce;

function requireCoerce () {
	if (hasRequiredCoerce) return coerce_1;
	hasRequiredCoerce = 1;
	const SemVer = requireSemver$1();
	const parse = requireParse();
	const { safeRe: re, t } = requireRe();
	const coerce = (version, options) => {
	  if (version instanceof SemVer) {
	    return version
	  }
	  if (typeof version === 'number') {
	    version = String(version);
	  }
	  if (typeof version !== 'string') {
	    return null
	  }
	  options = options || {};
	  let match = null;
	  if (!options.rtl) {
	    match = version.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
	  } else {
	    const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
	    let next;
	    while ((next = coerceRtlRegex.exec(version)) &&
	        (!match || match.index + match[0].length !== version.length)
	    ) {
	      if (!match ||
	            next.index + next[0].length !== match.index + match[0].length) {
	        match = next;
	      }
	      coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
	    }
	    coerceRtlRegex.lastIndex = -1;
	  }
	  if (match === null) {
	    return null
	  }
	  const major = match[2];
	  const minor = match[3] || '0';
	  const patch = match[4] || '0';
	  const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : '';
	  const build = options.includePrerelease && match[6] ? `+${match[6]}` : '';
	  return parse(`${major}.${minor}.${patch}${prerelease}${build}`, options)
	};
	coerce_1 = coerce;
	return coerce_1;
}

var lrucache;
var hasRequiredLrucache;

function requireLrucache () {
	if (hasRequiredLrucache) return lrucache;
	hasRequiredLrucache = 1;
	class LRUCache {
	  constructor () {
	    this.max = 1000;
	    this.map = new Map();
	  }
	  get (key) {
	    const value = this.map.get(key);
	    if (value === undefined) {
	      return undefined
	    } else {
	      this.map.delete(key);
	      this.map.set(key, value);
	      return value
	    }
	  }
	  delete (key) {
	    return this.map.delete(key)
	  }
	  set (key, value) {
	    const deleted = this.delete(key);
	    if (!deleted && value !== undefined) {
	      if (this.map.size >= this.max) {
	        const firstKey = this.map.keys().next().value;
	        this.delete(firstKey);
	      }
	      this.map.set(key, value);
	    }
	    return this
	  }
	}
	lrucache = LRUCache;
	return lrucache;
}

var range;
var hasRequiredRange;

function requireRange () {
	if (hasRequiredRange) return range;
	hasRequiredRange = 1;
	const SPACE_CHARACTERS = /\s+/g;
	class Range {
	  constructor (range, options) {
	    options = parseOptions(options);
	    if (range instanceof Range) {
	      if (
	        range.loose === !!options.loose &&
	        range.includePrerelease === !!options.includePrerelease
	      ) {
	        return range
	      } else {
	        return new Range(range.raw, options)
	      }
	    }
	    if (range instanceof Comparator) {
	      this.raw = range.value;
	      this.set = [[range]];
	      this.formatted = undefined;
	      return this
	    }
	    this.options = options;
	    this.loose = !!options.loose;
	    this.includePrerelease = !!options.includePrerelease;
	    this.raw = range.trim().replace(SPACE_CHARACTERS, ' ');
	    this.set = this.raw
	      .split('||')
	      .map(r => this.parseRange(r.trim()))
	      .filter(c => c.length);
	    if (!this.set.length) {
	      throw new TypeError(`Invalid SemVer Range: ${this.raw}`)
	    }
	    if (this.set.length > 1) {
	      const first = this.set[0];
	      this.set = this.set.filter(c => !isNullSet(c[0]));
	      if (this.set.length === 0) {
	        this.set = [first];
	      } else if (this.set.length > 1) {
	        for (const c of this.set) {
	          if (c.length === 1 && isAny(c[0])) {
	            this.set = [c];
	            break
	          }
	        }
	      }
	    }
	    this.formatted = undefined;
	  }
	  get range () {
	    if (this.formatted === undefined) {
	      this.formatted = '';
	      for (let i = 0; i < this.set.length; i++) {
	        if (i > 0) {
	          this.formatted += '||';
	        }
	        const comps = this.set[i];
	        for (let k = 0; k < comps.length; k++) {
	          if (k > 0) {
	            this.formatted += ' ';
	          }
	          this.formatted += comps[k].toString().trim();
	        }
	      }
	    }
	    return this.formatted
	  }
	  format () {
	    return this.range
	  }
	  toString () {
	    return this.range
	  }
	  parseRange (range) {
	    const memoOpts =
	      (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) |
	      (this.options.loose && FLAG_LOOSE);
	    const memoKey = memoOpts + ':' + range;
	    const cached = cache.get(memoKey);
	    if (cached) {
	      return cached
	    }
	    const loose = this.options.loose;
	    const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
	    range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
	    debug('hyphen replace', range);
	    range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
	    debug('comparator trim', range);
	    range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
	    debug('tilde trim', range);
	    range = range.replace(re[t.CARETTRIM], caretTrimReplace);
	    debug('caret trim', range);
	    let rangeList = range
	      .split(' ')
	      .map(comp => parseComparator(comp, this.options))
	      .join(' ')
	      .split(/\s+/)
	      .map(comp => replaceGTE0(comp, this.options));
	    if (loose) {
	      rangeList = rangeList.filter(comp => {
	        debug('loose invalid filter', comp, this.options);
	        return !!comp.match(re[t.COMPARATORLOOSE])
	      });
	    }
	    debug('range list', rangeList);
	    const rangeMap = new Map();
	    const comparators = rangeList.map(comp => new Comparator(comp, this.options));
	    for (const comp of comparators) {
	      if (isNullSet(comp)) {
	        return [comp]
	      }
	      rangeMap.set(comp.value, comp);
	    }
	    if (rangeMap.size > 1 && rangeMap.has('')) {
	      rangeMap.delete('');
	    }
	    const result = [...rangeMap.values()];
	    cache.set(memoKey, result);
	    return result
	  }
	  intersects (range, options) {
	    if (!(range instanceof Range)) {
	      throw new TypeError('a Range is required')
	    }
	    return this.set.some((thisComparators) => {
	      return (
	        isSatisfiable(thisComparators, options) &&
	        range.set.some((rangeComparators) => {
	          return (
	            isSatisfiable(rangeComparators, options) &&
	            thisComparators.every((thisComparator) => {
	              return rangeComparators.every((rangeComparator) => {
	                return thisComparator.intersects(rangeComparator, options)
	              })
	            })
	          )
	        })
	      )
	    })
	  }
	  test (version) {
	    if (!version) {
	      return false
	    }
	    if (typeof version === 'string') {
	      try {
	        version = new SemVer(version, this.options);
	      } catch (er) {
	        return false
	      }
	    }
	    for (let i = 0; i < this.set.length; i++) {
	      if (testSet(this.set[i], version, this.options)) {
	        return true
	      }
	    }
	    return false
	  }
	}
	range = Range;
	const LRU = requireLrucache();
	const cache = new LRU();
	const parseOptions = requireParseOptions();
	const Comparator = requireComparator();
	const debug = requireDebug$1();
	const SemVer = requireSemver$1();
	const {
	  safeRe: re,
	  t,
	  comparatorTrimReplace,
	  tildeTrimReplace,
	  caretTrimReplace,
	} = requireRe();
	const { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = requireConstants$4();
	const isNullSet = c => c.value === '<0.0.0-0';
	const isAny = c => c.value === '';
	const isSatisfiable = (comparators, options) => {
	  let result = true;
	  const remainingComparators = comparators.slice();
	  let testComparator = remainingComparators.pop();
	  while (result && remainingComparators.length) {
	    result = remainingComparators.every((otherComparator) => {
	      return testComparator.intersects(otherComparator, options)
	    });
	    testComparator = remainingComparators.pop();
	  }
	  return result
	};
	const parseComparator = (comp, options) => {
	  comp = comp.replace(re[t.BUILD], '');
	  debug('comp', comp, options);
	  comp = replaceCarets(comp, options);
	  debug('caret', comp);
	  comp = replaceTildes(comp, options);
	  debug('tildes', comp);
	  comp = replaceXRanges(comp, options);
	  debug('xrange', comp);
	  comp = replaceStars(comp, options);
	  debug('stars', comp);
	  return comp
	};
	const isX = id => !id || id.toLowerCase() === 'x' || id === '*';
	const replaceTildes = (comp, options) => {
	  return comp
	    .trim()
	    .split(/\s+/)
	    .map((c) => replaceTilde(c, options))
	    .join(' ')
	};
	const replaceTilde = (comp, options) => {
	  const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
	  return comp.replace(r, (_, M, m, p, pr) => {
	    debug('tilde', comp, _, M, m, p, pr);
	    let ret;
	    if (isX(M)) {
	      ret = '';
	    } else if (isX(m)) {
	      ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
	    } else if (isX(p)) {
	      ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
	    } else if (pr) {
	      debug('replaceTilde pr', pr);
	      ret = `>=${M}.${m}.${p}-${pr
	      } <${M}.${+m + 1}.0-0`;
	    } else {
	      ret = `>=${M}.${m}.${p
	      } <${M}.${+m + 1}.0-0`;
	    }
	    debug('tilde return', ret);
	    return ret
	  })
	};
	const replaceCarets = (comp, options) => {
	  return comp
	    .trim()
	    .split(/\s+/)
	    .map((c) => replaceCaret(c, options))
	    .join(' ')
	};
	const replaceCaret = (comp, options) => {
	  debug('caret', comp, options);
	  const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
	  const z = options.includePrerelease ? '-0' : '';
	  return comp.replace(r, (_, M, m, p, pr) => {
	    debug('caret', comp, _, M, m, p, pr);
	    let ret;
	    if (isX(M)) {
	      ret = '';
	    } else if (isX(m)) {
	      ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
	    } else if (isX(p)) {
	      if (M === '0') {
	        ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
	      } else {
	        ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
	      }
	    } else if (pr) {
	      debug('replaceCaret pr', pr);
	      if (M === '0') {
	        if (m === '0') {
	          ret = `>=${M}.${m}.${p}-${pr
	          } <${M}.${m}.${+p + 1}-0`;
	        } else {
	          ret = `>=${M}.${m}.${p}-${pr
	          } <${M}.${+m + 1}.0-0`;
	        }
	      } else {
	        ret = `>=${M}.${m}.${p}-${pr
	        } <${+M + 1}.0.0-0`;
	      }
	    } else {
	      debug('no pr');
	      if (M === '0') {
	        if (m === '0') {
	          ret = `>=${M}.${m}.${p
	          }${z} <${M}.${m}.${+p + 1}-0`;
	        } else {
	          ret = `>=${M}.${m}.${p
	          }${z} <${M}.${+m + 1}.0-0`;
	        }
	      } else {
	        ret = `>=${M}.${m}.${p
	        } <${+M + 1}.0.0-0`;
	      }
	    }
	    debug('caret return', ret);
	    return ret
	  })
	};
	const replaceXRanges = (comp, options) => {
	  debug('replaceXRanges', comp, options);
	  return comp
	    .split(/\s+/)
	    .map((c) => replaceXRange(c, options))
	    .join(' ')
	};
	const replaceXRange = (comp, options) => {
	  comp = comp.trim();
	  const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
	  return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
	    debug('xRange', comp, ret, gtlt, M, m, p, pr);
	    const xM = isX(M);
	    const xm = xM || isX(m);
	    const xp = xm || isX(p);
	    const anyX = xp;
	    if (gtlt === '=' && anyX) {
	      gtlt = '';
	    }
	    pr = options.includePrerelease ? '-0' : '';
	    if (xM) {
	      if (gtlt === '>' || gtlt === '<') {
	        ret = '<0.0.0-0';
	      } else {
	        ret = '*';
	      }
	    } else if (gtlt && anyX) {
	      if (xm) {
	        m = 0;
	      }
	      p = 0;
	      if (gtlt === '>') {
	        gtlt = '>=';
	        if (xm) {
	          M = +M + 1;
	          m = 0;
	          p = 0;
	        } else {
	          m = +m + 1;
	          p = 0;
	        }
	      } else if (gtlt === '<=') {
	        gtlt = '<';
	        if (xm) {
	          M = +M + 1;
	        } else {
	          m = +m + 1;
	        }
	      }
	      if (gtlt === '<') {
	        pr = '-0';
	      }
	      ret = `${gtlt + M}.${m}.${p}${pr}`;
	    } else if (xm) {
	      ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
	    } else if (xp) {
	      ret = `>=${M}.${m}.0${pr
	      } <${M}.${+m + 1}.0-0`;
	    }
	    debug('xRange return', ret);
	    return ret
	  })
	};
	const replaceStars = (comp, options) => {
	  debug('replaceStars', comp, options);
	  return comp
	    .trim()
	    .replace(re[t.STAR], '')
	};
	const replaceGTE0 = (comp, options) => {
	  debug('replaceGTE0', comp, options);
	  return comp
	    .trim()
	    .replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '')
	};
	const hyphenReplace = incPr => ($0,
	  from, fM, fm, fp, fpr, fb,
	  to, tM, tm, tp, tpr) => {
	  if (isX(fM)) {
	    from = '';
	  } else if (isX(fm)) {
	    from = `>=${fM}.0.0${incPr ? '-0' : ''}`;
	  } else if (isX(fp)) {
	    from = `>=${fM}.${fm}.0${incPr ? '-0' : ''}`;
	  } else if (fpr) {
	    from = `>=${from}`;
	  } else {
	    from = `>=${from}${incPr ? '-0' : ''}`;
	  }
	  if (isX(tM)) {
	    to = '';
	  } else if (isX(tm)) {
	    to = `<${+tM + 1}.0.0-0`;
	  } else if (isX(tp)) {
	    to = `<${tM}.${+tm + 1}.0-0`;
	  } else if (tpr) {
	    to = `<=${tM}.${tm}.${tp}-${tpr}`;
	  } else if (incPr) {
	    to = `<${tM}.${tm}.${+tp + 1}-0`;
	  } else {
	    to = `<=${to}`;
	  }
	  return `${from} ${to}`.trim()
	};
	const testSet = (set, version, options) => {
	  for (let i = 0; i < set.length; i++) {
	    if (!set[i].test(version)) {
	      return false
	    }
	  }
	  if (version.prerelease.length && !options.includePrerelease) {
	    for (let i = 0; i < set.length; i++) {
	      debug(set[i].semver);
	      if (set[i].semver === Comparator.ANY) {
	        continue
	      }
	      if (set[i].semver.prerelease.length > 0) {
	        const allowed = set[i].semver;
	        if (allowed.major === version.major &&
	            allowed.minor === version.minor &&
	            allowed.patch === version.patch) {
	          return true
	        }
	      }
	    }
	    return false
	  }
	  return true
	};
	return range;
}

var comparator;
var hasRequiredComparator;

function requireComparator () {
	if (hasRequiredComparator) return comparator;
	hasRequiredComparator = 1;
	const ANY = Symbol('SemVer ANY');
	class Comparator {
	  static get ANY () {
	    return ANY
	  }
	  constructor (comp, options) {
	    options = parseOptions(options);
	    if (comp instanceof Comparator) {
	      if (comp.loose === !!options.loose) {
	        return comp
	      } else {
	        comp = comp.value;
	      }
	    }
	    comp = comp.trim().split(/\s+/).join(' ');
	    debug('comparator', comp, options);
	    this.options = options;
	    this.loose = !!options.loose;
	    this.parse(comp);
	    if (this.semver === ANY) {
	      this.value = '';
	    } else {
	      this.value = this.operator + this.semver.version;
	    }
	    debug('comp', this);
	  }
	  parse (comp) {
	    const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
	    const m = comp.match(r);
	    if (!m) {
	      throw new TypeError(`Invalid comparator: ${comp}`)
	    }
	    this.operator = m[1] !== undefined ? m[1] : '';
	    if (this.operator === '=') {
	      this.operator = '';
	    }
	    if (!m[2]) {
	      this.semver = ANY;
	    } else {
	      this.semver = new SemVer(m[2], this.options.loose);
	    }
	  }
	  toString () {
	    return this.value
	  }
	  test (version) {
	    debug('Comparator.test', version, this.options.loose);
	    if (this.semver === ANY || version === ANY) {
	      return true
	    }
	    if (typeof version === 'string') {
	      try {
	        version = new SemVer(version, this.options);
	      } catch (er) {
	        return false
	      }
	    }
	    return cmp(version, this.operator, this.semver, this.options)
	  }
	  intersects (comp, options) {
	    if (!(comp instanceof Comparator)) {
	      throw new TypeError('a Comparator is required')
	    }
	    if (this.operator === '') {
	      if (this.value === '') {
	        return true
	      }
	      return new Range(comp.value, options).test(this.value)
	    } else if (comp.operator === '') {
	      if (comp.value === '') {
	        return true
	      }
	      return new Range(this.value, options).test(comp.semver)
	    }
	    options = parseOptions(options);
	    if (options.includePrerelease &&
	      (this.value === '<0.0.0-0' || comp.value === '<0.0.0-0')) {
	      return false
	    }
	    if (!options.includePrerelease &&
	      (this.value.startsWith('<0.0.0') || comp.value.startsWith('<0.0.0'))) {
	      return false
	    }
	    if (this.operator.startsWith('>') && comp.operator.startsWith('>')) {
	      return true
	    }
	    if (this.operator.startsWith('<') && comp.operator.startsWith('<')) {
	      return true
	    }
	    if (
	      (this.semver.version === comp.semver.version) &&
	      this.operator.includes('=') && comp.operator.includes('=')) {
	      return true
	    }
	    if (cmp(this.semver, '<', comp.semver, options) &&
	      this.operator.startsWith('>') && comp.operator.startsWith('<')) {
	      return true
	    }
	    if (cmp(this.semver, '>', comp.semver, options) &&
	      this.operator.startsWith('<') && comp.operator.startsWith('>')) {
	      return true
	    }
	    return false
	  }
	}
	comparator = Comparator;
	const parseOptions = requireParseOptions();
	const { safeRe: re, t } = requireRe();
	const cmp = requireCmp();
	const debug = requireDebug$1();
	const SemVer = requireSemver$1();
	const Range = requireRange();
	return comparator;
}

var satisfies_1;
var hasRequiredSatisfies;

function requireSatisfies () {
	if (hasRequiredSatisfies) return satisfies_1;
	hasRequiredSatisfies = 1;
	const Range = requireRange();
	const satisfies = (version, range, options) => {
	  try {
	    range = new Range(range, options);
	  } catch (er) {
	    return false
	  }
	  return range.test(version)
	};
	satisfies_1 = satisfies;
	return satisfies_1;
}

var toComparators_1;
var hasRequiredToComparators;

function requireToComparators () {
	if (hasRequiredToComparators) return toComparators_1;
	hasRequiredToComparators = 1;
	const Range = requireRange();
	const toComparators = (range, options) =>
	  new Range(range, options).set
	    .map(comp => comp.map(c => c.value).join(' ').trim().split(' '));
	toComparators_1 = toComparators;
	return toComparators_1;
}

var maxSatisfying_1;
var hasRequiredMaxSatisfying;

function requireMaxSatisfying () {
	if (hasRequiredMaxSatisfying) return maxSatisfying_1;
	hasRequiredMaxSatisfying = 1;
	const SemVer = requireSemver$1();
	const Range = requireRange();
	const maxSatisfying = (versions, range, options) => {
	  let max = null;
	  let maxSV = null;
	  let rangeObj = null;
	  try {
	    rangeObj = new Range(range, options);
	  } catch (er) {
	    return null
	  }
	  versions.forEach((v) => {
	    if (rangeObj.test(v)) {
	      if (!max || maxSV.compare(v) === -1) {
	        max = v;
	        maxSV = new SemVer(max, options);
	      }
	    }
	  });
	  return max
	};
	maxSatisfying_1 = maxSatisfying;
	return maxSatisfying_1;
}

var minSatisfying_1;
var hasRequiredMinSatisfying;

function requireMinSatisfying () {
	if (hasRequiredMinSatisfying) return minSatisfying_1;
	hasRequiredMinSatisfying = 1;
	const SemVer = requireSemver$1();
	const Range = requireRange();
	const minSatisfying = (versions, range, options) => {
	  let min = null;
	  let minSV = null;
	  let rangeObj = null;
	  try {
	    rangeObj = new Range(range, options);
	  } catch (er) {
	    return null
	  }
	  versions.forEach((v) => {
	    if (rangeObj.test(v)) {
	      if (!min || minSV.compare(v) === 1) {
	        min = v;
	        minSV = new SemVer(min, options);
	      }
	    }
	  });
	  return min
	};
	minSatisfying_1 = minSatisfying;
	return minSatisfying_1;
}

var minVersion_1;
var hasRequiredMinVersion;

function requireMinVersion () {
	if (hasRequiredMinVersion) return minVersion_1;
	hasRequiredMinVersion = 1;
	const SemVer = requireSemver$1();
	const Range = requireRange();
	const gt = requireGt();
	const minVersion = (range, loose) => {
	  range = new Range(range, loose);
	  let minver = new SemVer('0.0.0');
	  if (range.test(minver)) {
	    return minver
	  }
	  minver = new SemVer('0.0.0-0');
	  if (range.test(minver)) {
	    return minver
	  }
	  minver = null;
	  for (let i = 0; i < range.set.length; ++i) {
	    const comparators = range.set[i];
	    let setMin = null;
	    comparators.forEach((comparator) => {
	      const compver = new SemVer(comparator.semver.version);
	      switch (comparator.operator) {
	        case '>':
	          if (compver.prerelease.length === 0) {
	            compver.patch++;
	          } else {
	            compver.prerelease.push(0);
	          }
	          compver.raw = compver.format();
	        case '':
	        case '>=':
	          if (!setMin || gt(compver, setMin)) {
	            setMin = compver;
	          }
	          break
	        case '<':
	        case '<=':
	          break
	        default:
	          throw new Error(`Unexpected operation: ${comparator.operator}`)
	      }
	    });
	    if (setMin && (!minver || gt(minver, setMin))) {
	      minver = setMin;
	    }
	  }
	  if (minver && range.test(minver)) {
	    return minver
	  }
	  return null
	};
	minVersion_1 = minVersion;
	return minVersion_1;
}

var valid;
var hasRequiredValid;

function requireValid () {
	if (hasRequiredValid) return valid;
	hasRequiredValid = 1;
	const Range = requireRange();
	const validRange = (range, options) => {
	  try {
	    return new Range(range, options).range || '*'
	  } catch (er) {
	    return null
	  }
	};
	valid = validRange;
	return valid;
}

var outside_1;
var hasRequiredOutside;

function requireOutside () {
	if (hasRequiredOutside) return outside_1;
	hasRequiredOutside = 1;
	const SemVer = requireSemver$1();
	const Comparator = requireComparator();
	const { ANY } = Comparator;
	const Range = requireRange();
	const satisfies = requireSatisfies();
	const gt = requireGt();
	const lt = requireLt();
	const lte = requireLte();
	const gte = requireGte();
	const outside = (version, range, hilo, options) => {
	  version = new SemVer(version, options);
	  range = new Range(range, options);
	  let gtfn, ltefn, ltfn, comp, ecomp;
	  switch (hilo) {
	    case '>':
	      gtfn = gt;
	      ltefn = lte;
	      ltfn = lt;
	      comp = '>';
	      ecomp = '>=';
	      break
	    case '<':
	      gtfn = lt;
	      ltefn = gte;
	      ltfn = gt;
	      comp = '<';
	      ecomp = '<=';
	      break
	    default:
	      throw new TypeError('Must provide a hilo val of "<" or ">"')
	  }
	  if (satisfies(version, range, options)) {
	    return false
	  }
	  for (let i = 0; i < range.set.length; ++i) {
	    const comparators = range.set[i];
	    let high = null;
	    let low = null;
	    comparators.forEach((comparator) => {
	      if (comparator.semver === ANY) {
	        comparator = new Comparator('>=0.0.0');
	      }
	      high = high || comparator;
	      low = low || comparator;
	      if (gtfn(comparator.semver, high.semver, options)) {
	        high = comparator;
	      } else if (ltfn(comparator.semver, low.semver, options)) {
	        low = comparator;
	      }
	    });
	    if (high.operator === comp || high.operator === ecomp) {
	      return false
	    }
	    if ((!low.operator || low.operator === comp) &&
	        ltefn(version, low.semver)) {
	      return false
	    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
	      return false
	    }
	  }
	  return true
	};
	outside_1 = outside;
	return outside_1;
}

var gtr_1;
var hasRequiredGtr;

function requireGtr () {
	if (hasRequiredGtr) return gtr_1;
	hasRequiredGtr = 1;
	const outside = requireOutside();
	const gtr = (version, range, options) => outside(version, range, '>', options);
	gtr_1 = gtr;
	return gtr_1;
}

var ltr_1;
var hasRequiredLtr;

function requireLtr () {
	if (hasRequiredLtr) return ltr_1;
	hasRequiredLtr = 1;
	const outside = requireOutside();
	const ltr = (version, range, options) => outside(version, range, '<', options);
	ltr_1 = ltr;
	return ltr_1;
}

var intersects_1;
var hasRequiredIntersects;

function requireIntersects () {
	if (hasRequiredIntersects) return intersects_1;
	hasRequiredIntersects = 1;
	const Range = requireRange();
	const intersects = (r1, r2, options) => {
	  r1 = new Range(r1, options);
	  r2 = new Range(r2, options);
	  return r1.intersects(r2, options)
	};
	intersects_1 = intersects;
	return intersects_1;
}

var simplify;
var hasRequiredSimplify;

function requireSimplify () {
	if (hasRequiredSimplify) return simplify;
	hasRequiredSimplify = 1;
	const satisfies = requireSatisfies();
	const compare = requireCompare();
	simplify = (versions, range, options) => {
	  const set = [];
	  let first = null;
	  let prev = null;
	  const v = versions.sort((a, b) => compare(a, b, options));
	  for (const version of v) {
	    const included = satisfies(version, range, options);
	    if (included) {
	      prev = version;
	      if (!first) {
	        first = version;
	      }
	    } else {
	      if (prev) {
	        set.push([first, prev]);
	      }
	      prev = null;
	      first = null;
	    }
	  }
	  if (first) {
	    set.push([first, null]);
	  }
	  const ranges = [];
	  for (const [min, max] of set) {
	    if (min === max) {
	      ranges.push(min);
	    } else if (!max && min === v[0]) {
	      ranges.push('*');
	    } else if (!max) {
	      ranges.push(`>=${min}`);
	    } else if (min === v[0]) {
	      ranges.push(`<=${max}`);
	    } else {
	      ranges.push(`${min} - ${max}`);
	    }
	  }
	  const simplified = ranges.join(' || ');
	  const original = typeof range.raw === 'string' ? range.raw : String(range);
	  return simplified.length < original.length ? simplified : range
	};
	return simplify;
}

var subset_1;
var hasRequiredSubset;

function requireSubset () {
	if (hasRequiredSubset) return subset_1;
	hasRequiredSubset = 1;
	const Range = requireRange();
	const Comparator = requireComparator();
	const { ANY } = Comparator;
	const satisfies = requireSatisfies();
	const compare = requireCompare();
	const subset = (sub, dom, options = {}) => {
	  if (sub === dom) {
	    return true
	  }
	  sub = new Range(sub, options);
	  dom = new Range(dom, options);
	  let sawNonNull = false;
	  OUTER: for (const simpleSub of sub.set) {
	    for (const simpleDom of dom.set) {
	      const isSub = simpleSubset(simpleSub, simpleDom, options);
	      sawNonNull = sawNonNull || isSub !== null;
	      if (isSub) {
	        continue OUTER
	      }
	    }
	    if (sawNonNull) {
	      return false
	    }
	  }
	  return true
	};
	const minimumVersionWithPreRelease = [new Comparator('>=0.0.0-0')];
	const minimumVersion = [new Comparator('>=0.0.0')];
	const simpleSubset = (sub, dom, options) => {
	  if (sub === dom) {
	    return true
	  }
	  if (sub.length === 1 && sub[0].semver === ANY) {
	    if (dom.length === 1 && dom[0].semver === ANY) {
	      return true
	    } else if (options.includePrerelease) {
	      sub = minimumVersionWithPreRelease;
	    } else {
	      sub = minimumVersion;
	    }
	  }
	  if (dom.length === 1 && dom[0].semver === ANY) {
	    if (options.includePrerelease) {
	      return true
	    } else {
	      dom = minimumVersion;
	    }
	  }
	  const eqSet = new Set();
	  let gt, lt;
	  for (const c of sub) {
	    if (c.operator === '>' || c.operator === '>=') {
	      gt = higherGT(gt, c, options);
	    } else if (c.operator === '<' || c.operator === '<=') {
	      lt = lowerLT(lt, c, options);
	    } else {
	      eqSet.add(c.semver);
	    }
	  }
	  if (eqSet.size > 1) {
	    return null
	  }
	  let gtltComp;
	  if (gt && lt) {
	    gtltComp = compare(gt.semver, lt.semver, options);
	    if (gtltComp > 0) {
	      return null
	    } else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<=')) {
	      return null
	    }
	  }
	  for (const eq of eqSet) {
	    if (gt && !satisfies(eq, String(gt), options)) {
	      return null
	    }
	    if (lt && !satisfies(eq, String(lt), options)) {
	      return null
	    }
	    for (const c of dom) {
	      if (!satisfies(eq, String(c), options)) {
	        return false
	      }
	    }
	    return true
	  }
	  let higher, lower;
	  let hasDomLT, hasDomGT;
	  let needDomLTPre = lt &&
	    !options.includePrerelease &&
	    lt.semver.prerelease.length ? lt.semver : false;
	  let needDomGTPre = gt &&
	    !options.includePrerelease &&
	    gt.semver.prerelease.length ? gt.semver : false;
	  if (needDomLTPre && needDomLTPre.prerelease.length === 1 &&
	      lt.operator === '<' && needDomLTPre.prerelease[0] === 0) {
	    needDomLTPre = false;
	  }
	  for (const c of dom) {
	    hasDomGT = hasDomGT || c.operator === '>' || c.operator === '>=';
	    hasDomLT = hasDomLT || c.operator === '<' || c.operator === '<=';
	    if (gt) {
	      if (needDomGTPre) {
	        if (c.semver.prerelease && c.semver.prerelease.length &&
	            c.semver.major === needDomGTPre.major &&
	            c.semver.minor === needDomGTPre.minor &&
	            c.semver.patch === needDomGTPre.patch) {
	          needDomGTPre = false;
	        }
	      }
	      if (c.operator === '>' || c.operator === '>=') {
	        higher = higherGT(gt, c, options);
	        if (higher === c && higher !== gt) {
	          return false
	        }
	      } else if (gt.operator === '>=' && !satisfies(gt.semver, String(c), options)) {
	        return false
	      }
	    }
	    if (lt) {
	      if (needDomLTPre) {
	        if (c.semver.prerelease && c.semver.prerelease.length &&
	            c.semver.major === needDomLTPre.major &&
	            c.semver.minor === needDomLTPre.minor &&
	            c.semver.patch === needDomLTPre.patch) {
	          needDomLTPre = false;
	        }
	      }
	      if (c.operator === '<' || c.operator === '<=') {
	        lower = lowerLT(lt, c, options);
	        if (lower === c && lower !== lt) {
	          return false
	        }
	      } else if (lt.operator === '<=' && !satisfies(lt.semver, String(c), options)) {
	        return false
	      }
	    }
	    if (!c.operator && (lt || gt) && gtltComp !== 0) {
	      return false
	    }
	  }
	  if (gt && hasDomLT && !lt && gtltComp !== 0) {
	    return false
	  }
	  if (lt && hasDomGT && !gt && gtltComp !== 0) {
	    return false
	  }
	  if (needDomGTPre || needDomLTPre) {
	    return false
	  }
	  return true
	};
	const higherGT = (a, b, options) => {
	  if (!a) {
	    return b
	  }
	  const comp = compare(a.semver, b.semver, options);
	  return comp > 0 ? a
	    : comp < 0 ? b
	    : b.operator === '>' && a.operator === '>=' ? b
	    : a
	};
	const lowerLT = (a, b, options) => {
	  if (!a) {
	    return b
	  }
	  const comp = compare(a.semver, b.semver, options);
	  return comp < 0 ? a
	    : comp > 0 ? b
	    : b.operator === '<' && a.operator === '<=' ? b
	    : a
	};
	subset_1 = subset;
	return subset_1;
}

var semver$1;
var hasRequiredSemver;

function requireSemver () {
	if (hasRequiredSemver) return semver$1;
	hasRequiredSemver = 1;
	const internalRe = requireRe();
	const constants = requireConstants$4();
	const SemVer = requireSemver$1();
	const identifiers = requireIdentifiers();
	const parse = requireParse();
	const valid = requireValid$1();
	const clean = requireClean();
	const inc = requireInc();
	const diff = requireDiff();
	const major = requireMajor();
	const minor = requireMinor();
	const patch = requirePatch();
	const prerelease = requirePrerelease();
	const compare = requireCompare();
	const rcompare = requireRcompare();
	const compareLoose = requireCompareLoose();
	const compareBuild = requireCompareBuild();
	const sort = requireSort();
	const rsort = requireRsort();
	const gt = requireGt();
	const lt = requireLt();
	const eq = requireEq();
	const neq = requireNeq();
	const gte = requireGte();
	const lte = requireLte();
	const cmp = requireCmp();
	const coerce = requireCoerce();
	const Comparator = requireComparator();
	const Range = requireRange();
	const satisfies = requireSatisfies();
	const toComparators = requireToComparators();
	const maxSatisfying = requireMaxSatisfying();
	const minSatisfying = requireMinSatisfying();
	const minVersion = requireMinVersion();
	const validRange = requireValid();
	const outside = requireOutside();
	const gtr = requireGtr();
	const ltr = requireLtr();
	const intersects = requireIntersects();
	const simplifyRange = requireSimplify();
	const subset = requireSubset();
	semver$1 = {
	  parse,
	  valid,
	  clean,
	  inc,
	  diff,
	  major,
	  minor,
	  patch,
	  prerelease,
	  compare,
	  rcompare,
	  compareLoose,
	  compareBuild,
	  sort,
	  rsort,
	  gt,
	  lt,
	  eq,
	  neq,
	  gte,
	  lte,
	  cmp,
	  coerce,
	  Comparator,
	  Range,
	  satisfies,
	  toComparators,
	  maxSatisfying,
	  minSatisfying,
	  minVersion,
	  validRange,
	  outside,
	  gtr,
	  ltr,
	  intersects,
	  simplifyRange,
	  subset,
	  SemVer,
	  re: internalRe.re,
	  src: internalRe.src,
	  tokens: internalRe.t,
	  SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
	  RELEASE_TYPES: constants.RELEASE_TYPES,
	  compareIdentifiers: identifiers.compareIdentifiers,
	  rcompareIdentifiers: identifiers.rcompareIdentifiers,
	};
	return semver$1;
}

var semverExports = requireSemver();
var semver = /*@__PURE__*/getDefaultExportFromCjs(semverExports);

var dist$b = {};

var lruCache;
var hasRequiredLruCache;

function requireLruCache () {
	if (hasRequiredLruCache) return lruCache;
	hasRequiredLruCache = 1;
	const perf =
	  typeof performance === 'object' &&
	  performance &&
	  typeof performance.now === 'function'
	    ? performance
	    : Date;
	const hasAbortController = typeof AbortController === 'function';
	const AC = hasAbortController
	  ? AbortController
	  : class AbortController {
	      constructor() {
	        this.signal = new AS();
	      }
	      abort(reason = new Error('This operation was aborted')) {
	        this.signal.reason = this.signal.reason || reason;
	        this.signal.aborted = true;
	        this.signal.dispatchEvent({
	          type: 'abort',
	          target: this.signal,
	        });
	      }
	    };
	const hasAbortSignal = typeof AbortSignal === 'function';
	const hasACAbortSignal = typeof AC.AbortSignal === 'function';
	const AS = hasAbortSignal
	  ? AbortSignal
	  : hasACAbortSignal
	  ? AC.AbortController
	  : class AbortSignal {
	      constructor() {
	        this.reason = undefined;
	        this.aborted = false;
	        this._listeners = [];
	      }
	      dispatchEvent(e) {
	        if (e.type === 'abort') {
	          this.aborted = true;
	          this.onabort(e);
	          this._listeners.forEach(f => f(e), this);
	        }
	      }
	      onabort() {}
	      addEventListener(ev, fn) {
	        if (ev === 'abort') {
	          this._listeners.push(fn);
	        }
	      }
	      removeEventListener(ev, fn) {
	        if (ev === 'abort') {
	          this._listeners = this._listeners.filter(f => f !== fn);
	        }
	      }
	    };
	const warned = new Set();
	const deprecatedOption = (opt, instead) => {
	  const code = `LRU_CACHE_OPTION_${opt}`;
	  if (shouldWarn(code)) {
	    warn(code, `${opt} option`, `options.${instead}`, LRUCache);
	  }
	};
	const deprecatedMethod = (method, instead) => {
	  const code = `LRU_CACHE_METHOD_${method}`;
	  if (shouldWarn(code)) {
	    const { prototype } = LRUCache;
	    const { get } = Object.getOwnPropertyDescriptor(prototype, method);
	    warn(code, `${method} method`, `cache.${instead}()`, get);
	  }
	};
	const deprecatedProperty = (field, instead) => {
	  const code = `LRU_CACHE_PROPERTY_${field}`;
	  if (shouldWarn(code)) {
	    const { prototype } = LRUCache;
	    const { get } = Object.getOwnPropertyDescriptor(prototype, field);
	    warn(code, `${field} property`, `cache.${instead}`, get);
	  }
	};
	const emitWarning = (...a) => {
	  typeof process === 'object' &&
	  process &&
	  typeof process.emitWarning === 'function'
	    ? process.emitWarning(...a)
	    : console.error(...a);
	};
	const shouldWarn = code => !warned.has(code);
	const warn = (code, what, instead, fn) => {
	  warned.add(code);
	  const msg = `The ${what} is deprecated. Please use ${instead} instead.`;
	  emitWarning(msg, 'DeprecationWarning', code, fn);
	};
	const isPosInt = n => n && n === Math.floor(n) && n > 0 && isFinite(n);
	const getUintArray = max =>
	  !isPosInt(max)
	    ? null
	    : max <= Math.pow(2, 8)
	    ? Uint8Array
	    : max <= Math.pow(2, 16)
	    ? Uint16Array
	    : max <= Math.pow(2, 32)
	    ? Uint32Array
	    : max <= Number.MAX_SAFE_INTEGER
	    ? ZeroArray
	    : null;
	class ZeroArray extends Array {
	  constructor(size) {
	    super(size);
	    this.fill(0);
	  }
	}
	class Stack {
	  constructor(max) {
	    if (max === 0) {
	      return []
	    }
	    const UintArray = getUintArray(max);
	    this.heap = new UintArray(max);
	    this.length = 0;
	  }
	  push(n) {
	    this.heap[this.length++] = n;
	  }
	  pop() {
	    return this.heap[--this.length]
	  }
	}
	class LRUCache {
	  constructor(options = {}) {
	    const {
	      max = 0,
	      ttl,
	      ttlResolution = 1,
	      ttlAutopurge,
	      updateAgeOnGet,
	      updateAgeOnHas,
	      allowStale,
	      dispose,
	      disposeAfter,
	      noDisposeOnSet,
	      noUpdateTTL,
	      maxSize = 0,
	      maxEntrySize = 0,
	      sizeCalculation,
	      fetchMethod,
	      fetchContext,
	      noDeleteOnFetchRejection,
	      noDeleteOnStaleGet,
	      allowStaleOnFetchRejection,
	      allowStaleOnFetchAbort,
	      ignoreFetchAbort,
	    } = options;
	    const { length, maxAge, stale } =
	      options instanceof LRUCache ? {} : options;
	    if (max !== 0 && !isPosInt(max)) {
	      throw new TypeError('max option must be a nonnegative integer')
	    }
	    const UintArray = max ? getUintArray(max) : Array;
	    if (!UintArray) {
	      throw new Error('invalid max value: ' + max)
	    }
	    this.max = max;
	    this.maxSize = maxSize;
	    this.maxEntrySize = maxEntrySize || this.maxSize;
	    this.sizeCalculation = sizeCalculation || length;
	    if (this.sizeCalculation) {
	      if (!this.maxSize && !this.maxEntrySize) {
	        throw new TypeError(
	          'cannot set sizeCalculation without setting maxSize or maxEntrySize'
	        )
	      }
	      if (typeof this.sizeCalculation !== 'function') {
	        throw new TypeError('sizeCalculation set to non-function')
	      }
	    }
	    this.fetchMethod = fetchMethod || null;
	    if (this.fetchMethod && typeof this.fetchMethod !== 'function') {
	      throw new TypeError(
	        'fetchMethod must be a function if specified'
	      )
	    }
	    this.fetchContext = fetchContext;
	    if (!this.fetchMethod && fetchContext !== undefined) {
	      throw new TypeError(
	        'cannot set fetchContext without fetchMethod'
	      )
	    }
	    this.keyMap = new Map();
	    this.keyList = new Array(max).fill(null);
	    this.valList = new Array(max).fill(null);
	    this.next = new UintArray(max);
	    this.prev = new UintArray(max);
	    this.head = 0;
	    this.tail = 0;
	    this.free = new Stack(max);
	    this.initialFill = 1;
	    this.size = 0;
	    if (typeof dispose === 'function') {
	      this.dispose = dispose;
	    }
	    if (typeof disposeAfter === 'function') {
	      this.disposeAfter = disposeAfter;
	      this.disposed = [];
	    } else {
	      this.disposeAfter = null;
	      this.disposed = null;
	    }
	    this.noDisposeOnSet = !!noDisposeOnSet;
	    this.noUpdateTTL = !!noUpdateTTL;
	    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
	    this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
	    this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
	    this.ignoreFetchAbort = !!ignoreFetchAbort;
	    if (this.maxEntrySize !== 0) {
	      if (this.maxSize !== 0) {
	        if (!isPosInt(this.maxSize)) {
	          throw new TypeError(
	            'maxSize must be a positive integer if specified'
	          )
	        }
	      }
	      if (!isPosInt(this.maxEntrySize)) {
	        throw new TypeError(
	          'maxEntrySize must be a positive integer if specified'
	        )
	      }
	      this.initializeSizeTracking();
	    }
	    this.allowStale = !!allowStale || !!stale;
	    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
	    this.updateAgeOnGet = !!updateAgeOnGet;
	    this.updateAgeOnHas = !!updateAgeOnHas;
	    this.ttlResolution =
	      isPosInt(ttlResolution) || ttlResolution === 0
	        ? ttlResolution
	        : 1;
	    this.ttlAutopurge = !!ttlAutopurge;
	    this.ttl = ttl || maxAge || 0;
	    if (this.ttl) {
	      if (!isPosInt(this.ttl)) {
	        throw new TypeError(
	          'ttl must be a positive integer if specified'
	        )
	      }
	      this.initializeTTLTracking();
	    }
	    if (this.max === 0 && this.ttl === 0 && this.maxSize === 0) {
	      throw new TypeError(
	        'At least one of max, maxSize, or ttl is required'
	      )
	    }
	    if (!this.ttlAutopurge && !this.max && !this.maxSize) {
	      const code = 'LRU_CACHE_UNBOUNDED';
	      if (shouldWarn(code)) {
	        warned.add(code);
	        const msg =
	          'TTL caching without ttlAutopurge, max, or maxSize can ' +
	          'result in unbounded memory consumption.';
	        emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache);
	      }
	    }
	    if (stale) {
	      deprecatedOption('stale', 'allowStale');
	    }
	    if (maxAge) {
	      deprecatedOption('maxAge', 'ttl');
	    }
	    if (length) {
	      deprecatedOption('length', 'sizeCalculation');
	    }
	  }
	  getRemainingTTL(key) {
	    return this.has(key, { updateAgeOnHas: false }) ? Infinity : 0
	  }
	  initializeTTLTracking() {
	    this.ttls = new ZeroArray(this.max);
	    this.starts = new ZeroArray(this.max);
	    this.setItemTTL = (index, ttl, start = perf.now()) => {
	      this.starts[index] = ttl !== 0 ? start : 0;
	      this.ttls[index] = ttl;
	      if (ttl !== 0 && this.ttlAutopurge) {
	        const t = setTimeout(() => {
	          if (this.isStale(index)) {
	            this.delete(this.keyList[index]);
	          }
	        }, ttl + 1);
	        if (t.unref) {
	          t.unref();
	        }
	      }
	    };
	    this.updateItemAge = index => {
	      this.starts[index] = this.ttls[index] !== 0 ? perf.now() : 0;
	    };
	    this.statusTTL = (status, index) => {
	      if (status) {
	        status.ttl = this.ttls[index];
	        status.start = this.starts[index];
	        status.now = cachedNow || getNow();
	        status.remainingTTL = status.now + status.ttl - status.start;
	      }
	    };
	    let cachedNow = 0;
	    const getNow = () => {
	      const n = perf.now();
	      if (this.ttlResolution > 0) {
	        cachedNow = n;
	        const t = setTimeout(
	          () => (cachedNow = 0),
	          this.ttlResolution
	        );
	        if (t.unref) {
	          t.unref();
	        }
	      }
	      return n
	    };
	    this.getRemainingTTL = key => {
	      const index = this.keyMap.get(key);
	      if (index === undefined) {
	        return 0
	      }
	      return this.ttls[index] === 0 || this.starts[index] === 0
	        ? Infinity
	        : this.starts[index] +
	            this.ttls[index] -
	            (cachedNow || getNow())
	    };
	    this.isStale = index => {
	      return (
	        this.ttls[index] !== 0 &&
	        this.starts[index] !== 0 &&
	        (cachedNow || getNow()) - this.starts[index] >
	          this.ttls[index]
	      )
	    };
	  }
	  updateItemAge(_index) {}
	  statusTTL(_status, _index) {}
	  setItemTTL(_index, _ttl, _start) {}
	  isStale(_index) {
	    return false
	  }
	  initializeSizeTracking() {
	    this.calculatedSize = 0;
	    this.sizes = new ZeroArray(this.max);
	    this.removeItemSize = index => {
	      this.calculatedSize -= this.sizes[index];
	      this.sizes[index] = 0;
	    };
	    this.requireSize = (k, v, size, sizeCalculation) => {
	      if (this.isBackgroundFetch(v)) {
	        return 0
	      }
	      if (!isPosInt(size)) {
	        if (sizeCalculation) {
	          if (typeof sizeCalculation !== 'function') {
	            throw new TypeError('sizeCalculation must be a function')
	          }
	          size = sizeCalculation(v, k);
	          if (!isPosInt(size)) {
	            throw new TypeError(
	              'sizeCalculation return invalid (expect positive integer)'
	            )
	          }
	        } else {
	          throw new TypeError(
	            'invalid size value (must be positive integer). ' +
	              'When maxSize or maxEntrySize is used, sizeCalculation or size ' +
	              'must be set.'
	          )
	        }
	      }
	      return size
	    };
	    this.addItemSize = (index, size, status) => {
	      this.sizes[index] = size;
	      if (this.maxSize) {
	        const maxSize = this.maxSize - this.sizes[index];
	        while (this.calculatedSize > maxSize) {
	          this.evict(true);
	        }
	      }
	      this.calculatedSize += this.sizes[index];
	      if (status) {
	        status.entrySize = size;
	        status.totalCalculatedSize = this.calculatedSize;
	      }
	    };
	  }
	  removeItemSize(_index) {}
	  addItemSize(_index, _size) {}
	  requireSize(_k, _v, size, sizeCalculation) {
	    if (size || sizeCalculation) {
	      throw new TypeError(
	        'cannot set size without setting maxSize or maxEntrySize on cache'
	      )
	    }
	  }
	  *indexes({ allowStale = this.allowStale } = {}) {
	    if (this.size) {
	      for (let i = this.tail; true; ) {
	        if (!this.isValidIndex(i)) {
	          break
	        }
	        if (allowStale || !this.isStale(i)) {
	          yield i;
	        }
	        if (i === this.head) {
	          break
	        } else {
	          i = this.prev[i];
	        }
	      }
	    }
	  }
	  *rindexes({ allowStale = this.allowStale } = {}) {
	    if (this.size) {
	      for (let i = this.head; true; ) {
	        if (!this.isValidIndex(i)) {
	          break
	        }
	        if (allowStale || !this.isStale(i)) {
	          yield i;
	        }
	        if (i === this.tail) {
	          break
	        } else {
	          i = this.next[i];
	        }
	      }
	    }
	  }
	  isValidIndex(index) {
	    return (
	      index !== undefined &&
	      this.keyMap.get(this.keyList[index]) === index
	    )
	  }
	  *entries() {
	    for (const i of this.indexes()) {
	      if (
	        this.valList[i] !== undefined &&
	        this.keyList[i] !== undefined &&
	        !this.isBackgroundFetch(this.valList[i])
	      ) {
	        yield [this.keyList[i], this.valList[i]];
	      }
	    }
	  }
	  *rentries() {
	    for (const i of this.rindexes()) {
	      if (
	        this.valList[i] !== undefined &&
	        this.keyList[i] !== undefined &&
	        !this.isBackgroundFetch(this.valList[i])
	      ) {
	        yield [this.keyList[i], this.valList[i]];
	      }
	    }
	  }
	  *keys() {
	    for (const i of this.indexes()) {
	      if (
	        this.keyList[i] !== undefined &&
	        !this.isBackgroundFetch(this.valList[i])
	      ) {
	        yield this.keyList[i];
	      }
	    }
	  }
	  *rkeys() {
	    for (const i of this.rindexes()) {
	      if (
	        this.keyList[i] !== undefined &&
	        !this.isBackgroundFetch(this.valList[i])
	      ) {
	        yield this.keyList[i];
	      }
	    }
	  }
	  *values() {
	    for (const i of this.indexes()) {
	      if (
	        this.valList[i] !== undefined &&
	        !this.isBackgroundFetch(this.valList[i])
	      ) {
	        yield this.valList[i];
	      }
	    }
	  }
	  *rvalues() {
	    for (const i of this.rindexes()) {
	      if (
	        this.valList[i] !== undefined &&
	        !this.isBackgroundFetch(this.valList[i])
	      ) {
	        yield this.valList[i];
	      }
	    }
	  }
	  [Symbol.iterator]() {
	    return this.entries()
	  }
	  find(fn, getOptions) {
	    for (const i of this.indexes()) {
	      const v = this.valList[i];
	      const value = this.isBackgroundFetch(v)
	        ? v.__staleWhileFetching
	        : v;
	      if (value === undefined) continue
	      if (fn(value, this.keyList[i], this)) {
	        return this.get(this.keyList[i], getOptions)
	      }
	    }
	  }
	  forEach(fn, thisp = this) {
	    for (const i of this.indexes()) {
	      const v = this.valList[i];
	      const value = this.isBackgroundFetch(v)
	        ? v.__staleWhileFetching
	        : v;
	      if (value === undefined) continue
	      fn.call(thisp, value, this.keyList[i], this);
	    }
	  }
	  rforEach(fn, thisp = this) {
	    for (const i of this.rindexes()) {
	      const v = this.valList[i];
	      const value = this.isBackgroundFetch(v)
	        ? v.__staleWhileFetching
	        : v;
	      if (value === undefined) continue
	      fn.call(thisp, value, this.keyList[i], this);
	    }
	  }
	  get prune() {
	    deprecatedMethod('prune', 'purgeStale');
	    return this.purgeStale
	  }
	  purgeStale() {
	    let deleted = false;
	    for (const i of this.rindexes({ allowStale: true })) {
	      if (this.isStale(i)) {
	        this.delete(this.keyList[i]);
	        deleted = true;
	      }
	    }
	    return deleted
	  }
	  dump() {
	    const arr = [];
	    for (const i of this.indexes({ allowStale: true })) {
	      const key = this.keyList[i];
	      const v = this.valList[i];
	      const value = this.isBackgroundFetch(v)
	        ? v.__staleWhileFetching
	        : v;
	      if (value === undefined) continue
	      const entry = { value };
	      if (this.ttls) {
	        entry.ttl = this.ttls[i];
	        const age = perf.now() - this.starts[i];
	        entry.start = Math.floor(Date.now() - age);
	      }
	      if (this.sizes) {
	        entry.size = this.sizes[i];
	      }
	      arr.unshift([key, entry]);
	    }
	    return arr
	  }
	  load(arr) {
	    this.clear();
	    for (const [key, entry] of arr) {
	      if (entry.start) {
	        const age = Date.now() - entry.start;
	        entry.start = perf.now() - age;
	      }
	      this.set(key, entry.value, entry);
	    }
	  }
	  dispose(_v, _k, _reason) {}
	  set(
	    k,
	    v,
	    {
	      ttl = this.ttl,
	      start,
	      noDisposeOnSet = this.noDisposeOnSet,
	      size = 0,
	      sizeCalculation = this.sizeCalculation,
	      noUpdateTTL = this.noUpdateTTL,
	      status,
	    } = {}
	  ) {
	    size = this.requireSize(k, v, size, sizeCalculation);
	    if (this.maxEntrySize && size > this.maxEntrySize) {
	      if (status) {
	        status.set = 'miss';
	        status.maxEntrySizeExceeded = true;
	      }
	      this.delete(k);
	      return this
	    }
	    let index = this.size === 0 ? undefined : this.keyMap.get(k);
	    if (index === undefined) {
	      index = this.newIndex();
	      this.keyList[index] = k;
	      this.valList[index] = v;
	      this.keyMap.set(k, index);
	      this.next[this.tail] = index;
	      this.prev[index] = this.tail;
	      this.tail = index;
	      this.size++;
	      this.addItemSize(index, size, status);
	      if (status) {
	        status.set = 'add';
	      }
	      noUpdateTTL = false;
	    } else {
	      this.moveToTail(index);
	      const oldVal = this.valList[index];
	      if (v !== oldVal) {
	        if (this.isBackgroundFetch(oldVal)) {
	          oldVal.__abortController.abort(new Error('replaced'));
	        } else {
	          if (!noDisposeOnSet) {
	            this.dispose(oldVal, k, 'set');
	            if (this.disposeAfter) {
	              this.disposed.push([oldVal, k, 'set']);
	            }
	          }
	        }
	        this.removeItemSize(index);
	        this.valList[index] = v;
	        this.addItemSize(index, size, status);
	        if (status) {
	          status.set = 'replace';
	          const oldValue =
	            oldVal && this.isBackgroundFetch(oldVal)
	              ? oldVal.__staleWhileFetching
	              : oldVal;
	          if (oldValue !== undefined) status.oldValue = oldValue;
	        }
	      } else if (status) {
	        status.set = 'update';
	      }
	    }
	    if (ttl !== 0 && this.ttl === 0 && !this.ttls) {
	      this.initializeTTLTracking();
	    }
	    if (!noUpdateTTL) {
	      this.setItemTTL(index, ttl, start);
	    }
	    this.statusTTL(status, index);
	    if (this.disposeAfter) {
	      while (this.disposed.length) {
	        this.disposeAfter(...this.disposed.shift());
	      }
	    }
	    return this
	  }
	  newIndex() {
	    if (this.size === 0) {
	      return this.tail
	    }
	    if (this.size === this.max && this.max !== 0) {
	      return this.evict(false)
	    }
	    if (this.free.length !== 0) {
	      return this.free.pop()
	    }
	    return this.initialFill++
	  }
	  pop() {
	    if (this.size) {
	      const val = this.valList[this.head];
	      this.evict(true);
	      return val
	    }
	  }
	  evict(free) {
	    const head = this.head;
	    const k = this.keyList[head];
	    const v = this.valList[head];
	    if (this.isBackgroundFetch(v)) {
	      v.__abortController.abort(new Error('evicted'));
	    } else {
	      this.dispose(v, k, 'evict');
	      if (this.disposeAfter) {
	        this.disposed.push([v, k, 'evict']);
	      }
	    }
	    this.removeItemSize(head);
	    if (free) {
	      this.keyList[head] = null;
	      this.valList[head] = null;
	      this.free.push(head);
	    }
	    this.head = this.next[head];
	    this.keyMap.delete(k);
	    this.size--;
	    return head
	  }
	  has(k, { updateAgeOnHas = this.updateAgeOnHas, status } = {}) {
	    const index = this.keyMap.get(k);
	    if (index !== undefined) {
	      if (!this.isStale(index)) {
	        if (updateAgeOnHas) {
	          this.updateItemAge(index);
	        }
	        if (status) status.has = 'hit';
	        this.statusTTL(status, index);
	        return true
	      } else if (status) {
	        status.has = 'stale';
	        this.statusTTL(status, index);
	      }
	    } else if (status) {
	      status.has = 'miss';
	    }
	    return false
	  }
	  peek(k, { allowStale = this.allowStale } = {}) {
	    const index = this.keyMap.get(k);
	    if (index !== undefined && (allowStale || !this.isStale(index))) {
	      const v = this.valList[index];
	      return this.isBackgroundFetch(v) ? v.__staleWhileFetching : v
	    }
	  }
	  backgroundFetch(k, index, options, context) {
	    const v = index === undefined ? undefined : this.valList[index];
	    if (this.isBackgroundFetch(v)) {
	      return v
	    }
	    const ac = new AC();
	    if (options.signal) {
	      options.signal.addEventListener('abort', () =>
	        ac.abort(options.signal.reason)
	      );
	    }
	    const fetchOpts = {
	      signal: ac.signal,
	      options,
	      context,
	    };
	    const cb = (v, updateCache = false) => {
	      const { aborted } = ac.signal;
	      const ignoreAbort = options.ignoreFetchAbort && v !== undefined;
	      if (options.status) {
	        if (aborted && !updateCache) {
	          options.status.fetchAborted = true;
	          options.status.fetchError = ac.signal.reason;
	          if (ignoreAbort) options.status.fetchAbortIgnored = true;
	        } else {
	          options.status.fetchResolved = true;
	        }
	      }
	      if (aborted && !ignoreAbort && !updateCache) {
	        return fetchFail(ac.signal.reason)
	      }
	      if (this.valList[index] === p) {
	        if (v === undefined) {
	          if (p.__staleWhileFetching) {
	            this.valList[index] = p.__staleWhileFetching;
	          } else {
	            this.delete(k);
	          }
	        } else {
	          if (options.status) options.status.fetchUpdated = true;
	          this.set(k, v, fetchOpts.options);
	        }
	      }
	      return v
	    };
	    const eb = er => {
	      if (options.status) {
	        options.status.fetchRejected = true;
	        options.status.fetchError = er;
	      }
	      return fetchFail(er)
	    };
	    const fetchFail = er => {
	      const { aborted } = ac.signal;
	      const allowStaleAborted =
	        aborted && options.allowStaleOnFetchAbort;
	      const allowStale =
	        allowStaleAborted || options.allowStaleOnFetchRejection;
	      const noDelete = allowStale || options.noDeleteOnFetchRejection;
	      if (this.valList[index] === p) {
	        const del = !noDelete || p.__staleWhileFetching === undefined;
	        if (del) {
	          this.delete(k);
	        } else if (!allowStaleAborted) {
	          this.valList[index] = p.__staleWhileFetching;
	        }
	      }
	      if (allowStale) {
	        if (options.status && p.__staleWhileFetching !== undefined) {
	          options.status.returnedStale = true;
	        }
	        return p.__staleWhileFetching
	      } else if (p.__returned === p) {
	        throw er
	      }
	    };
	    const pcall = (res, rej) => {
	      this.fetchMethod(k, v, fetchOpts).then(v => res(v), rej);
	      ac.signal.addEventListener('abort', () => {
	        if (
	          !options.ignoreFetchAbort ||
	          options.allowStaleOnFetchAbort
	        ) {
	          res();
	          if (options.allowStaleOnFetchAbort) {
	            res = v => cb(v, true);
	          }
	        }
	      });
	    };
	    if (options.status) options.status.fetchDispatched = true;
	    const p = new Promise(pcall).then(cb, eb);
	    p.__abortController = ac;
	    p.__staleWhileFetching = v;
	    p.__returned = null;
	    if (index === undefined) {
	      this.set(k, p, { ...fetchOpts.options, status: undefined });
	      index = this.keyMap.get(k);
	    } else {
	      this.valList[index] = p;
	    }
	    return p
	  }
	  isBackgroundFetch(p) {
	    return (
	      p &&
	      typeof p === 'object' &&
	      typeof p.then === 'function' &&
	      Object.prototype.hasOwnProperty.call(
	        p,
	        '__staleWhileFetching'
	      ) &&
	      Object.prototype.hasOwnProperty.call(p, '__returned') &&
	      (p.__returned === p || p.__returned === null)
	    )
	  }
	  async fetch(
	    k,
	    {
	      allowStale = this.allowStale,
	      updateAgeOnGet = this.updateAgeOnGet,
	      noDeleteOnStaleGet = this.noDeleteOnStaleGet,
	      ttl = this.ttl,
	      noDisposeOnSet = this.noDisposeOnSet,
	      size = 0,
	      sizeCalculation = this.sizeCalculation,
	      noUpdateTTL = this.noUpdateTTL,
	      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
	      allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
	      ignoreFetchAbort = this.ignoreFetchAbort,
	      allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
	      fetchContext = this.fetchContext,
	      forceRefresh = false,
	      status,
	      signal,
	    } = {}
	  ) {
	    if (!this.fetchMethod) {
	      if (status) status.fetch = 'get';
	      return this.get(k, {
	        allowStale,
	        updateAgeOnGet,
	        noDeleteOnStaleGet,
	        status,
	      })
	    }
	    const options = {
	      allowStale,
	      updateAgeOnGet,
	      noDeleteOnStaleGet,
	      ttl,
	      noDisposeOnSet,
	      size,
	      sizeCalculation,
	      noUpdateTTL,
	      noDeleteOnFetchRejection,
	      allowStaleOnFetchRejection,
	      allowStaleOnFetchAbort,
	      ignoreFetchAbort,
	      status,
	      signal,
	    };
	    let index = this.keyMap.get(k);
	    if (index === undefined) {
	      if (status) status.fetch = 'miss';
	      const p = this.backgroundFetch(k, index, options, fetchContext);
	      return (p.__returned = p)
	    } else {
	      const v = this.valList[index];
	      if (this.isBackgroundFetch(v)) {
	        const stale =
	          allowStale && v.__staleWhileFetching !== undefined;
	        if (status) {
	          status.fetch = 'inflight';
	          if (stale) status.returnedStale = true;
	        }
	        return stale ? v.__staleWhileFetching : (v.__returned = v)
	      }
	      const isStale = this.isStale(index);
	      if (!forceRefresh && !isStale) {
	        if (status) status.fetch = 'hit';
	        this.moveToTail(index);
	        if (updateAgeOnGet) {
	          this.updateItemAge(index);
	        }
	        this.statusTTL(status, index);
	        return v
	      }
	      const p = this.backgroundFetch(k, index, options, fetchContext);
	      const hasStale = p.__staleWhileFetching !== undefined;
	      const staleVal = hasStale && allowStale;
	      if (status) {
	        status.fetch = hasStale && isStale ? 'stale' : 'refresh';
	        if (staleVal && isStale) status.returnedStale = true;
	      }
	      return staleVal ? p.__staleWhileFetching : (p.__returned = p)
	    }
	  }
	  get(
	    k,
	    {
	      allowStale = this.allowStale,
	      updateAgeOnGet = this.updateAgeOnGet,
	      noDeleteOnStaleGet = this.noDeleteOnStaleGet,
	      status,
	    } = {}
	  ) {
	    const index = this.keyMap.get(k);
	    if (index !== undefined) {
	      const value = this.valList[index];
	      const fetching = this.isBackgroundFetch(value);
	      this.statusTTL(status, index);
	      if (this.isStale(index)) {
	        if (status) status.get = 'stale';
	        if (!fetching) {
	          if (!noDeleteOnStaleGet) {
	            this.delete(k);
	          }
	          if (status) status.returnedStale = allowStale;
	          return allowStale ? value : undefined
	        } else {
	          if (status) {
	            status.returnedStale =
	              allowStale && value.__staleWhileFetching !== undefined;
	          }
	          return allowStale ? value.__staleWhileFetching : undefined
	        }
	      } else {
	        if (status) status.get = 'hit';
	        if (fetching) {
	          return value.__staleWhileFetching
	        }
	        this.moveToTail(index);
	        if (updateAgeOnGet) {
	          this.updateItemAge(index);
	        }
	        return value
	      }
	    } else if (status) {
	      status.get = 'miss';
	    }
	  }
	  connect(p, n) {
	    this.prev[n] = p;
	    this.next[p] = n;
	  }
	  moveToTail(index) {
	    if (index !== this.tail) {
	      if (index === this.head) {
	        this.head = this.next[index];
	      } else {
	        this.connect(this.prev[index], this.next[index]);
	      }
	      this.connect(this.tail, index);
	      this.tail = index;
	    }
	  }
	  get del() {
	    deprecatedMethod('del', 'delete');
	    return this.delete
	  }
	  delete(k) {
	    let deleted = false;
	    if (this.size !== 0) {
	      const index = this.keyMap.get(k);
	      if (index !== undefined) {
	        deleted = true;
	        if (this.size === 1) {
	          this.clear();
	        } else {
	          this.removeItemSize(index);
	          const v = this.valList[index];
	          if (this.isBackgroundFetch(v)) {
	            v.__abortController.abort(new Error('deleted'));
	          } else {
	            this.dispose(v, k, 'delete');
	            if (this.disposeAfter) {
	              this.disposed.push([v, k, 'delete']);
	            }
	          }
	          this.keyMap.delete(k);
	          this.keyList[index] = null;
	          this.valList[index] = null;
	          if (index === this.tail) {
	            this.tail = this.prev[index];
	          } else if (index === this.head) {
	            this.head = this.next[index];
	          } else {
	            this.next[this.prev[index]] = this.next[index];
	            this.prev[this.next[index]] = this.prev[index];
	          }
	          this.size--;
	          this.free.push(index);
	        }
	      }
	    }
	    if (this.disposed) {
	      while (this.disposed.length) {
	        this.disposeAfter(...this.disposed.shift());
	      }
	    }
	    return deleted
	  }
	  clear() {
	    for (const index of this.rindexes({ allowStale: true })) {
	      const v = this.valList[index];
	      if (this.isBackgroundFetch(v)) {
	        v.__abortController.abort(new Error('deleted'));
	      } else {
	        const k = this.keyList[index];
	        this.dispose(v, k, 'delete');
	        if (this.disposeAfter) {
	          this.disposed.push([v, k, 'delete']);
	        }
	      }
	    }
	    this.keyMap.clear();
	    this.valList.fill(null);
	    this.keyList.fill(null);
	    if (this.ttls) {
	      this.ttls.fill(0);
	      this.starts.fill(0);
	    }
	    if (this.sizes) {
	      this.sizes.fill(0);
	    }
	    this.head = 0;
	    this.tail = 0;
	    this.initialFill = 1;
	    this.free.length = 0;
	    this.calculatedSize = 0;
	    this.size = 0;
	    if (this.disposed) {
	      while (this.disposed.length) {
	        this.disposeAfter(...this.disposed.shift());
	      }
	    }
	  }
	  get reset() {
	    deprecatedMethod('reset', 'clear');
	    return this.clear
	  }
	  get length() {
	    deprecatedProperty('length', 'size');
	    return this.size
	  }
	  static get AbortController() {
	    return AC
	  }
	  static get AbortSignal() {
	    return AS
	  }
	}
	lruCache = LRUCache;
	return lruCache;
}

var dist$a = {};

var helpers$2 = {};

var hasRequiredHelpers$2;

function requireHelpers$2 () {
	if (hasRequiredHelpers$2) return helpers$2;
	hasRequiredHelpers$2 = 1;
	var __createBinding = (helpers$2 && helpers$2.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (helpers$2 && helpers$2.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (helpers$2 && helpers$2.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(helpers$2, "__esModule", { value: true });
	helpers$2.req = helpers$2.json = helpers$2.toBuffer = void 0;
	const http = __importStar(require$$0$3);
	const https = __importStar(require$$1$1);
	async function toBuffer(stream) {
	    let length = 0;
	    const chunks = [];
	    for await (const chunk of stream) {
	        length += chunk.length;
	        chunks.push(chunk);
	    }
	    return Buffer.concat(chunks, length);
	}
	helpers$2.toBuffer = toBuffer;
	async function json(stream) {
	    const buf = await toBuffer(stream);
	    const str = buf.toString('utf8');
	    try {
	        return JSON.parse(str);
	    }
	    catch (_err) {
	        const err = _err;
	        err.message += ` (input: ${str})`;
	        throw err;
	    }
	}
	helpers$2.json = json;
	function req(url, opts = {}) {
	    const href = typeof url === 'string' ? url : url.href;
	    const req = (href.startsWith('https:') ? https : http).request(url, opts);
	    const promise = new Promise((resolve, reject) => {
	        req
	            .once('response', resolve)
	            .once('error', reject)
	            .end();
	    });
	    req.then = promise.then.bind(promise);
	    return req;
	}
	helpers$2.req = req;
	return helpers$2;
}

var hasRequiredDist$b;

function requireDist$b () {
	if (hasRequiredDist$b) return dist$a;
	hasRequiredDist$b = 1;
	(function (exports) {
		var __createBinding = (dist$a && dist$a.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __setModuleDefault = (dist$a && dist$a.__setModuleDefault) || (Object.create ? (function(o, v) {
		    Object.defineProperty(o, "default", { enumerable: true, value: v });
		}) : function(o, v) {
		    o["default"] = v;
		});
		var __importStar = (dist$a && dist$a.__importStar) || function (mod) {
		    if (mod && mod.__esModule) return mod;
		    var result = {};
		    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
		    __setModuleDefault(result, mod);
		    return result;
		};
		var __exportStar = (dist$a && dist$a.__exportStar) || function(m, exports) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.Agent = void 0;
		const net = __importStar(require$$0$4);
		const http = __importStar(require$$0$3);
		const https_1 = require$$1$1;
		__exportStar(requireHelpers$2(), exports);
		const INTERNAL = Symbol('AgentBaseInternalState');
		class Agent extends http.Agent {
		    constructor(opts) {
		        super(opts);
		        this[INTERNAL] = {};
		    }
		    isSecureEndpoint(options) {
		        if (options) {
		            if (typeof options.secureEndpoint === 'boolean') {
		                return options.secureEndpoint;
		            }
		            if (typeof options.protocol === 'string') {
		                return options.protocol === 'https:';
		            }
		        }
		        const { stack } = new Error();
		        if (typeof stack !== 'string')
		            return false;
		        return stack
		            .split('\n')
		            .some((l) => l.indexOf('(https.js:') !== -1 ||
		            l.indexOf('node:https:') !== -1);
		    }
		    incrementSockets(name) {
		        if (this.maxSockets === Infinity && this.maxTotalSockets === Infinity) {
		            return null;
		        }
		        if (!this.sockets[name]) {
		            this.sockets[name] = [];
		        }
		        const fakeSocket = new net.Socket({ writable: false });
		        this.sockets[name].push(fakeSocket);
		        this.totalSocketCount++;
		        return fakeSocket;
		    }
		    decrementSockets(name, socket) {
		        if (!this.sockets[name] || socket === null) {
		            return;
		        }
		        const sockets = this.sockets[name];
		        const index = sockets.indexOf(socket);
		        if (index !== -1) {
		            sockets.splice(index, 1);
		            this.totalSocketCount--;
		            if (sockets.length === 0) {
		                delete this.sockets[name];
		            }
		        }
		    }
		    getName(options) {
		        const secureEndpoint = this.isSecureEndpoint(options);
		        if (secureEndpoint) {
		            return https_1.Agent.prototype.getName.call(this, options);
		        }
		        return super.getName(options);
		    }
		    createSocket(req, options, cb) {
		        const connectOpts = {
		            ...options,
		            secureEndpoint: this.isSecureEndpoint(options),
		        };
		        const name = this.getName(connectOpts);
		        const fakeSocket = this.incrementSockets(name);
		        Promise.resolve()
		            .then(() => this.connect(req, connectOpts))
		            .then((socket) => {
		            this.decrementSockets(name, fakeSocket);
		            if (socket instanceof http.Agent) {
		                try {
		                    return socket.addRequest(req, connectOpts);
		                }
		                catch (err) {
		                    return cb(err);
		                }
		            }
		            this[INTERNAL].currentSocket = socket;
		            super.createSocket(req, options, cb);
		        }, (err) => {
		            this.decrementSockets(name, fakeSocket);
		            cb(err);
		        });
		    }
		    createConnection() {
		        const socket = this[INTERNAL].currentSocket;
		        this[INTERNAL].currentSocket = undefined;
		        if (!socket) {
		            throw new Error('No socket was returned in the `connect()` function');
		        }
		        return socket;
		    }
		    get defaultPort() {
		        return (this[INTERNAL].defaultPort ??
		            (this.protocol === 'https:' ? 443 : 80));
		    }
		    set defaultPort(v) {
		        if (this[INTERNAL]) {
		            this[INTERNAL].defaultPort = v;
		        }
		    }
		    get protocol() {
		        return (this[INTERNAL].protocol ??
		            (this.isSecureEndpoint() ? 'https:' : 'http:'));
		    }
		    set protocol(v) {
		        if (this[INTERNAL]) {
		            this[INTERNAL].protocol = v;
		        }
		    }
		}
		exports.Agent = Agent; 
	} (dist$a));
	return dist$a;
}

var proxyFromEnv = {};

var hasRequiredProxyFromEnv;

function requireProxyFromEnv () {
	if (hasRequiredProxyFromEnv) return proxyFromEnv;
	hasRequiredProxyFromEnv = 1;
	var parseUrl = require$$5.parse;
	var DEFAULT_PORTS = {
	  ftp: 21,
	  gopher: 70,
	  http: 80,
	  https: 443,
	  ws: 80,
	  wss: 443,
	};
	var stringEndsWith = String.prototype.endsWith || function(s) {
	  return s.length <= this.length &&
	    this.indexOf(s, this.length - s.length) !== -1;
	};
	function getProxyForUrl(url) {
	  var parsedUrl = typeof url === 'string' ? parseUrl(url) : url || {};
	  var proto = parsedUrl.protocol;
	  var hostname = parsedUrl.host;
	  var port = parsedUrl.port;
	  if (typeof hostname !== 'string' || !hostname || typeof proto !== 'string') {
	    return '';
	  }
	  proto = proto.split(':', 1)[0];
	  hostname = hostname.replace(/:\d*$/, '');
	  port = parseInt(port) || DEFAULT_PORTS[proto] || 0;
	  if (!shouldProxy(hostname, port)) {
	    return '';
	  }
	  var proxy =
	    getEnv('npm_config_' + proto + '_proxy') ||
	    getEnv(proto + '_proxy') ||
	    getEnv('npm_config_proxy') ||
	    getEnv('all_proxy');
	  if (proxy && proxy.indexOf('://') === -1) {
	    proxy = proto + '://' + proxy;
	  }
	  return proxy;
	}
	function shouldProxy(hostname, port) {
	  var NO_PROXY =
	    (getEnv('npm_config_no_proxy') || getEnv('no_proxy')).toLowerCase();
	  if (!NO_PROXY) {
	    return true;
	  }
	  if (NO_PROXY === '*') {
	    return false;
	  }
	  return NO_PROXY.split(/[,\s]/).every(function(proxy) {
	    if (!proxy) {
	      return true;
	    }
	    var parsedProxy = proxy.match(/^(.+):(\d+)$/);
	    var parsedProxyHostname = parsedProxy ? parsedProxy[1] : proxy;
	    var parsedProxyPort = parsedProxy ? parseInt(parsedProxy[2]) : 0;
	    if (parsedProxyPort && parsedProxyPort !== port) {
	      return true;
	    }
	    if (!/^[.*]/.test(parsedProxyHostname)) {
	      return hostname !== parsedProxyHostname;
	    }
	    if (parsedProxyHostname.charAt(0) === '*') {
	      parsedProxyHostname = parsedProxyHostname.slice(1);
	    }
	    return !stringEndsWith.call(hostname, parsedProxyHostname);
	  });
	}
	function getEnv(key) {
	  return process.env[key.toLowerCase()] || process.env[key.toUpperCase()] || '';
	}
	proxyFromEnv.getProxyForUrl = getProxyForUrl;
	return proxyFromEnv;
}

var dist$9 = {};

var hasRequiredDist$a;

function requireDist$a () {
	if (hasRequiredDist$a) return dist$9;
	hasRequiredDist$a = 1;
	var __createBinding = (dist$9 && dist$9.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (dist$9 && dist$9.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (dist$9 && dist$9.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	var __importDefault = (dist$9 && dist$9.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(dist$9, "__esModule", { value: true });
	dist$9.HttpProxyAgent = void 0;
	const net = __importStar(require$$0$4);
	const tls = __importStar(require$$1$2);
	const debug_1 = __importDefault(requireSrc());
	const events_1 = require$$0$5;
	const agent_base_1 = requireDist$b();
	const url_1 = require$$5;
	const debug = (0, debug_1.default)('http-proxy-agent');
	class HttpProxyAgent extends agent_base_1.Agent {
	    constructor(proxy, opts) {
	        super(opts);
	        this.proxy = typeof proxy === 'string' ? new url_1.URL(proxy) : proxy;
	        this.proxyHeaders = opts?.headers ?? {};
	        debug('Creating new HttpProxyAgent instance: %o', this.proxy.href);
	        const host = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, '');
	        const port = this.proxy.port
	            ? parseInt(this.proxy.port, 10)
	            : this.proxy.protocol === 'https:'
	                ? 443
	                : 80;
	        this.connectOpts = {
	            ...(opts ? omit(opts, 'headers') : null),
	            host,
	            port,
	        };
	    }
	    addRequest(req, opts) {
	        req._header = null;
	        this.setRequestProps(req, opts);
	        super.addRequest(req, opts);
	    }
	    setRequestProps(req, opts) {
	        const { proxy } = this;
	        const protocol = opts.secureEndpoint ? 'https:' : 'http:';
	        const hostname = req.getHeader('host') || 'localhost';
	        const base = `${protocol}//${hostname}`;
	        const url = new url_1.URL(req.path, base);
	        if (opts.port !== 80) {
	            url.port = String(opts.port);
	        }
	        req.path = String(url);
	        const headers = typeof this.proxyHeaders === 'function'
	            ? this.proxyHeaders()
	            : { ...this.proxyHeaders };
	        if (proxy.username || proxy.password) {
	            const auth = `${decodeURIComponent(proxy.username)}:${decodeURIComponent(proxy.password)}`;
	            headers['Proxy-Authorization'] = `Basic ${Buffer.from(auth).toString('base64')}`;
	        }
	        if (!headers['Proxy-Connection']) {
	            headers['Proxy-Connection'] = this.keepAlive
	                ? 'Keep-Alive'
	                : 'close';
	        }
	        for (const name of Object.keys(headers)) {
	            const value = headers[name];
	            if (value) {
	                req.setHeader(name, value);
	            }
	        }
	    }
	    async connect(req, opts) {
	        req._header = null;
	        if (!req.path.includes('://')) {
	            this.setRequestProps(req, opts);
	        }
	        let first;
	        let endOfHeaders;
	        debug('Regenerating stored HTTP header string for request');
	        req._implicitHeader();
	        if (req.outputData && req.outputData.length > 0) {
	            debug('Patching connection write() output buffer with updated header');
	            first = req.outputData[0].data;
	            endOfHeaders = first.indexOf('\r\n\r\n') + 4;
	            req.outputData[0].data =
	                req._header + first.substring(endOfHeaders);
	            debug('Output buffer: %o', req.outputData[0].data);
	        }
	        let socket;
	        if (this.proxy.protocol === 'https:') {
	            debug('Creating `tls.Socket`: %o', this.connectOpts);
	            socket = tls.connect(this.connectOpts);
	        }
	        else {
	            debug('Creating `net.Socket`: %o', this.connectOpts);
	            socket = net.connect(this.connectOpts);
	        }
	        await (0, events_1.once)(socket, 'connect');
	        return socket;
	    }
	}
	HttpProxyAgent.protocols = ['http', 'https'];
	dist$9.HttpProxyAgent = HttpProxyAgent;
	function omit(obj, ...keys) {
	    const ret = {};
	    let key;
	    for (key in obj) {
	        if (!keys.includes(key)) {
	            ret[key] = obj[key];
	        }
	    }
	    return ret;
	}
	return dist$9;
}

var dist$8 = {};

var parseProxyResponse = {};

var hasRequiredParseProxyResponse;

function requireParseProxyResponse () {
	if (hasRequiredParseProxyResponse) return parseProxyResponse;
	hasRequiredParseProxyResponse = 1;
	var __importDefault = (parseProxyResponse && parseProxyResponse.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(parseProxyResponse, "__esModule", { value: true });
	parseProxyResponse.parseProxyResponse = void 0;
	const debug_1 = __importDefault(requireSrc());
	const debug = (0, debug_1.default)('https-proxy-agent:parse-proxy-response');
	function parseProxyResponse$1(socket) {
	    return new Promise((resolve, reject) => {
	        let buffersLength = 0;
	        const buffers = [];
	        function read() {
	            const b = socket.read();
	            if (b)
	                ondata(b);
	            else
	                socket.once('readable', read);
	        }
	        function cleanup() {
	            socket.removeListener('end', onend);
	            socket.removeListener('error', onerror);
	            socket.removeListener('readable', read);
	        }
	        function onend() {
	            cleanup();
	            debug('onend');
	            reject(new Error('Proxy connection ended before receiving CONNECT response'));
	        }
	        function onerror(err) {
	            cleanup();
	            debug('onerror %o', err);
	            reject(err);
	        }
	        function ondata(b) {
	            buffers.push(b);
	            buffersLength += b.length;
	            const buffered = Buffer.concat(buffers, buffersLength);
	            const endOfHeaders = buffered.indexOf('\r\n\r\n');
	            if (endOfHeaders === -1) {
	                debug('have not received end of HTTP headers yet...');
	                read();
	                return;
	            }
	            const headerParts = buffered
	                .slice(0, endOfHeaders)
	                .toString('ascii')
	                .split('\r\n');
	            const firstLine = headerParts.shift();
	            if (!firstLine) {
	                socket.destroy();
	                return reject(new Error('No header received from proxy CONNECT response'));
	            }
	            const firstLineParts = firstLine.split(' ');
	            const statusCode = +firstLineParts[1];
	            const statusText = firstLineParts.slice(2).join(' ');
	            const headers = {};
	            for (const header of headerParts) {
	                if (!header)
	                    continue;
	                const firstColon = header.indexOf(':');
	                if (firstColon === -1) {
	                    socket.destroy();
	                    return reject(new Error(`Invalid header from proxy CONNECT response: "${header}"`));
	                }
	                const key = header.slice(0, firstColon).toLowerCase();
	                const value = header.slice(firstColon + 1).trimStart();
	                const current = headers[key];
	                if (typeof current === 'string') {
	                    headers[key] = [current, value];
	                }
	                else if (Array.isArray(current)) {
	                    current.push(value);
	                }
	                else {
	                    headers[key] = value;
	                }
	            }
	            debug('got proxy server response: %o %o', firstLine, headers);
	            cleanup();
	            resolve({
	                connect: {
	                    statusCode,
	                    statusText,
	                    headers,
	                },
	                buffered,
	            });
	        }
	        socket.on('error', onerror);
	        socket.on('end', onend);
	        read();
	    });
	}
	parseProxyResponse.parseProxyResponse = parseProxyResponse$1;
	return parseProxyResponse;
}

var hasRequiredDist$9;

function requireDist$9 () {
	if (hasRequiredDist$9) return dist$8;
	hasRequiredDist$9 = 1;
	var __createBinding = (dist$8 && dist$8.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (dist$8 && dist$8.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (dist$8 && dist$8.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	var __importDefault = (dist$8 && dist$8.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(dist$8, "__esModule", { value: true });
	dist$8.HttpsProxyAgent = void 0;
	const net = __importStar(require$$0$4);
	const tls = __importStar(require$$1$2);
	const assert_1 = __importDefault(require$$2);
	const debug_1 = __importDefault(requireSrc());
	const agent_base_1 = requireDist$b();
	const url_1 = require$$5;
	const parse_proxy_response_1 = requireParseProxyResponse();
	const debug = (0, debug_1.default)('https-proxy-agent');
	const setServernameFromNonIpHost = (options) => {
	    if (options.servername === undefined &&
	        options.host &&
	        !net.isIP(options.host)) {
	        return {
	            ...options,
	            servername: options.host,
	        };
	    }
	    return options;
	};
	class HttpsProxyAgent extends agent_base_1.Agent {
	    constructor(proxy, opts) {
	        super(opts);
	        this.options = { path: undefined };
	        this.proxy = typeof proxy === 'string' ? new url_1.URL(proxy) : proxy;
	        this.proxyHeaders = opts?.headers ?? {};
	        debug('Creating new HttpsProxyAgent instance: %o', this.proxy.href);
	        const host = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, '');
	        const port = this.proxy.port
	            ? parseInt(this.proxy.port, 10)
	            : this.proxy.protocol === 'https:'
	                ? 443
	                : 80;
	        this.connectOpts = {
	            ALPNProtocols: ['http/1.1'],
	            ...(opts ? omit(opts, 'headers') : null),
	            host,
	            port,
	        };
	    }
	    async connect(req, opts) {
	        const { proxy } = this;
	        if (!opts.host) {
	            throw new TypeError('No "host" provided');
	        }
	        let socket;
	        if (proxy.protocol === 'https:') {
	            debug('Creating `tls.Socket`: %o', this.connectOpts);
	            socket = tls.connect(setServernameFromNonIpHost(this.connectOpts));
	        }
	        else {
	            debug('Creating `net.Socket`: %o', this.connectOpts);
	            socket = net.connect(this.connectOpts);
	        }
	        const headers = typeof this.proxyHeaders === 'function'
	            ? this.proxyHeaders()
	            : { ...this.proxyHeaders };
	        const host = net.isIPv6(opts.host) ? `[${opts.host}]` : opts.host;
	        let payload = `CONNECT ${host}:${opts.port} HTTP/1.1\r\n`;
	        if (proxy.username || proxy.password) {
	            const auth = `${decodeURIComponent(proxy.username)}:${decodeURIComponent(proxy.password)}`;
	            headers['Proxy-Authorization'] = `Basic ${Buffer.from(auth).toString('base64')}`;
	        }
	        headers.Host = `${host}:${opts.port}`;
	        if (!headers['Proxy-Connection']) {
	            headers['Proxy-Connection'] = this.keepAlive
	                ? 'Keep-Alive'
	                : 'close';
	        }
	        for (const name of Object.keys(headers)) {
	            payload += `${name}: ${headers[name]}\r\n`;
	        }
	        const proxyResponsePromise = (0, parse_proxy_response_1.parseProxyResponse)(socket);
	        socket.write(`${payload}\r\n`);
	        const { connect, buffered } = await proxyResponsePromise;
	        req.emit('proxyConnect', connect);
	        this.emit('proxyConnect', connect, req);
	        if (connect.statusCode === 200) {
	            req.once('socket', resume);
	            if (opts.secureEndpoint) {
	                debug('Upgrading socket connection to TLS');
	                return tls.connect({
	                    ...omit(setServernameFromNonIpHost(opts), 'host', 'path', 'port'),
	                    socket,
	                });
	            }
	            return socket;
	        }
	        socket.destroy();
	        const fakeSocket = new net.Socket({ writable: false });
	        fakeSocket.readable = true;
	        req.once('socket', (s) => {
	            debug('Replaying proxy buffer for failed request');
	            (0, assert_1.default)(s.listenerCount('data') > 0);
	            s.push(buffered);
	            s.push(null);
	        });
	        return fakeSocket;
	    }
	}
	HttpsProxyAgent.protocols = ['http', 'https'];
	dist$8.HttpsProxyAgent = HttpsProxyAgent;
	function resume(socket) {
	    socket.resume();
	}
	function omit(obj, ...keys) {
	    const ret = {};
	    let key;
	    for (key in obj) {
	        if (!keys.includes(key)) {
	            ret[key] = obj[key];
	        }
	    }
	    return ret;
	}
	return dist$8;
}

var dist$7 = {};

var build = {};

var socksclient = {};

var smartbuffer = {};

var utils$1 = {};

var hasRequiredUtils$1;

function requireUtils$1 () {
	if (hasRequiredUtils$1) return utils$1;
	hasRequiredUtils$1 = 1;
	Object.defineProperty(utils$1, "__esModule", { value: true });
	const buffer_1 = require$$0$6;
	const ERRORS = {
	    INVALID_ENCODING: 'Invalid encoding provided. Please specify a valid encoding the internal Node.js Buffer supports.',
	    INVALID_SMARTBUFFER_SIZE: 'Invalid size provided. Size must be a valid integer greater than zero.',
	    INVALID_SMARTBUFFER_BUFFER: 'Invalid Buffer provided in SmartBufferOptions.',
	    INVALID_SMARTBUFFER_OBJECT: 'Invalid SmartBufferOptions object supplied to SmartBuffer constructor or factory methods.',
	    INVALID_OFFSET: 'An invalid offset value was provided.',
	    INVALID_OFFSET_NON_NUMBER: 'An invalid offset value was provided. A numeric value is required.',
	    INVALID_LENGTH: 'An invalid length value was provided.',
	    INVALID_LENGTH_NON_NUMBER: 'An invalid length value was provived. A numeric value is required.',
	    INVALID_TARGET_OFFSET: 'Target offset is beyond the bounds of the internal SmartBuffer data.',
	    INVALID_TARGET_LENGTH: 'Specified length value moves cursor beyong the bounds of the internal SmartBuffer data.',
	    INVALID_READ_BEYOND_BOUNDS: 'Attempted to read beyond the bounds of the managed data.',
	    INVALID_WRITE_BEYOND_BOUNDS: 'Attempted to write beyond the bounds of the managed data.'
	};
	utils$1.ERRORS = ERRORS;
	function checkEncoding(encoding) {
	    if (!buffer_1.Buffer.isEncoding(encoding)) {
	        throw new Error(ERRORS.INVALID_ENCODING);
	    }
	}
	utils$1.checkEncoding = checkEncoding;
	function isFiniteInteger(value) {
	    return typeof value === 'number' && isFinite(value) && isInteger(value);
	}
	utils$1.isFiniteInteger = isFiniteInteger;
	function checkOffsetOrLengthValue(value, offset) {
	    if (typeof value === 'number') {
	        if (!isFiniteInteger(value) || value < 0) {
	            throw new Error(offset ? ERRORS.INVALID_OFFSET : ERRORS.INVALID_LENGTH);
	        }
	    }
	    else {
	        throw new Error(offset ? ERRORS.INVALID_OFFSET_NON_NUMBER : ERRORS.INVALID_LENGTH_NON_NUMBER);
	    }
	}
	function checkLengthValue(length) {
	    checkOffsetOrLengthValue(length, false);
	}
	utils$1.checkLengthValue = checkLengthValue;
	function checkOffsetValue(offset) {
	    checkOffsetOrLengthValue(offset, true);
	}
	utils$1.checkOffsetValue = checkOffsetValue;
	function checkTargetOffset(offset, buff) {
	    if (offset < 0 || offset > buff.length) {
	        throw new Error(ERRORS.INVALID_TARGET_OFFSET);
	    }
	}
	utils$1.checkTargetOffset = checkTargetOffset;
	function isInteger(value) {
	    return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;
	}
	function bigIntAndBufferInt64Check(bufferMethod) {
	    if (typeof BigInt === 'undefined') {
	        throw new Error('Platform does not support JS BigInt type.');
	    }
	    if (typeof buffer_1.Buffer.prototype[bufferMethod] === 'undefined') {
	        throw new Error(`Platform does not support Buffer.prototype.${bufferMethod}.`);
	    }
	}
	utils$1.bigIntAndBufferInt64Check = bigIntAndBufferInt64Check;
	return utils$1;
}

var hasRequiredSmartbuffer;

function requireSmartbuffer () {
	if (hasRequiredSmartbuffer) return smartbuffer;
	hasRequiredSmartbuffer = 1;
	Object.defineProperty(smartbuffer, "__esModule", { value: true });
	const utils_1 = requireUtils$1();
	const DEFAULT_SMARTBUFFER_SIZE = 4096;
	const DEFAULT_SMARTBUFFER_ENCODING = 'utf8';
	class SmartBuffer {
	    constructor(options) {
	        this.length = 0;
	        this._encoding = DEFAULT_SMARTBUFFER_ENCODING;
	        this._writeOffset = 0;
	        this._readOffset = 0;
	        if (SmartBuffer.isSmartBufferOptions(options)) {
	            if (options.encoding) {
	                utils_1.checkEncoding(options.encoding);
	                this._encoding = options.encoding;
	            }
	            if (options.size) {
	                if (utils_1.isFiniteInteger(options.size) && options.size > 0) {
	                    this._buff = Buffer.allocUnsafe(options.size);
	                }
	                else {
	                    throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_SIZE);
	                }
	            }
	            else if (options.buff) {
	                if (Buffer.isBuffer(options.buff)) {
	                    this._buff = options.buff;
	                    this.length = options.buff.length;
	                }
	                else {
	                    throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_BUFFER);
	                }
	            }
	            else {
	                this._buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);
	            }
	        }
	        else {
	            if (typeof options !== 'undefined') {
	                throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_OBJECT);
	            }
	            this._buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);
	        }
	    }
	    static fromSize(size, encoding) {
	        return new this({
	            size: size,
	            encoding: encoding
	        });
	    }
	    static fromBuffer(buff, encoding) {
	        return new this({
	            buff: buff,
	            encoding: encoding
	        });
	    }
	    static fromOptions(options) {
	        return new this(options);
	    }
	    static isSmartBufferOptions(options) {
	        const castOptions = options;
	        return (castOptions &&
	            (castOptions.encoding !== undefined || castOptions.size !== undefined || castOptions.buff !== undefined));
	    }
	    readInt8(offset) {
	        return this._readNumberValue(Buffer.prototype.readInt8, 1, offset);
	    }
	    readInt16BE(offset) {
	        return this._readNumberValue(Buffer.prototype.readInt16BE, 2, offset);
	    }
	    readInt16LE(offset) {
	        return this._readNumberValue(Buffer.prototype.readInt16LE, 2, offset);
	    }
	    readInt32BE(offset) {
	        return this._readNumberValue(Buffer.prototype.readInt32BE, 4, offset);
	    }
	    readInt32LE(offset) {
	        return this._readNumberValue(Buffer.prototype.readInt32LE, 4, offset);
	    }
	    readBigInt64BE(offset) {
	        utils_1.bigIntAndBufferInt64Check('readBigInt64BE');
	        return this._readNumberValue(Buffer.prototype.readBigInt64BE, 8, offset);
	    }
	    readBigInt64LE(offset) {
	        utils_1.bigIntAndBufferInt64Check('readBigInt64LE');
	        return this._readNumberValue(Buffer.prototype.readBigInt64LE, 8, offset);
	    }
	    writeInt8(value, offset) {
	        this._writeNumberValue(Buffer.prototype.writeInt8, 1, value, offset);
	        return this;
	    }
	    insertInt8(value, offset) {
	        return this._insertNumberValue(Buffer.prototype.writeInt8, 1, value, offset);
	    }
	    writeInt16BE(value, offset) {
	        return this._writeNumberValue(Buffer.prototype.writeInt16BE, 2, value, offset);
	    }
	    insertInt16BE(value, offset) {
	        return this._insertNumberValue(Buffer.prototype.writeInt16BE, 2, value, offset);
	    }
	    writeInt16LE(value, offset) {
	        return this._writeNumberValue(Buffer.prototype.writeInt16LE, 2, value, offset);
	    }
	    insertInt16LE(value, offset) {
	        return this._insertNumberValue(Buffer.prototype.writeInt16LE, 2, value, offset);
	    }
	    writeInt32BE(value, offset) {
	        return this._writeNumberValue(Buffer.prototype.writeInt32BE, 4, value, offset);
	    }
	    insertInt32BE(value, offset) {
	        return this._insertNumberValue(Buffer.prototype.writeInt32BE, 4, value, offset);
	    }
	    writeInt32LE(value, offset) {
	        return this._writeNumberValue(Buffer.prototype.writeInt32LE, 4, value, offset);
	    }
	    insertInt32LE(value, offset) {
	        return this._insertNumberValue(Buffer.prototype.writeInt32LE, 4, value, offset);
	    }
	    writeBigInt64BE(value, offset) {
	        utils_1.bigIntAndBufferInt64Check('writeBigInt64BE');
	        return this._writeNumberValue(Buffer.prototype.writeBigInt64BE, 8, value, offset);
	    }
	    insertBigInt64BE(value, offset) {
	        utils_1.bigIntAndBufferInt64Check('writeBigInt64BE');
	        return this._insertNumberValue(Buffer.prototype.writeBigInt64BE, 8, value, offset);
	    }
	    writeBigInt64LE(value, offset) {
	        utils_1.bigIntAndBufferInt64Check('writeBigInt64LE');
	        return this._writeNumberValue(Buffer.prototype.writeBigInt64LE, 8, value, offset);
	    }
	    insertBigInt64LE(value, offset) {
	        utils_1.bigIntAndBufferInt64Check('writeBigInt64LE');
	        return this._insertNumberValue(Buffer.prototype.writeBigInt64LE, 8, value, offset);
	    }
	    readUInt8(offset) {
	        return this._readNumberValue(Buffer.prototype.readUInt8, 1, offset);
	    }
	    readUInt16BE(offset) {
	        return this._readNumberValue(Buffer.prototype.readUInt16BE, 2, offset);
	    }
	    readUInt16LE(offset) {
	        return this._readNumberValue(Buffer.prototype.readUInt16LE, 2, offset);
	    }
	    readUInt32BE(offset) {
	        return this._readNumberValue(Buffer.prototype.readUInt32BE, 4, offset);
	    }
	    readUInt32LE(offset) {
	        return this._readNumberValue(Buffer.prototype.readUInt32LE, 4, offset);
	    }
	    readBigUInt64BE(offset) {
	        utils_1.bigIntAndBufferInt64Check('readBigUInt64BE');
	        return this._readNumberValue(Buffer.prototype.readBigUInt64BE, 8, offset);
	    }
	    readBigUInt64LE(offset) {
	        utils_1.bigIntAndBufferInt64Check('readBigUInt64LE');
	        return this._readNumberValue(Buffer.prototype.readBigUInt64LE, 8, offset);
	    }
	    writeUInt8(value, offset) {
	        return this._writeNumberValue(Buffer.prototype.writeUInt8, 1, value, offset);
	    }
	    insertUInt8(value, offset) {
	        return this._insertNumberValue(Buffer.prototype.writeUInt8, 1, value, offset);
	    }
	    writeUInt16BE(value, offset) {
	        return this._writeNumberValue(Buffer.prototype.writeUInt16BE, 2, value, offset);
	    }
	    insertUInt16BE(value, offset) {
	        return this._insertNumberValue(Buffer.prototype.writeUInt16BE, 2, value, offset);
	    }
	    writeUInt16LE(value, offset) {
	        return this._writeNumberValue(Buffer.prototype.writeUInt16LE, 2, value, offset);
	    }
	    insertUInt16LE(value, offset) {
	        return this._insertNumberValue(Buffer.prototype.writeUInt16LE, 2, value, offset);
	    }
	    writeUInt32BE(value, offset) {
	        return this._writeNumberValue(Buffer.prototype.writeUInt32BE, 4, value, offset);
	    }
	    insertUInt32BE(value, offset) {
	        return this._insertNumberValue(Buffer.prototype.writeUInt32BE, 4, value, offset);
	    }
	    writeUInt32LE(value, offset) {
	        return this._writeNumberValue(Buffer.prototype.writeUInt32LE, 4, value, offset);
	    }
	    insertUInt32LE(value, offset) {
	        return this._insertNumberValue(Buffer.prototype.writeUInt32LE, 4, value, offset);
	    }
	    writeBigUInt64BE(value, offset) {
	        utils_1.bigIntAndBufferInt64Check('writeBigUInt64BE');
	        return this._writeNumberValue(Buffer.prototype.writeBigUInt64BE, 8, value, offset);
	    }
	    insertBigUInt64BE(value, offset) {
	        utils_1.bigIntAndBufferInt64Check('writeBigUInt64BE');
	        return this._insertNumberValue(Buffer.prototype.writeBigUInt64BE, 8, value, offset);
	    }
	    writeBigUInt64LE(value, offset) {
	        utils_1.bigIntAndBufferInt64Check('writeBigUInt64LE');
	        return this._writeNumberValue(Buffer.prototype.writeBigUInt64LE, 8, value, offset);
	    }
	    insertBigUInt64LE(value, offset) {
	        utils_1.bigIntAndBufferInt64Check('writeBigUInt64LE');
	        return this._insertNumberValue(Buffer.prototype.writeBigUInt64LE, 8, value, offset);
	    }
	    readFloatBE(offset) {
	        return this._readNumberValue(Buffer.prototype.readFloatBE, 4, offset);
	    }
	    readFloatLE(offset) {
	        return this._readNumberValue(Buffer.prototype.readFloatLE, 4, offset);
	    }
	    writeFloatBE(value, offset) {
	        return this._writeNumberValue(Buffer.prototype.writeFloatBE, 4, value, offset);
	    }
	    insertFloatBE(value, offset) {
	        return this._insertNumberValue(Buffer.prototype.writeFloatBE, 4, value, offset);
	    }
	    writeFloatLE(value, offset) {
	        return this._writeNumberValue(Buffer.prototype.writeFloatLE, 4, value, offset);
	    }
	    insertFloatLE(value, offset) {
	        return this._insertNumberValue(Buffer.prototype.writeFloatLE, 4, value, offset);
	    }
	    readDoubleBE(offset) {
	        return this._readNumberValue(Buffer.prototype.readDoubleBE, 8, offset);
	    }
	    readDoubleLE(offset) {
	        return this._readNumberValue(Buffer.prototype.readDoubleLE, 8, offset);
	    }
	    writeDoubleBE(value, offset) {
	        return this._writeNumberValue(Buffer.prototype.writeDoubleBE, 8, value, offset);
	    }
	    insertDoubleBE(value, offset) {
	        return this._insertNumberValue(Buffer.prototype.writeDoubleBE, 8, value, offset);
	    }
	    writeDoubleLE(value, offset) {
	        return this._writeNumberValue(Buffer.prototype.writeDoubleLE, 8, value, offset);
	    }
	    insertDoubleLE(value, offset) {
	        return this._insertNumberValue(Buffer.prototype.writeDoubleLE, 8, value, offset);
	    }
	    readString(arg1, encoding) {
	        let lengthVal;
	        if (typeof arg1 === 'number') {
	            utils_1.checkLengthValue(arg1);
	            lengthVal = Math.min(arg1, this.length - this._readOffset);
	        }
	        else {
	            encoding = arg1;
	            lengthVal = this.length - this._readOffset;
	        }
	        if (typeof encoding !== 'undefined') {
	            utils_1.checkEncoding(encoding);
	        }
	        const value = this._buff.slice(this._readOffset, this._readOffset + lengthVal).toString(encoding || this._encoding);
	        this._readOffset += lengthVal;
	        return value;
	    }
	    insertString(value, offset, encoding) {
	        utils_1.checkOffsetValue(offset);
	        return this._handleString(value, true, offset, encoding);
	    }
	    writeString(value, arg2, encoding) {
	        return this._handleString(value, false, arg2, encoding);
	    }
	    readStringNT(encoding) {
	        if (typeof encoding !== 'undefined') {
	            utils_1.checkEncoding(encoding);
	        }
	        let nullPos = this.length;
	        for (let i = this._readOffset; i < this.length; i++) {
	            if (this._buff[i] === 0x00) {
	                nullPos = i;
	                break;
	            }
	        }
	        const value = this._buff.slice(this._readOffset, nullPos);
	        this._readOffset = nullPos + 1;
	        return value.toString(encoding || this._encoding);
	    }
	    insertStringNT(value, offset, encoding) {
	        utils_1.checkOffsetValue(offset);
	        this.insertString(value, offset, encoding);
	        this.insertUInt8(0x00, offset + value.length);
	        return this;
	    }
	    writeStringNT(value, arg2, encoding) {
	        this.writeString(value, arg2, encoding);
	        this.writeUInt8(0x00, typeof arg2 === 'number' ? arg2 + value.length : this.writeOffset);
	        return this;
	    }
	    readBuffer(length) {
	        if (typeof length !== 'undefined') {
	            utils_1.checkLengthValue(length);
	        }
	        const lengthVal = typeof length === 'number' ? length : this.length;
	        const endPoint = Math.min(this.length, this._readOffset + lengthVal);
	        const value = this._buff.slice(this._readOffset, endPoint);
	        this._readOffset = endPoint;
	        return value;
	    }
	    insertBuffer(value, offset) {
	        utils_1.checkOffsetValue(offset);
	        return this._handleBuffer(value, true, offset);
	    }
	    writeBuffer(value, offset) {
	        return this._handleBuffer(value, false, offset);
	    }
	    readBufferNT() {
	        let nullPos = this.length;
	        for (let i = this._readOffset; i < this.length; i++) {
	            if (this._buff[i] === 0x00) {
	                nullPos = i;
	                break;
	            }
	        }
	        const value = this._buff.slice(this._readOffset, nullPos);
	        this._readOffset = nullPos + 1;
	        return value;
	    }
	    insertBufferNT(value, offset) {
	        utils_1.checkOffsetValue(offset);
	        this.insertBuffer(value, offset);
	        this.insertUInt8(0x00, offset + value.length);
	        return this;
	    }
	    writeBufferNT(value, offset) {
	        if (typeof offset !== 'undefined') {
	            utils_1.checkOffsetValue(offset);
	        }
	        this.writeBuffer(value, offset);
	        this.writeUInt8(0x00, typeof offset === 'number' ? offset + value.length : this._writeOffset);
	        return this;
	    }
	    clear() {
	        this._writeOffset = 0;
	        this._readOffset = 0;
	        this.length = 0;
	        return this;
	    }
	    remaining() {
	        return this.length - this._readOffset;
	    }
	    get readOffset() {
	        return this._readOffset;
	    }
	    set readOffset(offset) {
	        utils_1.checkOffsetValue(offset);
	        utils_1.checkTargetOffset(offset, this);
	        this._readOffset = offset;
	    }
	    get writeOffset() {
	        return this._writeOffset;
	    }
	    set writeOffset(offset) {
	        utils_1.checkOffsetValue(offset);
	        utils_1.checkTargetOffset(offset, this);
	        this._writeOffset = offset;
	    }
	    get encoding() {
	        return this._encoding;
	    }
	    set encoding(encoding) {
	        utils_1.checkEncoding(encoding);
	        this._encoding = encoding;
	    }
	    get internalBuffer() {
	        return this._buff;
	    }
	    toBuffer() {
	        return this._buff.slice(0, this.length);
	    }
	    toString(encoding) {
	        const encodingVal = typeof encoding === 'string' ? encoding : this._encoding;
	        utils_1.checkEncoding(encodingVal);
	        return this._buff.toString(encodingVal, 0, this.length);
	    }
	    destroy() {
	        this.clear();
	        return this;
	    }
	    _handleString(value, isInsert, arg3, encoding) {
	        let offsetVal = this._writeOffset;
	        let encodingVal = this._encoding;
	        if (typeof arg3 === 'number') {
	            offsetVal = arg3;
	        }
	        else if (typeof arg3 === 'string') {
	            utils_1.checkEncoding(arg3);
	            encodingVal = arg3;
	        }
	        if (typeof encoding === 'string') {
	            utils_1.checkEncoding(encoding);
	            encodingVal = encoding;
	        }
	        const byteLength = Buffer.byteLength(value, encodingVal);
	        if (isInsert) {
	            this.ensureInsertable(byteLength, offsetVal);
	        }
	        else {
	            this._ensureWriteable(byteLength, offsetVal);
	        }
	        this._buff.write(value, offsetVal, byteLength, encodingVal);
	        if (isInsert) {
	            this._writeOffset += byteLength;
	        }
	        else {
	            if (typeof arg3 === 'number') {
	                this._writeOffset = Math.max(this._writeOffset, offsetVal + byteLength);
	            }
	            else {
	                this._writeOffset += byteLength;
	            }
	        }
	        return this;
	    }
	    _handleBuffer(value, isInsert, offset) {
	        const offsetVal = typeof offset === 'number' ? offset : this._writeOffset;
	        if (isInsert) {
	            this.ensureInsertable(value.length, offsetVal);
	        }
	        else {
	            this._ensureWriteable(value.length, offsetVal);
	        }
	        value.copy(this._buff, offsetVal);
	        if (isInsert) {
	            this._writeOffset += value.length;
	        }
	        else {
	            if (typeof offset === 'number') {
	                this._writeOffset = Math.max(this._writeOffset, offsetVal + value.length);
	            }
	            else {
	                this._writeOffset += value.length;
	            }
	        }
	        return this;
	    }
	    ensureReadable(length, offset) {
	        let offsetVal = this._readOffset;
	        if (typeof offset !== 'undefined') {
	            utils_1.checkOffsetValue(offset);
	            offsetVal = offset;
	        }
	        if (offsetVal < 0 || offsetVal + length > this.length) {
	            throw new Error(utils_1.ERRORS.INVALID_READ_BEYOND_BOUNDS);
	        }
	    }
	    ensureInsertable(dataLength, offset) {
	        utils_1.checkOffsetValue(offset);
	        this._ensureCapacity(this.length + dataLength);
	        if (offset < this.length) {
	            this._buff.copy(this._buff, offset + dataLength, offset, this._buff.length);
	        }
	        if (offset + dataLength > this.length) {
	            this.length = offset + dataLength;
	        }
	        else {
	            this.length += dataLength;
	        }
	    }
	    _ensureWriteable(dataLength, offset) {
	        const offsetVal = typeof offset === 'number' ? offset : this._writeOffset;
	        this._ensureCapacity(offsetVal + dataLength);
	        if (offsetVal + dataLength > this.length) {
	            this.length = offsetVal + dataLength;
	        }
	    }
	    _ensureCapacity(minLength) {
	        const oldLength = this._buff.length;
	        if (minLength > oldLength) {
	            let data = this._buff;
	            let newLength = (oldLength * 3) / 2 + 1;
	            if (newLength < minLength) {
	                newLength = minLength;
	            }
	            this._buff = Buffer.allocUnsafe(newLength);
	            data.copy(this._buff, 0, 0, oldLength);
	        }
	    }
	    _readNumberValue(func, byteSize, offset) {
	        this.ensureReadable(byteSize, offset);
	        const value = func.call(this._buff, typeof offset === 'number' ? offset : this._readOffset);
	        if (typeof offset === 'undefined') {
	            this._readOffset += byteSize;
	        }
	        return value;
	    }
	    _insertNumberValue(func, byteSize, value, offset) {
	        utils_1.checkOffsetValue(offset);
	        this.ensureInsertable(byteSize, offset);
	        func.call(this._buff, value, offset);
	        this._writeOffset += byteSize;
	        return this;
	    }
	    _writeNumberValue(func, byteSize, value, offset) {
	        if (typeof offset === 'number') {
	            if (offset < 0) {
	                throw new Error(utils_1.ERRORS.INVALID_WRITE_BEYOND_BOUNDS);
	            }
	            utils_1.checkOffsetValue(offset);
	        }
	        const offsetVal = typeof offset === 'number' ? offset : this._writeOffset;
	        this._ensureWriteable(byteSize, offsetVal);
	        func.call(this._buff, value, offsetVal);
	        if (typeof offset === 'number') {
	            this._writeOffset = Math.max(this._writeOffset, offsetVal + byteSize);
	        }
	        else {
	            this._writeOffset += byteSize;
	        }
	        return this;
	    }
	}
	smartbuffer.SmartBuffer = SmartBuffer;
	return smartbuffer;
}

var constants$3 = {};

var hasRequiredConstants$3;

function requireConstants$3 () {
	if (hasRequiredConstants$3) return constants$3;
	hasRequiredConstants$3 = 1;
	Object.defineProperty(constants$3, "__esModule", { value: true });
	constants$3.SOCKS5_NO_ACCEPTABLE_AUTH = constants$3.SOCKS5_CUSTOM_AUTH_END = constants$3.SOCKS5_CUSTOM_AUTH_START = constants$3.SOCKS_INCOMING_PACKET_SIZES = constants$3.SocksClientState = constants$3.Socks5Response = constants$3.Socks5HostType = constants$3.Socks5Auth = constants$3.Socks4Response = constants$3.SocksCommand = constants$3.ERRORS = constants$3.DEFAULT_TIMEOUT = void 0;
	const DEFAULT_TIMEOUT = 30000;
	constants$3.DEFAULT_TIMEOUT = DEFAULT_TIMEOUT;
	const ERRORS = {
	    InvalidSocksCommand: 'An invalid SOCKS command was provided. Valid options are connect, bind, and associate.',
	    InvalidSocksCommandForOperation: 'An invalid SOCKS command was provided. Only a subset of commands are supported for this operation.',
	    InvalidSocksCommandChain: 'An invalid SOCKS command was provided. Chaining currently only supports the connect command.',
	    InvalidSocksClientOptionsDestination: 'An invalid destination host was provided.',
	    InvalidSocksClientOptionsExistingSocket: 'An invalid existing socket was provided. This should be an instance of stream.Duplex.',
	    InvalidSocksClientOptionsProxy: 'Invalid SOCKS proxy details were provided.',
	    InvalidSocksClientOptionsTimeout: 'An invalid timeout value was provided. Please enter a value above 0 (in ms).',
	    InvalidSocksClientOptionsProxiesLength: 'At least two socks proxies must be provided for chaining.',
	    InvalidSocksClientOptionsCustomAuthRange: 'Custom auth must be a value between 0x80 and 0xFE.',
	    InvalidSocksClientOptionsCustomAuthOptions: 'When a custom_auth_method is provided, custom_auth_request_handler, custom_auth_response_size, and custom_auth_response_handler must also be provided and valid.',
	    NegotiationError: 'Negotiation error',
	    SocketClosed: 'Socket closed',
	    ProxyConnectionTimedOut: 'Proxy connection timed out',
	    InternalError: 'SocksClient internal error (this should not happen)',
	    InvalidSocks4HandshakeResponse: 'Received invalid Socks4 handshake response',
	    Socks4ProxyRejectedConnection: 'Socks4 Proxy rejected connection',
	    InvalidSocks4IncomingConnectionResponse: 'Socks4 invalid incoming connection response',
	    Socks4ProxyRejectedIncomingBoundConnection: 'Socks4 Proxy rejected incoming bound connection',
	    InvalidSocks5InitialHandshakeResponse: 'Received invalid Socks5 initial handshake response',
	    InvalidSocks5IntiailHandshakeSocksVersion: 'Received invalid Socks5 initial handshake (invalid socks version)',
	    InvalidSocks5InitialHandshakeNoAcceptedAuthType: 'Received invalid Socks5 initial handshake (no accepted authentication type)',
	    InvalidSocks5InitialHandshakeUnknownAuthType: 'Received invalid Socks5 initial handshake (unknown authentication type)',
	    Socks5AuthenticationFailed: 'Socks5 Authentication failed',
	    InvalidSocks5FinalHandshake: 'Received invalid Socks5 final handshake response',
	    InvalidSocks5FinalHandshakeRejected: 'Socks5 proxy rejected connection',
	    InvalidSocks5IncomingConnectionResponse: 'Received invalid Socks5 incoming connection response',
	    Socks5ProxyRejectedIncomingBoundConnection: 'Socks5 Proxy rejected incoming bound connection',
	};
	constants$3.ERRORS = ERRORS;
	const SOCKS_INCOMING_PACKET_SIZES = {
	    Socks5InitialHandshakeResponse: 2,
	    Socks5UserPassAuthenticationResponse: 2,
	    Socks5ResponseHeader: 5,
	    Socks5ResponseIPv4: 10,
	    Socks5ResponseIPv6: 22,
	    Socks5ResponseHostname: (hostNameLength) => hostNameLength + 7,
	    Socks4Response: 8,
	};
	constants$3.SOCKS_INCOMING_PACKET_SIZES = SOCKS_INCOMING_PACKET_SIZES;
	var SocksCommand;
	(function (SocksCommand) {
	    SocksCommand[SocksCommand["connect"] = 1] = "connect";
	    SocksCommand[SocksCommand["bind"] = 2] = "bind";
	    SocksCommand[SocksCommand["associate"] = 3] = "associate";
	})(SocksCommand || (constants$3.SocksCommand = SocksCommand = {}));
	var Socks4Response;
	(function (Socks4Response) {
	    Socks4Response[Socks4Response["Granted"] = 90] = "Granted";
	    Socks4Response[Socks4Response["Failed"] = 91] = "Failed";
	    Socks4Response[Socks4Response["Rejected"] = 92] = "Rejected";
	    Socks4Response[Socks4Response["RejectedIdent"] = 93] = "RejectedIdent";
	})(Socks4Response || (constants$3.Socks4Response = Socks4Response = {}));
	var Socks5Auth;
	(function (Socks5Auth) {
	    Socks5Auth[Socks5Auth["NoAuth"] = 0] = "NoAuth";
	    Socks5Auth[Socks5Auth["GSSApi"] = 1] = "GSSApi";
	    Socks5Auth[Socks5Auth["UserPass"] = 2] = "UserPass";
	})(Socks5Auth || (constants$3.Socks5Auth = Socks5Auth = {}));
	const SOCKS5_CUSTOM_AUTH_START = 0x80;
	constants$3.SOCKS5_CUSTOM_AUTH_START = SOCKS5_CUSTOM_AUTH_START;
	const SOCKS5_CUSTOM_AUTH_END = 0xfe;
	constants$3.SOCKS5_CUSTOM_AUTH_END = SOCKS5_CUSTOM_AUTH_END;
	const SOCKS5_NO_ACCEPTABLE_AUTH = 0xff;
	constants$3.SOCKS5_NO_ACCEPTABLE_AUTH = SOCKS5_NO_ACCEPTABLE_AUTH;
	var Socks5Response;
	(function (Socks5Response) {
	    Socks5Response[Socks5Response["Granted"] = 0] = "Granted";
	    Socks5Response[Socks5Response["Failure"] = 1] = "Failure";
	    Socks5Response[Socks5Response["NotAllowed"] = 2] = "NotAllowed";
	    Socks5Response[Socks5Response["NetworkUnreachable"] = 3] = "NetworkUnreachable";
	    Socks5Response[Socks5Response["HostUnreachable"] = 4] = "HostUnreachable";
	    Socks5Response[Socks5Response["ConnectionRefused"] = 5] = "ConnectionRefused";
	    Socks5Response[Socks5Response["TTLExpired"] = 6] = "TTLExpired";
	    Socks5Response[Socks5Response["CommandNotSupported"] = 7] = "CommandNotSupported";
	    Socks5Response[Socks5Response["AddressNotSupported"] = 8] = "AddressNotSupported";
	})(Socks5Response || (constants$3.Socks5Response = Socks5Response = {}));
	var Socks5HostType;
	(function (Socks5HostType) {
	    Socks5HostType[Socks5HostType["IPv4"] = 1] = "IPv4";
	    Socks5HostType[Socks5HostType["Hostname"] = 3] = "Hostname";
	    Socks5HostType[Socks5HostType["IPv6"] = 4] = "IPv6";
	})(Socks5HostType || (constants$3.Socks5HostType = Socks5HostType = {}));
	var SocksClientState;
	(function (SocksClientState) {
	    SocksClientState[SocksClientState["Created"] = 0] = "Created";
	    SocksClientState[SocksClientState["Connecting"] = 1] = "Connecting";
	    SocksClientState[SocksClientState["Connected"] = 2] = "Connected";
	    SocksClientState[SocksClientState["SentInitialHandshake"] = 3] = "SentInitialHandshake";
	    SocksClientState[SocksClientState["ReceivedInitialHandshakeResponse"] = 4] = "ReceivedInitialHandshakeResponse";
	    SocksClientState[SocksClientState["SentAuthentication"] = 5] = "SentAuthentication";
	    SocksClientState[SocksClientState["ReceivedAuthenticationResponse"] = 6] = "ReceivedAuthenticationResponse";
	    SocksClientState[SocksClientState["SentFinalHandshake"] = 7] = "SentFinalHandshake";
	    SocksClientState[SocksClientState["ReceivedFinalResponse"] = 8] = "ReceivedFinalResponse";
	    SocksClientState[SocksClientState["BoundWaitingForConnection"] = 9] = "BoundWaitingForConnection";
	    SocksClientState[SocksClientState["Established"] = 10] = "Established";
	    SocksClientState[SocksClientState["Disconnected"] = 11] = "Disconnected";
	    SocksClientState[SocksClientState["Error"] = 99] = "Error";
	})(SocksClientState || (constants$3.SocksClientState = SocksClientState = {}));
	return constants$3;
}

var helpers$1 = {};

var util$2 = {};

var hasRequiredUtil$2;

function requireUtil$2 () {
	if (hasRequiredUtil$2) return util$2;
	hasRequiredUtil$2 = 1;
	Object.defineProperty(util$2, "__esModule", { value: true });
	util$2.shuffleArray = util$2.SocksClientError = void 0;
	class SocksClientError extends Error {
	    constructor(message, options) {
	        super(message);
	        this.options = options;
	    }
	}
	util$2.SocksClientError = SocksClientError;
	function shuffleArray(array) {
	    for (let i = array.length - 1; i > 0; i--) {
	        const j = Math.floor(Math.random() * (i + 1));
	        [array[i], array[j]] = [array[j], array[i]];
	    }
	}
	util$2.shuffleArray = shuffleArray;
	return util$2;
}

var ipAddress = {};

var ipv4 = {};

var common$1 = {};

var hasRequiredCommon$1;

function requireCommon$1 () {
	if (hasRequiredCommon$1) return common$1;
	hasRequiredCommon$1 = 1;
	Object.defineProperty(common$1, "__esModule", { value: true });
	common$1.isInSubnet = isInSubnet;
	common$1.isCorrect = isCorrect;
	common$1.numberToPaddedHex = numberToPaddedHex;
	common$1.stringToPaddedHex = stringToPaddedHex;
	common$1.testBit = testBit;
	function isInSubnet(address) {
	    if (this.subnetMask < address.subnetMask) {
	        return false;
	    }
	    if (this.mask(address.subnetMask) === address.mask()) {
	        return true;
	    }
	    return false;
	}
	function isCorrect(defaultBits) {
	    return function () {
	        if (this.addressMinusSuffix !== this.correctForm()) {
	            return false;
	        }
	        if (this.subnetMask === defaultBits && !this.parsedSubnet) {
	            return true;
	        }
	        return this.parsedSubnet === String(this.subnetMask);
	    };
	}
	function numberToPaddedHex(number) {
	    return number.toString(16).padStart(2, '0');
	}
	function stringToPaddedHex(numberString) {
	    return numberToPaddedHex(parseInt(numberString, 10));
	}
	function testBit(binaryValue, position) {
	    const { length } = binaryValue;
	    if (position > length) {
	        return false;
	    }
	    const positionInString = length - position;
	    return binaryValue.substring(positionInString, positionInString + 1) === '1';
	}
	return common$1;
}

var constants$2 = {};

var hasRequiredConstants$2;

function requireConstants$2 () {
	if (hasRequiredConstants$2) return constants$2;
	hasRequiredConstants$2 = 1;
	Object.defineProperty(constants$2, "__esModule", { value: true });
	constants$2.RE_SUBNET_STRING = constants$2.RE_ADDRESS = constants$2.GROUPS = constants$2.BITS = void 0;
	constants$2.BITS = 32;
	constants$2.GROUPS = 4;
	constants$2.RE_ADDRESS = /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/g;
	constants$2.RE_SUBNET_STRING = /\/\d{1,2}$/;
	return constants$2;
}

var addressError = {};

var hasRequiredAddressError;

function requireAddressError () {
	if (hasRequiredAddressError) return addressError;
	hasRequiredAddressError = 1;
	Object.defineProperty(addressError, "__esModule", { value: true });
	addressError.AddressError = void 0;
	class AddressError extends Error {
	    constructor(message, parseMessage) {
	        super(message);
	        this.name = 'AddressError';
	        this.parseMessage = parseMessage;
	    }
	}
	addressError.AddressError = AddressError;
	return addressError;
}

var hasRequiredIpv4;

function requireIpv4 () {
	if (hasRequiredIpv4) return ipv4;
	hasRequiredIpv4 = 1;
	var __createBinding = (ipv4 && ipv4.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (ipv4 && ipv4.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (ipv4 && ipv4.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(ipv4, "__esModule", { value: true });
	ipv4.Address4 = void 0;
	const common = __importStar(requireCommon$1());
	const constants = __importStar(requireConstants$2());
	const address_error_1 = requireAddressError();
	class Address4 {
	    constructor(address) {
	        this.groups = constants.GROUPS;
	        this.parsedAddress = [];
	        this.parsedSubnet = '';
	        this.subnet = '/32';
	        this.subnetMask = 32;
	        this.v4 = true;
	        this.isCorrect = common.isCorrect(constants.BITS);
	        this.isInSubnet = common.isInSubnet;
	        this.address = address;
	        const subnet = constants.RE_SUBNET_STRING.exec(address);
	        if (subnet) {
	            this.parsedSubnet = subnet[0].replace('/', '');
	            this.subnetMask = parseInt(this.parsedSubnet, 10);
	            this.subnet = `/${this.subnetMask}`;
	            if (this.subnetMask < 0 || this.subnetMask > constants.BITS) {
	                throw new address_error_1.AddressError('Invalid subnet mask.');
	            }
	            address = address.replace(constants.RE_SUBNET_STRING, '');
	        }
	        this.addressMinusSuffix = address;
	        this.parsedAddress = this.parse(address);
	    }
	    static isValid(address) {
	        try {
	            new Address4(address);
	            return true;
	        }
	        catch (e) {
	            return false;
	        }
	    }
	    parse(address) {
	        const groups = address.split('.');
	        if (!address.match(constants.RE_ADDRESS)) {
	            throw new address_error_1.AddressError('Invalid IPv4 address.');
	        }
	        return groups;
	    }
	    correctForm() {
	        return this.parsedAddress.map((part) => parseInt(part, 10)).join('.');
	    }
	    static fromHex(hex) {
	        const padded = hex.replace(/:/g, '').padStart(8, '0');
	        const groups = [];
	        let i;
	        for (i = 0; i < 8; i += 2) {
	            const h = padded.slice(i, i + 2);
	            groups.push(parseInt(h, 16));
	        }
	        return new Address4(groups.join('.'));
	    }
	    static fromInteger(integer) {
	        return Address4.fromHex(integer.toString(16));
	    }
	    static fromArpa(arpaFormAddress) {
	        const leader = arpaFormAddress.replace(/(\.in-addr\.arpa)?\.$/, '');
	        const address = leader.split('.').reverse().join('.');
	        return new Address4(address);
	    }
	    toHex() {
	        return this.parsedAddress.map((part) => common.stringToPaddedHex(part)).join(':');
	    }
	    toArray() {
	        return this.parsedAddress.map((part) => parseInt(part, 10));
	    }
	    toGroup6() {
	        const output = [];
	        let i;
	        for (i = 0; i < constants.GROUPS; i += 2) {
	            output.push(`${common.stringToPaddedHex(this.parsedAddress[i])}${common.stringToPaddedHex(this.parsedAddress[i + 1])}`);
	        }
	        return output.join(':');
	    }
	    bigInt() {
	        return BigInt(`0x${this.parsedAddress.map((n) => common.stringToPaddedHex(n)).join('')}`);
	    }
	    _startAddress() {
	        return BigInt(`0b${this.mask() + '0'.repeat(constants.BITS - this.subnetMask)}`);
	    }
	    startAddress() {
	        return Address4.fromBigInt(this._startAddress());
	    }
	    startAddressExclusive() {
	        const adjust = BigInt('1');
	        return Address4.fromBigInt(this._startAddress() + adjust);
	    }
	    _endAddress() {
	        return BigInt(`0b${this.mask() + '1'.repeat(constants.BITS - this.subnetMask)}`);
	    }
	    endAddress() {
	        return Address4.fromBigInt(this._endAddress());
	    }
	    endAddressExclusive() {
	        const adjust = BigInt('1');
	        return Address4.fromBigInt(this._endAddress() - adjust);
	    }
	    static fromBigInt(bigInt) {
	        return Address4.fromHex(bigInt.toString(16));
	    }
	    mask(mask) {
	        if (mask === undefined) {
	            mask = this.subnetMask;
	        }
	        return this.getBitsBase2(0, mask);
	    }
	    getBitsBase2(start, end) {
	        return this.binaryZeroPad().slice(start, end);
	    }
	    reverseForm(options) {
	        if (!options) {
	            options = {};
	        }
	        const reversed = this.correctForm().split('.').reverse().join('.');
	        if (options.omitSuffix) {
	            return reversed;
	        }
	        return `${reversed}.in-addr.arpa.`;
	    }
	    isMulticast() {
	        return this.isInSubnet(new Address4('224.0.0.0/4'));
	    }
	    binaryZeroPad() {
	        return this.bigInt().toString(2).padStart(constants.BITS, '0');
	    }
	    groupForV6() {
	        const segments = this.parsedAddress;
	        return this.address.replace(constants.RE_ADDRESS, `<span class="hover-group group-v4 group-6">${segments
	            .slice(0, 2)
	            .join('.')}</span>.<span class="hover-group group-v4 group-7">${segments
	            .slice(2, 4)
	            .join('.')}</span>`);
	    }
	}
	ipv4.Address4 = Address4;
	return ipv4;
}

var ipv6 = {};

var constants$1 = {};

var hasRequiredConstants$1;

function requireConstants$1 () {
	if (hasRequiredConstants$1) return constants$1;
	hasRequiredConstants$1 = 1;
	Object.defineProperty(constants$1, "__esModule", { value: true });
	constants$1.RE_URL_WITH_PORT = constants$1.RE_URL = constants$1.RE_ZONE_STRING = constants$1.RE_SUBNET_STRING = constants$1.RE_BAD_ADDRESS = constants$1.RE_BAD_CHARACTERS = constants$1.TYPES = constants$1.SCOPES = constants$1.GROUPS = constants$1.BITS = void 0;
	constants$1.BITS = 128;
	constants$1.GROUPS = 8;
	constants$1.SCOPES = {
	    0: 'Reserved',
	    1: 'Interface local',
	    2: 'Link local',
	    4: 'Admin local',
	    5: 'Site local',
	    8: 'Organization local',
	    14: 'Global',
	    15: 'Reserved',
	};
	constants$1.TYPES = {
	    'ff01::1/128': 'Multicast (All nodes on this interface)',
	    'ff01::2/128': 'Multicast (All routers on this interface)',
	    'ff02::1/128': 'Multicast (All nodes on this link)',
	    'ff02::2/128': 'Multicast (All routers on this link)',
	    'ff05::2/128': 'Multicast (All routers in this site)',
	    'ff02::5/128': 'Multicast (OSPFv3 AllSPF routers)',
	    'ff02::6/128': 'Multicast (OSPFv3 AllDR routers)',
	    'ff02::9/128': 'Multicast (RIP routers)',
	    'ff02::a/128': 'Multicast (EIGRP routers)',
	    'ff02::d/128': 'Multicast (PIM routers)',
	    'ff02::16/128': 'Multicast (MLDv2 reports)',
	    'ff01::fb/128': 'Multicast (mDNSv6)',
	    'ff02::fb/128': 'Multicast (mDNSv6)',
	    'ff05::fb/128': 'Multicast (mDNSv6)',
	    'ff02::1:2/128': 'Multicast (All DHCP servers and relay agents on this link)',
	    'ff05::1:2/128': 'Multicast (All DHCP servers and relay agents in this site)',
	    'ff02::1:3/128': 'Multicast (All DHCP servers on this link)',
	    'ff05::1:3/128': 'Multicast (All DHCP servers in this site)',
	    '::/128': 'Unspecified',
	    '::1/128': 'Loopback',
	    'ff00::/8': 'Multicast',
	    'fe80::/10': 'Link-local unicast',
	};
	constants$1.RE_BAD_CHARACTERS = /([^0-9a-f:/%])/gi;
	constants$1.RE_BAD_ADDRESS = /([0-9a-f]{5,}|:{3,}|[^:]:$|^:[^:]|\/$)/gi;
	constants$1.RE_SUBNET_STRING = /\/\d{1,3}(?=%|$)/;
	constants$1.RE_ZONE_STRING = /%.*$/;
	constants$1.RE_URL = /^\[{0,1}([0-9a-f:]+)\]{0,1}/;
	constants$1.RE_URL_WITH_PORT = /\[([0-9a-f:]+)\]:([0-9]{1,5})/;
	return constants$1;
}

var helpers = {};

var hasRequiredHelpers$1;

function requireHelpers$1 () {
	if (hasRequiredHelpers$1) return helpers;
	hasRequiredHelpers$1 = 1;
	Object.defineProperty(helpers, "__esModule", { value: true });
	helpers.spanAllZeroes = spanAllZeroes;
	helpers.spanAll = spanAll;
	helpers.spanLeadingZeroes = spanLeadingZeroes;
	helpers.simpleGroup = simpleGroup;
	function spanAllZeroes(s) {
	    return s.replace(/(0+)/g, '<span class="zero">$1</span>');
	}
	function spanAll(s, offset = 0) {
	    const letters = s.split('');
	    return letters
	        .map((n, i) => `<span class="digit value-${n} position-${i + offset}">${spanAllZeroes(n)}</span>`)
	        .join('');
	}
	function spanLeadingZeroesSimple(group) {
	    return group.replace(/^(0+)/, '<span class="zero">$1</span>');
	}
	function spanLeadingZeroes(address) {
	    const groups = address.split(':');
	    return groups.map((g) => spanLeadingZeroesSimple(g)).join(':');
	}
	function simpleGroup(addressString, offset = 0) {
	    const groups = addressString.split(':');
	    return groups.map((g, i) => {
	        if (/group-v4/.test(g)) {
	            return g;
	        }
	        return `<span class="hover-group group-${i + offset}">${spanLeadingZeroesSimple(g)}</span>`;
	    });
	}
	return helpers;
}

var regularExpressions = {};

var hasRequiredRegularExpressions;

function requireRegularExpressions () {
	if (hasRequiredRegularExpressions) return regularExpressions;
	hasRequiredRegularExpressions = 1;
	var __createBinding = (regularExpressions && regularExpressions.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (regularExpressions && regularExpressions.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (regularExpressions && regularExpressions.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(regularExpressions, "__esModule", { value: true });
	regularExpressions.ADDRESS_BOUNDARY = void 0;
	regularExpressions.groupPossibilities = groupPossibilities;
	regularExpressions.padGroup = padGroup;
	regularExpressions.simpleRegularExpression = simpleRegularExpression;
	regularExpressions.possibleElisions = possibleElisions;
	const v6 = __importStar(requireConstants$1());
	function groupPossibilities(possibilities) {
	    return `(${possibilities.join('|')})`;
	}
	function padGroup(group) {
	    if (group.length < 4) {
	        return `0{0,${4 - group.length}}${group}`;
	    }
	    return group;
	}
	regularExpressions.ADDRESS_BOUNDARY = '[^A-Fa-f0-9:]';
	function simpleRegularExpression(groups) {
	    const zeroIndexes = [];
	    groups.forEach((group, i) => {
	        const groupInteger = parseInt(group, 16);
	        if (groupInteger === 0) {
	            zeroIndexes.push(i);
	        }
	    });
	    const possibilities = zeroIndexes.map((zeroIndex) => groups
	        .map((group, i) => {
	        if (i === zeroIndex) {
	            const elision = i === 0 || i === v6.GROUPS - 1 ? ':' : '';
	            return groupPossibilities([padGroup(group), elision]);
	        }
	        return padGroup(group);
	    })
	        .join(':'));
	    possibilities.push(groups.map(padGroup).join(':'));
	    return groupPossibilities(possibilities);
	}
	function possibleElisions(elidedGroups, moreLeft, moreRight) {
	    const left = moreLeft ? '' : ':';
	    const right = moreRight ? '' : ':';
	    const possibilities = [];
	    if (!moreLeft && !moreRight) {
	        possibilities.push('::');
	    }
	    if (moreLeft && moreRight) {
	        possibilities.push('');
	    }
	    if ((moreRight && !moreLeft) || (!moreRight && moreLeft)) {
	        possibilities.push(':');
	    }
	    possibilities.push(`${left}(:0{1,4}){1,${elidedGroups - 1}}`);
	    possibilities.push(`(0{1,4}:){1,${elidedGroups - 1}}${right}`);
	    possibilities.push(`(0{1,4}:){${elidedGroups - 1}}0{1,4}`);
	    for (let groups = 1; groups < elidedGroups - 1; groups++) {
	        for (let position = 1; position < elidedGroups - groups; position++) {
	            possibilities.push(`(0{1,4}:){${position}}:(0{1,4}:){${elidedGroups - position - groups - 1}}0{1,4}`);
	        }
	    }
	    return groupPossibilities(possibilities);
	}
	return regularExpressions;
}

var hasRequiredIpv6;

function requireIpv6 () {
	if (hasRequiredIpv6) return ipv6;
	hasRequiredIpv6 = 1;
	var __createBinding = (ipv6 && ipv6.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (ipv6 && ipv6.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (ipv6 && ipv6.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(ipv6, "__esModule", { value: true });
	ipv6.Address6 = void 0;
	const common = __importStar(requireCommon$1());
	const constants4 = __importStar(requireConstants$2());
	const constants6 = __importStar(requireConstants$1());
	const helpers = __importStar(requireHelpers$1());
	const ipv4_1 = requireIpv4();
	const regular_expressions_1 = requireRegularExpressions();
	const address_error_1 = requireAddressError();
	const common_1 = requireCommon$1();
	function assert(condition) {
	    if (!condition) {
	        throw new Error('Assertion failed.');
	    }
	}
	function addCommas(number) {
	    const r = /(\d+)(\d{3})/;
	    while (r.test(number)) {
	        number = number.replace(r, '$1,$2');
	    }
	    return number;
	}
	function spanLeadingZeroes4(n) {
	    n = n.replace(/^(0{1,})([1-9]+)$/, '<span class="parse-error">$1</span>$2');
	    n = n.replace(/^(0{1,})(0)$/, '<span class="parse-error">$1</span>$2');
	    return n;
	}
	function compact(address, slice) {
	    const s1 = [];
	    const s2 = [];
	    let i;
	    for (i = 0; i < address.length; i++) {
	        if (i < slice[0]) {
	            s1.push(address[i]);
	        }
	        else if (i > slice[1]) {
	            s2.push(address[i]);
	        }
	    }
	    return s1.concat(['compact']).concat(s2);
	}
	function paddedHex(octet) {
	    return parseInt(octet, 16).toString(16).padStart(4, '0');
	}
	function unsignByte(b) {
	    return b & 0xff;
	}
	class Address6 {
	    constructor(address, optionalGroups) {
	        this.addressMinusSuffix = '';
	        this.parsedSubnet = '';
	        this.subnet = '/128';
	        this.subnetMask = 128;
	        this.v4 = false;
	        this.zone = '';
	        this.isInSubnet = common.isInSubnet;
	        this.isCorrect = common.isCorrect(constants6.BITS);
	        if (optionalGroups === undefined) {
	            this.groups = constants6.GROUPS;
	        }
	        else {
	            this.groups = optionalGroups;
	        }
	        this.address = address;
	        const subnet = constants6.RE_SUBNET_STRING.exec(address);
	        if (subnet) {
	            this.parsedSubnet = subnet[0].replace('/', '');
	            this.subnetMask = parseInt(this.parsedSubnet, 10);
	            this.subnet = `/${this.subnetMask}`;
	            if (Number.isNaN(this.subnetMask) ||
	                this.subnetMask < 0 ||
	                this.subnetMask > constants6.BITS) {
	                throw new address_error_1.AddressError('Invalid subnet mask.');
	            }
	            address = address.replace(constants6.RE_SUBNET_STRING, '');
	        }
	        else if (/\//.test(address)) {
	            throw new address_error_1.AddressError('Invalid subnet mask.');
	        }
	        const zone = constants6.RE_ZONE_STRING.exec(address);
	        if (zone) {
	            this.zone = zone[0];
	            address = address.replace(constants6.RE_ZONE_STRING, '');
	        }
	        this.addressMinusSuffix = address;
	        this.parsedAddress = this.parse(this.addressMinusSuffix);
	    }
	    static isValid(address) {
	        try {
	            new Address6(address);
	            return true;
	        }
	        catch (e) {
	            return false;
	        }
	    }
	    static fromBigInt(bigInt) {
	        const hex = bigInt.toString(16).padStart(32, '0');
	        const groups = [];
	        let i;
	        for (i = 0; i < constants6.GROUPS; i++) {
	            groups.push(hex.slice(i * 4, (i + 1) * 4));
	        }
	        return new Address6(groups.join(':'));
	    }
	    static fromURL(url) {
	        let host;
	        let port = null;
	        let result;
	        if (url.indexOf('[') !== -1 && url.indexOf(']:') !== -1) {
	            result = constants6.RE_URL_WITH_PORT.exec(url);
	            if (result === null) {
	                return {
	                    error: 'failed to parse address with port',
	                    address: null,
	                    port: null,
	                };
	            }
	            host = result[1];
	            port = result[2];
	        }
	        else if (url.indexOf('/') !== -1) {
	            url = url.replace(/^[a-z0-9]+:\/\//, '');
	            result = constants6.RE_URL.exec(url);
	            if (result === null) {
	                return {
	                    error: 'failed to parse address from URL',
	                    address: null,
	                    port: null,
	                };
	            }
	            host = result[1];
	        }
	        else {
	            host = url;
	        }
	        if (port) {
	            port = parseInt(port, 10);
	            if (port < 0 || port > 65536) {
	                port = null;
	            }
	        }
	        else {
	            port = null;
	        }
	        return {
	            address: new Address6(host),
	            port,
	        };
	    }
	    static fromAddress4(address) {
	        const address4 = new ipv4_1.Address4(address);
	        const mask6 = constants6.BITS - (constants4.BITS - address4.subnetMask);
	        return new Address6(`::ffff:${address4.correctForm()}/${mask6}`);
	    }
	    static fromArpa(arpaFormAddress) {
	        let address = arpaFormAddress.replace(/(\.ip6\.arpa)?\.$/, '');
	        const semicolonAmount = 7;
	        if (address.length !== 63) {
	            throw new address_error_1.AddressError("Invalid 'ip6.arpa' form.");
	        }
	        const parts = address.split('.').reverse();
	        for (let i = semicolonAmount; i > 0; i--) {
	            const insertIndex = i * 4;
	            parts.splice(insertIndex, 0, ':');
	        }
	        address = parts.join('');
	        return new Address6(address);
	    }
	    microsoftTranscription() {
	        return `${this.correctForm().replace(/:/g, '-')}.ipv6-literal.net`;
	    }
	    mask(mask = this.subnetMask) {
	        return this.getBitsBase2(0, mask);
	    }
	    possibleSubnets(subnetSize = 128) {
	        const availableBits = constants6.BITS - this.subnetMask;
	        const subnetBits = Math.abs(subnetSize - constants6.BITS);
	        const subnetPowers = availableBits - subnetBits;
	        if (subnetPowers < 0) {
	            return '0';
	        }
	        return addCommas((BigInt('2') ** BigInt(subnetPowers)).toString(10));
	    }
	    _startAddress() {
	        return BigInt(`0b${this.mask() + '0'.repeat(constants6.BITS - this.subnetMask)}`);
	    }
	    startAddress() {
	        return Address6.fromBigInt(this._startAddress());
	    }
	    startAddressExclusive() {
	        const adjust = BigInt('1');
	        return Address6.fromBigInt(this._startAddress() + adjust);
	    }
	    _endAddress() {
	        return BigInt(`0b${this.mask() + '1'.repeat(constants6.BITS - this.subnetMask)}`);
	    }
	    endAddress() {
	        return Address6.fromBigInt(this._endAddress());
	    }
	    endAddressExclusive() {
	        const adjust = BigInt('1');
	        return Address6.fromBigInt(this._endAddress() - adjust);
	    }
	    getScope() {
	        let scope = constants6.SCOPES[parseInt(this.getBits(12, 16).toString(10), 10)];
	        if (this.getType() === 'Global unicast' && scope !== 'Link local') {
	            scope = 'Global';
	        }
	        return scope || 'Unknown';
	    }
	    getType() {
	        for (const subnet of Object.keys(constants6.TYPES)) {
	            if (this.isInSubnet(new Address6(subnet))) {
	                return constants6.TYPES[subnet];
	            }
	        }
	        return 'Global unicast';
	    }
	    getBits(start, end) {
	        return BigInt(`0b${this.getBitsBase2(start, end)}`);
	    }
	    getBitsBase2(start, end) {
	        return this.binaryZeroPad().slice(start, end);
	    }
	    getBitsBase16(start, end) {
	        const length = end - start;
	        if (length % 4 !== 0) {
	            throw new Error('Length of bits to retrieve must be divisible by four');
	        }
	        return this.getBits(start, end)
	            .toString(16)
	            .padStart(length / 4, '0');
	    }
	    getBitsPastSubnet() {
	        return this.getBitsBase2(this.subnetMask, constants6.BITS);
	    }
	    reverseForm(options) {
	        if (!options) {
	            options = {};
	        }
	        const characters = Math.floor(this.subnetMask / 4);
	        const reversed = this.canonicalForm()
	            .replace(/:/g, '')
	            .split('')
	            .slice(0, characters)
	            .reverse()
	            .join('.');
	        if (characters > 0) {
	            if (options.omitSuffix) {
	                return reversed;
	            }
	            return `${reversed}.ip6.arpa.`;
	        }
	        if (options.omitSuffix) {
	            return '';
	        }
	        return 'ip6.arpa.';
	    }
	    correctForm() {
	        let i;
	        let groups = [];
	        let zeroCounter = 0;
	        const zeroes = [];
	        for (i = 0; i < this.parsedAddress.length; i++) {
	            const value = parseInt(this.parsedAddress[i], 16);
	            if (value === 0) {
	                zeroCounter++;
	            }
	            if (value !== 0 && zeroCounter > 0) {
	                if (zeroCounter > 1) {
	                    zeroes.push([i - zeroCounter, i - 1]);
	                }
	                zeroCounter = 0;
	            }
	        }
	        if (zeroCounter > 1) {
	            zeroes.push([this.parsedAddress.length - zeroCounter, this.parsedAddress.length - 1]);
	        }
	        const zeroLengths = zeroes.map((n) => n[1] - n[0] + 1);
	        if (zeroes.length > 0) {
	            const index = zeroLengths.indexOf(Math.max(...zeroLengths));
	            groups = compact(this.parsedAddress, zeroes[index]);
	        }
	        else {
	            groups = this.parsedAddress;
	        }
	        for (i = 0; i < groups.length; i++) {
	            if (groups[i] !== 'compact') {
	                groups[i] = parseInt(groups[i], 16).toString(16);
	            }
	        }
	        let correct = groups.join(':');
	        correct = correct.replace(/^compact$/, '::');
	        correct = correct.replace(/(^compact)|(compact$)/, ':');
	        correct = correct.replace(/compact/, '');
	        return correct;
	    }
	    binaryZeroPad() {
	        return this.bigInt().toString(2).padStart(constants6.BITS, '0');
	    }
	    parse4in6(address) {
	        const groups = address.split(':');
	        const lastGroup = groups.slice(-1)[0];
	        const address4 = lastGroup.match(constants4.RE_ADDRESS);
	        if (address4) {
	            this.parsedAddress4 = address4[0];
	            this.address4 = new ipv4_1.Address4(this.parsedAddress4);
	            for (let i = 0; i < this.address4.groups; i++) {
	                if (/^0[0-9]+/.test(this.address4.parsedAddress[i])) {
	                    throw new address_error_1.AddressError("IPv4 addresses can't have leading zeroes.", address.replace(constants4.RE_ADDRESS, this.address4.parsedAddress.map(spanLeadingZeroes4).join('.')));
	                }
	            }
	            this.v4 = true;
	            groups[groups.length - 1] = this.address4.toGroup6();
	            address = groups.join(':');
	        }
	        return address;
	    }
	    parse(address) {
	        address = this.parse4in6(address);
	        const badCharacters = address.match(constants6.RE_BAD_CHARACTERS);
	        if (badCharacters) {
	            throw new address_error_1.AddressError(`Bad character${badCharacters.length > 1 ? 's' : ''} detected in address: ${badCharacters.join('')}`, address.replace(constants6.RE_BAD_CHARACTERS, '<span class="parse-error">$1</span>'));
	        }
	        const badAddress = address.match(constants6.RE_BAD_ADDRESS);
	        if (badAddress) {
	            throw new address_error_1.AddressError(`Address failed regex: ${badAddress.join('')}`, address.replace(constants6.RE_BAD_ADDRESS, '<span class="parse-error">$1</span>'));
	        }
	        let groups = [];
	        const halves = address.split('::');
	        if (halves.length === 2) {
	            let first = halves[0].split(':');
	            let last = halves[1].split(':');
	            if (first.length === 1 && first[0] === '') {
	                first = [];
	            }
	            if (last.length === 1 && last[0] === '') {
	                last = [];
	            }
	            const remaining = this.groups - (first.length + last.length);
	            if (!remaining) {
	                throw new address_error_1.AddressError('Error parsing groups');
	            }
	            this.elidedGroups = remaining;
	            this.elisionBegin = first.length;
	            this.elisionEnd = first.length + this.elidedGroups;
	            groups = groups.concat(first);
	            for (let i = 0; i < remaining; i++) {
	                groups.push('0');
	            }
	            groups = groups.concat(last);
	        }
	        else if (halves.length === 1) {
	            groups = address.split(':');
	            this.elidedGroups = 0;
	        }
	        else {
	            throw new address_error_1.AddressError('Too many :: groups found');
	        }
	        groups = groups.map((group) => parseInt(group, 16).toString(16));
	        if (groups.length !== this.groups) {
	            throw new address_error_1.AddressError('Incorrect number of groups found');
	        }
	        return groups;
	    }
	    canonicalForm() {
	        return this.parsedAddress.map(paddedHex).join(':');
	    }
	    decimal() {
	        return this.parsedAddress.map((n) => parseInt(n, 16).toString(10).padStart(5, '0')).join(':');
	    }
	    bigInt() {
	        return BigInt(`0x${this.parsedAddress.map(paddedHex).join('')}`);
	    }
	    to4() {
	        const binary = this.binaryZeroPad().split('');
	        return ipv4_1.Address4.fromHex(BigInt(`0b${binary.slice(96, 128).join('')}`).toString(16));
	    }
	    to4in6() {
	        const address4 = this.to4();
	        const address6 = new Address6(this.parsedAddress.slice(0, 6).join(':'), 6);
	        const correct = address6.correctForm();
	        let infix = '';
	        if (!/:$/.test(correct)) {
	            infix = ':';
	        }
	        return correct + infix + address4.address;
	    }
	    inspectTeredo() {
	        const prefix = this.getBitsBase16(0, 32);
	        const bitsForUdpPort = this.getBits(80, 96);
	        const udpPort = (bitsForUdpPort ^ BigInt('0xffff')).toString();
	        const server4 = ipv4_1.Address4.fromHex(this.getBitsBase16(32, 64));
	        const bitsForClient4 = this.getBits(96, 128);
	        const client4 = ipv4_1.Address4.fromHex((bitsForClient4 ^ BigInt('0xffffffff')).toString(16));
	        const flagsBase2 = this.getBitsBase2(64, 80);
	        const coneNat = (0, common_1.testBit)(flagsBase2, 15);
	        const reserved = (0, common_1.testBit)(flagsBase2, 14);
	        const groupIndividual = (0, common_1.testBit)(flagsBase2, 8);
	        const universalLocal = (0, common_1.testBit)(flagsBase2, 9);
	        const nonce = BigInt(`0b${flagsBase2.slice(2, 6) + flagsBase2.slice(8, 16)}`).toString(10);
	        return {
	            prefix: `${prefix.slice(0, 4)}:${prefix.slice(4, 8)}`,
	            server4: server4.address,
	            client4: client4.address,
	            flags: flagsBase2,
	            coneNat,
	            microsoft: {
	                reserved,
	                universalLocal,
	                groupIndividual,
	                nonce,
	            },
	            udpPort,
	        };
	    }
	    inspect6to4() {
	        const prefix = this.getBitsBase16(0, 16);
	        const gateway = ipv4_1.Address4.fromHex(this.getBitsBase16(16, 48));
	        return {
	            prefix: prefix.slice(0, 4),
	            gateway: gateway.address,
	        };
	    }
	    to6to4() {
	        if (!this.is4()) {
	            return null;
	        }
	        const addr6to4 = [
	            '2002',
	            this.getBitsBase16(96, 112),
	            this.getBitsBase16(112, 128),
	            '',
	            '/16',
	        ].join(':');
	        return new Address6(addr6to4);
	    }
	    toByteArray() {
	        const valueWithoutPadding = this.bigInt().toString(16);
	        const leadingPad = '0'.repeat(valueWithoutPadding.length % 2);
	        const value = `${leadingPad}${valueWithoutPadding}`;
	        const bytes = [];
	        for (let i = 0, length = value.length; i < length; i += 2) {
	            bytes.push(parseInt(value.substring(i, i + 2), 16));
	        }
	        return bytes;
	    }
	    toUnsignedByteArray() {
	        return this.toByteArray().map(unsignByte);
	    }
	    static fromByteArray(bytes) {
	        return this.fromUnsignedByteArray(bytes.map(unsignByte));
	    }
	    static fromUnsignedByteArray(bytes) {
	        const BYTE_MAX = BigInt('256');
	        let result = BigInt('0');
	        let multiplier = BigInt('1');
	        for (let i = bytes.length - 1; i >= 0; i--) {
	            result += multiplier * BigInt(bytes[i].toString(10));
	            multiplier *= BYTE_MAX;
	        }
	        return Address6.fromBigInt(result);
	    }
	    isCanonical() {
	        return this.addressMinusSuffix === this.canonicalForm();
	    }
	    isLinkLocal() {
	        if (this.getBitsBase2(0, 64) ===
	            '1111111010000000000000000000000000000000000000000000000000000000') {
	            return true;
	        }
	        return false;
	    }
	    isMulticast() {
	        return this.getType() === 'Multicast';
	    }
	    is4() {
	        return this.v4;
	    }
	    isTeredo() {
	        return this.isInSubnet(new Address6('2001::/32'));
	    }
	    is6to4() {
	        return this.isInSubnet(new Address6('2002::/16'));
	    }
	    isLoopback() {
	        return this.getType() === 'Loopback';
	    }
	    href(optionalPort) {
	        if (optionalPort === undefined) {
	            optionalPort = '';
	        }
	        else {
	            optionalPort = `:${optionalPort}`;
	        }
	        return `http://[${this.correctForm()}]${optionalPort}/`;
	    }
	    link(options) {
	        if (!options) {
	            options = {};
	        }
	        if (options.className === undefined) {
	            options.className = '';
	        }
	        if (options.prefix === undefined) {
	            options.prefix = '/#address=';
	        }
	        if (options.v4 === undefined) {
	            options.v4 = false;
	        }
	        let formFunction = this.correctForm;
	        if (options.v4) {
	            formFunction = this.to4in6;
	        }
	        const form = formFunction.call(this);
	        if (options.className) {
	            return `<a href="${options.prefix}${form}" class="${options.className}">${form}</a>`;
	        }
	        return `<a href="${options.prefix}${form}">${form}</a>`;
	    }
	    group() {
	        if (this.elidedGroups === 0) {
	            return helpers.simpleGroup(this.address).join(':');
	        }
	        assert(typeof this.elidedGroups === 'number');
	        assert(typeof this.elisionBegin === 'number');
	        const output = [];
	        const [left, right] = this.address.split('::');
	        if (left.length) {
	            output.push(...helpers.simpleGroup(left));
	        }
	        else {
	            output.push('');
	        }
	        const classes = ['hover-group'];
	        for (let i = this.elisionBegin; i < this.elisionBegin + this.elidedGroups; i++) {
	            classes.push(`group-${i}`);
	        }
	        output.push(`<span class="${classes.join(' ')}"></span>`);
	        if (right.length) {
	            output.push(...helpers.simpleGroup(right, this.elisionEnd));
	        }
	        else {
	            output.push('');
	        }
	        if (this.is4()) {
	            assert(this.address4 instanceof ipv4_1.Address4);
	            output.pop();
	            output.push(this.address4.groupForV6());
	        }
	        return output.join(':');
	    }
	    regularExpressionString(substringSearch = false) {
	        let output = [];
	        const address6 = new Address6(this.correctForm());
	        if (address6.elidedGroups === 0) {
	            output.push((0, regular_expressions_1.simpleRegularExpression)(address6.parsedAddress));
	        }
	        else if (address6.elidedGroups === constants6.GROUPS) {
	            output.push((0, regular_expressions_1.possibleElisions)(constants6.GROUPS));
	        }
	        else {
	            const halves = address6.address.split('::');
	            if (halves[0].length) {
	                output.push((0, regular_expressions_1.simpleRegularExpression)(halves[0].split(':')));
	            }
	            assert(typeof address6.elidedGroups === 'number');
	            output.push((0, regular_expressions_1.possibleElisions)(address6.elidedGroups, halves[0].length !== 0, halves[1].length !== 0));
	            if (halves[1].length) {
	                output.push((0, regular_expressions_1.simpleRegularExpression)(halves[1].split(':')));
	            }
	            output = [output.join(':')];
	        }
	        if (!substringSearch) {
	            output = [
	                '(?=^|',
	                regular_expressions_1.ADDRESS_BOUNDARY,
	                '|[^\\w\\:])(',
	                ...output,
	                ')(?=[^\\w\\:]|',
	                regular_expressions_1.ADDRESS_BOUNDARY,
	                '|$)',
	            ];
	        }
	        return output.join('');
	    }
	    regularExpression(substringSearch = false) {
	        return new RegExp(this.regularExpressionString(substringSearch), 'i');
	    }
	}
	ipv6.Address6 = Address6;
	return ipv6;
}

var hasRequiredIpAddress;

function requireIpAddress () {
	if (hasRequiredIpAddress) return ipAddress;
	hasRequiredIpAddress = 1;
	(function (exports) {
		var __createBinding = (ipAddress && ipAddress.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __setModuleDefault = (ipAddress && ipAddress.__setModuleDefault) || (Object.create ? (function(o, v) {
		    Object.defineProperty(o, "default", { enumerable: true, value: v });
		}) : function(o, v) {
		    o["default"] = v;
		});
		var __importStar = (ipAddress && ipAddress.__importStar) || function (mod) {
		    if (mod && mod.__esModule) return mod;
		    var result = {};
		    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
		    __setModuleDefault(result, mod);
		    return result;
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.v6 = exports.AddressError = exports.Address6 = exports.Address4 = void 0;
		var ipv4_1 = requireIpv4();
		Object.defineProperty(exports, "Address4", { enumerable: true, get: function () { return ipv4_1.Address4; } });
		var ipv6_1 = requireIpv6();
		Object.defineProperty(exports, "Address6", { enumerable: true, get: function () { return ipv6_1.Address6; } });
		var address_error_1 = requireAddressError();
		Object.defineProperty(exports, "AddressError", { enumerable: true, get: function () { return address_error_1.AddressError; } });
		const helpers = __importStar(requireHelpers$1());
		exports.v6 = { helpers }; 
	} (ipAddress));
	return ipAddress;
}

var hasRequiredHelpers;

function requireHelpers () {
	if (hasRequiredHelpers) return helpers$1;
	hasRequiredHelpers = 1;
	Object.defineProperty(helpers$1, "__esModule", { value: true });
	helpers$1.ipToBuffer = helpers$1.int32ToIpv4 = helpers$1.ipv4ToInt32 = helpers$1.validateSocksClientChainOptions = helpers$1.validateSocksClientOptions = void 0;
	const util_1 = requireUtil$2();
	const constants_1 = requireConstants$3();
	const stream = require$$1$3;
	const ip_address_1 = requireIpAddress();
	const net = require$$0$4;
	function validateSocksClientOptions(options, acceptedCommands = ['connect', 'bind', 'associate']) {
	    if (!constants_1.SocksCommand[options.command]) {
	        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksCommand, options);
	    }
	    if (acceptedCommands.indexOf(options.command) === -1) {
	        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksCommandForOperation, options);
	    }
	    if (!isValidSocksRemoteHost(options.destination)) {
	        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsDestination, options);
	    }
	    if (!isValidSocksProxy(options.proxy)) {
	        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsProxy, options);
	    }
	    validateCustomProxyAuth(options.proxy, options);
	    if (options.timeout && !isValidTimeoutValue(options.timeout)) {
	        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsTimeout, options);
	    }
	    if (options.existing_socket &&
	        !(options.existing_socket instanceof stream.Duplex)) {
	        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsExistingSocket, options);
	    }
	}
	helpers$1.validateSocksClientOptions = validateSocksClientOptions;
	function validateSocksClientChainOptions(options) {
	    if (options.command !== 'connect') {
	        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksCommandChain, options);
	    }
	    if (!isValidSocksRemoteHost(options.destination)) {
	        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsDestination, options);
	    }
	    if (!(options.proxies &&
	        Array.isArray(options.proxies) &&
	        options.proxies.length >= 2)) {
	        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsProxiesLength, options);
	    }
	    options.proxies.forEach((proxy) => {
	        if (!isValidSocksProxy(proxy)) {
	            throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsProxy, options);
	        }
	        validateCustomProxyAuth(proxy, options);
	    });
	    if (options.timeout && !isValidTimeoutValue(options.timeout)) {
	        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsTimeout, options);
	    }
	}
	helpers$1.validateSocksClientChainOptions = validateSocksClientChainOptions;
	function validateCustomProxyAuth(proxy, options) {
	    if (proxy.custom_auth_method !== undefined) {
	        if (proxy.custom_auth_method < constants_1.SOCKS5_CUSTOM_AUTH_START ||
	            proxy.custom_auth_method > constants_1.SOCKS5_CUSTOM_AUTH_END) {
	            throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthRange, options);
	        }
	        if (proxy.custom_auth_request_handler === undefined ||
	            typeof proxy.custom_auth_request_handler !== 'function') {
	            throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthOptions, options);
	        }
	        if (proxy.custom_auth_response_size === undefined) {
	            throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthOptions, options);
	        }
	        if (proxy.custom_auth_response_handler === undefined ||
	            typeof proxy.custom_auth_response_handler !== 'function') {
	            throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthOptions, options);
	        }
	    }
	}
	function isValidSocksRemoteHost(remoteHost) {
	    return (remoteHost &&
	        typeof remoteHost.host === 'string' &&
	        Buffer.byteLength(remoteHost.host) < 256 &&
	        typeof remoteHost.port === 'number' &&
	        remoteHost.port >= 0 &&
	        remoteHost.port <= 65535);
	}
	function isValidSocksProxy(proxy) {
	    return (proxy &&
	        (typeof proxy.host === 'string' || typeof proxy.ipaddress === 'string') &&
	        typeof proxy.port === 'number' &&
	        proxy.port >= 0 &&
	        proxy.port <= 65535 &&
	        (proxy.type === 4 || proxy.type === 5));
	}
	function isValidTimeoutValue(value) {
	    return typeof value === 'number' && value > 0;
	}
	function ipv4ToInt32(ip) {
	    const address = new ip_address_1.Address4(ip);
	    return address.toArray().reduce((acc, part) => (acc << 8) + part, 0) >>> 0;
	}
	helpers$1.ipv4ToInt32 = ipv4ToInt32;
	function int32ToIpv4(int32) {
	    const octet1 = (int32 >>> 24) & 0xff;
	    const octet2 = (int32 >>> 16) & 0xff;
	    const octet3 = (int32 >>> 8) & 0xff;
	    const octet4 = int32 & 0xff;
	    return [octet1, octet2, octet3, octet4].join('.');
	}
	helpers$1.int32ToIpv4 = int32ToIpv4;
	function ipToBuffer(ip) {
	    if (net.isIPv4(ip)) {
	        const address = new ip_address_1.Address4(ip);
	        return Buffer.from(address.toArray());
	    }
	    else if (net.isIPv6(ip)) {
	        const address = new ip_address_1.Address6(ip);
	        return Buffer.from(address
	            .canonicalForm()
	            .split(':')
	            .map((segment) => segment.padStart(4, '0'))
	            .join(''), 'hex');
	    }
	    else {
	        throw new Error('Invalid IP address format');
	    }
	}
	helpers$1.ipToBuffer = ipToBuffer;
	return helpers$1;
}

var receivebuffer = {};

var hasRequiredReceivebuffer;

function requireReceivebuffer () {
	if (hasRequiredReceivebuffer) return receivebuffer;
	hasRequiredReceivebuffer = 1;
	Object.defineProperty(receivebuffer, "__esModule", { value: true });
	receivebuffer.ReceiveBuffer = void 0;
	class ReceiveBuffer {
	    constructor(size = 4096) {
	        this.buffer = Buffer.allocUnsafe(size);
	        this.offset = 0;
	        this.originalSize = size;
	    }
	    get length() {
	        return this.offset;
	    }
	    append(data) {
	        if (!Buffer.isBuffer(data)) {
	            throw new Error('Attempted to append a non-buffer instance to ReceiveBuffer.');
	        }
	        if (this.offset + data.length >= this.buffer.length) {
	            const tmp = this.buffer;
	            this.buffer = Buffer.allocUnsafe(Math.max(this.buffer.length + this.originalSize, this.buffer.length + data.length));
	            tmp.copy(this.buffer);
	        }
	        data.copy(this.buffer, this.offset);
	        return (this.offset += data.length);
	    }
	    peek(length) {
	        if (length > this.offset) {
	            throw new Error('Attempted to read beyond the bounds of the managed internal data.');
	        }
	        return this.buffer.slice(0, length);
	    }
	    get(length) {
	        if (length > this.offset) {
	            throw new Error('Attempted to read beyond the bounds of the managed internal data.');
	        }
	        const value = Buffer.allocUnsafe(length);
	        this.buffer.slice(0, length).copy(value);
	        this.buffer.copyWithin(0, length, length + this.offset - length);
	        this.offset -= length;
	        return value;
	    }
	}
	receivebuffer.ReceiveBuffer = ReceiveBuffer;
	return receivebuffer;
}

var hasRequiredSocksclient;

function requireSocksclient () {
	if (hasRequiredSocksclient) return socksclient;
	hasRequiredSocksclient = 1;
	(function (exports) {
		var __awaiter = (socksclient && socksclient.__awaiter) || function (thisArg, _arguments, P, generator) {
		    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
		    return new (P || (P = Promise))(function (resolve, reject) {
		        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
		        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
		        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
		        step((generator = generator.apply(thisArg, _arguments || [])).next());
		    });
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.SocksClientError = exports.SocksClient = void 0;
		const events_1 = require$$0$5;
		const net = require$$0$4;
		const smart_buffer_1 = requireSmartbuffer();
		const constants_1 = requireConstants$3();
		const helpers_1 = requireHelpers();
		const receivebuffer_1 = requireReceivebuffer();
		const util_1 = requireUtil$2();
		Object.defineProperty(exports, "SocksClientError", { enumerable: true, get: function () { return util_1.SocksClientError; } });
		const ip_address_1 = requireIpAddress();
		class SocksClient extends events_1.EventEmitter {
		    constructor(options) {
		        super();
		        this.options = Object.assign({}, options);
		        (0, helpers_1.validateSocksClientOptions)(options);
		        this.setState(constants_1.SocksClientState.Created);
		    }
		    static createConnection(options, callback) {
		        return new Promise((resolve, reject) => {
		            try {
		                (0, helpers_1.validateSocksClientOptions)(options, ['connect']);
		            }
		            catch (err) {
		                if (typeof callback === 'function') {
		                    callback(err);
		                    return resolve(err);
		                }
		                else {
		                    return reject(err);
		                }
		            }
		            const client = new SocksClient(options);
		            client.connect(options.existing_socket);
		            client.once('established', (info) => {
		                client.removeAllListeners();
		                if (typeof callback === 'function') {
		                    callback(null, info);
		                    resolve(info);
		                }
		                else {
		                    resolve(info);
		                }
		            });
		            client.once('error', (err) => {
		                client.removeAllListeners();
		                if (typeof callback === 'function') {
		                    callback(err);
		                    resolve(err);
		                }
		                else {
		                    reject(err);
		                }
		            });
		        });
		    }
		    static createConnectionChain(options, callback) {
		        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
		            try {
		                (0, helpers_1.validateSocksClientChainOptions)(options);
		            }
		            catch (err) {
		                if (typeof callback === 'function') {
		                    callback(err);
		                    return resolve(err);
		                }
		                else {
		                    return reject(err);
		                }
		            }
		            if (options.randomizeChain) {
		                (0, util_1.shuffleArray)(options.proxies);
		            }
		            try {
		                let sock;
		                for (let i = 0; i < options.proxies.length; i++) {
		                    const nextProxy = options.proxies[i];
		                    const nextDestination = i === options.proxies.length - 1
		                        ? options.destination
		                        : {
		                            host: options.proxies[i + 1].host ||
		                                options.proxies[i + 1].ipaddress,
		                            port: options.proxies[i + 1].port,
		                        };
		                    const result = yield SocksClient.createConnection({
		                        command: 'connect',
		                        proxy: nextProxy,
		                        destination: nextDestination,
		                        existing_socket: sock,
		                    });
		                    sock = sock || result.socket;
		                }
		                if (typeof callback === 'function') {
		                    callback(null, { socket: sock });
		                    resolve({ socket: sock });
		                }
		                else {
		                    resolve({ socket: sock });
		                }
		            }
		            catch (err) {
		                if (typeof callback === 'function') {
		                    callback(err);
		                    resolve(err);
		                }
		                else {
		                    reject(err);
		                }
		            }
		        }));
		    }
		    static createUDPFrame(options) {
		        const buff = new smart_buffer_1.SmartBuffer();
		        buff.writeUInt16BE(0);
		        buff.writeUInt8(options.frameNumber || 0);
		        if (net.isIPv4(options.remoteHost.host)) {
		            buff.writeUInt8(constants_1.Socks5HostType.IPv4);
		            buff.writeUInt32BE((0, helpers_1.ipv4ToInt32)(options.remoteHost.host));
		        }
		        else if (net.isIPv6(options.remoteHost.host)) {
		            buff.writeUInt8(constants_1.Socks5HostType.IPv6);
		            buff.writeBuffer((0, helpers_1.ipToBuffer)(options.remoteHost.host));
		        }
		        else {
		            buff.writeUInt8(constants_1.Socks5HostType.Hostname);
		            buff.writeUInt8(Buffer.byteLength(options.remoteHost.host));
		            buff.writeString(options.remoteHost.host);
		        }
		        buff.writeUInt16BE(options.remoteHost.port);
		        buff.writeBuffer(options.data);
		        return buff.toBuffer();
		    }
		    static parseUDPFrame(data) {
		        const buff = smart_buffer_1.SmartBuffer.fromBuffer(data);
		        buff.readOffset = 2;
		        const frameNumber = buff.readUInt8();
		        const hostType = buff.readUInt8();
		        let remoteHost;
		        if (hostType === constants_1.Socks5HostType.IPv4) {
		            remoteHost = (0, helpers_1.int32ToIpv4)(buff.readUInt32BE());
		        }
		        else if (hostType === constants_1.Socks5HostType.IPv6) {
		            remoteHost = ip_address_1.Address6.fromByteArray(Array.from(buff.readBuffer(16))).canonicalForm();
		        }
		        else {
		            remoteHost = buff.readString(buff.readUInt8());
		        }
		        const remotePort = buff.readUInt16BE();
		        return {
		            frameNumber,
		            remoteHost: {
		                host: remoteHost,
		                port: remotePort,
		            },
		            data: buff.readBuffer(),
		        };
		    }
		    setState(newState) {
		        if (this.state !== constants_1.SocksClientState.Error) {
		            this.state = newState;
		        }
		    }
		    connect(existingSocket) {
		        this.onDataReceived = (data) => this.onDataReceivedHandler(data);
		        this.onClose = () => this.onCloseHandler();
		        this.onError = (err) => this.onErrorHandler(err);
		        this.onConnect = () => this.onConnectHandler();
		        const timer = setTimeout(() => this.onEstablishedTimeout(), this.options.timeout || constants_1.DEFAULT_TIMEOUT);
		        if (timer.unref && typeof timer.unref === 'function') {
		            timer.unref();
		        }
		        if (existingSocket) {
		            this.socket = existingSocket;
		        }
		        else {
		            this.socket = new net.Socket();
		        }
		        this.socket.once('close', this.onClose);
		        this.socket.once('error', this.onError);
		        this.socket.once('connect', this.onConnect);
		        this.socket.on('data', this.onDataReceived);
		        this.setState(constants_1.SocksClientState.Connecting);
		        this.receiveBuffer = new receivebuffer_1.ReceiveBuffer();
		        if (existingSocket) {
		            this.socket.emit('connect');
		        }
		        else {
		            this.socket.connect(this.getSocketOptions());
		            if (this.options.set_tcp_nodelay !== undefined &&
		                this.options.set_tcp_nodelay !== null) {
		                this.socket.setNoDelay(!!this.options.set_tcp_nodelay);
		            }
		        }
		        this.prependOnceListener('established', (info) => {
		            setImmediate(() => {
		                if (this.receiveBuffer.length > 0) {
		                    const excessData = this.receiveBuffer.get(this.receiveBuffer.length);
		                    info.socket.emit('data', excessData);
		                }
		                info.socket.resume();
		            });
		        });
		    }
		    getSocketOptions() {
		        return Object.assign(Object.assign({}, this.options.socket_options), { host: this.options.proxy.host || this.options.proxy.ipaddress, port: this.options.proxy.port });
		    }
		    onEstablishedTimeout() {
		        if (this.state !== constants_1.SocksClientState.Established &&
		            this.state !== constants_1.SocksClientState.BoundWaitingForConnection) {
		            this.closeSocket(constants_1.ERRORS.ProxyConnectionTimedOut);
		        }
		    }
		    onConnectHandler() {
		        this.setState(constants_1.SocksClientState.Connected);
		        if (this.options.proxy.type === 4) {
		            this.sendSocks4InitialHandshake();
		        }
		        else {
		            this.sendSocks5InitialHandshake();
		        }
		        this.setState(constants_1.SocksClientState.SentInitialHandshake);
		    }
		    onDataReceivedHandler(data) {
		        this.receiveBuffer.append(data);
		        this.processData();
		    }
		    processData() {
		        while (this.state !== constants_1.SocksClientState.Established &&
		            this.state !== constants_1.SocksClientState.Error &&
		            this.receiveBuffer.length >= this.nextRequiredPacketBufferSize) {
		            if (this.state === constants_1.SocksClientState.SentInitialHandshake) {
		                if (this.options.proxy.type === 4) {
		                    this.handleSocks4FinalHandshakeResponse();
		                }
		                else {
		                    this.handleInitialSocks5HandshakeResponse();
		                }
		            }
		            else if (this.state === constants_1.SocksClientState.SentAuthentication) {
		                this.handleInitialSocks5AuthenticationHandshakeResponse();
		            }
		            else if (this.state === constants_1.SocksClientState.SentFinalHandshake) {
		                this.handleSocks5FinalHandshakeResponse();
		            }
		            else if (this.state === constants_1.SocksClientState.BoundWaitingForConnection) {
		                if (this.options.proxy.type === 4) {
		                    this.handleSocks4IncomingConnectionResponse();
		                }
		                else {
		                    this.handleSocks5IncomingConnectionResponse();
		                }
		            }
		            else {
		                this.closeSocket(constants_1.ERRORS.InternalError);
		                break;
		            }
		        }
		    }
		    onCloseHandler() {
		        this.closeSocket(constants_1.ERRORS.SocketClosed);
		    }
		    onErrorHandler(err) {
		        this.closeSocket(err.message);
		    }
		    removeInternalSocketHandlers() {
		        this.socket.pause();
		        this.socket.removeListener('data', this.onDataReceived);
		        this.socket.removeListener('close', this.onClose);
		        this.socket.removeListener('error', this.onError);
		        this.socket.removeListener('connect', this.onConnect);
		    }
		    closeSocket(err) {
		        if (this.state !== constants_1.SocksClientState.Error) {
		            this.setState(constants_1.SocksClientState.Error);
		            this.socket.destroy();
		            this.removeInternalSocketHandlers();
		            this.emit('error', new util_1.SocksClientError(err, this.options));
		        }
		    }
		    sendSocks4InitialHandshake() {
		        const userId = this.options.proxy.userId || '';
		        const buff = new smart_buffer_1.SmartBuffer();
		        buff.writeUInt8(0x04);
		        buff.writeUInt8(constants_1.SocksCommand[this.options.command]);
		        buff.writeUInt16BE(this.options.destination.port);
		        if (net.isIPv4(this.options.destination.host)) {
		            buff.writeBuffer((0, helpers_1.ipToBuffer)(this.options.destination.host));
		            buff.writeStringNT(userId);
		        }
		        else {
		            buff.writeUInt8(0x00);
		            buff.writeUInt8(0x00);
		            buff.writeUInt8(0x00);
		            buff.writeUInt8(0x01);
		            buff.writeStringNT(userId);
		            buff.writeStringNT(this.options.destination.host);
		        }
		        this.nextRequiredPacketBufferSize =
		            constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks4Response;
		        this.socket.write(buff.toBuffer());
		    }
		    handleSocks4FinalHandshakeResponse() {
		        const data = this.receiveBuffer.get(8);
		        if (data[1] !== constants_1.Socks4Response.Granted) {
		            this.closeSocket(`${constants_1.ERRORS.Socks4ProxyRejectedConnection} - (${constants_1.Socks4Response[data[1]]})`);
		        }
		        else {
		            if (constants_1.SocksCommand[this.options.command] === constants_1.SocksCommand.bind) {
		                const buff = smart_buffer_1.SmartBuffer.fromBuffer(data);
		                buff.readOffset = 2;
		                const remoteHost = {
		                    port: buff.readUInt16BE(),
		                    host: (0, helpers_1.int32ToIpv4)(buff.readUInt32BE()),
		                };
		                if (remoteHost.host === '0.0.0.0') {
		                    remoteHost.host = this.options.proxy.ipaddress;
		                }
		                this.setState(constants_1.SocksClientState.BoundWaitingForConnection);
		                this.emit('bound', { remoteHost, socket: this.socket });
		            }
		            else {
		                this.setState(constants_1.SocksClientState.Established);
		                this.removeInternalSocketHandlers();
		                this.emit('established', { socket: this.socket });
		            }
		        }
		    }
		    handleSocks4IncomingConnectionResponse() {
		        const data = this.receiveBuffer.get(8);
		        if (data[1] !== constants_1.Socks4Response.Granted) {
		            this.closeSocket(`${constants_1.ERRORS.Socks4ProxyRejectedIncomingBoundConnection} - (${constants_1.Socks4Response[data[1]]})`);
		        }
		        else {
		            const buff = smart_buffer_1.SmartBuffer.fromBuffer(data);
		            buff.readOffset = 2;
		            const remoteHost = {
		                port: buff.readUInt16BE(),
		                host: (0, helpers_1.int32ToIpv4)(buff.readUInt32BE()),
		            };
		            this.setState(constants_1.SocksClientState.Established);
		            this.removeInternalSocketHandlers();
		            this.emit('established', { remoteHost, socket: this.socket });
		        }
		    }
		    sendSocks5InitialHandshake() {
		        const buff = new smart_buffer_1.SmartBuffer();
		        const supportedAuthMethods = [constants_1.Socks5Auth.NoAuth];
		        if (this.options.proxy.userId || this.options.proxy.password) {
		            supportedAuthMethods.push(constants_1.Socks5Auth.UserPass);
		        }
		        if (this.options.proxy.custom_auth_method !== undefined) {
		            supportedAuthMethods.push(this.options.proxy.custom_auth_method);
		        }
		        buff.writeUInt8(0x05);
		        buff.writeUInt8(supportedAuthMethods.length);
		        for (const authMethod of supportedAuthMethods) {
		            buff.writeUInt8(authMethod);
		        }
		        this.nextRequiredPacketBufferSize =
		            constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5InitialHandshakeResponse;
		        this.socket.write(buff.toBuffer());
		        this.setState(constants_1.SocksClientState.SentInitialHandshake);
		    }
		    handleInitialSocks5HandshakeResponse() {
		        const data = this.receiveBuffer.get(2);
		        if (data[0] !== 0x05) {
		            this.closeSocket(constants_1.ERRORS.InvalidSocks5IntiailHandshakeSocksVersion);
		        }
		        else if (data[1] === constants_1.SOCKS5_NO_ACCEPTABLE_AUTH) {
		            this.closeSocket(constants_1.ERRORS.InvalidSocks5InitialHandshakeNoAcceptedAuthType);
		        }
		        else {
		            if (data[1] === constants_1.Socks5Auth.NoAuth) {
		                this.socks5ChosenAuthType = constants_1.Socks5Auth.NoAuth;
		                this.sendSocks5CommandRequest();
		            }
		            else if (data[1] === constants_1.Socks5Auth.UserPass) {
		                this.socks5ChosenAuthType = constants_1.Socks5Auth.UserPass;
		                this.sendSocks5UserPassAuthentication();
		            }
		            else if (data[1] === this.options.proxy.custom_auth_method) {
		                this.socks5ChosenAuthType = this.options.proxy.custom_auth_method;
		                this.sendSocks5CustomAuthentication();
		            }
		            else {
		                this.closeSocket(constants_1.ERRORS.InvalidSocks5InitialHandshakeUnknownAuthType);
		            }
		        }
		    }
		    sendSocks5UserPassAuthentication() {
		        const userId = this.options.proxy.userId || '';
		        const password = this.options.proxy.password || '';
		        const buff = new smart_buffer_1.SmartBuffer();
		        buff.writeUInt8(0x01);
		        buff.writeUInt8(Buffer.byteLength(userId));
		        buff.writeString(userId);
		        buff.writeUInt8(Buffer.byteLength(password));
		        buff.writeString(password);
		        this.nextRequiredPacketBufferSize =
		            constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5UserPassAuthenticationResponse;
		        this.socket.write(buff.toBuffer());
		        this.setState(constants_1.SocksClientState.SentAuthentication);
		    }
		    sendSocks5CustomAuthentication() {
		        return __awaiter(this, void 0, void 0, function* () {
		            this.nextRequiredPacketBufferSize =
		                this.options.proxy.custom_auth_response_size;
		            this.socket.write(yield this.options.proxy.custom_auth_request_handler());
		            this.setState(constants_1.SocksClientState.SentAuthentication);
		        });
		    }
		    handleSocks5CustomAuthHandshakeResponse(data) {
		        return __awaiter(this, void 0, void 0, function* () {
		            return yield this.options.proxy.custom_auth_response_handler(data);
		        });
		    }
		    handleSocks5AuthenticationNoAuthHandshakeResponse(data) {
		        return __awaiter(this, void 0, void 0, function* () {
		            return data[1] === 0x00;
		        });
		    }
		    handleSocks5AuthenticationUserPassHandshakeResponse(data) {
		        return __awaiter(this, void 0, void 0, function* () {
		            return data[1] === 0x00;
		        });
		    }
		    handleInitialSocks5AuthenticationHandshakeResponse() {
		        return __awaiter(this, void 0, void 0, function* () {
		            this.setState(constants_1.SocksClientState.ReceivedAuthenticationResponse);
		            let authResult = false;
		            if (this.socks5ChosenAuthType === constants_1.Socks5Auth.NoAuth) {
		                authResult = yield this.handleSocks5AuthenticationNoAuthHandshakeResponse(this.receiveBuffer.get(2));
		            }
		            else if (this.socks5ChosenAuthType === constants_1.Socks5Auth.UserPass) {
		                authResult =
		                    yield this.handleSocks5AuthenticationUserPassHandshakeResponse(this.receiveBuffer.get(2));
		            }
		            else if (this.socks5ChosenAuthType === this.options.proxy.custom_auth_method) {
		                authResult = yield this.handleSocks5CustomAuthHandshakeResponse(this.receiveBuffer.get(this.options.proxy.custom_auth_response_size));
		            }
		            if (!authResult) {
		                this.closeSocket(constants_1.ERRORS.Socks5AuthenticationFailed);
		            }
		            else {
		                this.sendSocks5CommandRequest();
		            }
		        });
		    }
		    sendSocks5CommandRequest() {
		        const buff = new smart_buffer_1.SmartBuffer();
		        buff.writeUInt8(0x05);
		        buff.writeUInt8(constants_1.SocksCommand[this.options.command]);
		        buff.writeUInt8(0x00);
		        if (net.isIPv4(this.options.destination.host)) {
		            buff.writeUInt8(constants_1.Socks5HostType.IPv4);
		            buff.writeBuffer((0, helpers_1.ipToBuffer)(this.options.destination.host));
		        }
		        else if (net.isIPv6(this.options.destination.host)) {
		            buff.writeUInt8(constants_1.Socks5HostType.IPv6);
		            buff.writeBuffer((0, helpers_1.ipToBuffer)(this.options.destination.host));
		        }
		        else {
		            buff.writeUInt8(constants_1.Socks5HostType.Hostname);
		            buff.writeUInt8(this.options.destination.host.length);
		            buff.writeString(this.options.destination.host);
		        }
		        buff.writeUInt16BE(this.options.destination.port);
		        this.nextRequiredPacketBufferSize =
		            constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHeader;
		        this.socket.write(buff.toBuffer());
		        this.setState(constants_1.SocksClientState.SentFinalHandshake);
		    }
		    handleSocks5FinalHandshakeResponse() {
		        const header = this.receiveBuffer.peek(5);
		        if (header[0] !== 0x05 || header[1] !== constants_1.Socks5Response.Granted) {
		            this.closeSocket(`${constants_1.ERRORS.InvalidSocks5FinalHandshakeRejected} - ${constants_1.Socks5Response[header[1]]}`);
		        }
		        else {
		            const addressType = header[3];
		            let remoteHost;
		            let buff;
		            if (addressType === constants_1.Socks5HostType.IPv4) {
		                const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv4;
		                if (this.receiveBuffer.length < dataNeeded) {
		                    this.nextRequiredPacketBufferSize = dataNeeded;
		                    return;
		                }
		                buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));
		                remoteHost = {
		                    host: (0, helpers_1.int32ToIpv4)(buff.readUInt32BE()),
		                    port: buff.readUInt16BE(),
		                };
		                if (remoteHost.host === '0.0.0.0') {
		                    remoteHost.host = this.options.proxy.ipaddress;
		                }
		            }
		            else if (addressType === constants_1.Socks5HostType.Hostname) {
		                const hostLength = header[4];
		                const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHostname(hostLength);
		                if (this.receiveBuffer.length < dataNeeded) {
		                    this.nextRequiredPacketBufferSize = dataNeeded;
		                    return;
		                }
		                buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(5));
		                remoteHost = {
		                    host: buff.readString(hostLength),
		                    port: buff.readUInt16BE(),
		                };
		            }
		            else if (addressType === constants_1.Socks5HostType.IPv6) {
		                const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv6;
		                if (this.receiveBuffer.length < dataNeeded) {
		                    this.nextRequiredPacketBufferSize = dataNeeded;
		                    return;
		                }
		                buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));
		                remoteHost = {
		                    host: ip_address_1.Address6.fromByteArray(Array.from(buff.readBuffer(16))).canonicalForm(),
		                    port: buff.readUInt16BE(),
		                };
		            }
		            this.setState(constants_1.SocksClientState.ReceivedFinalResponse);
		            if (constants_1.SocksCommand[this.options.command] === constants_1.SocksCommand.connect) {
		                this.setState(constants_1.SocksClientState.Established);
		                this.removeInternalSocketHandlers();
		                this.emit('established', { remoteHost, socket: this.socket });
		            }
		            else if (constants_1.SocksCommand[this.options.command] === constants_1.SocksCommand.bind) {
		                this.setState(constants_1.SocksClientState.BoundWaitingForConnection);
		                this.nextRequiredPacketBufferSize =
		                    constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHeader;
		                this.emit('bound', { remoteHost, socket: this.socket });
		            }
		            else if (constants_1.SocksCommand[this.options.command] === constants_1.SocksCommand.associate) {
		                this.setState(constants_1.SocksClientState.Established);
		                this.removeInternalSocketHandlers();
		                this.emit('established', {
		                    remoteHost,
		                    socket: this.socket,
		                });
		            }
		        }
		    }
		    handleSocks5IncomingConnectionResponse() {
		        const header = this.receiveBuffer.peek(5);
		        if (header[0] !== 0x05 || header[1] !== constants_1.Socks5Response.Granted) {
		            this.closeSocket(`${constants_1.ERRORS.Socks5ProxyRejectedIncomingBoundConnection} - ${constants_1.Socks5Response[header[1]]}`);
		        }
		        else {
		            const addressType = header[3];
		            let remoteHost;
		            let buff;
		            if (addressType === constants_1.Socks5HostType.IPv4) {
		                const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv4;
		                if (this.receiveBuffer.length < dataNeeded) {
		                    this.nextRequiredPacketBufferSize = dataNeeded;
		                    return;
		                }
		                buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));
		                remoteHost = {
		                    host: (0, helpers_1.int32ToIpv4)(buff.readUInt32BE()),
		                    port: buff.readUInt16BE(),
		                };
		                if (remoteHost.host === '0.0.0.0') {
		                    remoteHost.host = this.options.proxy.ipaddress;
		                }
		            }
		            else if (addressType === constants_1.Socks5HostType.Hostname) {
		                const hostLength = header[4];
		                const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHostname(hostLength);
		                if (this.receiveBuffer.length < dataNeeded) {
		                    this.nextRequiredPacketBufferSize = dataNeeded;
		                    return;
		                }
		                buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(5));
		                remoteHost = {
		                    host: buff.readString(hostLength),
		                    port: buff.readUInt16BE(),
		                };
		            }
		            else if (addressType === constants_1.Socks5HostType.IPv6) {
		                const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv6;
		                if (this.receiveBuffer.length < dataNeeded) {
		                    this.nextRequiredPacketBufferSize = dataNeeded;
		                    return;
		                }
		                buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));
		                remoteHost = {
		                    host: ip_address_1.Address6.fromByteArray(Array.from(buff.readBuffer(16))).canonicalForm(),
		                    port: buff.readUInt16BE(),
		                };
		            }
		            this.setState(constants_1.SocksClientState.Established);
		            this.removeInternalSocketHandlers();
		            this.emit('established', { remoteHost, socket: this.socket });
		        }
		    }
		    get socksClientOptions() {
		        return Object.assign({}, this.options);
		    }
		}
		exports.SocksClient = SocksClient; 
	} (socksclient));
	return socksclient;
}

var hasRequiredBuild;

function requireBuild () {
	if (hasRequiredBuild) return build;
	hasRequiredBuild = 1;
	(function (exports) {
		var __createBinding = (build && build.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (build && build.__exportStar) || function(m, exports) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		__exportStar(requireSocksclient(), exports); 
	} (build));
	return build;
}

var hasRequiredDist$8;

function requireDist$8 () {
	if (hasRequiredDist$8) return dist$7;
	hasRequiredDist$8 = 1;
	var __createBinding = (dist$7 && dist$7.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (dist$7 && dist$7.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (dist$7 && dist$7.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	var __importDefault = (dist$7 && dist$7.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(dist$7, "__esModule", { value: true });
	dist$7.SocksProxyAgent = void 0;
	const socks_1 = requireBuild();
	const agent_base_1 = requireDist$b();
	const debug_1 = __importDefault(requireSrc());
	const dns = __importStar(require$$3$1);
	const net = __importStar(require$$0$4);
	const tls = __importStar(require$$1$2);
	const url_1 = require$$5;
	const debug = (0, debug_1.default)('socks-proxy-agent');
	const setServernameFromNonIpHost = (options) => {
	    if (options.servername === undefined &&
	        options.host &&
	        !net.isIP(options.host)) {
	        return {
	            ...options,
	            servername: options.host,
	        };
	    }
	    return options;
	};
	function parseSocksURL(url) {
	    let lookup = false;
	    let type = 5;
	    const host = url.hostname;
	    const port = parseInt(url.port, 10) || 1080;
	    switch (url.protocol.replace(':', '')) {
	        case 'socks4':
	            lookup = true;
	            type = 4;
	            break;
	        case 'socks4a':
	            type = 4;
	            break;
	        case 'socks5':
	            lookup = true;
	            type = 5;
	            break;
	        case 'socks':
	            type = 5;
	            break;
	        case 'socks5h':
	            type = 5;
	            break;
	        default:
	            throw new TypeError(`A "socks" protocol must be specified! Got: ${String(url.protocol)}`);
	    }
	    const proxy = {
	        host,
	        port,
	        type,
	    };
	    if (url.username) {
	        Object.defineProperty(proxy, 'userId', {
	            value: decodeURIComponent(url.username),
	            enumerable: false,
	        });
	    }
	    if (url.password != null) {
	        Object.defineProperty(proxy, 'password', {
	            value: decodeURIComponent(url.password),
	            enumerable: false,
	        });
	    }
	    return { lookup, proxy };
	}
	class SocksProxyAgent extends agent_base_1.Agent {
	    constructor(uri, opts) {
	        super(opts);
	        const url = typeof uri === 'string' ? new url_1.URL(uri) : uri;
	        const { proxy, lookup } = parseSocksURL(url);
	        this.shouldLookup = lookup;
	        this.proxy = proxy;
	        this.timeout = opts?.timeout ?? null;
	        this.socketOptions = opts?.socketOptions ?? null;
	    }
	    async connect(req, opts) {
	        const { shouldLookup, proxy, timeout } = this;
	        if (!opts.host) {
	            throw new Error('No `host` defined!');
	        }
	        let { host } = opts;
	        const { port, lookup: lookupFn = dns.lookup } = opts;
	        if (shouldLookup) {
	            host = await new Promise((resolve, reject) => {
	                lookupFn(host, {}, (err, res) => {
	                    if (err) {
	                        reject(err);
	                    }
	                    else {
	                        resolve(res);
	                    }
	                });
	            });
	        }
	        const socksOpts = {
	            proxy,
	            destination: {
	                host,
	                port: typeof port === 'number' ? port : parseInt(port, 10),
	            },
	            command: 'connect',
	            timeout: timeout ?? undefined,
	            socket_options: this.socketOptions ?? undefined,
	        };
	        const cleanup = (tlsSocket) => {
	            req.destroy();
	            socket.destroy();
	            if (tlsSocket)
	                tlsSocket.destroy();
	        };
	        debug('Creating socks proxy connection: %o', socksOpts);
	        const { socket } = await socks_1.SocksClient.createConnection(socksOpts);
	        debug('Successfully created socks proxy connection');
	        if (timeout !== null) {
	            socket.setTimeout(timeout);
	            socket.on('timeout', () => cleanup());
	        }
	        if (opts.secureEndpoint) {
	            debug('Upgrading socket connection to TLS');
	            const tlsSocket = tls.connect({
	                ...omit(setServernameFromNonIpHost(opts), 'host', 'path', 'port'),
	                socket,
	            });
	            tlsSocket.once('error', (error) => {
	                debug('Socket TLS error', error.message);
	                cleanup(tlsSocket);
	            });
	            return tlsSocket;
	        }
	        return socket;
	    }
	}
	SocksProxyAgent.protocols = [
	    'socks',
	    'socks4',
	    'socks4a',
	    'socks5',
	    'socks5h',
	];
	dist$7.SocksProxyAgent = SocksProxyAgent;
	function omit(obj, ...keys) {
	    const ret = {};
	    let key;
	    for (key in obj) {
	        if (!keys.includes(key)) {
	            ret[key] = obj[key];
	        }
	    }
	    return ret;
	}
	return dist$7;
}

var dist$6 = {};

var dist$5 = {};

var data = {};

var dist$4 = {};

var common = {};

var hasRequiredCommon;

function requireCommon () {
	if (hasRequiredCommon) return common;
	hasRequiredCommon = 1;
	Object.defineProperty(common, "__esModule", { value: true });
	common.makeDataUriToBuffer = void 0;
	const makeDataUriToBuffer = (convert) => (uri) => {
	    uri = String(uri);
	    if (!/^data:/i.test(uri)) {
	        throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
	    }
	    uri = uri.replace(/\r?\n/g, '');
	    const firstComma = uri.indexOf(',');
	    if (firstComma === -1 || firstComma <= 4) {
	        throw new TypeError('malformed data: URI');
	    }
	    const meta = uri.substring(5, firstComma).split(';');
	    let charset = '';
	    let base64 = false;
	    const type = meta[0] || 'text/plain';
	    let typeFull = type;
	    for (let i = 1; i < meta.length; i++) {
	        if (meta[i] === 'base64') {
	            base64 = true;
	        }
	        else if (meta[i]) {
	            typeFull += `;${meta[i]}`;
	            if (meta[i].indexOf('charset=') === 0) {
	                charset = meta[i].substring(8);
	            }
	        }
	    }
	    if (!meta[0] && !charset.length) {
	        typeFull += ';charset=US-ASCII';
	        charset = 'US-ASCII';
	    }
	    const data = unescape(uri.substring(firstComma + 1));
	    const buffer = base64 ? convert.base64ToArrayBuffer(data) : convert.stringToBuffer(data);
	    return {
	        type,
	        typeFull,
	        charset,
	        buffer,
	    };
	};
	common.makeDataUriToBuffer = makeDataUriToBuffer;
	return common;
}

var hasRequiredDist$7;

function requireDist$7 () {
	if (hasRequiredDist$7) return dist$4;
	hasRequiredDist$7 = 1;
	Object.defineProperty(dist$4, "__esModule", { value: true });
	dist$4.dataUriToBuffer = void 0;
	const common_1 = requireCommon();
	function base64ToArrayBuffer(base64) {
	    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
	    const bytes = [];
	    for (let i = 0; i < base64.length; i += 4) {
	        const idx0 = chars.indexOf(base64.charAt(i));
	        const idx1 = chars.indexOf(base64.charAt(i + 1));
	        const idx2 = base64.charAt(i + 2) === '='
	            ? 0
	            : chars.indexOf(base64.charAt(i + 2));
	        const idx3 = base64.charAt(i + 3) === '='
	            ? 0
	            : chars.indexOf(base64.charAt(i + 3));
	        const bin0 = (idx0 << 2) | (idx1 >> 4);
	        const bin1 = ((idx1 & 15) << 4) | (idx2 >> 2);
	        const bin2 = ((idx2 & 3) << 6) | idx3;
	        bytes.push(bin0);
	        if (base64.charAt(i + 2) !== '=')
	            bytes.push(bin1);
	        if (base64.charAt(i + 3) !== '=')
	            bytes.push(bin2);
	    }
	    const buffer = new ArrayBuffer(bytes.length);
	    const view = new Uint8Array(buffer);
	    view.set(bytes);
	    return buffer;
	}
	function stringToBuffer(str) {
	    const buffer = new ArrayBuffer(str.length);
	    const view = new Uint8Array(buffer);
	    for (let i = 0; i < str.length; i++) {
	        view[i] = str.charCodeAt(i);
	    }
	    return buffer;
	}
	dist$4.dataUriToBuffer = (0, common_1.makeDataUriToBuffer)({ stringToBuffer, base64ToArrayBuffer });
	return dist$4;
}

var notmodified = {};

var hasRequiredNotmodified;

function requireNotmodified () {
	if (hasRequiredNotmodified) return notmodified;
	hasRequiredNotmodified = 1;
	Object.defineProperty(notmodified, "__esModule", { value: true });
	class NotModifiedError extends Error {
	    constructor(message) {
	        super(message ||
	            'Source has not been modified since the provied "cache", re-use previous results');
	        this.code = 'ENOTMODIFIED';
	    }
	}
	notmodified.default = NotModifiedError;
	return notmodified;
}

var hasRequiredData;

function requireData () {
	if (hasRequiredData) return data;
	hasRequiredData = 1;
	var __importDefault = (data && data.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(data, "__esModule", { value: true });
	data.data = void 0;
	const debug_1 = __importDefault(requireSrc());
	const stream_1 = require$$1$3;
	const crypto_1 = require$$2$1;
	const data_uri_to_buffer_1 = requireDist$7();
	const notmodified_1 = __importDefault(requireNotmodified());
	const debug = (0, debug_1.default)('get-uri:data');
	class DataReadable extends stream_1.Readable {
	    constructor(hash, buf) {
	        super();
	        this.push(buf);
	        this.push(null);
	        this.hash = hash;
	    }
	}
	const data$1 = async ({ href: uri }, { cache } = {}) => {
	    const shasum = (0, crypto_1.createHash)('sha1');
	    shasum.update(uri);
	    const hash = shasum.digest('hex');
	    debug('generated SHA1 hash for "data:" URI: %o', hash);
	    if (cache?.hash === hash) {
	        debug('got matching cache SHA1 hash: %o', hash);
	        throw new notmodified_1.default();
	    }
	    else {
	        debug('creating Readable stream from "data:" URI buffer');
	        const { buffer } = (0, data_uri_to_buffer_1.dataUriToBuffer)(uri);
	        return new DataReadable(hash, Buffer.from(buffer));
	    }
	};
	data.data = data$1;
	return data;
}

var file = {};

var notfound = {};

var hasRequiredNotfound;

function requireNotfound () {
	if (hasRequiredNotfound) return notfound;
	hasRequiredNotfound = 1;
	Object.defineProperty(notfound, "__esModule", { value: true });
	class NotFoundError extends Error {
	    constructor(message) {
	        super(message || 'File does not exist at the specified endpoint');
	        this.code = 'ENOTFOUND';
	    }
	}
	notfound.default = NotFoundError;
	return notfound;
}

var hasRequiredFile;

function requireFile () {
	if (hasRequiredFile) return file;
	hasRequiredFile = 1;
	var __importDefault = (file && file.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(file, "__esModule", { value: true });
	file.file = void 0;
	const debug_1 = __importDefault(requireSrc());
	const fs_1 = require$$0$7;
	const notfound_1 = __importDefault(requireNotfound());
	const notmodified_1 = __importDefault(requireNotmodified());
	const url_1 = require$$5;
	const debug = (0, debug_1.default)('get-uri:file');
	const file$1 = async ({ href: uri }, opts = {}) => {
	    const { cache, flags = 'r', mode = 438,
	     } = opts;
	    try {
	        const filepath = (0, url_1.fileURLToPath)(uri);
	        debug('Normalized pathname: %o', filepath);
	        const fdHandle = await fs_1.promises.open(filepath, flags, mode);
	        const fd = fdHandle.fd;
	        const stat = await fdHandle.stat();
	        if (cache && cache.stat && stat && isNotModified(cache.stat, stat)) {
	            await fdHandle.close();
	            throw new notmodified_1.default();
	        }
	        const rs = (0, fs_1.createReadStream)(filepath, {
	            autoClose: true,
	            ...opts,
	            fd,
	        });
	        rs.stat = stat;
	        return rs;
	    }
	    catch (err) {
	        if (err.code === 'ENOENT') {
	            throw new notfound_1.default();
	        }
	        throw err;
	    }
	};
	file.file = file$1;
	function isNotModified(prev, curr) {
	    return +prev.mtime === +curr.mtime;
	}
	return file;
}

var ftp = {};

var dist$3 = {};

var Client = {};

var FtpContext = {};

var parseControlResponse = {};

var hasRequiredParseControlResponse;

function requireParseControlResponse () {
	if (hasRequiredParseControlResponse) return parseControlResponse;
	hasRequiredParseControlResponse = 1;
	Object.defineProperty(parseControlResponse, "__esModule", { value: true });
	parseControlResponse.positiveIntermediate = parseControlResponse.positiveCompletion = parseControlResponse.isMultiline = parseControlResponse.isSingleLine = parseControlResponse.parseControlResponse = void 0;
	const LF = "\n";
	function parseControlResponse$1(text) {
	    const lines = text.split(/\r?\n/).filter(isNotBlank);
	    const messages = [];
	    let startAt = 0;
	    let tokenRegex;
	    for (let i = 0; i < lines.length; i++) {
	        const line = lines[i];
	        if (!tokenRegex) {
	            if (isMultiline(line)) {
	                const token = line.substr(0, 3);
	                tokenRegex = new RegExp(`^${token}(?:$| )`);
	                startAt = i;
	            }
	            else if (isSingleLine(line)) {
	                messages.push(line);
	            }
	        }
	        else if (tokenRegex.test(line)) {
	            tokenRegex = undefined;
	            messages.push(lines.slice(startAt, i + 1).join(LF));
	        }
	    }
	    const rest = tokenRegex ? lines.slice(startAt).join(LF) + LF : "";
	    return { messages, rest };
	}
	parseControlResponse.parseControlResponse = parseControlResponse$1;
	function isSingleLine(line) {
	    return /^\d\d\d(?:$| )/.test(line);
	}
	parseControlResponse.isSingleLine = isSingleLine;
	function isMultiline(line) {
	    return /^\d\d\d-/.test(line);
	}
	parseControlResponse.isMultiline = isMultiline;
	function positiveCompletion(code) {
	    return code >= 200 && code < 300;
	}
	parseControlResponse.positiveCompletion = positiveCompletion;
	function positiveIntermediate(code) {
	    return code >= 300 && code < 400;
	}
	parseControlResponse.positiveIntermediate = positiveIntermediate;
	function isNotBlank(str) {
	    return str.trim() !== "";
	}
	return parseControlResponse;
}

var hasRequiredFtpContext;

function requireFtpContext () {
	if (hasRequiredFtpContext) return FtpContext;
	hasRequiredFtpContext = 1;
	Object.defineProperty(FtpContext, "__esModule", { value: true });
	FtpContext.FTPContext = FtpContext.FTPError = void 0;
	const net_1 = require$$0$4;
	const parseControlResponse_1 = requireParseControlResponse();
	class FTPError extends Error {
	    constructor(res) {
	        super(res.message);
	        this.name = this.constructor.name;
	        this.code = res.code;
	    }
	}
	FtpContext.FTPError = FTPError;
	function doNothing() {
	}
	class FTPContext {
	    constructor(timeout = 0, encoding = "utf8") {
	        this.timeout = timeout;
	        this.verbose = false;
	        this.ipFamily = undefined;
	        this.tlsOptions = {};
	        this._partialResponse = "";
	        this._encoding = encoding;
	        this._socket = this.socket = this._newSocket();
	        this._dataSocket = undefined;
	    }
	    close() {
	        const message = this._task ? "User closed client during task" : "User closed client";
	        const err = new Error(message);
	        this.closeWithError(err);
	    }
	    closeWithError(err) {
	        if (this._closingError) {
	            return;
	        }
	        this._closingError = err;
	        this._closeControlSocket();
	        this._closeSocket(this._dataSocket);
	        this._passToHandler(err);
	        this._stopTrackingTask();
	    }
	    get closed() {
	        return this.socket.remoteAddress === undefined || this._closingError !== undefined;
	    }
	    reset() {
	        this.socket = this._newSocket();
	    }
	    get socket() {
	        return this._socket;
	    }
	    set socket(socket) {
	        this.dataSocket = undefined;
	        this.tlsOptions = {};
	        this._partialResponse = "";
	        if (this._socket) {
	            const newSocketUpgradesExisting = socket.localPort === this._socket.localPort;
	            if (newSocketUpgradesExisting) {
	                this._removeSocketListeners(this.socket);
	            }
	            else {
	                this._closeControlSocket();
	            }
	        }
	        if (socket) {
	            this._closingError = undefined;
	            socket.setTimeout(0);
	            socket.setEncoding(this._encoding);
	            socket.setKeepAlive(true);
	            socket.on("data", data => this._onControlSocketData(data));
	            socket.on("end", () => this.closeWithError(new Error("Server sent FIN packet unexpectedly, closing connection.")));
	            socket.on("close", hadError => { if (!hadError)
	                this.closeWithError(new Error("Server closed connection unexpectedly.")); });
	            this._setupDefaultErrorHandlers(socket, "control socket");
	        }
	        this._socket = socket;
	    }
	    get dataSocket() {
	        return this._dataSocket;
	    }
	    set dataSocket(socket) {
	        this._closeSocket(this._dataSocket);
	        if (socket) {
	            socket.setTimeout(0);
	            this._setupDefaultErrorHandlers(socket, "data socket");
	        }
	        this._dataSocket = socket;
	    }
	    get encoding() {
	        return this._encoding;
	    }
	    set encoding(encoding) {
	        this._encoding = encoding;
	        if (this.socket) {
	            this.socket.setEncoding(encoding);
	        }
	    }
	    send(command) {
	        const containsPassword = command.startsWith("PASS");
	        const message = containsPassword ? "> PASS ###" : `> ${command}`;
	        this.log(message);
	        this._socket.write(command + "\r\n", this.encoding);
	    }
	    request(command) {
	        return this.handle(command, (res, task) => {
	            if (res instanceof Error) {
	                task.reject(res);
	            }
	            else {
	                task.resolve(res);
	            }
	        });
	    }
	    handle(command, responseHandler) {
	        if (this._task) {
	            const err = new Error("User launched a task while another one is still running. Forgot to use 'await' or '.then()'?");
	            err.stack += `\nRunning task launched at: ${this._task.stack}`;
	            this.closeWithError(err);
	        }
	        return new Promise((resolveTask, rejectTask) => {
	            this._task = {
	                stack: new Error().stack || "Unknown call stack",
	                responseHandler,
	                resolver: {
	                    resolve: arg => {
	                        this._stopTrackingTask();
	                        resolveTask(arg);
	                    },
	                    reject: err => {
	                        this._stopTrackingTask();
	                        rejectTask(err);
	                    }
	                }
	            };
	            if (this._closingError) {
	                const err = new Error(`Client is closed because ${this._closingError.message}`);
	                err.stack += `\nClosing reason: ${this._closingError.stack}`;
	                err.code = this._closingError.code !== undefined ? this._closingError.code : "0";
	                this._passToHandler(err);
	                return;
	            }
	            this.socket.setTimeout(this.timeout);
	            if (command) {
	                this.send(command);
	            }
	        });
	    }
	    log(message) {
	        if (this.verbose) {
	            console.log(message);
	        }
	    }
	    get hasTLS() {
	        return "encrypted" in this._socket;
	    }
	    _stopTrackingTask() {
	        this.socket.setTimeout(0);
	        this._task = undefined;
	    }
	    _onControlSocketData(chunk) {
	        this.log(`< ${chunk}`);
	        const completeResponse = this._partialResponse + chunk;
	        const parsed = (0, parseControlResponse_1.parseControlResponse)(completeResponse);
	        this._partialResponse = parsed.rest;
	        for (const message of parsed.messages) {
	            const code = parseInt(message.substr(0, 3), 10);
	            const response = { code, message };
	            const err = code >= 400 ? new FTPError(response) : undefined;
	            this._passToHandler(err ? err : response);
	        }
	    }
	    _passToHandler(response) {
	        if (this._task) {
	            this._task.responseHandler(response, this._task.resolver);
	        }
	    }
	    _setupDefaultErrorHandlers(socket, identifier) {
	        socket.once("error", error => {
	            error.message += ` (${identifier})`;
	            this.closeWithError(error);
	        });
	        socket.once("close", hadError => {
	            if (hadError) {
	                this.closeWithError(new Error(`Socket closed due to transmission error (${identifier})`));
	            }
	        });
	        socket.once("timeout", () => {
	            socket.destroy();
	            this.closeWithError(new Error(`Timeout (${identifier})`));
	        });
	    }
	    _closeControlSocket() {
	        this._removeSocketListeners(this._socket);
	        this._socket.on("error", doNothing);
	        this.send("QUIT");
	        this._closeSocket(this._socket);
	    }
	    _closeSocket(socket) {
	        if (socket) {
	            this._removeSocketListeners(socket);
	            socket.on("error", doNothing);
	            socket.destroy();
	        }
	    }
	    _removeSocketListeners(socket) {
	        socket.removeAllListeners();
	        socket.removeAllListeners("timeout");
	        socket.removeAllListeners("data");
	        socket.removeAllListeners("end");
	        socket.removeAllListeners("error");
	        socket.removeAllListeners("close");
	        socket.removeAllListeners("connect");
	    }
	    _newSocket() {
	        return new net_1.Socket();
	    }
	}
	FtpContext.FTPContext = FTPContext;
	return FtpContext;
}

var parseList = {};

var parseListDOS = {};

var FileInfo = {};

var hasRequiredFileInfo;

function requireFileInfo () {
	if (hasRequiredFileInfo) return FileInfo;
	hasRequiredFileInfo = 1;
	Object.defineProperty(FileInfo, "__esModule", { value: true });
	FileInfo.FileInfo = FileInfo.FileType = void 0;
	var FileType;
	(function (FileType) {
	    FileType[FileType["Unknown"] = 0] = "Unknown";
	    FileType[FileType["File"] = 1] = "File";
	    FileType[FileType["Directory"] = 2] = "Directory";
	    FileType[FileType["SymbolicLink"] = 3] = "SymbolicLink";
	})(FileType || (FileInfo.FileType = FileType = {}));
	let FileInfo$1 = class FileInfo {
	    constructor(name) {
	        this.name = name;
	        this.type = FileType.Unknown;
	        this.size = 0;
	        this.rawModifiedAt = "";
	        this.modifiedAt = undefined;
	        this.permissions = undefined;
	        this.hardLinkCount = undefined;
	        this.link = undefined;
	        this.group = undefined;
	        this.user = undefined;
	        this.uniqueID = undefined;
	        this.name = name;
	    }
	    get isDirectory() {
	        return this.type === FileType.Directory;
	    }
	    get isSymbolicLink() {
	        return this.type === FileType.SymbolicLink;
	    }
	    get isFile() {
	        return this.type === FileType.File;
	    }
	    get date() {
	        return this.rawModifiedAt;
	    }
	    set date(rawModifiedAt) {
	        this.rawModifiedAt = rawModifiedAt;
	    }
	};
	FileInfo.FileInfo = FileInfo$1;
	FileInfo$1.UnixPermission = {
	    Read: 4,
	    Write: 2,
	    Execute: 1
	};
	return FileInfo;
}

var hasRequiredParseListDOS;

function requireParseListDOS () {
	if (hasRequiredParseListDOS) return parseListDOS;
	hasRequiredParseListDOS = 1;
	Object.defineProperty(parseListDOS, "__esModule", { value: true });
	parseListDOS.transformList = parseListDOS.parseLine = parseListDOS.testLine = void 0;
	const FileInfo_1 = requireFileInfo();
	const RE_LINE = new RegExp("(\\S+)\\s+(\\S+)\\s+"
	    + "(?:(<DIR>)|([0-9]+))\\s+"
	    + "(\\S.*)"
	);
	function testLine(line) {
	    return /^\d{2}/.test(line) && RE_LINE.test(line);
	}
	parseListDOS.testLine = testLine;
	function parseLine(line) {
	    const groups = line.match(RE_LINE);
	    if (groups === null) {
	        return undefined;
	    }
	    const name = groups[5];
	    if (name === "." || name === "..") {
	        return undefined;
	    }
	    const file = new FileInfo_1.FileInfo(name);
	    const fileType = groups[3];
	    if (fileType === "<DIR>") {
	        file.type = FileInfo_1.FileType.Directory;
	        file.size = 0;
	    }
	    else {
	        file.type = FileInfo_1.FileType.File;
	        file.size = parseInt(groups[4], 10);
	    }
	    file.rawModifiedAt = groups[1] + " " + groups[2];
	    return file;
	}
	parseListDOS.parseLine = parseLine;
	function transformList(files) {
	    return files;
	}
	parseListDOS.transformList = transformList;
	return parseListDOS;
}

var parseListUnix = {};

var hasRequiredParseListUnix;

function requireParseListUnix () {
	if (hasRequiredParseListUnix) return parseListUnix;
	hasRequiredParseListUnix = 1;
	Object.defineProperty(parseListUnix, "__esModule", { value: true });
	parseListUnix.transformList = parseListUnix.parseLine = parseListUnix.testLine = void 0;
	const FileInfo_1 = requireFileInfo();
	const JA_MONTH = "\u6708";
	const JA_DAY = "\u65e5";
	const JA_YEAR = "\u5e74";
	const RE_LINE = new RegExp("([bcdelfmpSs-])"
	    + "(((r|-)(w|-)([xsStTL-]))((r|-)(w|-)([xsStTL-]))((r|-)(w|-)([xsStTL-]?)))\\+?"
	    + "\\s*"
	    + "(\\d+)"
	    + "\\s+"
	    + "(?:(\\S+(?:\\s\\S+)*?)\\s+)?"
	    + "(?:(\\S+(?:\\s\\S+)*)\\s+)?"
	    + "(\\d+(?:,\\s*\\d+)?)"
	    + "\\s+"
	    + "(" +
	    "(?:\\d+[-/]\\d+[-/]\\d+)" +
	    "|(?:\\S{3}\\s+\\d{1,2})" +
	    "|(?:\\d{1,2}\\s+\\S{3})" +
	    "|(?:\\d{1,2}" + JA_MONTH + "\\s+\\d{1,2}" + JA_DAY + ")" +
	    ")"
	    + "\\s+"
	    + "((?:\\d+(?::\\d+)?)|(?:\\d{4}" + JA_YEAR + "))"
	    + "\\s"
	    + "(.*)");
	function testLine(line) {
	    return RE_LINE.test(line);
	}
	parseListUnix.testLine = testLine;
	function parseLine(line) {
	    const groups = line.match(RE_LINE);
	    if (groups === null) {
	        return undefined;
	    }
	    const name = groups[21];
	    if (name === "." || name === "..") {
	        return undefined;
	    }
	    const file = new FileInfo_1.FileInfo(name);
	    file.size = parseInt(groups[18], 10);
	    file.user = groups[16];
	    file.group = groups[17];
	    file.hardLinkCount = parseInt(groups[15], 10);
	    file.rawModifiedAt = groups[19] + " " + groups[20];
	    file.permissions = {
	        user: parseMode(groups[4], groups[5], groups[6]),
	        group: parseMode(groups[8], groups[9], groups[10]),
	        world: parseMode(groups[12], groups[13], groups[14]),
	    };
	    switch (groups[1].charAt(0)) {
	        case "d":
	            file.type = FileInfo_1.FileType.Directory;
	            break;
	        case "e":
	            file.type = FileInfo_1.FileType.SymbolicLink;
	            break;
	        case "l":
	            file.type = FileInfo_1.FileType.SymbolicLink;
	            break;
	        case "b":
	        case "c":
	            file.type = FileInfo_1.FileType.File;
	            break;
	        case "f":
	        case "-":
	            file.type = FileInfo_1.FileType.File;
	            break;
	        default:
	            file.type = FileInfo_1.FileType.Unknown;
	    }
	    if (file.isSymbolicLink) {
	        const end = name.indexOf(" -> ");
	        if (end !== -1) {
	            file.name = name.substring(0, end);
	            file.link = name.substring(end + 4);
	        }
	    }
	    return file;
	}
	parseListUnix.parseLine = parseLine;
	function transformList(files) {
	    return files;
	}
	parseListUnix.transformList = transformList;
	function parseMode(r, w, x) {
	    let value = 0;
	    if (r !== "-") {
	        value += FileInfo_1.FileInfo.UnixPermission.Read;
	    }
	    if (w !== "-") {
	        value += FileInfo_1.FileInfo.UnixPermission.Write;
	    }
	    const execToken = x.charAt(0);
	    if (execToken !== "-" && execToken.toUpperCase() !== execToken) {
	        value += FileInfo_1.FileInfo.UnixPermission.Execute;
	    }
	    return value;
	}
	return parseListUnix;
}

var parseListMLSD = {};

var hasRequiredParseListMLSD;

function requireParseListMLSD () {
	if (hasRequiredParseListMLSD) return parseListMLSD;
	hasRequiredParseListMLSD = 1;
	Object.defineProperty(parseListMLSD, "__esModule", { value: true });
	parseListMLSD.parseMLSxDate = parseListMLSD.transformList = parseListMLSD.parseLine = parseListMLSD.testLine = void 0;
	const FileInfo_1 = requireFileInfo();
	function parseSize(value, info) {
	    info.size = parseInt(value, 10);
	}
	const factHandlersByName = {
	    "size": parseSize,
	    "sizd": parseSize,
	    "unique": (value, info) => {
	        info.uniqueID = value;
	    },
	    "modify": (value, info) => {
	        info.modifiedAt = parseMLSxDate(value);
	        info.rawModifiedAt = info.modifiedAt.toISOString();
	    },
	    "type": (value, info) => {
	        if (value.startsWith("OS.unix=slink")) {
	            info.type = FileInfo_1.FileType.SymbolicLink;
	            info.link = value.substr(value.indexOf(":") + 1);
	            return 1 ;
	        }
	        switch (value) {
	            case "file":
	                info.type = FileInfo_1.FileType.File;
	                break;
	            case "dir":
	                info.type = FileInfo_1.FileType.Directory;
	                break;
	            case "OS.unix=symlink":
	                info.type = FileInfo_1.FileType.SymbolicLink;
	                break;
	            case "cdir":
	            case "pdir":
	                return 2 ;
	            default:
	                info.type = FileInfo_1.FileType.Unknown;
	        }
	        return 1 ;
	    },
	    "unix.mode": (value, info) => {
	        const digits = value.substr(-3);
	        info.permissions = {
	            user: parseInt(digits[0], 10),
	            group: parseInt(digits[1], 10),
	            world: parseInt(digits[2], 10)
	        };
	    },
	    "unix.ownername": (value, info) => {
	        info.user = value;
	    },
	    "unix.owner": (value, info) => {
	        if (info.user === undefined)
	            info.user = value;
	    },
	    get "unix.uid"() {
	        return this["unix.owner"];
	    },
	    "unix.groupname": (value, info) => {
	        info.group = value;
	    },
	    "unix.group": (value, info) => {
	        if (info.group === undefined)
	            info.group = value;
	    },
	    get "unix.gid"() {
	        return this["unix.group"];
	    }
	};
	function splitStringOnce(str, delimiter) {
	    const pos = str.indexOf(delimiter);
	    const a = str.substr(0, pos);
	    const b = str.substr(pos + delimiter.length);
	    return [a, b];
	}
	function testLine(line) {
	    return /^\S+=\S+;/.test(line) || line.startsWith(" ");
	}
	parseListMLSD.testLine = testLine;
	function parseLine(line) {
	    const [packedFacts, name] = splitStringOnce(line, " ");
	    if (name === "" || name === "." || name === "..") {
	        return undefined;
	    }
	    const info = new FileInfo_1.FileInfo(name);
	    const facts = packedFacts.split(";");
	    for (const fact of facts) {
	        const [factName, factValue] = splitStringOnce(fact, "=");
	        if (!factValue) {
	            continue;
	        }
	        const factHandler = factHandlersByName[factName.toLowerCase()];
	        if (!factHandler) {
	            continue;
	        }
	        const result = factHandler(factValue, info);
	        if (result === 2 ) {
	            return undefined;
	        }
	    }
	    return info;
	}
	parseListMLSD.parseLine = parseLine;
	function transformList(files) {
	    const nonLinksByID = new Map();
	    for (const file of files) {
	        if (!file.isSymbolicLink && file.uniqueID !== undefined) {
	            nonLinksByID.set(file.uniqueID, file);
	        }
	    }
	    const resolvedFiles = [];
	    for (const file of files) {
	        if (file.isSymbolicLink && file.uniqueID !== undefined && file.link === undefined) {
	            const target = nonLinksByID.get(file.uniqueID);
	            if (target !== undefined) {
	                file.link = target.name;
	            }
	        }
	        const isPartOfDirectory = !file.name.includes("/");
	        if (isPartOfDirectory) {
	            resolvedFiles.push(file);
	        }
	    }
	    return resolvedFiles;
	}
	parseListMLSD.transformList = transformList;
	function parseMLSxDate(fact) {
	    return new Date(Date.UTC(+fact.slice(0, 4),
	    +fact.slice(4, 6) - 1,
	    +fact.slice(6, 8),
	    +fact.slice(8, 10),
	    +fact.slice(10, 12),
	    +fact.slice(12, 14),
	    +fact.slice(15, 18)
	    ));
	}
	parseListMLSD.parseMLSxDate = parseMLSxDate;
	return parseListMLSD;
}

var hasRequiredParseList;

function requireParseList () {
	if (hasRequiredParseList) return parseList;
	hasRequiredParseList = 1;
	var __createBinding = (parseList && parseList.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (parseList && parseList.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (parseList && parseList.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(parseList, "__esModule", { value: true });
	parseList.parseList = void 0;
	const dosParser = __importStar(requireParseListDOS());
	const unixParser = __importStar(requireParseListUnix());
	const mlsdParser = __importStar(requireParseListMLSD());
	const availableParsers = [
	    dosParser,
	    unixParser,
	    mlsdParser
	];
	function firstCompatibleParser(line, parsers) {
	    return parsers.find(parser => parser.testLine(line) === true);
	}
	function isNotBlank(str) {
	    return str.trim() !== "";
	}
	function isNotMeta(str) {
	    return !str.startsWith("total");
	}
	const REGEX_NEWLINE = /\r?\n/;
	function parseList$1(rawList) {
	    const lines = rawList
	        .split(REGEX_NEWLINE)
	        .filter(isNotBlank)
	        .filter(isNotMeta);
	    if (lines.length === 0) {
	        return [];
	    }
	    const testLine = lines[lines.length - 1];
	    const parser = firstCompatibleParser(testLine, availableParsers);
	    if (!parser) {
	        throw new Error("This library only supports MLSD, Unix- or DOS-style directory listing. Your FTP server seems to be using another format. You can see the transmitted listing when setting `client.ftp.verbose = true`. You can then provide a custom parser to `client.parseList`, see the documentation for details.");
	    }
	    const files = lines
	        .map(parser.parseLine)
	        .filter((info) => info !== undefined);
	    return parser.transformList(files);
	}
	parseList.parseList = parseList$1;
	return parseList;
}

var ProgressTracker = {};

var hasRequiredProgressTracker;

function requireProgressTracker () {
	if (hasRequiredProgressTracker) return ProgressTracker;
	hasRequiredProgressTracker = 1;
	Object.defineProperty(ProgressTracker, "__esModule", { value: true });
	ProgressTracker.ProgressTracker = void 0;
	let ProgressTracker$1 = class ProgressTracker {
	    constructor() {
	        this.bytesOverall = 0;
	        this.intervalMs = 500;
	        this.onStop = noop;
	        this.onHandle = noop;
	    }
	    reportTo(onHandle = noop) {
	        this.onHandle = onHandle;
	    }
	    start(socket, name, type) {
	        let lastBytes = 0;
	        this.onStop = poll(this.intervalMs, () => {
	            const bytes = socket.bytesRead + socket.bytesWritten;
	            this.bytesOverall += bytes - lastBytes;
	            lastBytes = bytes;
	            this.onHandle({
	                name,
	                type,
	                bytes,
	                bytesOverall: this.bytesOverall
	            });
	        });
	    }
	    stop() {
	        this.onStop(false);
	    }
	    updateAndStop() {
	        this.onStop(true);
	    }
	};
	ProgressTracker.ProgressTracker = ProgressTracker$1;
	function poll(intervalMs, updateFunc) {
	    const id = setInterval(updateFunc, intervalMs);
	    const stopFunc = (stopWithUpdate) => {
	        clearInterval(id);
	        if (stopWithUpdate) {
	            updateFunc();
	        }
	        updateFunc = noop;
	    };
	    updateFunc();
	    return stopFunc;
	}
	function noop() { }
	return ProgressTracker;
}

var StringWriter = {};

var hasRequiredStringWriter;

function requireStringWriter () {
	if (hasRequiredStringWriter) return StringWriter;
	hasRequiredStringWriter = 1;
	Object.defineProperty(StringWriter, "__esModule", { value: true });
	StringWriter.StringWriter = void 0;
	const stream_1 = require$$1$3;
	let StringWriter$1 = class StringWriter extends stream_1.Writable {
	    constructor() {
	        super(...arguments);
	        this.buf = Buffer.alloc(0);
	    }
	    _write(chunk, _, callback) {
	        if (chunk instanceof Buffer) {
	            this.buf = Buffer.concat([this.buf, chunk]);
	            callback(null);
	        }
	        else {
	            callback(new Error("StringWriter expects chunks of type 'Buffer'."));
	        }
	    }
	    getText(encoding) {
	        return this.buf.toString(encoding);
	    }
	};
	StringWriter.StringWriter = StringWriter$1;
	return StringWriter;
}

var netUtils = {};

var hasRequiredNetUtils;

function requireNetUtils () {
	if (hasRequiredNetUtils) return netUtils;
	hasRequiredNetUtils = 1;
	Object.defineProperty(netUtils, "__esModule", { value: true });
	netUtils.ipIsPrivateV4Address = netUtils.upgradeSocket = netUtils.describeAddress = netUtils.describeTLS = void 0;
	const tls_1 = require$$1$2;
	function describeTLS(socket) {
	    if (socket instanceof tls_1.TLSSocket) {
	        const protocol = socket.getProtocol();
	        return protocol ? protocol : "Server socket or disconnected client socket";
	    }
	    return "No encryption";
	}
	netUtils.describeTLS = describeTLS;
	function describeAddress(socket) {
	    if (socket.remoteFamily === "IPv6") {
	        return `[${socket.remoteAddress}]:${socket.remotePort}`;
	    }
	    return `${socket.remoteAddress}:${socket.remotePort}`;
	}
	netUtils.describeAddress = describeAddress;
	function upgradeSocket(socket, options) {
	    return new Promise((resolve, reject) => {
	        const tlsOptions = Object.assign({}, options, {
	            socket
	        });
	        const tlsSocket = (0, tls_1.connect)(tlsOptions, () => {
	            const expectCertificate = tlsOptions.rejectUnauthorized !== false;
	            if (expectCertificate && !tlsSocket.authorized) {
	                reject(tlsSocket.authorizationError);
	            }
	            else {
	                tlsSocket.removeAllListeners("error");
	                resolve(tlsSocket);
	            }
	        }).once("error", error => {
	            reject(error);
	        });
	    });
	}
	netUtils.upgradeSocket = upgradeSocket;
	function ipIsPrivateV4Address(ip = "") {
	    if (ip.startsWith("::ffff:")) {
	        ip = ip.substr(7);
	    }
	    const octets = ip.split(".").map(o => parseInt(o, 10));
	    return octets[0] === 10
	        || (octets[0] === 172 && octets[1] >= 16 && octets[1] <= 31)
	        || (octets[0] === 192 && octets[1] === 168)
	        || ip === "127.0.0.1";
	}
	netUtils.ipIsPrivateV4Address = ipIsPrivateV4Address;
	return netUtils;
}

var transfer = {};

var hasRequiredTransfer;

function requireTransfer () {
	if (hasRequiredTransfer) return transfer;
	hasRequiredTransfer = 1;
	Object.defineProperty(transfer, "__esModule", { value: true });
	transfer.downloadTo = transfer.uploadFrom = transfer.connectForPassiveTransfer = transfer.parsePasvResponse = transfer.enterPassiveModeIPv4 = transfer.parseEpsvResponse = transfer.enterPassiveModeIPv6 = void 0;
	const netUtils_1 = requireNetUtils();
	const stream_1 = require$$1$3;
	const tls_1 = require$$1$2;
	const parseControlResponse_1 = requireParseControlResponse();
	async function enterPassiveModeIPv6(ftp) {
	    const res = await ftp.request("EPSV");
	    const port = parseEpsvResponse(res.message);
	    if (!port) {
	        throw new Error("Can't parse EPSV response: " + res.message);
	    }
	    const controlHost = ftp.socket.remoteAddress;
	    if (controlHost === undefined) {
	        throw new Error("Control socket is disconnected, can't get remote address.");
	    }
	    await connectForPassiveTransfer(controlHost, port, ftp);
	    return res;
	}
	transfer.enterPassiveModeIPv6 = enterPassiveModeIPv6;
	function parseEpsvResponse(message) {
	    const groups = message.match(/[|!]{3}(.+)[|!]/);
	    if (groups === null || groups[1] === undefined) {
	        throw new Error(`Can't parse response to 'EPSV': ${message}`);
	    }
	    const port = parseInt(groups[1], 10);
	    if (Number.isNaN(port)) {
	        throw new Error(`Can't parse response to 'EPSV', port is not a number: ${message}`);
	    }
	    return port;
	}
	transfer.parseEpsvResponse = parseEpsvResponse;
	async function enterPassiveModeIPv4(ftp) {
	    const res = await ftp.request("PASV");
	    const target = parsePasvResponse(res.message);
	    if (!target) {
	        throw new Error("Can't parse PASV response: " + res.message);
	    }
	    const controlHost = ftp.socket.remoteAddress;
	    if ((0, netUtils_1.ipIsPrivateV4Address)(target.host) && controlHost && !(0, netUtils_1.ipIsPrivateV4Address)(controlHost)) {
	        target.host = controlHost;
	    }
	    await connectForPassiveTransfer(target.host, target.port, ftp);
	    return res;
	}
	transfer.enterPassiveModeIPv4 = enterPassiveModeIPv4;
	function parsePasvResponse(message) {
	    const groups = message.match(/([-\d]+,[-\d]+,[-\d]+,[-\d]+),([-\d]+),([-\d]+)/);
	    if (groups === null || groups.length !== 4) {
	        throw new Error(`Can't parse response to 'PASV': ${message}`);
	    }
	    return {
	        host: groups[1].replace(/,/g, "."),
	        port: (parseInt(groups[2], 10) & 255) * 256 + (parseInt(groups[3], 10) & 255)
	    };
	}
	transfer.parsePasvResponse = parsePasvResponse;
	function connectForPassiveTransfer(host, port, ftp) {
	    return new Promise((resolve, reject) => {
	        let socket = ftp._newSocket();
	        const handleConnErr = function (err) {
	            err.message = "Can't open data connection in passive mode: " + err.message;
	            reject(err);
	        };
	        const handleTimeout = function () {
	            socket.destroy();
	            reject(new Error(`Timeout when trying to open data connection to ${host}:${port}`));
	        };
	        socket.setTimeout(ftp.timeout);
	        socket.on("error", handleConnErr);
	        socket.on("timeout", handleTimeout);
	        socket.connect({ port, host, family: ftp.ipFamily }, () => {
	            if (ftp.socket instanceof tls_1.TLSSocket) {
	                socket = (0, tls_1.connect)(Object.assign({}, ftp.tlsOptions, {
	                    socket,
	                    session: ftp.socket.getSession()
	                }));
	            }
	            socket.removeListener("error", handleConnErr);
	            socket.removeListener("timeout", handleTimeout);
	            ftp.dataSocket = socket;
	            resolve();
	        });
	    });
	}
	transfer.connectForPassiveTransfer = connectForPassiveTransfer;
	class TransferResolver {
	    constructor(ftp, progress) {
	        this.ftp = ftp;
	        this.progress = progress;
	        this.response = undefined;
	        this.dataTransferDone = false;
	    }
	    onDataStart(name, type) {
	        if (this.ftp.dataSocket === undefined) {
	            throw new Error("Data transfer should start but there is no data connection.");
	        }
	        this.ftp.socket.setTimeout(0);
	        this.ftp.dataSocket.setTimeout(this.ftp.timeout);
	        this.progress.start(this.ftp.dataSocket, name, type);
	    }
	    onDataDone(task) {
	        this.progress.updateAndStop();
	        this.ftp.socket.setTimeout(this.ftp.timeout);
	        if (this.ftp.dataSocket) {
	            this.ftp.dataSocket.setTimeout(0);
	        }
	        this.dataTransferDone = true;
	        this.tryResolve(task);
	    }
	    onControlDone(task, response) {
	        this.response = response;
	        this.tryResolve(task);
	    }
	    onError(task, err) {
	        this.progress.updateAndStop();
	        this.ftp.socket.setTimeout(this.ftp.timeout);
	        this.ftp.dataSocket = undefined;
	        task.reject(err);
	    }
	    onUnexpectedRequest(response) {
	        const err = new Error(`Unexpected FTP response is requesting an answer: ${response.message}`);
	        this.ftp.closeWithError(err);
	    }
	    tryResolve(task) {
	        const canResolve = this.dataTransferDone && this.response !== undefined;
	        if (canResolve) {
	            this.ftp.dataSocket = undefined;
	            task.resolve(this.response);
	        }
	    }
	}
	function uploadFrom(source, config) {
	    const resolver = new TransferResolver(config.ftp, config.tracker);
	    const fullCommand = `${config.command} ${config.remotePath}`;
	    return config.ftp.handle(fullCommand, (res, task) => {
	        if (res instanceof Error) {
	            resolver.onError(task, res);
	        }
	        else if (res.code === 150 || res.code === 125) {
	            const dataSocket = config.ftp.dataSocket;
	            if (!dataSocket) {
	                resolver.onError(task, new Error("Upload should begin but no data connection is available."));
	                return;
	            }
	            const canUpload = "getCipher" in dataSocket ? dataSocket.getCipher() !== undefined : true;
	            onConditionOrEvent(canUpload, dataSocket, "secureConnect", () => {
	                config.ftp.log(`Uploading to ${(0, netUtils_1.describeAddress)(dataSocket)} (${(0, netUtils_1.describeTLS)(dataSocket)})`);
	                resolver.onDataStart(config.remotePath, config.type);
	                (0, stream_1.pipeline)(source, dataSocket, err => {
	                    if (err) {
	                        resolver.onError(task, err);
	                    }
	                    else {
	                        resolver.onDataDone(task);
	                    }
	                });
	            });
	        }
	        else if ((0, parseControlResponse_1.positiveCompletion)(res.code)) {
	            resolver.onControlDone(task, res);
	        }
	        else if ((0, parseControlResponse_1.positiveIntermediate)(res.code)) {
	            resolver.onUnexpectedRequest(res);
	        }
	    });
	}
	transfer.uploadFrom = uploadFrom;
	function downloadTo(destination, config) {
	    if (!config.ftp.dataSocket) {
	        throw new Error("Download will be initiated but no data connection is available.");
	    }
	    const resolver = new TransferResolver(config.ftp, config.tracker);
	    return config.ftp.handle(config.command, (res, task) => {
	        if (res instanceof Error) {
	            resolver.onError(task, res);
	        }
	        else if (res.code === 150 || res.code === 125) {
	            const dataSocket = config.ftp.dataSocket;
	            if (!dataSocket) {
	                resolver.onError(task, new Error("Download should begin but no data connection is available."));
	                return;
	            }
	            config.ftp.log(`Downloading from ${(0, netUtils_1.describeAddress)(dataSocket)} (${(0, netUtils_1.describeTLS)(dataSocket)})`);
	            resolver.onDataStart(config.remotePath, config.type);
	            (0, stream_1.pipeline)(dataSocket, destination, err => {
	                if (err) {
	                    resolver.onError(task, err);
	                }
	                else {
	                    resolver.onDataDone(task);
	                }
	            });
	        }
	        else if (res.code === 350) {
	            config.ftp.send("RETR " + config.remotePath);
	        }
	        else if ((0, parseControlResponse_1.positiveCompletion)(res.code)) {
	            resolver.onControlDone(task, res);
	        }
	        else if ((0, parseControlResponse_1.positiveIntermediate)(res.code)) {
	            resolver.onUnexpectedRequest(res);
	        }
	    });
	}
	transfer.downloadTo = downloadTo;
	function onConditionOrEvent(condition, emitter, eventName, action) {
	    if (condition === true) {
	        action();
	    }
	    else {
	        emitter.once(eventName, () => action());
	    }
	}
	return transfer;
}

var hasRequiredClient;

function requireClient () {
	if (hasRequiredClient) return Client;
	hasRequiredClient = 1;
	Object.defineProperty(Client, "__esModule", { value: true });
	Client.Client = void 0;
	const fs_1 = require$$0$7;
	const path_1 = require$$1$4;
	const tls_1 = require$$1$2;
	const util_1 = require$$0$2;
	const FtpContext_1 = requireFtpContext();
	const parseList_1 = requireParseList();
	const ProgressTracker_1 = requireProgressTracker();
	const StringWriter_1 = requireStringWriter();
	const parseListMLSD_1 = requireParseListMLSD();
	const netUtils_1 = requireNetUtils();
	const transfer_1 = requireTransfer();
	const parseControlResponse_1 = requireParseControlResponse();
	const fsReadDir = (0, util_1.promisify)(fs_1.readdir);
	const fsMkDir = (0, util_1.promisify)(fs_1.mkdir);
	const fsStat = (0, util_1.promisify)(fs_1.stat);
	const fsOpen = (0, util_1.promisify)(fs_1.open);
	const fsClose = (0, util_1.promisify)(fs_1.close);
	const fsUnlink = (0, util_1.promisify)(fs_1.unlink);
	const LIST_COMMANDS_DEFAULT = () => ["LIST -a", "LIST"];
	const LIST_COMMANDS_MLSD = () => ["MLSD", "LIST -a", "LIST"];
	let Client$1 = class Client {
	    constructor(timeout = 30000) {
	        this.availableListCommands = LIST_COMMANDS_DEFAULT();
	        this.ftp = new FtpContext_1.FTPContext(timeout);
	        this.prepareTransfer = this._enterFirstCompatibleMode([transfer_1.enterPassiveModeIPv6, transfer_1.enterPassiveModeIPv4]);
	        this.parseList = parseList_1.parseList;
	        this._progressTracker = new ProgressTracker_1.ProgressTracker();
	    }
	    close() {
	        this.ftp.close();
	        this._progressTracker.stop();
	    }
	    get closed() {
	        return this.ftp.closed;
	    }
	    connect(host = "localhost", port = 21) {
	        this.ftp.reset();
	        this.ftp.socket.connect({
	            host,
	            port,
	            family: this.ftp.ipFamily
	        }, () => this.ftp.log(`Connected to ${(0, netUtils_1.describeAddress)(this.ftp.socket)} (${(0, netUtils_1.describeTLS)(this.ftp.socket)})`));
	        return this._handleConnectResponse();
	    }
	    connectImplicitTLS(host = "localhost", port = 21, tlsOptions = {}) {
	        this.ftp.reset();
	        this.ftp.socket = (0, tls_1.connect)(port, host, tlsOptions, () => this.ftp.log(`Connected to ${(0, netUtils_1.describeAddress)(this.ftp.socket)} (${(0, netUtils_1.describeTLS)(this.ftp.socket)})`));
	        this.ftp.tlsOptions = tlsOptions;
	        return this._handleConnectResponse();
	    }
	    _handleConnectResponse() {
	        return this.ftp.handle(undefined, (res, task) => {
	            if (res instanceof Error) {
	                task.reject(res);
	            }
	            else if ((0, parseControlResponse_1.positiveCompletion)(res.code)) {
	                task.resolve(res);
	            }
	            else {
	                task.reject(new FtpContext_1.FTPError(res));
	            }
	        });
	    }
	    send(command, ignoreErrorCodesDEPRECATED = false) {
	        if (ignoreErrorCodesDEPRECATED) {
	            this.ftp.log("Deprecated call using send(command, flag) with boolean flag to ignore errors. Use sendIgnoringError(command).");
	            return this.sendIgnoringError(command);
	        }
	        return this.ftp.request(command);
	    }
	    sendIgnoringError(command) {
	        return this.ftp.handle(command, (res, task) => {
	            if (res instanceof FtpContext_1.FTPError) {
	                task.resolve({ code: res.code, message: res.message });
	            }
	            else if (res instanceof Error) {
	                task.reject(res);
	            }
	            else {
	                task.resolve(res);
	            }
	        });
	    }
	    async useTLS(options = {}, command = "AUTH TLS") {
	        const ret = await this.send(command);
	        this.ftp.socket = await (0, netUtils_1.upgradeSocket)(this.ftp.socket, options);
	        this.ftp.tlsOptions = options;
	        this.ftp.log(`Control socket is using: ${(0, netUtils_1.describeTLS)(this.ftp.socket)}`);
	        return ret;
	    }
	    login(user = "anonymous", password = "guest") {
	        this.ftp.log(`Login security: ${(0, netUtils_1.describeTLS)(this.ftp.socket)}`);
	        return this.ftp.handle("USER " + user, (res, task) => {
	            if (res instanceof Error) {
	                task.reject(res);
	            }
	            else if ((0, parseControlResponse_1.positiveCompletion)(res.code)) {
	                task.resolve(res);
	            }
	            else if (res.code === 331) {
	                this.ftp.send("PASS " + password);
	            }
	            else {
	                task.reject(new FtpContext_1.FTPError(res));
	            }
	        });
	    }
	    async useDefaultSettings() {
	        const features = await this.features();
	        const supportsMLSD = features.has("MLST");
	        this.availableListCommands = supportsMLSD ? LIST_COMMANDS_MLSD() : LIST_COMMANDS_DEFAULT();
	        await this.send("TYPE I");
	        await this.sendIgnoringError("STRU F");
	        await this.sendIgnoringError("OPTS UTF8 ON");
	        if (supportsMLSD) {
	            await this.sendIgnoringError("OPTS MLST type;size;modify;unique;unix.mode;unix.owner;unix.group;unix.ownername;unix.groupname;");
	        }
	        if (this.ftp.hasTLS) {
	            await this.sendIgnoringError("PBSZ 0");
	            await this.sendIgnoringError("PROT P");
	        }
	    }
	    async access(options = {}) {
	        var _a, _b;
	        const useExplicitTLS = options.secure === true;
	        const useImplicitTLS = options.secure === "implicit";
	        let welcome;
	        if (useImplicitTLS) {
	            welcome = await this.connectImplicitTLS(options.host, options.port, options.secureOptions);
	        }
	        else {
	            welcome = await this.connect(options.host, options.port);
	        }
	        if (useExplicitTLS) {
	            const secureOptions = (_a = options.secureOptions) !== null && _a !== void 0 ? _a : {};
	            secureOptions.host = (_b = secureOptions.host) !== null && _b !== void 0 ? _b : options.host;
	            await this.useTLS(secureOptions);
	        }
	        await this.sendIgnoringError("OPTS UTF8 ON");
	        await this.login(options.user, options.password);
	        await this.useDefaultSettings();
	        return welcome;
	    }
	    async pwd() {
	        const res = await this.send("PWD");
	        const parsed = res.message.match(/"(.+)"/);
	        if (parsed === null || parsed[1] === undefined) {
	            throw new Error(`Can't parse response to command 'PWD': ${res.message}`);
	        }
	        return parsed[1];
	    }
	    async features() {
	        const res = await this.sendIgnoringError("FEAT");
	        const features = new Map();
	        if (res.code < 400 && (0, parseControlResponse_1.isMultiline)(res.message)) {
	            res.message.split("\n").slice(1, -1).forEach(line => {
	                const entry = line.trim().split(" ");
	                features.set(entry[0], entry[1] || "");
	            });
	        }
	        return features;
	    }
	    async cd(path) {
	        const validPath = await this.protectWhitespace(path);
	        return this.send("CWD " + validPath);
	    }
	    async cdup() {
	        return this.send("CDUP");
	    }
	    async lastMod(path) {
	        const validPath = await this.protectWhitespace(path);
	        const res = await this.send(`MDTM ${validPath}`);
	        const date = res.message.slice(4);
	        return (0, parseListMLSD_1.parseMLSxDate)(date);
	    }
	    async size(path) {
	        const validPath = await this.protectWhitespace(path);
	        const command = `SIZE ${validPath}`;
	        const res = await this.send(command);
	        const size = parseInt(res.message.slice(4), 10);
	        if (Number.isNaN(size)) {
	            throw new Error(`Can't parse response to command '${command}' as a numerical value: ${res.message}`);
	        }
	        return size;
	    }
	    async rename(srcPath, destPath) {
	        const validSrc = await this.protectWhitespace(srcPath);
	        const validDest = await this.protectWhitespace(destPath);
	        await this.send("RNFR " + validSrc);
	        return this.send("RNTO " + validDest);
	    }
	    async remove(path, ignoreErrorCodes = false) {
	        const validPath = await this.protectWhitespace(path);
	        if (ignoreErrorCodes) {
	            return this.sendIgnoringError(`DELE ${validPath}`);
	        }
	        return this.send(`DELE ${validPath}`);
	    }
	    trackProgress(handler) {
	        this._progressTracker.bytesOverall = 0;
	        this._progressTracker.reportTo(handler);
	    }
	    async uploadFrom(source, toRemotePath, options = {}) {
	        return this._uploadWithCommand(source, toRemotePath, "STOR", options);
	    }
	    async appendFrom(source, toRemotePath, options = {}) {
	        return this._uploadWithCommand(source, toRemotePath, "APPE", options);
	    }
	    async _uploadWithCommand(source, remotePath, command, options) {
	        if (typeof source === "string") {
	            return this._uploadLocalFile(source, remotePath, command, options);
	        }
	        return this._uploadFromStream(source, remotePath, command);
	    }
	    async _uploadLocalFile(localPath, remotePath, command, options) {
	        const fd = await fsOpen(localPath, "r");
	        const source = (0, fs_1.createReadStream)("", {
	            fd,
	            start: options.localStart,
	            end: options.localEndInclusive,
	            autoClose: false
	        });
	        try {
	            return await this._uploadFromStream(source, remotePath, command);
	        }
	        finally {
	            await ignoreError(() => fsClose(fd));
	        }
	    }
	    async _uploadFromStream(source, remotePath, command) {
	        const onError = (err) => this.ftp.closeWithError(err);
	        source.once("error", onError);
	        try {
	            const validPath = await this.protectWhitespace(remotePath);
	            await this.prepareTransfer(this.ftp);
	            return await (0, transfer_1.uploadFrom)(source, {
	                ftp: this.ftp,
	                tracker: this._progressTracker,
	                command,
	                remotePath: validPath,
	                type: "upload"
	            });
	        }
	        finally {
	            source.removeListener("error", onError);
	        }
	    }
	    async downloadTo(destination, fromRemotePath, startAt = 0) {
	        if (typeof destination === "string") {
	            return this._downloadToFile(destination, fromRemotePath, startAt);
	        }
	        return this._downloadToStream(destination, fromRemotePath, startAt);
	    }
	    async _downloadToFile(localPath, remotePath, startAt) {
	        const appendingToLocalFile = startAt > 0;
	        const fileSystemFlags = appendingToLocalFile ? "r+" : "w";
	        const fd = await fsOpen(localPath, fileSystemFlags);
	        const destination = (0, fs_1.createWriteStream)("", {
	            fd,
	            start: startAt,
	            autoClose: false
	        });
	        try {
	            return await this._downloadToStream(destination, remotePath, startAt);
	        }
	        catch (err) {
	            const localFileStats = await ignoreError(() => fsStat(localPath));
	            const hasDownloadedData = localFileStats && localFileStats.size > 0;
	            const shouldRemoveLocalFile = !appendingToLocalFile && !hasDownloadedData;
	            if (shouldRemoveLocalFile) {
	                await ignoreError(() => fsUnlink(localPath));
	            }
	            throw err;
	        }
	        finally {
	            await ignoreError(() => fsClose(fd));
	        }
	    }
	    async _downloadToStream(destination, remotePath, startAt) {
	        const onError = (err) => this.ftp.closeWithError(err);
	        destination.once("error", onError);
	        try {
	            const validPath = await this.protectWhitespace(remotePath);
	            await this.prepareTransfer(this.ftp);
	            return await (0, transfer_1.downloadTo)(destination, {
	                ftp: this.ftp,
	                tracker: this._progressTracker,
	                command: startAt > 0 ? `REST ${startAt}` : `RETR ${validPath}`,
	                remotePath: validPath,
	                type: "download"
	            });
	        }
	        finally {
	            destination.removeListener("error", onError);
	            destination.end();
	        }
	    }
	    async list(path = "") {
	        const validPath = await this.protectWhitespace(path);
	        let lastError;
	        for (const candidate of this.availableListCommands) {
	            const command = validPath === "" ? candidate : `${candidate} ${validPath}`;
	            await this.prepareTransfer(this.ftp);
	            try {
	                const parsedList = await this._requestListWithCommand(command);
	                this.availableListCommands = [candidate];
	                return parsedList;
	            }
	            catch (err) {
	                const shouldTryNext = err instanceof FtpContext_1.FTPError;
	                if (!shouldTryNext) {
	                    throw err;
	                }
	                lastError = err;
	            }
	        }
	        throw lastError;
	    }
	    async _requestListWithCommand(command) {
	        const buffer = new StringWriter_1.StringWriter();
	        await (0, transfer_1.downloadTo)(buffer, {
	            ftp: this.ftp,
	            tracker: this._progressTracker,
	            command,
	            remotePath: "",
	            type: "list"
	        });
	        const text = buffer.getText(this.ftp.encoding);
	        this.ftp.log(text);
	        return this.parseList(text);
	    }
	    async removeDir(remoteDirPath) {
	        return this._exitAtCurrentDirectory(async () => {
	            await this.cd(remoteDirPath);
	            const absoluteDirPath = await this.pwd();
	            await this.clearWorkingDir();
	            const dirIsRoot = absoluteDirPath === "/";
	            if (!dirIsRoot) {
	                await this.cdup();
	                await this.removeEmptyDir(absoluteDirPath);
	            }
	        });
	    }
	    async clearWorkingDir() {
	        for (const file of await this.list()) {
	            if (file.isDirectory) {
	                await this.cd(file.name);
	                await this.clearWorkingDir();
	                await this.cdup();
	                await this.removeEmptyDir(file.name);
	            }
	            else {
	                await this.remove(file.name);
	            }
	        }
	    }
	    async uploadFromDir(localDirPath, remoteDirPath) {
	        return this._exitAtCurrentDirectory(async () => {
	            if (remoteDirPath) {
	                await this.ensureDir(remoteDirPath);
	            }
	            return await this._uploadToWorkingDir(localDirPath);
	        });
	    }
	    async _uploadToWorkingDir(localDirPath) {
	        const files = await fsReadDir(localDirPath);
	        for (const file of files) {
	            const fullPath = (0, path_1.join)(localDirPath, file);
	            const stats = await fsStat(fullPath);
	            if (stats.isFile()) {
	                await this.uploadFrom(fullPath, file);
	            }
	            else if (stats.isDirectory()) {
	                await this._openDir(file);
	                await this._uploadToWorkingDir(fullPath);
	                await this.cdup();
	            }
	        }
	    }
	    async downloadToDir(localDirPath, remoteDirPath) {
	        return this._exitAtCurrentDirectory(async () => {
	            if (remoteDirPath) {
	                await this.cd(remoteDirPath);
	            }
	            return await this._downloadFromWorkingDir(localDirPath);
	        });
	    }
	    async _downloadFromWorkingDir(localDirPath) {
	        await ensureLocalDirectory(localDirPath);
	        for (const file of await this.list()) {
	            const localPath = (0, path_1.join)(localDirPath, file.name);
	            if (file.isDirectory) {
	                await this.cd(file.name);
	                await this._downloadFromWorkingDir(localPath);
	                await this.cdup();
	            }
	            else if (file.isFile) {
	                await this.downloadTo(localPath, file.name);
	            }
	        }
	    }
	    async ensureDir(remoteDirPath) {
	        if (remoteDirPath.startsWith("/")) {
	            await this.cd("/");
	        }
	        const names = remoteDirPath.split("/").filter(name => name !== "");
	        for (const name of names) {
	            await this._openDir(name);
	        }
	    }
	    async _openDir(dirName) {
	        await this.sendIgnoringError("MKD " + dirName);
	        await this.cd(dirName);
	    }
	    async removeEmptyDir(path) {
	        const validPath = await this.protectWhitespace(path);
	        return this.send(`RMD ${validPath}`);
	    }
	    async protectWhitespace(path) {
	        if (!path.startsWith(" ")) {
	            return path;
	        }
	        const pwd = await this.pwd();
	        const absolutePathPrefix = pwd.endsWith("/") ? pwd : pwd + "/";
	        return absolutePathPrefix + path;
	    }
	    async _exitAtCurrentDirectory(func) {
	        const userDir = await this.pwd();
	        try {
	            return await func();
	        }
	        finally {
	            if (!this.closed) {
	                await ignoreError(() => this.cd(userDir));
	            }
	        }
	    }
	    _enterFirstCompatibleMode(strategies) {
	        return async (ftp) => {
	            ftp.log("Trying to find optimal transfer strategy...");
	            let lastError = undefined;
	            for (const strategy of strategies) {
	                try {
	                    const res = await strategy(ftp);
	                    ftp.log("Optimal transfer strategy found.");
	                    this.prepareTransfer = strategy;
	                    return res;
	                }
	                catch (err) {
	                    lastError = err;
	                }
	            }
	            throw new Error(`None of the available transfer strategies work. Last error response was '${lastError}'.`);
	        };
	    }
	    async upload(source, toRemotePath, options = {}) {
	        this.ftp.log("Warning: upload() has been deprecated, use uploadFrom().");
	        return this.uploadFrom(source, toRemotePath, options);
	    }
	    async append(source, toRemotePath, options = {}) {
	        this.ftp.log("Warning: append() has been deprecated, use appendFrom().");
	        return this.appendFrom(source, toRemotePath, options);
	    }
	    async download(destination, fromRemotePath, startAt = 0) {
	        this.ftp.log("Warning: download() has been deprecated, use downloadTo().");
	        return this.downloadTo(destination, fromRemotePath, startAt);
	    }
	    async uploadDir(localDirPath, remoteDirPath) {
	        this.ftp.log("Warning: uploadDir() has been deprecated, use uploadFromDir().");
	        return this.uploadFromDir(localDirPath, remoteDirPath);
	    }
	    async downloadDir(localDirPath) {
	        this.ftp.log("Warning: downloadDir() has been deprecated, use downloadToDir().");
	        return this.downloadToDir(localDirPath);
	    }
	};
	Client.Client = Client$1;
	async function ensureLocalDirectory(path) {
	    try {
	        await fsStat(path);
	    }
	    catch (err) {
	        await fsMkDir(path, { recursive: true });
	    }
	}
	async function ignoreError(func) {
	    try {
	        return await func();
	    }
	    catch (err) {
	        return undefined;
	    }
	}
	return Client;
}

var StringEncoding = {};

var hasRequiredStringEncoding;

function requireStringEncoding () {
	if (hasRequiredStringEncoding) return StringEncoding;
	hasRequiredStringEncoding = 1;
	Object.defineProperty(StringEncoding, "__esModule", { value: true });
	return StringEncoding;
}

var hasRequiredDist$6;

function requireDist$6 () {
	if (hasRequiredDist$6) return dist$3;
	hasRequiredDist$6 = 1;
	(function (exports) {
		var __createBinding = (dist$3 && dist$3.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (dist$3 && dist$3.__exportStar) || function(m, exports) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.enterPassiveModeIPv6 = exports.enterPassiveModeIPv4 = void 0;
		__exportStar(requireClient(), exports);
		__exportStar(requireFtpContext(), exports);
		__exportStar(requireFileInfo(), exports);
		__exportStar(requireParseList(), exports);
		__exportStar(requireStringEncoding(), exports);
		var transfer_1 = requireTransfer();
		Object.defineProperty(exports, "enterPassiveModeIPv4", { enumerable: true, get: function () { return transfer_1.enterPassiveModeIPv4; } });
		Object.defineProperty(exports, "enterPassiveModeIPv6", { enumerable: true, get: function () { return transfer_1.enterPassiveModeIPv6; } }); 
	} (dist$3));
	return dist$3;
}

var hasRequiredFtp;

function requireFtp () {
	if (hasRequiredFtp) return ftp;
	hasRequiredFtp = 1;
	var __importDefault = (ftp && ftp.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(ftp, "__esModule", { value: true });
	ftp.ftp = void 0;
	const basic_ftp_1 = requireDist$6();
	const stream_1 = require$$1$3;
	const path_1 = require$$1$4;
	const debug_1 = __importDefault(requireSrc());
	const notfound_1 = __importDefault(requireNotfound());
	const notmodified_1 = __importDefault(requireNotmodified());
	const debug = (0, debug_1.default)('get-uri:ftp');
	const ftp$1 = async (url, opts = {}) => {
	    const { cache } = opts;
	    const filepath = decodeURIComponent(url.pathname);
	    let lastModified;
	    if (!filepath) {
	        throw new TypeError('No "pathname"!');
	    }
	    const client = new basic_ftp_1.Client();
	    try {
	        const host = url.hostname || url.host || 'localhost';
	        const port = parseInt(url.port || '0', 10) || 21;
	        const user = url.username
	            ? decodeURIComponent(url.username)
	            : undefined;
	        const password = url.password
	            ? decodeURIComponent(url.password)
	            : undefined;
	        await client.access({
	            host,
	            port,
	            user,
	            password,
	            ...opts,
	        });
	        try {
	            lastModified = await client.lastMod(filepath);
	        }
	        catch (err) {
	            if (err.code === 550) {
	                throw new notfound_1.default();
	            }
	        }
	        if (!lastModified) {
	            const list = await client.list((0, path_1.dirname)(filepath));
	            const name = (0, path_1.basename)(filepath);
	            const entry = list.find((e) => e.name === name);
	            if (entry) {
	                lastModified = entry.modifiedAt;
	            }
	        }
	        if (lastModified) {
	            if (isNotModified()) {
	                throw new notmodified_1.default();
	            }
	        }
	        else {
	            throw new notfound_1.default();
	        }
	        const stream = new stream_1.PassThrough();
	        const rs = stream;
	        client.downloadTo(stream, filepath).then((result) => {
	            debug(result.message);
	            client.close();
	        });
	        rs.lastModified = lastModified;
	        return rs;
	    }
	    catch (err) {
	        client.close();
	        throw err;
	    }
	    function isNotModified() {
	        if (cache?.lastModified && lastModified) {
	            return +cache.lastModified === +lastModified;
	        }
	        return false;
	    }
	};
	ftp.ftp = ftp$1;
	return ftp;
}

var http = {};

var httpError = {};

var hasRequiredHttpError;

function requireHttpError () {
	if (hasRequiredHttpError) return httpError;
	hasRequiredHttpError = 1;
	Object.defineProperty(httpError, "__esModule", { value: true });
	const http_1 = require$$0$3;
	class HTTPError extends Error {
	    constructor(statusCode, message = http_1.STATUS_CODES[statusCode]) {
	        super(message);
	        this.statusCode = statusCode;
	        this.code = `E${String(message).toUpperCase().replace(/\s+/g, '')}`;
	    }
	}
	httpError.default = HTTPError;
	return httpError;
}

var hasRequiredHttp;

function requireHttp () {
	if (hasRequiredHttp) return http;
	hasRequiredHttp = 1;
	(function (exports) {
		var __importDefault = (http && http.__importDefault) || function (mod) {
		    return (mod && mod.__esModule) ? mod : { "default": mod };
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.http = void 0;
		const http_1 = __importDefault(require$$0$3);
		const https_1 = __importDefault(require$$1$1);
		const events_1 = require$$0$5;
		const debug_1 = __importDefault(requireSrc());
		const http_error_1 = __importDefault(requireHttpError());
		const notfound_1 = __importDefault(requireNotfound());
		const notmodified_1 = __importDefault(requireNotmodified());
		const debug = (0, debug_1.default)('get-uri:http');
		const http$1 = async (url, opts = {}) => {
		    debug('GET %o', url.href);
		    const cache = getCache(url, opts.cache);
		    if (cache && isFresh(cache) && typeof cache.statusCode === 'number') {
		        const type = (cache.statusCode / 100) | 0;
		        if (type === 3 && cache.headers.location) {
		            debug('cached redirect');
		            throw new Error('TODO: implement cached redirects!');
		        }
		        throw new notmodified_1.default();
		    }
		    const maxRedirects = typeof opts.maxRedirects === 'number' ? opts.maxRedirects : 5;
		    debug('allowing %o max redirects', maxRedirects);
		    let mod;
		    if (opts.http) {
		        mod = opts.http;
		        debug('using secure `https` core module');
		    }
		    else {
		        mod = http_1.default;
		        debug('using `http` core module');
		    }
		    const options = { ...opts };
		    if (cache) {
		        if (!options.headers) {
		            options.headers = {};
		        }
		        const lastModified = cache.headers['last-modified'];
		        if (lastModified) {
		            options.headers['If-Modified-Since'] = lastModified;
		            debug('added "If-Modified-Since" request header: %o', lastModified);
		        }
		        const etag = cache.headers.etag;
		        if (etag) {
		            options.headers['If-None-Match'] = etag;
		            debug('added "If-None-Match" request header: %o', etag);
		        }
		    }
		    const req = mod.get(url, options);
		    const [res] = await (0, events_1.once)(req, 'response');
		    const code = res.statusCode || 0;
		    res.date = Date.now();
		    res.parsed = url;
		    debug('got %o response status code', code);
		    const type = (code / 100) | 0;
		    const location = res.headers.location;
		    if (type === 3 && location) {
		        if (!opts.redirects)
		            opts.redirects = [];
		        const redirects = opts.redirects;
		        if (redirects.length < maxRedirects) {
		            debug('got a "redirect" status code with Location: %o', location);
		            res.resume();
		            redirects.push(res);
		            const newUri = new URL(location, url.href);
		            debug('resolved redirect URL: %o', newUri.href);
		            const left = maxRedirects - redirects.length;
		            debug('%o more redirects allowed after this one', left);
		            if (newUri.protocol !== url.protocol) {
		                opts.http = newUri.protocol === 'https:' ? https_1.default : undefined;
		            }
		            return (0, exports.http)(newUri, opts);
		        }
		    }
		    if (type !== 2) {
		        res.resume();
		        if (code === 304) {
		            throw new notmodified_1.default();
		        }
		        else if (code === 404) {
		            throw new notfound_1.default();
		        }
		        throw new http_error_1.default(code);
		    }
		    if (opts.redirects) {
		        res.redirects = opts.redirects;
		    }
		    return res;
		};
		exports.http = http$1;
		function isFresh(cache) {
		    let fresh = false;
		    let expires = parseInt(cache.headers.expires || '', 10);
		    const cacheControl = cache.headers['cache-control'];
		    if (cacheControl) {
		        debug('Cache-Control: %o', cacheControl);
		        const parts = cacheControl.split(/,\s*?\b/);
		        for (let i = 0; i < parts.length; i++) {
		            const part = parts[i];
		            const subparts = part.split('=');
		            const name = subparts[0];
		            switch (name) {
		                case 'max-age':
		                    expires =
		                        (cache.date || 0) + parseInt(subparts[1], 10) * 1000;
		                    fresh = Date.now() < expires;
		                    if (fresh) {
		                        debug('cache is "fresh" due to previous %o Cache-Control param', part);
		                    }
		                    return fresh;
		                case 'must-revalidate':
		                    break;
		                case 'no-cache':
		                case 'no-store':
		                    debug('cache is "stale" due to explicit %o Cache-Control param', name);
		                    return false;
		            }
		        }
		    }
		    else if (expires) {
		        debug('Expires: %o', expires);
		        fresh = Date.now() < expires;
		        if (fresh) {
		            debug('cache is "fresh" due to previous Expires response header');
		        }
		        return fresh;
		    }
		    return false;
		}
		function getCache(url, cache) {
		    if (cache) {
		        if (cache.parsed && cache.parsed.href === url.href) {
		            return cache;
		        }
		        if (cache.redirects) {
		            for (let i = 0; i < cache.redirects.length; i++) {
		                const c = getCache(url, cache.redirects[i]);
		                if (c) {
		                    return c;
		                }
		            }
		        }
		    }
		    return null;
		} 
	} (http));
	return http;
}

var https = {};

var hasRequiredHttps;

function requireHttps () {
	if (hasRequiredHttps) return https;
	hasRequiredHttps = 1;
	var __importDefault = (https && https.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(https, "__esModule", { value: true });
	https.https = void 0;
	const https_1 = __importDefault(require$$1$1);
	const http_1 = requireHttp();
	const https$1 = (url, opts) => {
	    return (0, http_1.http)(url, { ...opts, http: https_1.default });
	};
	https.https = https$1;
	return https;
}

var hasRequiredDist$5;

function requireDist$5 () {
	if (hasRequiredDist$5) return dist$5;
	hasRequiredDist$5 = 1;
	(function (exports) {
		var __importDefault = (dist$5 && dist$5.__importDefault) || function (mod) {
		    return (mod && mod.__esModule) ? mod : { "default": mod };
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.getUri = exports.isValidProtocol = exports.protocols = void 0;
		const debug_1 = __importDefault(requireSrc());
		const data_1 = requireData();
		const file_1 = requireFile();
		const ftp_1 = requireFtp();
		const http_1 = requireHttp();
		const https_1 = requireHttps();
		const debug = (0, debug_1.default)('get-uri');
		exports.protocols = {
		    data: data_1.data,
		    file: file_1.file,
		    ftp: ftp_1.ftp,
		    http: http_1.http,
		    https: https_1.https,
		};
		const VALID_PROTOCOLS = new Set(Object.keys(exports.protocols));
		function isValidProtocol(p) {
		    return VALID_PROTOCOLS.has(p);
		}
		exports.isValidProtocol = isValidProtocol;
		async function getUri(uri, opts) {
		    debug('getUri(%o)', uri);
		    if (!uri) {
		        throw new TypeError('Must pass in a URI to "getUri()"');
		    }
		    const url = typeof uri === 'string' ? new URL(uri) : uri;
		    const protocol = url.protocol.replace(/:$/, '');
		    if (!isValidProtocol(protocol)) {
		        throw new TypeError(`Unsupported protocol "${protocol}" specified in URI: "${uri}"`);
		    }
		    const getter = exports.protocols[protocol];
		    return getter(url, opts);
		}
		exports.getUri = getUri; 
	} (dist$5));
	return dist$5;
}

var dist$2 = {};

var dist$1 = {};

var degenerator = {};

var escodegen = {};

var estraverse = {};

/*
  Copyright (C) 2012-2013 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>
  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

var hasRequiredEstraverse;

function requireEstraverse () {
	if (hasRequiredEstraverse) return estraverse;
	hasRequiredEstraverse = 1;
	(function (exports) {
		(function clone(exports) {
		    var Syntax,
		        VisitorOption,
		        VisitorKeys,
		        BREAK,
		        SKIP,
		        REMOVE;
		    function deepCopy(obj) {
		        var ret = {}, key, val;
		        for (key in obj) {
		            if (obj.hasOwnProperty(key)) {
		                val = obj[key];
		                if (typeof val === 'object' && val !== null) {
		                    ret[key] = deepCopy(val);
		                } else {
		                    ret[key] = val;
		                }
		            }
		        }
		        return ret;
		    }
		    function upperBound(array, func) {
		        var diff, len, i, current;
		        len = array.length;
		        i = 0;
		        while (len) {
		            diff = len >>> 1;
		            current = i + diff;
		            if (func(array[current])) {
		                len = diff;
		            } else {
		                i = current + 1;
		                len -= diff + 1;
		            }
		        }
		        return i;
		    }
		    Syntax = {
		        AssignmentExpression: 'AssignmentExpression',
		        AssignmentPattern: 'AssignmentPattern',
		        ArrayExpression: 'ArrayExpression',
		        ArrayPattern: 'ArrayPattern',
		        ArrowFunctionExpression: 'ArrowFunctionExpression',
		        AwaitExpression: 'AwaitExpression',
		        BlockStatement: 'BlockStatement',
		        BinaryExpression: 'BinaryExpression',
		        BreakStatement: 'BreakStatement',
		        CallExpression: 'CallExpression',
		        CatchClause: 'CatchClause',
		        ChainExpression: 'ChainExpression',
		        ClassBody: 'ClassBody',
		        ClassDeclaration: 'ClassDeclaration',
		        ClassExpression: 'ClassExpression',
		        ComprehensionBlock: 'ComprehensionBlock',
		        ComprehensionExpression: 'ComprehensionExpression',
		        ConditionalExpression: 'ConditionalExpression',
		        ContinueStatement: 'ContinueStatement',
		        DebuggerStatement: 'DebuggerStatement',
		        DirectiveStatement: 'DirectiveStatement',
		        DoWhileStatement: 'DoWhileStatement',
		        EmptyStatement: 'EmptyStatement',
		        ExportAllDeclaration: 'ExportAllDeclaration',
		        ExportDefaultDeclaration: 'ExportDefaultDeclaration',
		        ExportNamedDeclaration: 'ExportNamedDeclaration',
		        ExportSpecifier: 'ExportSpecifier',
		        ExpressionStatement: 'ExpressionStatement',
		        ForStatement: 'ForStatement',
		        ForInStatement: 'ForInStatement',
		        ForOfStatement: 'ForOfStatement',
		        FunctionDeclaration: 'FunctionDeclaration',
		        FunctionExpression: 'FunctionExpression',
		        GeneratorExpression: 'GeneratorExpression',
		        Identifier: 'Identifier',
		        IfStatement: 'IfStatement',
		        ImportExpression: 'ImportExpression',
		        ImportDeclaration: 'ImportDeclaration',
		        ImportDefaultSpecifier: 'ImportDefaultSpecifier',
		        ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
		        ImportSpecifier: 'ImportSpecifier',
		        Literal: 'Literal',
		        LabeledStatement: 'LabeledStatement',
		        LogicalExpression: 'LogicalExpression',
		        MemberExpression: 'MemberExpression',
		        MetaProperty: 'MetaProperty',
		        MethodDefinition: 'MethodDefinition',
		        ModuleSpecifier: 'ModuleSpecifier',
		        NewExpression: 'NewExpression',
		        ObjectExpression: 'ObjectExpression',
		        ObjectPattern: 'ObjectPattern',
		        PrivateIdentifier: 'PrivateIdentifier',
		        Program: 'Program',
		        Property: 'Property',
		        PropertyDefinition: 'PropertyDefinition',
		        RestElement: 'RestElement',
		        ReturnStatement: 'ReturnStatement',
		        SequenceExpression: 'SequenceExpression',
		        SpreadElement: 'SpreadElement',
		        Super: 'Super',
		        SwitchStatement: 'SwitchStatement',
		        SwitchCase: 'SwitchCase',
		        TaggedTemplateExpression: 'TaggedTemplateExpression',
		        TemplateElement: 'TemplateElement',
		        TemplateLiteral: 'TemplateLiteral',
		        ThisExpression: 'ThisExpression',
		        ThrowStatement: 'ThrowStatement',
		        TryStatement: 'TryStatement',
		        UnaryExpression: 'UnaryExpression',
		        UpdateExpression: 'UpdateExpression',
		        VariableDeclaration: 'VariableDeclaration',
		        VariableDeclarator: 'VariableDeclarator',
		        WhileStatement: 'WhileStatement',
		        WithStatement: 'WithStatement',
		        YieldExpression: 'YieldExpression'
		    };
		    VisitorKeys = {
		        AssignmentExpression: ['left', 'right'],
		        AssignmentPattern: ['left', 'right'],
		        ArrayExpression: ['elements'],
		        ArrayPattern: ['elements'],
		        ArrowFunctionExpression: ['params', 'body'],
		        AwaitExpression: ['argument'],
		        BlockStatement: ['body'],
		        BinaryExpression: ['left', 'right'],
		        BreakStatement: ['label'],
		        CallExpression: ['callee', 'arguments'],
		        CatchClause: ['param', 'body'],
		        ChainExpression: ['expression'],
		        ClassBody: ['body'],
		        ClassDeclaration: ['id', 'superClass', 'body'],
		        ClassExpression: ['id', 'superClass', 'body'],
		        ComprehensionBlock: ['left', 'right'],
		        ComprehensionExpression: ['blocks', 'filter', 'body'],
		        ConditionalExpression: ['test', 'consequent', 'alternate'],
		        ContinueStatement: ['label'],
		        DebuggerStatement: [],
		        DirectiveStatement: [],
		        DoWhileStatement: ['body', 'test'],
		        EmptyStatement: [],
		        ExportAllDeclaration: ['source'],
		        ExportDefaultDeclaration: ['declaration'],
		        ExportNamedDeclaration: ['declaration', 'specifiers', 'source'],
		        ExportSpecifier: ['exported', 'local'],
		        ExpressionStatement: ['expression'],
		        ForStatement: ['init', 'test', 'update', 'body'],
		        ForInStatement: ['left', 'right', 'body'],
		        ForOfStatement: ['left', 'right', 'body'],
		        FunctionDeclaration: ['id', 'params', 'body'],
		        FunctionExpression: ['id', 'params', 'body'],
		        GeneratorExpression: ['blocks', 'filter', 'body'],
		        Identifier: [],
		        IfStatement: ['test', 'consequent', 'alternate'],
		        ImportExpression: ['source'],
		        ImportDeclaration: ['specifiers', 'source'],
		        ImportDefaultSpecifier: ['local'],
		        ImportNamespaceSpecifier: ['local'],
		        ImportSpecifier: ['imported', 'local'],
		        Literal: [],
		        LabeledStatement: ['label', 'body'],
		        LogicalExpression: ['left', 'right'],
		        MemberExpression: ['object', 'property'],
		        MetaProperty: ['meta', 'property'],
		        MethodDefinition: ['key', 'value'],
		        ModuleSpecifier: [],
		        NewExpression: ['callee', 'arguments'],
		        ObjectExpression: ['properties'],
		        ObjectPattern: ['properties'],
		        PrivateIdentifier: [],
		        Program: ['body'],
		        Property: ['key', 'value'],
		        PropertyDefinition: ['key', 'value'],
		        RestElement: [ 'argument' ],
		        ReturnStatement: ['argument'],
		        SequenceExpression: ['expressions'],
		        SpreadElement: ['argument'],
		        Super: [],
		        SwitchStatement: ['discriminant', 'cases'],
		        SwitchCase: ['test', 'consequent'],
		        TaggedTemplateExpression: ['tag', 'quasi'],
		        TemplateElement: [],
		        TemplateLiteral: ['quasis', 'expressions'],
		        ThisExpression: [],
		        ThrowStatement: ['argument'],
		        TryStatement: ['block', 'handler', 'finalizer'],
		        UnaryExpression: ['argument'],
		        UpdateExpression: ['argument'],
		        VariableDeclaration: ['declarations'],
		        VariableDeclarator: ['id', 'init'],
		        WhileStatement: ['test', 'body'],
		        WithStatement: ['object', 'body'],
		        YieldExpression: ['argument']
		    };
		    BREAK = {};
		    SKIP = {};
		    REMOVE = {};
		    VisitorOption = {
		        Break: BREAK,
		        Skip: SKIP,
		        Remove: REMOVE
		    };
		    function Reference(parent, key) {
		        this.parent = parent;
		        this.key = key;
		    }
		    Reference.prototype.replace = function replace(node) {
		        this.parent[this.key] = node;
		    };
		    Reference.prototype.remove = function remove() {
		        if (Array.isArray(this.parent)) {
		            this.parent.splice(this.key, 1);
		            return true;
		        } else {
		            this.replace(null);
		            return false;
		        }
		    };
		    function Element(node, path, wrap, ref) {
		        this.node = node;
		        this.path = path;
		        this.wrap = wrap;
		        this.ref = ref;
		    }
		    function Controller() { }
		    Controller.prototype.path = function path() {
		        var i, iz, j, jz, result, element;
		        function addToPath(result, path) {
		            if (Array.isArray(path)) {
		                for (j = 0, jz = path.length; j < jz; ++j) {
		                    result.push(path[j]);
		                }
		            } else {
		                result.push(path);
		            }
		        }
		        if (!this.__current.path) {
		            return null;
		        }
		        result = [];
		        for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {
		            element = this.__leavelist[i];
		            addToPath(result, element.path);
		        }
		        addToPath(result, this.__current.path);
		        return result;
		    };
		    Controller.prototype.type = function () {
		        var node = this.current();
		        return node.type || this.__current.wrap;
		    };
		    Controller.prototype.parents = function parents() {
		        var i, iz, result;
		        result = [];
		        for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {
		            result.push(this.__leavelist[i].node);
		        }
		        return result;
		    };
		    Controller.prototype.current = function current() {
		        return this.__current.node;
		    };
		    Controller.prototype.__execute = function __execute(callback, element) {
		        var previous, result;
		        result = undefined;
		        previous  = this.__current;
		        this.__current = element;
		        this.__state = null;
		        if (callback) {
		            result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);
		        }
		        this.__current = previous;
		        return result;
		    };
		    Controller.prototype.notify = function notify(flag) {
		        this.__state = flag;
		    };
		    Controller.prototype.skip = function () {
		        this.notify(SKIP);
		    };
		    Controller.prototype['break'] = function () {
		        this.notify(BREAK);
		    };
		    Controller.prototype.remove = function () {
		        this.notify(REMOVE);
		    };
		    Controller.prototype.__initialize = function(root, visitor) {
		        this.visitor = visitor;
		        this.root = root;
		        this.__worklist = [];
		        this.__leavelist = [];
		        this.__current = null;
		        this.__state = null;
		        this.__fallback = null;
		        if (visitor.fallback === 'iteration') {
		            this.__fallback = Object.keys;
		        } else if (typeof visitor.fallback === 'function') {
		            this.__fallback = visitor.fallback;
		        }
		        this.__keys = VisitorKeys;
		        if (visitor.keys) {
		            this.__keys = Object.assign(Object.create(this.__keys), visitor.keys);
		        }
		    };
		    function isNode(node) {
		        if (node == null) {
		            return false;
		        }
		        return typeof node === 'object' && typeof node.type === 'string';
		    }
		    function isProperty(nodeType, key) {
		        return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && 'properties' === key;
		    }
		    function candidateExistsInLeaveList(leavelist, candidate) {
		        for (var i = leavelist.length - 1; i >= 0; --i) {
		            if (leavelist[i].node === candidate) {
		                return true;
		            }
		        }
		        return false;
		    }
		    Controller.prototype.traverse = function traverse(root, visitor) {
		        var worklist,
		            leavelist,
		            element,
		            node,
		            nodeType,
		            ret,
		            key,
		            current,
		            current2,
		            candidates,
		            candidate,
		            sentinel;
		        this.__initialize(root, visitor);
		        sentinel = {};
		        worklist = this.__worklist;
		        leavelist = this.__leavelist;
		        worklist.push(new Element(root, null, null, null));
		        leavelist.push(new Element(null, null, null, null));
		        while (worklist.length) {
		            element = worklist.pop();
		            if (element === sentinel) {
		                element = leavelist.pop();
		                ret = this.__execute(visitor.leave, element);
		                if (this.__state === BREAK || ret === BREAK) {
		                    return;
		                }
		                continue;
		            }
		            if (element.node) {
		                ret = this.__execute(visitor.enter, element);
		                if (this.__state === BREAK || ret === BREAK) {
		                    return;
		                }
		                worklist.push(sentinel);
		                leavelist.push(element);
		                if (this.__state === SKIP || ret === SKIP) {
		                    continue;
		                }
		                node = element.node;
		                nodeType = node.type || element.wrap;
		                candidates = this.__keys[nodeType];
		                if (!candidates) {
		                    if (this.__fallback) {
		                        candidates = this.__fallback(node);
		                    } else {
		                        throw new Error('Unknown node type ' + nodeType + '.');
		                    }
		                }
		                current = candidates.length;
		                while ((current -= 1) >= 0) {
		                    key = candidates[current];
		                    candidate = node[key];
		                    if (!candidate) {
		                        continue;
		                    }
		                    if (Array.isArray(candidate)) {
		                        current2 = candidate.length;
		                        while ((current2 -= 1) >= 0) {
		                            if (!candidate[current2]) {
		                                continue;
		                            }
		                            if (candidateExistsInLeaveList(leavelist, candidate[current2])) {
		                              continue;
		                            }
		                            if (isProperty(nodeType, candidates[current])) {
		                                element = new Element(candidate[current2], [key, current2], 'Property', null);
		                            } else if (isNode(candidate[current2])) {
		                                element = new Element(candidate[current2], [key, current2], null, null);
		                            } else {
		                                continue;
		                            }
		                            worklist.push(element);
		                        }
		                    } else if (isNode(candidate)) {
		                        if (candidateExistsInLeaveList(leavelist, candidate)) {
		                          continue;
		                        }
		                        worklist.push(new Element(candidate, key, null, null));
		                    }
		                }
		            }
		        }
		    };
		    Controller.prototype.replace = function replace(root, visitor) {
		        var worklist,
		            leavelist,
		            node,
		            nodeType,
		            target,
		            element,
		            current,
		            current2,
		            candidates,
		            candidate,
		            sentinel,
		            outer,
		            key;
		        function removeElem(element) {
		            var i,
		                key,
		                nextElem,
		                parent;
		            if (element.ref.remove()) {
		                key = element.ref.key;
		                parent = element.ref.parent;
		                i = worklist.length;
		                while (i--) {
		                    nextElem = worklist[i];
		                    if (nextElem.ref && nextElem.ref.parent === parent) {
		                        if  (nextElem.ref.key < key) {
		                            break;
		                        }
		                        --nextElem.ref.key;
		                    }
		                }
		            }
		        }
		        this.__initialize(root, visitor);
		        sentinel = {};
		        worklist = this.__worklist;
		        leavelist = this.__leavelist;
		        outer = {
		            root: root
		        };
		        element = new Element(root, null, null, new Reference(outer, 'root'));
		        worklist.push(element);
		        leavelist.push(element);
		        while (worklist.length) {
		            element = worklist.pop();
		            if (element === sentinel) {
		                element = leavelist.pop();
		                target = this.__execute(visitor.leave, element);
		                if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
		                    element.ref.replace(target);
		                }
		                if (this.__state === REMOVE || target === REMOVE) {
		                    removeElem(element);
		                }
		                if (this.__state === BREAK || target === BREAK) {
		                    return outer.root;
		                }
		                continue;
		            }
		            target = this.__execute(visitor.enter, element);
		            if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
		                element.ref.replace(target);
		                element.node = target;
		            }
		            if (this.__state === REMOVE || target === REMOVE) {
		                removeElem(element);
		                element.node = null;
		            }
		            if (this.__state === BREAK || target === BREAK) {
		                return outer.root;
		            }
		            node = element.node;
		            if (!node) {
		                continue;
		            }
		            worklist.push(sentinel);
		            leavelist.push(element);
		            if (this.__state === SKIP || target === SKIP) {
		                continue;
		            }
		            nodeType = node.type || element.wrap;
		            candidates = this.__keys[nodeType];
		            if (!candidates) {
		                if (this.__fallback) {
		                    candidates = this.__fallback(node);
		                } else {
		                    throw new Error('Unknown node type ' + nodeType + '.');
		                }
		            }
		            current = candidates.length;
		            while ((current -= 1) >= 0) {
		                key = candidates[current];
		                candidate = node[key];
		                if (!candidate) {
		                    continue;
		                }
		                if (Array.isArray(candidate)) {
		                    current2 = candidate.length;
		                    while ((current2 -= 1) >= 0) {
		                        if (!candidate[current2]) {
		                            continue;
		                        }
		                        if (isProperty(nodeType, candidates[current])) {
		                            element = new Element(candidate[current2], [key, current2], 'Property', new Reference(candidate, current2));
		                        } else if (isNode(candidate[current2])) {
		                            element = new Element(candidate[current2], [key, current2], null, new Reference(candidate, current2));
		                        } else {
		                            continue;
		                        }
		                        worklist.push(element);
		                    }
		                } else if (isNode(candidate)) {
		                    worklist.push(new Element(candidate, key, null, new Reference(node, key)));
		                }
		            }
		        }
		        return outer.root;
		    };
		    function traverse(root, visitor) {
		        var controller = new Controller();
		        return controller.traverse(root, visitor);
		    }
		    function replace(root, visitor) {
		        var controller = new Controller();
		        return controller.replace(root, visitor);
		    }
		    function extendCommentRange(comment, tokens) {
		        var target;
		        target = upperBound(tokens, function search(token) {
		            return token.range[0] > comment.range[0];
		        });
		        comment.extendedRange = [comment.range[0], comment.range[1]];
		        if (target !== tokens.length) {
		            comment.extendedRange[1] = tokens[target].range[0];
		        }
		        target -= 1;
		        if (target >= 0) {
		            comment.extendedRange[0] = tokens[target].range[1];
		        }
		        return comment;
		    }
		    function attachComments(tree, providedComments, tokens) {
		        var comments = [], comment, len, i, cursor;
		        if (!tree.range) {
		            throw new Error('attachComments needs range information');
		        }
		        if (!tokens.length) {
		            if (providedComments.length) {
		                for (i = 0, len = providedComments.length; i < len; i += 1) {
		                    comment = deepCopy(providedComments[i]);
		                    comment.extendedRange = [0, tree.range[0]];
		                    comments.push(comment);
		                }
		                tree.leadingComments = comments;
		            }
		            return tree;
		        }
		        for (i = 0, len = providedComments.length; i < len; i += 1) {
		            comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
		        }
		        cursor = 0;
		        traverse(tree, {
		            enter: function (node) {
		                var comment;
		                while (cursor < comments.length) {
		                    comment = comments[cursor];
		                    if (comment.extendedRange[1] > node.range[0]) {
		                        break;
		                    }
		                    if (comment.extendedRange[1] === node.range[0]) {
		                        if (!node.leadingComments) {
		                            node.leadingComments = [];
		                        }
		                        node.leadingComments.push(comment);
		                        comments.splice(cursor, 1);
		                    } else {
		                        cursor += 1;
		                    }
		                }
		                if (cursor === comments.length) {
		                    return VisitorOption.Break;
		                }
		                if (comments[cursor].extendedRange[0] > node.range[1]) {
		                    return VisitorOption.Skip;
		                }
		            }
		        });
		        cursor = 0;
		        traverse(tree, {
		            leave: function (node) {
		                var comment;
		                while (cursor < comments.length) {
		                    comment = comments[cursor];
		                    if (node.range[1] < comment.extendedRange[0]) {
		                        break;
		                    }
		                    if (node.range[1] === comment.extendedRange[0]) {
		                        if (!node.trailingComments) {
		                            node.trailingComments = [];
		                        }
		                        node.trailingComments.push(comment);
		                        comments.splice(cursor, 1);
		                    } else {
		                        cursor += 1;
		                    }
		                }
		                if (cursor === comments.length) {
		                    return VisitorOption.Break;
		                }
		                if (comments[cursor].extendedRange[0] > node.range[1]) {
		                    return VisitorOption.Skip;
		                }
		            }
		        });
		        return tree;
		    }
		    exports.Syntax = Syntax;
		    exports.traverse = traverse;
		    exports.replace = replace;
		    exports.attachComments = attachComments;
		    exports.VisitorKeys = VisitorKeys;
		    exports.VisitorOption = VisitorOption;
		    exports.Controller = Controller;
		    exports.cloneEnvironment = function () { return clone({}); };
		    return exports;
		}(exports)); 
	} (estraverse));
	return estraverse;
}

var utils = {};

var ast = {exports: {}};

/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>
  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS'
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

var hasRequiredAst;

function requireAst () {
	if (hasRequiredAst) return ast.exports;
	hasRequiredAst = 1;
	(function () {
	    function isExpression(node) {
	        if (node == null) { return false; }
	        switch (node.type) {
	            case 'ArrayExpression':
	            case 'AssignmentExpression':
	            case 'BinaryExpression':
	            case 'CallExpression':
	            case 'ConditionalExpression':
	            case 'FunctionExpression':
	            case 'Identifier':
	            case 'Literal':
	            case 'LogicalExpression':
	            case 'MemberExpression':
	            case 'NewExpression':
	            case 'ObjectExpression':
	            case 'SequenceExpression':
	            case 'ThisExpression':
	            case 'UnaryExpression':
	            case 'UpdateExpression':
	                return true;
	        }
	        return false;
	    }
	    function isIterationStatement(node) {
	        if (node == null) { return false; }
	        switch (node.type) {
	            case 'DoWhileStatement':
	            case 'ForInStatement':
	            case 'ForStatement':
	            case 'WhileStatement':
	                return true;
	        }
	        return false;
	    }
	    function isStatement(node) {
	        if (node == null) { return false; }
	        switch (node.type) {
	            case 'BlockStatement':
	            case 'BreakStatement':
	            case 'ContinueStatement':
	            case 'DebuggerStatement':
	            case 'DoWhileStatement':
	            case 'EmptyStatement':
	            case 'ExpressionStatement':
	            case 'ForInStatement':
	            case 'ForStatement':
	            case 'IfStatement':
	            case 'LabeledStatement':
	            case 'ReturnStatement':
	            case 'SwitchStatement':
	            case 'ThrowStatement':
	            case 'TryStatement':
	            case 'VariableDeclaration':
	            case 'WhileStatement':
	            case 'WithStatement':
	                return true;
	        }
	        return false;
	    }
	    function isSourceElement(node) {
	      return isStatement(node) || node != null && node.type === 'FunctionDeclaration';
	    }
	    function trailingStatement(node) {
	        switch (node.type) {
	        case 'IfStatement':
	            if (node.alternate != null) {
	                return node.alternate;
	            }
	            return node.consequent;
	        case 'LabeledStatement':
	        case 'ForStatement':
	        case 'ForInStatement':
	        case 'WhileStatement':
	        case 'WithStatement':
	            return node.body;
	        }
	        return null;
	    }
	    function isProblematicIfStatement(node) {
	        var current;
	        if (node.type !== 'IfStatement') {
	            return false;
	        }
	        if (node.alternate == null) {
	            return false;
	        }
	        current = node.consequent;
	        do {
	            if (current.type === 'IfStatement') {
	                if (current.alternate == null)  {
	                    return true;
	                }
	            }
	            current = trailingStatement(current);
	        } while (current);
	        return false;
	    }
	    ast.exports = {
	        isExpression: isExpression,
	        isStatement: isStatement,
	        isIterationStatement: isIterationStatement,
	        isSourceElement: isSourceElement,
	        isProblematicIfStatement: isProblematicIfStatement,
	        trailingStatement: trailingStatement
	    };
	}());
	return ast.exports;
}

var code = {exports: {}};

/*
  Copyright (C) 2013-2014 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2014 Ivan Nikulin <ifaaan@gmail.com>
  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

var hasRequiredCode;

function requireCode () {
	if (hasRequiredCode) return code.exports;
	hasRequiredCode = 1;
	(function () {
	    var ES6Regex, ES5Regex, NON_ASCII_WHITESPACES, IDENTIFIER_START, IDENTIFIER_PART, ch;
	    ES5Regex = {
	        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
	        NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/
	    };
	    ES6Regex = {
	        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
	        NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
	    };
	    function isDecimalDigit(ch) {
	        return 0x30 <= ch && ch <= 0x39;
	    }
	    function isHexDigit(ch) {
	        return 0x30 <= ch && ch <= 0x39 ||
	            0x61 <= ch && ch <= 0x66 ||
	            0x41 <= ch && ch <= 0x46;
	    }
	    function isOctalDigit(ch) {
	        return ch >= 0x30 && ch <= 0x37;
	    }
	    NON_ASCII_WHITESPACES = [
	        0x1680,
	        0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A,
	        0x202F, 0x205F,
	        0x3000,
	        0xFEFF
	    ];
	    function isWhiteSpace(ch) {
	        return ch === 0x20 || ch === 0x09 || ch === 0x0B || ch === 0x0C || ch === 0xA0 ||
	            ch >= 0x1680 && NON_ASCII_WHITESPACES.indexOf(ch) >= 0;
	    }
	    function isLineTerminator(ch) {
	        return ch === 0x0A || ch === 0x0D || ch === 0x2028 || ch === 0x2029;
	    }
	    function fromCodePoint(cp) {
	        if (cp <= 0xFFFF) { return String.fromCharCode(cp); }
	        var cu1 = String.fromCharCode(Math.floor((cp - 0x10000) / 0x400) + 0xD800);
	        var cu2 = String.fromCharCode(((cp - 0x10000) % 0x400) + 0xDC00);
	        return cu1 + cu2;
	    }
	    IDENTIFIER_START = new Array(0x80);
	    for(ch = 0; ch < 0x80; ++ch) {
	        IDENTIFIER_START[ch] =
	            ch >= 0x61 && ch <= 0x7A ||
	            ch >= 0x41 && ch <= 0x5A ||
	            ch === 0x24 || ch === 0x5F;
	    }
	    IDENTIFIER_PART = new Array(0x80);
	    for(ch = 0; ch < 0x80; ++ch) {
	        IDENTIFIER_PART[ch] =
	            ch >= 0x61 && ch <= 0x7A ||
	            ch >= 0x41 && ch <= 0x5A ||
	            ch >= 0x30 && ch <= 0x39 ||
	            ch === 0x24 || ch === 0x5F;
	    }
	    function isIdentifierStartES5(ch) {
	        return ch < 0x80 ? IDENTIFIER_START[ch] : ES5Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
	    }
	    function isIdentifierPartES5(ch) {
	        return ch < 0x80 ? IDENTIFIER_PART[ch] : ES5Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
	    }
	    function isIdentifierStartES6(ch) {
	        return ch < 0x80 ? IDENTIFIER_START[ch] : ES6Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
	    }
	    function isIdentifierPartES6(ch) {
	        return ch < 0x80 ? IDENTIFIER_PART[ch] : ES6Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
	    }
	    code.exports = {
	        isDecimalDigit: isDecimalDigit,
	        isHexDigit: isHexDigit,
	        isOctalDigit: isOctalDigit,
	        isWhiteSpace: isWhiteSpace,
	        isLineTerminator: isLineTerminator,
	        isIdentifierStartES5: isIdentifierStartES5,
	        isIdentifierPartES5: isIdentifierPartES5,
	        isIdentifierStartES6: isIdentifierStartES6,
	        isIdentifierPartES6: isIdentifierPartES6
	    };
	}());
	return code.exports;
}

var keyword = {exports: {}};

/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>
  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

var hasRequiredKeyword;

function requireKeyword () {
	if (hasRequiredKeyword) return keyword.exports;
	hasRequiredKeyword = 1;
	(function () {
	    var code = requireCode();
	    function isStrictModeReservedWordES6(id) {
	        switch (id) {
	        case 'implements':
	        case 'interface':
	        case 'package':
	        case 'private':
	        case 'protected':
	        case 'public':
	        case 'static':
	        case 'let':
	            return true;
	        default:
	            return false;
	        }
	    }
	    function isKeywordES5(id, strict) {
	        if (!strict && id === 'yield') {
	            return false;
	        }
	        return isKeywordES6(id, strict);
	    }
	    function isKeywordES6(id, strict) {
	        if (strict && isStrictModeReservedWordES6(id)) {
	            return true;
	        }
	        switch (id.length) {
	        case 2:
	            return (id === 'if') || (id === 'in') || (id === 'do');
	        case 3:
	            return (id === 'var') || (id === 'for') || (id === 'new') || (id === 'try');
	        case 4:
	            return (id === 'this') || (id === 'else') || (id === 'case') ||
	                (id === 'void') || (id === 'with') || (id === 'enum');
	        case 5:
	            return (id === 'while') || (id === 'break') || (id === 'catch') ||
	                (id === 'throw') || (id === 'const') || (id === 'yield') ||
	                (id === 'class') || (id === 'super');
	        case 6:
	            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
	                (id === 'switch') || (id === 'export') || (id === 'import');
	        case 7:
	            return (id === 'default') || (id === 'finally') || (id === 'extends');
	        case 8:
	            return (id === 'function') || (id === 'continue') || (id === 'debugger');
	        case 10:
	            return (id === 'instanceof');
	        default:
	            return false;
	        }
	    }
	    function isReservedWordES5(id, strict) {
	        return id === 'null' || id === 'true' || id === 'false' || isKeywordES5(id, strict);
	    }
	    function isReservedWordES6(id, strict) {
	        return id === 'null' || id === 'true' || id === 'false' || isKeywordES6(id, strict);
	    }
	    function isRestrictedWord(id) {
	        return id === 'eval' || id === 'arguments';
	    }
	    function isIdentifierNameES5(id) {
	        var i, iz, ch;
	        if (id.length === 0) { return false; }
	        ch = id.charCodeAt(0);
	        if (!code.isIdentifierStartES5(ch)) {
	            return false;
	        }
	        for (i = 1, iz = id.length; i < iz; ++i) {
	            ch = id.charCodeAt(i);
	            if (!code.isIdentifierPartES5(ch)) {
	                return false;
	            }
	        }
	        return true;
	    }
	    function decodeUtf16(lead, trail) {
	        return (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
	    }
	    function isIdentifierNameES6(id) {
	        var i, iz, ch, lowCh, check;
	        if (id.length === 0) { return false; }
	        check = code.isIdentifierStartES6;
	        for (i = 0, iz = id.length; i < iz; ++i) {
	            ch = id.charCodeAt(i);
	            if (0xD800 <= ch && ch <= 0xDBFF) {
	                ++i;
	                if (i >= iz) { return false; }
	                lowCh = id.charCodeAt(i);
	                if (!(0xDC00 <= lowCh && lowCh <= 0xDFFF)) {
	                    return false;
	                }
	                ch = decodeUtf16(ch, lowCh);
	            }
	            if (!check(ch)) {
	                return false;
	            }
	            check = code.isIdentifierPartES6;
	        }
	        return true;
	    }
	    function isIdentifierES5(id, strict) {
	        return isIdentifierNameES5(id) && !isReservedWordES5(id, strict);
	    }
	    function isIdentifierES6(id, strict) {
	        return isIdentifierNameES6(id) && !isReservedWordES6(id, strict);
	    }
	    keyword.exports = {
	        isKeywordES5: isKeywordES5,
	        isKeywordES6: isKeywordES6,
	        isReservedWordES5: isReservedWordES5,
	        isReservedWordES6: isReservedWordES6,
	        isRestrictedWord: isRestrictedWord,
	        isIdentifierNameES5: isIdentifierNameES5,
	        isIdentifierNameES6: isIdentifierNameES6,
	        isIdentifierES5: isIdentifierES5,
	        isIdentifierES6: isIdentifierES6
	    };
	}());
	return keyword.exports;
}

/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>
  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

var hasRequiredUtils;

function requireUtils () {
	if (hasRequiredUtils) return utils;
	hasRequiredUtils = 1;
	(function () {
	    utils.ast = requireAst();
	    utils.code = requireCode();
	    utils.keyword = requireKeyword();
	}());
	return utils;
}

var sourceMap = {};

var sourceMapGenerator = {};

var base64Vlq = {};

var base64 = {};

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var hasRequiredBase64;

function requireBase64 () {
	if (hasRequiredBase64) return base64;
	hasRequiredBase64 = 1;
	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');
	base64.encode = function (number) {
	  if (0 <= number && number < intToCharMap.length) {
	    return intToCharMap[number];
	  }
	  throw new TypeError("Must be between 0 and 63: " + number);
	};
	base64.decode = function (charCode) {
	  var bigA = 65;
	  var bigZ = 90;
	  var littleA = 97;
	  var littleZ = 122;
	  var zero = 48;
	  var nine = 57;
	  var plus = 43;
	  var slash = 47;
	  var littleOffset = 26;
	  var numberOffset = 52;
	  if (bigA <= charCode && charCode <= bigZ) {
	    return (charCode - bigA);
	  }
	  if (littleA <= charCode && charCode <= littleZ) {
	    return (charCode - littleA + littleOffset);
	  }
	  if (zero <= charCode && charCode <= nine) {
	    return (charCode - zero + numberOffset);
	  }
	  if (charCode == plus) {
	    return 62;
	  }
	  if (charCode == slash) {
	    return 63;
	  }
	  return -1;
	};
	return base64;
}

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var hasRequiredBase64Vlq;

function requireBase64Vlq () {
	if (hasRequiredBase64Vlq) return base64Vlq;
	hasRequiredBase64Vlq = 1;
	var base64 = requireBase64();
	var VLQ_BASE_SHIFT = 5;
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
	var VLQ_BASE_MASK = VLQ_BASE - 1;
	var VLQ_CONTINUATION_BIT = VLQ_BASE;
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}
	base64Vlq.encode = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;
	  var vlq = toVLQSigned(aValue);
	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;
	    if (vlq > 0) {
	      digit |= VLQ_CONTINUATION_BIT;
	    }
	    encoded += base64.encode(digit);
	  } while (vlq > 0);
	  return encoded;
	};
	base64Vlq.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;
	  do {
	    if (aIndex >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }
	    digit = base64.decode(aStr.charCodeAt(aIndex++));
	    if (digit === -1) {
	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	    }
	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);
	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aIndex;
	};
	return base64Vlq;
}

var util$1 = {};

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var hasRequiredUtil$1;

function requireUtil$1 () {
	if (hasRequiredUtil$1) return util$1;
	hasRequiredUtil$1 = 1;
	(function (exports) {
		function getArg(aArgs, aName, aDefaultValue) {
		  if (aName in aArgs) {
		    return aArgs[aName];
		  } else if (arguments.length === 3) {
		    return aDefaultValue;
		  } else {
		    throw new Error('"' + aName + '" is a required argument.');
		  }
		}
		exports.getArg = getArg;
		var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
		var dataUrlRegexp = /^data:.+\,.+$/;
		function urlParse(aUrl) {
		  var match = aUrl.match(urlRegexp);
		  if (!match) {
		    return null;
		  }
		  return {
		    scheme: match[1],
		    auth: match[2],
		    host: match[3],
		    port: match[4],
		    path: match[5]
		  };
		}
		exports.urlParse = urlParse;
		function urlGenerate(aParsedUrl) {
		  var url = '';
		  if (aParsedUrl.scheme) {
		    url += aParsedUrl.scheme + ':';
		  }
		  url += '//';
		  if (aParsedUrl.auth) {
		    url += aParsedUrl.auth + '@';
		  }
		  if (aParsedUrl.host) {
		    url += aParsedUrl.host;
		  }
		  if (aParsedUrl.port) {
		    url += ":" + aParsedUrl.port;
		  }
		  if (aParsedUrl.path) {
		    url += aParsedUrl.path;
		  }
		  return url;
		}
		exports.urlGenerate = urlGenerate;
		function normalize(aPath) {
		  var path = aPath;
		  var url = urlParse(aPath);
		  if (url) {
		    if (!url.path) {
		      return aPath;
		    }
		    path = url.path;
		  }
		  var isAbsolute = exports.isAbsolute(path);
		  var parts = path.split(/\/+/);
		  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
		    part = parts[i];
		    if (part === '.') {
		      parts.splice(i, 1);
		    } else if (part === '..') {
		      up++;
		    } else if (up > 0) {
		      if (part === '') {
		        parts.splice(i + 1, up);
		        up = 0;
		      } else {
		        parts.splice(i, 2);
		        up--;
		      }
		    }
		  }
		  path = parts.join('/');
		  if (path === '') {
		    path = isAbsolute ? '/' : '.';
		  }
		  if (url) {
		    url.path = path;
		    return urlGenerate(url);
		  }
		  return path;
		}
		exports.normalize = normalize;
		function join(aRoot, aPath) {
		  if (aRoot === "") {
		    aRoot = ".";
		  }
		  if (aPath === "") {
		    aPath = ".";
		  }
		  var aPathUrl = urlParse(aPath);
		  var aRootUrl = urlParse(aRoot);
		  if (aRootUrl) {
		    aRoot = aRootUrl.path || '/';
		  }
		  if (aPathUrl && !aPathUrl.scheme) {
		    if (aRootUrl) {
		      aPathUrl.scheme = aRootUrl.scheme;
		    }
		    return urlGenerate(aPathUrl);
		  }
		  if (aPathUrl || aPath.match(dataUrlRegexp)) {
		    return aPath;
		  }
		  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
		    aRootUrl.host = aPath;
		    return urlGenerate(aRootUrl);
		  }
		  var joined = aPath.charAt(0) === '/'
		    ? aPath
		    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);
		  if (aRootUrl) {
		    aRootUrl.path = joined;
		    return urlGenerate(aRootUrl);
		  }
		  return joined;
		}
		exports.join = join;
		exports.isAbsolute = function (aPath) {
		  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
		};
		function relative(aRoot, aPath) {
		  if (aRoot === "") {
		    aRoot = ".";
		  }
		  aRoot = aRoot.replace(/\/$/, '');
		  var level = 0;
		  while (aPath.indexOf(aRoot + '/') !== 0) {
		    var index = aRoot.lastIndexOf("/");
		    if (index < 0) {
		      return aPath;
		    }
		    aRoot = aRoot.slice(0, index);
		    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
		      return aPath;
		    }
		    ++level;
		  }
		  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
		}
		exports.relative = relative;
		var supportsNullProto = (function () {
		  var obj = Object.create(null);
		  return !('__proto__' in obj);
		}());
		function identity (s) {
		  return s;
		}
		function toSetString(aStr) {
		  if (isProtoString(aStr)) {
		    return '$' + aStr;
		  }
		  return aStr;
		}
		exports.toSetString = supportsNullProto ? identity : toSetString;
		function fromSetString(aStr) {
		  if (isProtoString(aStr)) {
		    return aStr.slice(1);
		  }
		  return aStr;
		}
		exports.fromSetString = supportsNullProto ? identity : fromSetString;
		function isProtoString(s) {
		  if (!s) {
		    return false;
		  }
		  var length = s.length;
		  if (length < 9 ) {
		    return false;
		  }
		  if (s.charCodeAt(length - 1) !== 95   ||
		      s.charCodeAt(length - 2) !== 95   ||
		      s.charCodeAt(length - 3) !== 111  ||
		      s.charCodeAt(length - 4) !== 116  ||
		      s.charCodeAt(length - 5) !== 111  ||
		      s.charCodeAt(length - 6) !== 114  ||
		      s.charCodeAt(length - 7) !== 112  ||
		      s.charCodeAt(length - 8) !== 95   ||
		      s.charCodeAt(length - 9) !== 95  ) {
		    return false;
		  }
		  for (var i = length - 10; i >= 0; i--) {
		    if (s.charCodeAt(i) !== 36 ) {
		      return false;
		    }
		  }
		  return true;
		}
		function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
		  var cmp = strcmp(mappingA.source, mappingB.source);
		  if (cmp !== 0) {
		    return cmp;
		  }
		  cmp = mappingA.originalLine - mappingB.originalLine;
		  if (cmp !== 0) {
		    return cmp;
		  }
		  cmp = mappingA.originalColumn - mappingB.originalColumn;
		  if (cmp !== 0 || onlyCompareOriginal) {
		    return cmp;
		  }
		  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
		  if (cmp !== 0) {
		    return cmp;
		  }
		  cmp = mappingA.generatedLine - mappingB.generatedLine;
		  if (cmp !== 0) {
		    return cmp;
		  }
		  return strcmp(mappingA.name, mappingB.name);
		}
		exports.compareByOriginalPositions = compareByOriginalPositions;
		function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
		  var cmp = mappingA.generatedLine - mappingB.generatedLine;
		  if (cmp !== 0) {
		    return cmp;
		  }
		  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
		  if (cmp !== 0 || onlyCompareGenerated) {
		    return cmp;
		  }
		  cmp = strcmp(mappingA.source, mappingB.source);
		  if (cmp !== 0) {
		    return cmp;
		  }
		  cmp = mappingA.originalLine - mappingB.originalLine;
		  if (cmp !== 0) {
		    return cmp;
		  }
		  cmp = mappingA.originalColumn - mappingB.originalColumn;
		  if (cmp !== 0) {
		    return cmp;
		  }
		  return strcmp(mappingA.name, mappingB.name);
		}
		exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
		function strcmp(aStr1, aStr2) {
		  if (aStr1 === aStr2) {
		    return 0;
		  }
		  if (aStr1 === null) {
		    return 1;
		  }
		  if (aStr2 === null) {
		    return -1;
		  }
		  if (aStr1 > aStr2) {
		    return 1;
		  }
		  return -1;
		}
		function compareByGeneratedPositionsInflated(mappingA, mappingB) {
		  var cmp = mappingA.generatedLine - mappingB.generatedLine;
		  if (cmp !== 0) {
		    return cmp;
		  }
		  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
		  if (cmp !== 0) {
		    return cmp;
		  }
		  cmp = strcmp(mappingA.source, mappingB.source);
		  if (cmp !== 0) {
		    return cmp;
		  }
		  cmp = mappingA.originalLine - mappingB.originalLine;
		  if (cmp !== 0) {
		    return cmp;
		  }
		  cmp = mappingA.originalColumn - mappingB.originalColumn;
		  if (cmp !== 0) {
		    return cmp;
		  }
		  return strcmp(mappingA.name, mappingB.name);
		}
		exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
		function parseSourceMapInput(str) {
		  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
		}
		exports.parseSourceMapInput = parseSourceMapInput;
		function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
		  sourceURL = sourceURL || '';
		  if (sourceRoot) {
		    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
		      sourceRoot += '/';
		    }
		    sourceURL = sourceRoot + sourceURL;
		  }
		  if (sourceMapURL) {
		    var parsed = urlParse(sourceMapURL);
		    if (!parsed) {
		      throw new Error("sourceMapURL could not be parsed");
		    }
		    if (parsed.path) {
		      var index = parsed.path.lastIndexOf('/');
		      if (index >= 0) {
		        parsed.path = parsed.path.substring(0, index + 1);
		      }
		    }
		    sourceURL = join(urlGenerate(parsed), sourceURL);
		  }
		  return normalize(sourceURL);
		}
		exports.computeSourceURL = computeSourceURL; 
	} (util$1));
	return util$1;
}

var arraySet = {};

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var hasRequiredArraySet;

function requireArraySet () {
	if (hasRequiredArraySet) return arraySet;
	hasRequiredArraySet = 1;
	var util = requireUtil$1();
	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";
	function ArraySet() {
	  this._array = [];
	  this._set = hasNativeMap ? new Map() : Object.create(null);
	}
	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet();
	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }
	  return set;
	};
	ArraySet.prototype.size = function ArraySet_size() {
	  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};
	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
	  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
	  var idx = this._array.length;
	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }
	  if (!isDuplicate) {
	    if (hasNativeMap) {
	      this._set.set(aStr, idx);
	    } else {
	      this._set[sStr] = idx;
	    }
	  }
	};
	ArraySet.prototype.has = function ArraySet_has(aStr) {
	  if (hasNativeMap) {
	    return this._set.has(aStr);
	  } else {
	    var sStr = util.toSetString(aStr);
	    return has.call(this._set, sStr);
	  }
	};
	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  if (hasNativeMap) {
	    var idx = this._set.get(aStr);
	    if (idx >= 0) {
	        return idx;
	    }
	  } else {
	    var sStr = util.toSetString(aStr);
	    if (has.call(this._set, sStr)) {
	      return this._set[sStr];
	    }
	  }
	  throw new Error('"' + aStr + '" is not in the set.');
	};
	ArraySet.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }
	  throw new Error('No element indexed by ' + aIdx);
	};
	ArraySet.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};
	arraySet.ArraySet = ArraySet;
	return arraySet;
}

var mappingList = {};

/*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var hasRequiredMappingList;

function requireMappingList () {
	if (hasRequiredMappingList) return mappingList;
	hasRequiredMappingList = 1;
	var util = requireUtil$1();
	function generatedPositionAfter(mappingA, mappingB) {
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}
	function MappingList() {
	  this._array = [];
	  this._sorted = true;
	  this._last = {generatedLine: -1, generatedColumn: 0};
	}
	MappingList.prototype.unsortedForEach =
	  function MappingList_forEach(aCallback, aThisArg) {
	    this._array.forEach(aCallback, aThisArg);
	  };
	MappingList.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;
	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;
	    this._array.push(aMapping);
	  }
	};
	MappingList.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util.compareByGeneratedPositionsInflated);
	    this._sorted = true;
	  }
	  return this._array;
	};
	mappingList.MappingList = MappingList;
	return mappingList;
}

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var hasRequiredSourceMapGenerator;

function requireSourceMapGenerator () {
	if (hasRequiredSourceMapGenerator) return sourceMapGenerator;
	hasRequiredSourceMapGenerator = 1;
	var base64VLQ = requireBase64Vlq();
	var util = requireUtil$1();
	var ArraySet = requireArraySet().ArraySet;
	var MappingList = requireMappingList().MappingList;
	function SourceMapGenerator(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }
	  this._file = util.getArg(aArgs, 'file', null);
	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	  this._sources = new ArraySet();
	  this._names = new ArraySet();
	  this._mappings = new MappingList();
	  this._sourcesContents = null;
	}
	SourceMapGenerator.prototype._version = 3;
	SourceMapGenerator.fromSourceMap =
	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	    var sourceRoot = aSourceMapConsumer.sourceRoot;
	    var generator = new SourceMapGenerator({
	      file: aSourceMapConsumer.file,
	      sourceRoot: sourceRoot
	    });
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      var newMapping = {
	        generated: {
	          line: mapping.generatedLine,
	          column: mapping.generatedColumn
	        }
	      };
	      if (mapping.source != null) {
	        newMapping.source = mapping.source;
	        if (sourceRoot != null) {
	          newMapping.source = util.relative(sourceRoot, newMapping.source);
	        }
	        newMapping.original = {
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        };
	        if (mapping.name != null) {
	          newMapping.name = mapping.name;
	        }
	      }
	      generator.addMapping(newMapping);
	    });
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var sourceRelative = sourceFile;
	      if (sourceRoot !== null) {
	        sourceRelative = util.relative(sourceRoot, sourceFile);
	      }
	      if (!generator._sources.has(sourceRelative)) {
	        generator._sources.add(sourceRelative);
	      }
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        generator.setSourceContent(sourceFile, content);
	      }
	    });
	    return generator;
	  };
	SourceMapGenerator.prototype.addMapping =
	  function SourceMapGenerator_addMapping(aArgs) {
	    var generated = util.getArg(aArgs, 'generated');
	    var original = util.getArg(aArgs, 'original', null);
	    var source = util.getArg(aArgs, 'source', null);
	    var name = util.getArg(aArgs, 'name', null);
	    if (!this._skipValidation) {
	      this._validateMapping(generated, original, source, name);
	    }
	    if (source != null) {
	      source = String(source);
	      if (!this._sources.has(source)) {
	        this._sources.add(source);
	      }
	    }
	    if (name != null) {
	      name = String(name);
	      if (!this._names.has(name)) {
	        this._names.add(name);
	      }
	    }
	    this._mappings.add({
	      generatedLine: generated.line,
	      generatedColumn: generated.column,
	      originalLine: original != null && original.line,
	      originalColumn: original != null && original.column,
	      source: source,
	      name: name
	    });
	  };
	SourceMapGenerator.prototype.setSourceContent =
	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	    var source = aSourceFile;
	    if (this._sourceRoot != null) {
	      source = util.relative(this._sourceRoot, source);
	    }
	    if (aSourceContent != null) {
	      if (!this._sourcesContents) {
	        this._sourcesContents = Object.create(null);
	      }
	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
	    } else if (this._sourcesContents) {
	      delete this._sourcesContents[util.toSetString(source)];
	      if (Object.keys(this._sourcesContents).length === 0) {
	        this._sourcesContents = null;
	      }
	    }
	  };
	SourceMapGenerator.prototype.applySourceMap =
	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	    var sourceFile = aSourceFile;
	    if (aSourceFile == null) {
	      if (aSourceMapConsumer.file == null) {
	        throw new Error(
	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	          'or the source map\'s "file" property. Both were omitted.'
	        );
	      }
	      sourceFile = aSourceMapConsumer.file;
	    }
	    var sourceRoot = this._sourceRoot;
	    if (sourceRoot != null) {
	      sourceFile = util.relative(sourceRoot, sourceFile);
	    }
	    var newSources = new ArraySet();
	    var newNames = new ArraySet();
	    this._mappings.unsortedForEach(function (mapping) {
	      if (mapping.source === sourceFile && mapping.originalLine != null) {
	        var original = aSourceMapConsumer.originalPositionFor({
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        });
	        if (original.source != null) {
	          mapping.source = original.source;
	          if (aSourceMapPath != null) {
	            mapping.source = util.join(aSourceMapPath, mapping.source);
	          }
	          if (sourceRoot != null) {
	            mapping.source = util.relative(sourceRoot, mapping.source);
	          }
	          mapping.originalLine = original.line;
	          mapping.originalColumn = original.column;
	          if (original.name != null) {
	            mapping.name = original.name;
	          }
	        }
	      }
	      var source = mapping.source;
	      if (source != null && !newSources.has(source)) {
	        newSources.add(source);
	      }
	      var name = mapping.name;
	      if (name != null && !newNames.has(name)) {
	        newNames.add(name);
	      }
	    }, this);
	    this._sources = newSources;
	    this._names = newNames;
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aSourceMapPath != null) {
	          sourceFile = util.join(aSourceMapPath, sourceFile);
	        }
	        if (sourceRoot != null) {
	          sourceFile = util.relative(sourceRoot, sourceFile);
	        }
	        this.setSourceContent(sourceFile, content);
	      }
	    }, this);
	  };
	SourceMapGenerator.prototype._validateMapping =
	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                              aName) {
	    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
	        throw new Error(
	            'original.line and original.column are not numbers -- you probably meant to omit ' +
	            'the original mapping entirely and only map the generated position. If so, pass ' +
	            'null for the original mapping instead of an object with empty or null values.'
	        );
	    }
	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	        && aGenerated.line > 0 && aGenerated.column >= 0
	        && !aOriginal && !aSource && !aName) {
	      return;
	    }
	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	             && aGenerated.line > 0 && aGenerated.column >= 0
	             && aOriginal.line > 0 && aOriginal.column >= 0
	             && aSource) {
	      return;
	    }
	    else {
	      throw new Error('Invalid mapping: ' + JSON.stringify({
	        generated: aGenerated,
	        source: aSource,
	        original: aOriginal,
	        name: aName
	      }));
	    }
	  };
	SourceMapGenerator.prototype._serializeMappings =
	  function SourceMapGenerator_serializeMappings() {
	    var previousGeneratedColumn = 0;
	    var previousGeneratedLine = 1;
	    var previousOriginalColumn = 0;
	    var previousOriginalLine = 0;
	    var previousName = 0;
	    var previousSource = 0;
	    var result = '';
	    var next;
	    var mapping;
	    var nameIdx;
	    var sourceIdx;
	    var mappings = this._mappings.toArray();
	    for (var i = 0, len = mappings.length; i < len; i++) {
	      mapping = mappings[i];
	      next = '';
	      if (mapping.generatedLine !== previousGeneratedLine) {
	        previousGeneratedColumn = 0;
	        while (mapping.generatedLine !== previousGeneratedLine) {
	          next += ';';
	          previousGeneratedLine++;
	        }
	      }
	      else {
	        if (i > 0) {
	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	            continue;
	          }
	          next += ',';
	        }
	      }
	      next += base64VLQ.encode(mapping.generatedColumn
	                                 - previousGeneratedColumn);
	      previousGeneratedColumn = mapping.generatedColumn;
	      if (mapping.source != null) {
	        sourceIdx = this._sources.indexOf(mapping.source);
	        next += base64VLQ.encode(sourceIdx - previousSource);
	        previousSource = sourceIdx;
	        next += base64VLQ.encode(mapping.originalLine - 1
	                                   - previousOriginalLine);
	        previousOriginalLine = mapping.originalLine - 1;
	        next += base64VLQ.encode(mapping.originalColumn
	                                   - previousOriginalColumn);
	        previousOriginalColumn = mapping.originalColumn;
	        if (mapping.name != null) {
	          nameIdx = this._names.indexOf(mapping.name);
	          next += base64VLQ.encode(nameIdx - previousName);
	          previousName = nameIdx;
	        }
	      }
	      result += next;
	    }
	    return result;
	  };
	SourceMapGenerator.prototype._generateSourcesContent =
	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	    return aSources.map(function (source) {
	      if (!this._sourcesContents) {
	        return null;
	      }
	      if (aSourceRoot != null) {
	        source = util.relative(aSourceRoot, source);
	      }
	      var key = util.toSetString(source);
	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
	        ? this._sourcesContents[key]
	        : null;
	    }, this);
	  };
	SourceMapGenerator.prototype.toJSON =
	  function SourceMapGenerator_toJSON() {
	    var map = {
	      version: this._version,
	      sources: this._sources.toArray(),
	      names: this._names.toArray(),
	      mappings: this._serializeMappings()
	    };
	    if (this._file != null) {
	      map.file = this._file;
	    }
	    if (this._sourceRoot != null) {
	      map.sourceRoot = this._sourceRoot;
	    }
	    if (this._sourcesContents) {
	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	    }
	    return map;
	  };
	SourceMapGenerator.prototype.toString =
	  function SourceMapGenerator_toString() {
	    return JSON.stringify(this.toJSON());
	  };
	sourceMapGenerator.SourceMapGenerator = SourceMapGenerator;
	return sourceMapGenerator;
}

var sourceMapConsumer = {};

var binarySearch = {};

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var hasRequiredBinarySearch;

function requireBinarySearch () {
	if (hasRequiredBinarySearch) return binarySearch;
	hasRequiredBinarySearch = 1;
	(function (exports) {
		exports.GREATEST_LOWER_BOUND = 1;
		exports.LEAST_UPPER_BOUND = 2;
		function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
		  var mid = Math.floor((aHigh - aLow) / 2) + aLow;
		  var cmp = aCompare(aNeedle, aHaystack[mid], true);
		  if (cmp === 0) {
		    return mid;
		  }
		  else if (cmp > 0) {
		    if (aHigh - mid > 1) {
		      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
		    }
		    if (aBias == exports.LEAST_UPPER_BOUND) {
		      return aHigh < aHaystack.length ? aHigh : -1;
		    } else {
		      return mid;
		    }
		  }
		  else {
		    if (mid - aLow > 1) {
		      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
		    }
		    if (aBias == exports.LEAST_UPPER_BOUND) {
		      return mid;
		    } else {
		      return aLow < 0 ? -1 : aLow;
		    }
		  }
		}
		exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
		  if (aHaystack.length === 0) {
		    return -1;
		  }
		  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
		                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);
		  if (index < 0) {
		    return -1;
		  }
		  while (index - 1 >= 0) {
		    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
		      break;
		    }
		    --index;
		  }
		  return index;
		}; 
	} (binarySearch));
	return binarySearch;
}

var quickSort = {};

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var hasRequiredQuickSort;

function requireQuickSort () {
	if (hasRequiredQuickSort) return quickSort;
	hasRequiredQuickSort = 1;
	function swap(ary, x, y) {
	  var temp = ary[x];
	  ary[x] = ary[y];
	  ary[y] = temp;
	}
	function randomIntInRange(low, high) {
	  return Math.round(low + (Math.random() * (high - low)));
	}
	function doQuickSort(ary, comparator, p, r) {
	  if (p < r) {
	    var pivotIndex = randomIntInRange(p, r);
	    var i = p - 1;
	    swap(ary, pivotIndex, r);
	    var pivot = ary[r];
	    for (var j = p; j < r; j++) {
	      if (comparator(ary[j], pivot) <= 0) {
	        i += 1;
	        swap(ary, i, j);
	      }
	    }
	    swap(ary, i + 1, j);
	    var q = i + 1;
	    doQuickSort(ary, comparator, p, q - 1);
	    doQuickSort(ary, comparator, q + 1, r);
	  }
	}
	quickSort.quickSort = function (ary, comparator) {
	  doQuickSort(ary, comparator, 0, ary.length - 1);
	};
	return quickSort;
}

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var hasRequiredSourceMapConsumer;

function requireSourceMapConsumer () {
	if (hasRequiredSourceMapConsumer) return sourceMapConsumer;
	hasRequiredSourceMapConsumer = 1;
	var util = requireUtil$1();
	var binarySearch = requireBinarySearch();
	var ArraySet = requireArraySet().ArraySet;
	var base64VLQ = requireBase64Vlq();
	var quickSort = requireQuickSort().quickSort;
	function SourceMapConsumer(aSourceMap, aSourceMapURL) {
	  var sourceMap = aSourceMap;
	  if (typeof aSourceMap === 'string') {
	    sourceMap = util.parseSourceMapInput(aSourceMap);
	  }
	  return sourceMap.sections != null
	    ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)
	    : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
	}
	SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
	  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
	};
	SourceMapConsumer.prototype._version = 3;
	SourceMapConsumer.prototype.__generatedMappings = null;
	Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
	  configurable: true,
	  enumerable: true,
	  get: function () {
	    if (!this.__generatedMappings) {
	      this._parseMappings(this._mappings, this.sourceRoot);
	    }
	    return this.__generatedMappings;
	  }
	});
	SourceMapConsumer.prototype.__originalMappings = null;
	Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
	  configurable: true,
	  enumerable: true,
	  get: function () {
	    if (!this.__originalMappings) {
	      this._parseMappings(this._mappings, this.sourceRoot);
	    }
	    return this.__originalMappings;
	  }
	});
	SourceMapConsumer.prototype._charIsMappingSeparator =
	  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
	    var c = aStr.charAt(index);
	    return c === ";" || c === ",";
	  };
	SourceMapConsumer.prototype._parseMappings =
	  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	    throw new Error("Subclasses must implement _parseMappings");
	  };
	SourceMapConsumer.GENERATED_ORDER = 1;
	SourceMapConsumer.ORIGINAL_ORDER = 2;
	SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
	SourceMapConsumer.LEAST_UPPER_BOUND = 2;
	SourceMapConsumer.prototype.eachMapping =
	  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
	    var context = aContext || null;
	    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
	    var mappings;
	    switch (order) {
	    case SourceMapConsumer.GENERATED_ORDER:
	      mappings = this._generatedMappings;
	      break;
	    case SourceMapConsumer.ORIGINAL_ORDER:
	      mappings = this._originalMappings;
	      break;
	    default:
	      throw new Error("Unknown order of iteration.");
	    }
	    var sourceRoot = this.sourceRoot;
	    mappings.map(function (mapping) {
	      var source = mapping.source === null ? null : this._sources.at(mapping.source);
	      source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
	      return {
	        source: source,
	        generatedLine: mapping.generatedLine,
	        generatedColumn: mapping.generatedColumn,
	        originalLine: mapping.originalLine,
	        originalColumn: mapping.originalColumn,
	        name: mapping.name === null ? null : this._names.at(mapping.name)
	      };
	    }, this).forEach(aCallback, context);
	  };
	SourceMapConsumer.prototype.allGeneratedPositionsFor =
	  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
	    var line = util.getArg(aArgs, 'line');
	    var needle = {
	      source: util.getArg(aArgs, 'source'),
	      originalLine: line,
	      originalColumn: util.getArg(aArgs, 'column', 0)
	    };
	    needle.source = this._findSourceIndex(needle.source);
	    if (needle.source < 0) {
	      return [];
	    }
	    var mappings = [];
	    var index = this._findMapping(needle,
	                                  this._originalMappings,
	                                  "originalLine",
	                                  "originalColumn",
	                                  util.compareByOriginalPositions,
	                                  binarySearch.LEAST_UPPER_BOUND);
	    if (index >= 0) {
	      var mapping = this._originalMappings[index];
	      if (aArgs.column === undefined) {
	        var originalLine = mapping.originalLine;
	        while (mapping && mapping.originalLine === originalLine) {
	          mappings.push({
	            line: util.getArg(mapping, 'generatedLine', null),
	            column: util.getArg(mapping, 'generatedColumn', null),
	            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	          });
	          mapping = this._originalMappings[++index];
	        }
	      } else {
	        var originalColumn = mapping.originalColumn;
	        while (mapping &&
	               mapping.originalLine === line &&
	               mapping.originalColumn == originalColumn) {
	          mappings.push({
	            line: util.getArg(mapping, 'generatedLine', null),
	            column: util.getArg(mapping, 'generatedColumn', null),
	            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	          });
	          mapping = this._originalMappings[++index];
	        }
	      }
	    }
	    return mappings;
	  };
	sourceMapConsumer.SourceMapConsumer = SourceMapConsumer;
	function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
	  var sourceMap = aSourceMap;
	  if (typeof aSourceMap === 'string') {
	    sourceMap = util.parseSourceMapInput(aSourceMap);
	  }
	  var version = util.getArg(sourceMap, 'version');
	  var sources = util.getArg(sourceMap, 'sources');
	  var names = util.getArg(sourceMap, 'names', []);
	  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
	  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
	  var mappings = util.getArg(sourceMap, 'mappings');
	  var file = util.getArg(sourceMap, 'file', null);
	  if (version != this._version) {
	    throw new Error('Unsupported version: ' + version);
	  }
	  if (sourceRoot) {
	    sourceRoot = util.normalize(sourceRoot);
	  }
	  sources = sources
	    .map(String)
	    .map(util.normalize)
	    .map(function (source) {
	      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)
	        ? util.relative(sourceRoot, source)
	        : source;
	    });
	  this._names = ArraySet.fromArray(names.map(String), true);
	  this._sources = ArraySet.fromArray(sources, true);
	  this._absoluteSources = this._sources.toArray().map(function (s) {
	    return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
	  });
	  this.sourceRoot = sourceRoot;
	  this.sourcesContent = sourcesContent;
	  this._mappings = mappings;
	  this._sourceMapURL = aSourceMapURL;
	  this.file = file;
	}
	BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
	BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
	BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
	  var relativeSource = aSource;
	  if (this.sourceRoot != null) {
	    relativeSource = util.relative(this.sourceRoot, relativeSource);
	  }
	  if (this._sources.has(relativeSource)) {
	    return this._sources.indexOf(relativeSource);
	  }
	  var i;
	  for (i = 0; i < this._absoluteSources.length; ++i) {
	    if (this._absoluteSources[i] == aSource) {
	      return i;
	    }
	  }
	  return -1;
	};
	BasicSourceMapConsumer.fromSourceMap =
	  function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
	    var smc = Object.create(BasicSourceMapConsumer.prototype);
	    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
	    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
	    smc.sourceRoot = aSourceMap._sourceRoot;
	    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
	                                                            smc.sourceRoot);
	    smc.file = aSourceMap._file;
	    smc._sourceMapURL = aSourceMapURL;
	    smc._absoluteSources = smc._sources.toArray().map(function (s) {
	      return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
	    });
	    var generatedMappings = aSourceMap._mappings.toArray().slice();
	    var destGeneratedMappings = smc.__generatedMappings = [];
	    var destOriginalMappings = smc.__originalMappings = [];
	    for (var i = 0, length = generatedMappings.length; i < length; i++) {
	      var srcMapping = generatedMappings[i];
	      var destMapping = new Mapping;
	      destMapping.generatedLine = srcMapping.generatedLine;
	      destMapping.generatedColumn = srcMapping.generatedColumn;
	      if (srcMapping.source) {
	        destMapping.source = sources.indexOf(srcMapping.source);
	        destMapping.originalLine = srcMapping.originalLine;
	        destMapping.originalColumn = srcMapping.originalColumn;
	        if (srcMapping.name) {
	          destMapping.name = names.indexOf(srcMapping.name);
	        }
	        destOriginalMappings.push(destMapping);
	      }
	      destGeneratedMappings.push(destMapping);
	    }
	    quickSort(smc.__originalMappings, util.compareByOriginalPositions);
	    return smc;
	  };
	BasicSourceMapConsumer.prototype._version = 3;
	Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
	  get: function () {
	    return this._absoluteSources.slice();
	  }
	});
	function Mapping() {
	  this.generatedLine = 0;
	  this.generatedColumn = 0;
	  this.source = null;
	  this.originalLine = null;
	  this.originalColumn = null;
	  this.name = null;
	}
	BasicSourceMapConsumer.prototype._parseMappings =
	  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	    var generatedLine = 1;
	    var previousGeneratedColumn = 0;
	    var previousOriginalLine = 0;
	    var previousOriginalColumn = 0;
	    var previousSource = 0;
	    var previousName = 0;
	    var length = aStr.length;
	    var index = 0;
	    var cachedSegments = {};
	    var temp = {};
	    var originalMappings = [];
	    var generatedMappings = [];
	    var mapping, str, segment, end, value;
	    while (index < length) {
	      if (aStr.charAt(index) === ';') {
	        generatedLine++;
	        index++;
	        previousGeneratedColumn = 0;
	      }
	      else if (aStr.charAt(index) === ',') {
	        index++;
	      }
	      else {
	        mapping = new Mapping();
	        mapping.generatedLine = generatedLine;
	        for (end = index; end < length; end++) {
	          if (this._charIsMappingSeparator(aStr, end)) {
	            break;
	          }
	        }
	        str = aStr.slice(index, end);
	        segment = cachedSegments[str];
	        if (segment) {
	          index += str.length;
	        } else {
	          segment = [];
	          while (index < end) {
	            base64VLQ.decode(aStr, index, temp);
	            value = temp.value;
	            index = temp.rest;
	            segment.push(value);
	          }
	          if (segment.length === 2) {
	            throw new Error('Found a source, but no line and column');
	          }
	          if (segment.length === 3) {
	            throw new Error('Found a source and line, but no column');
	          }
	          cachedSegments[str] = segment;
	        }
	        mapping.generatedColumn = previousGeneratedColumn + segment[0];
	        previousGeneratedColumn = mapping.generatedColumn;
	        if (segment.length > 1) {
	          mapping.source = previousSource + segment[1];
	          previousSource += segment[1];
	          mapping.originalLine = previousOriginalLine + segment[2];
	          previousOriginalLine = mapping.originalLine;
	          mapping.originalLine += 1;
	          mapping.originalColumn = previousOriginalColumn + segment[3];
	          previousOriginalColumn = mapping.originalColumn;
	          if (segment.length > 4) {
	            mapping.name = previousName + segment[4];
	            previousName += segment[4];
	          }
	        }
	        generatedMappings.push(mapping);
	        if (typeof mapping.originalLine === 'number') {
	          originalMappings.push(mapping);
	        }
	      }
	    }
	    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
	    this.__generatedMappings = generatedMappings;
	    quickSort(originalMappings, util.compareByOriginalPositions);
	    this.__originalMappings = originalMappings;
	  };
	BasicSourceMapConsumer.prototype._findMapping =
	  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
	                                         aColumnName, aComparator, aBias) {
	    if (aNeedle[aLineName] <= 0) {
	      throw new TypeError('Line must be greater than or equal to 1, got '
	                          + aNeedle[aLineName]);
	    }
	    if (aNeedle[aColumnName] < 0) {
	      throw new TypeError('Column must be greater than or equal to 0, got '
	                          + aNeedle[aColumnName]);
	    }
	    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
	  };
	BasicSourceMapConsumer.prototype.computeColumnSpans =
	  function SourceMapConsumer_computeColumnSpans() {
	    for (var index = 0; index < this._generatedMappings.length; ++index) {
	      var mapping = this._generatedMappings[index];
	      if (index + 1 < this._generatedMappings.length) {
	        var nextMapping = this._generatedMappings[index + 1];
	        if (mapping.generatedLine === nextMapping.generatedLine) {
	          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
	          continue;
	        }
	      }
	      mapping.lastGeneratedColumn = Infinity;
	    }
	  };
	BasicSourceMapConsumer.prototype.originalPositionFor =
	  function SourceMapConsumer_originalPositionFor(aArgs) {
	    var needle = {
	      generatedLine: util.getArg(aArgs, 'line'),
	      generatedColumn: util.getArg(aArgs, 'column')
	    };
	    var index = this._findMapping(
	      needle,
	      this._generatedMappings,
	      "generatedLine",
	      "generatedColumn",
	      util.compareByGeneratedPositionsDeflated,
	      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
	    );
	    if (index >= 0) {
	      var mapping = this._generatedMappings[index];
	      if (mapping.generatedLine === needle.generatedLine) {
	        var source = util.getArg(mapping, 'source', null);
	        if (source !== null) {
	          source = this._sources.at(source);
	          source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
	        }
	        var name = util.getArg(mapping, 'name', null);
	        if (name !== null) {
	          name = this._names.at(name);
	        }
	        return {
	          source: source,
	          line: util.getArg(mapping, 'originalLine', null),
	          column: util.getArg(mapping, 'originalColumn', null),
	          name: name
	        };
	      }
	    }
	    return {
	      source: null,
	      line: null,
	      column: null,
	      name: null
	    };
	  };
	BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
	  function BasicSourceMapConsumer_hasContentsOfAllSources() {
	    if (!this.sourcesContent) {
	      return false;
	    }
	    return this.sourcesContent.length >= this._sources.size() &&
	      !this.sourcesContent.some(function (sc) { return sc == null; });
	  };
	BasicSourceMapConsumer.prototype.sourceContentFor =
	  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
	    if (!this.sourcesContent) {
	      return null;
	    }
	    var index = this._findSourceIndex(aSource);
	    if (index >= 0) {
	      return this.sourcesContent[index];
	    }
	    var relativeSource = aSource;
	    if (this.sourceRoot != null) {
	      relativeSource = util.relative(this.sourceRoot, relativeSource);
	    }
	    var url;
	    if (this.sourceRoot != null
	        && (url = util.urlParse(this.sourceRoot))) {
	      var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
	      if (url.scheme == "file"
	          && this._sources.has(fileUriAbsPath)) {
	        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
	      }
	      if ((!url.path || url.path == "/")
	          && this._sources.has("/" + relativeSource)) {
	        return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
	      }
	    }
	    if (nullOnMissing) {
	      return null;
	    }
	    else {
	      throw new Error('"' + relativeSource + '" is not in the SourceMap.');
	    }
	  };
	BasicSourceMapConsumer.prototype.generatedPositionFor =
	  function SourceMapConsumer_generatedPositionFor(aArgs) {
	    var source = util.getArg(aArgs, 'source');
	    source = this._findSourceIndex(source);
	    if (source < 0) {
	      return {
	        line: null,
	        column: null,
	        lastColumn: null
	      };
	    }
	    var needle = {
	      source: source,
	      originalLine: util.getArg(aArgs, 'line'),
	      originalColumn: util.getArg(aArgs, 'column')
	    };
	    var index = this._findMapping(
	      needle,
	      this._originalMappings,
	      "originalLine",
	      "originalColumn",
	      util.compareByOriginalPositions,
	      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
	    );
	    if (index >= 0) {
	      var mapping = this._originalMappings[index];
	      if (mapping.source === needle.source) {
	        return {
	          line: util.getArg(mapping, 'generatedLine', null),
	          column: util.getArg(mapping, 'generatedColumn', null),
	          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	        };
	      }
	    }
	    return {
	      line: null,
	      column: null,
	      lastColumn: null
	    };
	  };
	sourceMapConsumer.BasicSourceMapConsumer = BasicSourceMapConsumer;
	function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
	  var sourceMap = aSourceMap;
	  if (typeof aSourceMap === 'string') {
	    sourceMap = util.parseSourceMapInput(aSourceMap);
	  }
	  var version = util.getArg(sourceMap, 'version');
	  var sections = util.getArg(sourceMap, 'sections');
	  if (version != this._version) {
	    throw new Error('Unsupported version: ' + version);
	  }
	  this._sources = new ArraySet();
	  this._names = new ArraySet();
	  var lastOffset = {
	    line: -1,
	    column: 0
	  };
	  this._sections = sections.map(function (s) {
	    if (s.url) {
	      throw new Error('Support for url field in sections not implemented.');
	    }
	    var offset = util.getArg(s, 'offset');
	    var offsetLine = util.getArg(offset, 'line');
	    var offsetColumn = util.getArg(offset, 'column');
	    if (offsetLine < lastOffset.line ||
	        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
	      throw new Error('Section offsets must be ordered and non-overlapping.');
	    }
	    lastOffset = offset;
	    return {
	      generatedOffset: {
	        generatedLine: offsetLine + 1,
	        generatedColumn: offsetColumn + 1
	      },
	      consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL)
	    }
	  });
	}
	IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
	IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
	IndexedSourceMapConsumer.prototype._version = 3;
	Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
	  get: function () {
	    var sources = [];
	    for (var i = 0; i < this._sections.length; i++) {
	      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
	        sources.push(this._sections[i].consumer.sources[j]);
	      }
	    }
	    return sources;
	  }
	});
	IndexedSourceMapConsumer.prototype.originalPositionFor =
	  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
	    var needle = {
	      generatedLine: util.getArg(aArgs, 'line'),
	      generatedColumn: util.getArg(aArgs, 'column')
	    };
	    var sectionIndex = binarySearch.search(needle, this._sections,
	      function(needle, section) {
	        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
	        if (cmp) {
	          return cmp;
	        }
	        return (needle.generatedColumn -
	                section.generatedOffset.generatedColumn);
	      });
	    var section = this._sections[sectionIndex];
	    if (!section) {
	      return {
	        source: null,
	        line: null,
	        column: null,
	        name: null
	      };
	    }
	    return section.consumer.originalPositionFor({
	      line: needle.generatedLine -
	        (section.generatedOffset.generatedLine - 1),
	      column: needle.generatedColumn -
	        (section.generatedOffset.generatedLine === needle.generatedLine
	         ? section.generatedOffset.generatedColumn - 1
	         : 0),
	      bias: aArgs.bias
	    });
	  };
	IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
	  function IndexedSourceMapConsumer_hasContentsOfAllSources() {
	    return this._sections.every(function (s) {
	      return s.consumer.hasContentsOfAllSources();
	    });
	  };
	IndexedSourceMapConsumer.prototype.sourceContentFor =
	  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
	    for (var i = 0; i < this._sections.length; i++) {
	      var section = this._sections[i];
	      var content = section.consumer.sourceContentFor(aSource, true);
	      if (content) {
	        return content;
	      }
	    }
	    if (nullOnMissing) {
	      return null;
	    }
	    else {
	      throw new Error('"' + aSource + '" is not in the SourceMap.');
	    }
	  };
	IndexedSourceMapConsumer.prototype.generatedPositionFor =
	  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
	    for (var i = 0; i < this._sections.length; i++) {
	      var section = this._sections[i];
	      if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {
	        continue;
	      }
	      var generatedPosition = section.consumer.generatedPositionFor(aArgs);
	      if (generatedPosition) {
	        var ret = {
	          line: generatedPosition.line +
	            (section.generatedOffset.generatedLine - 1),
	          column: generatedPosition.column +
	            (section.generatedOffset.generatedLine === generatedPosition.line
	             ? section.generatedOffset.generatedColumn - 1
	             : 0)
	        };
	        return ret;
	      }
	    }
	    return {
	      line: null,
	      column: null
	    };
	  };
	IndexedSourceMapConsumer.prototype._parseMappings =
	  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	    this.__generatedMappings = [];
	    this.__originalMappings = [];
	    for (var i = 0; i < this._sections.length; i++) {
	      var section = this._sections[i];
	      var sectionMappings = section.consumer._generatedMappings;
	      for (var j = 0; j < sectionMappings.length; j++) {
	        var mapping = sectionMappings[j];
	        var source = section.consumer._sources.at(mapping.source);
	        source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
	        this._sources.add(source);
	        source = this._sources.indexOf(source);
	        var name = null;
	        if (mapping.name) {
	          name = section.consumer._names.at(mapping.name);
	          this._names.add(name);
	          name = this._names.indexOf(name);
	        }
	        var adjustedMapping = {
	          source: source,
	          generatedLine: mapping.generatedLine +
	            (section.generatedOffset.generatedLine - 1),
	          generatedColumn: mapping.generatedColumn +
	            (section.generatedOffset.generatedLine === mapping.generatedLine
	            ? section.generatedOffset.generatedColumn - 1
	            : 0),
	          originalLine: mapping.originalLine,
	          originalColumn: mapping.originalColumn,
	          name: name
	        };
	        this.__generatedMappings.push(adjustedMapping);
	        if (typeof adjustedMapping.originalLine === 'number') {
	          this.__originalMappings.push(adjustedMapping);
	        }
	      }
	    }
	    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
	    quickSort(this.__originalMappings, util.compareByOriginalPositions);
	  };
	sourceMapConsumer.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
	return sourceMapConsumer;
}

var sourceNode = {};

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var hasRequiredSourceNode;

function requireSourceNode () {
	if (hasRequiredSourceNode) return sourceNode;
	hasRequiredSourceNode = 1;
	var SourceMapGenerator = requireSourceMapGenerator().SourceMapGenerator;
	var util = requireUtil$1();
	var REGEX_NEWLINE = /(\r?\n)/;
	var NEWLINE_CODE = 10;
	var isSourceNode = "$$$isSourceNode$$$";
	function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
	  this.children = [];
	  this.sourceContents = {};
	  this.line = aLine == null ? null : aLine;
	  this.column = aColumn == null ? null : aColumn;
	  this.source = aSource == null ? null : aSource;
	  this.name = aName == null ? null : aName;
	  this[isSourceNode] = true;
	  if (aChunks != null) this.add(aChunks);
	}
	SourceNode.fromStringWithSourceMap =
	  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
	    var node = new SourceNode();
	    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
	    var remainingLinesIndex = 0;
	    var shiftNextLine = function() {
	      var lineContents = getNextLine();
	      var newLine = getNextLine() || "";
	      return lineContents + newLine;
	      function getNextLine() {
	        return remainingLinesIndex < remainingLines.length ?
	            remainingLines[remainingLinesIndex++] : undefined;
	      }
	    };
	    var lastGeneratedLine = 1, lastGeneratedColumn = 0;
	    var lastMapping = null;
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      if (lastMapping !== null) {
	        if (lastGeneratedLine < mapping.generatedLine) {
	          addMappingWithCode(lastMapping, shiftNextLine());
	          lastGeneratedLine++;
	          lastGeneratedColumn = 0;
	        } else {
	          var nextLine = remainingLines[remainingLinesIndex] || '';
	          var code = nextLine.substr(0, mapping.generatedColumn -
	                                        lastGeneratedColumn);
	          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -
	                                              lastGeneratedColumn);
	          lastGeneratedColumn = mapping.generatedColumn;
	          addMappingWithCode(lastMapping, code);
	          lastMapping = mapping;
	          return;
	        }
	      }
	      while (lastGeneratedLine < mapping.generatedLine) {
	        node.add(shiftNextLine());
	        lastGeneratedLine++;
	      }
	      if (lastGeneratedColumn < mapping.generatedColumn) {
	        var nextLine = remainingLines[remainingLinesIndex] || '';
	        node.add(nextLine.substr(0, mapping.generatedColumn));
	        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
	        lastGeneratedColumn = mapping.generatedColumn;
	      }
	      lastMapping = mapping;
	    }, this);
	    if (remainingLinesIndex < remainingLines.length) {
	      if (lastMapping) {
	        addMappingWithCode(lastMapping, shiftNextLine());
	      }
	      node.add(remainingLines.splice(remainingLinesIndex).join(""));
	    }
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aRelativePath != null) {
	          sourceFile = util.join(aRelativePath, sourceFile);
	        }
	        node.setSourceContent(sourceFile, content);
	      }
	    });
	    return node;
	    function addMappingWithCode(mapping, code) {
	      if (mapping === null || mapping.source === undefined) {
	        node.add(code);
	      } else {
	        var source = aRelativePath
	          ? util.join(aRelativePath, mapping.source)
	          : mapping.source;
	        node.add(new SourceNode(mapping.originalLine,
	                                mapping.originalColumn,
	                                source,
	                                code,
	                                mapping.name));
	      }
	    }
	  };
	SourceNode.prototype.add = function SourceNode_add(aChunk) {
	  if (Array.isArray(aChunk)) {
	    aChunk.forEach(function (chunk) {
	      this.add(chunk);
	    }, this);
	  }
	  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
	    if (aChunk) {
	      this.children.push(aChunk);
	    }
	  }
	  else {
	    throw new TypeError(
	      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
	    );
	  }
	  return this;
	};
	SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
	  if (Array.isArray(aChunk)) {
	    for (var i = aChunk.length-1; i >= 0; i--) {
	      this.prepend(aChunk[i]);
	    }
	  }
	  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
	    this.children.unshift(aChunk);
	  }
	  else {
	    throw new TypeError(
	      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
	    );
	  }
	  return this;
	};
	SourceNode.prototype.walk = function SourceNode_walk(aFn) {
	  var chunk;
	  for (var i = 0, len = this.children.length; i < len; i++) {
	    chunk = this.children[i];
	    if (chunk[isSourceNode]) {
	      chunk.walk(aFn);
	    }
	    else {
	      if (chunk !== '') {
	        aFn(chunk, { source: this.source,
	                     line: this.line,
	                     column: this.column,
	                     name: this.name });
	      }
	    }
	  }
	};
	SourceNode.prototype.join = function SourceNode_join(aSep) {
	  var newChildren;
	  var i;
	  var len = this.children.length;
	  if (len > 0) {
	    newChildren = [];
	    for (i = 0; i < len-1; i++) {
	      newChildren.push(this.children[i]);
	      newChildren.push(aSep);
	    }
	    newChildren.push(this.children[i]);
	    this.children = newChildren;
	  }
	  return this;
	};
	SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
	  var lastChild = this.children[this.children.length - 1];
	  if (lastChild[isSourceNode]) {
	    lastChild.replaceRight(aPattern, aReplacement);
	  }
	  else if (typeof lastChild === 'string') {
	    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
	  }
	  else {
	    this.children.push(''.replace(aPattern, aReplacement));
	  }
	  return this;
	};
	SourceNode.prototype.setSourceContent =
	  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
	    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
	  };
	SourceNode.prototype.walkSourceContents =
	  function SourceNode_walkSourceContents(aFn) {
	    for (var i = 0, len = this.children.length; i < len; i++) {
	      if (this.children[i][isSourceNode]) {
	        this.children[i].walkSourceContents(aFn);
	      }
	    }
	    var sources = Object.keys(this.sourceContents);
	    for (var i = 0, len = sources.length; i < len; i++) {
	      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
	    }
	  };
	SourceNode.prototype.toString = function SourceNode_toString() {
	  var str = "";
	  this.walk(function (chunk) {
	    str += chunk;
	  });
	  return str;
	};
	SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
	  var generated = {
	    code: "",
	    line: 1,
	    column: 0
	  };
	  var map = new SourceMapGenerator(aArgs);
	  var sourceMappingActive = false;
	  var lastOriginalSource = null;
	  var lastOriginalLine = null;
	  var lastOriginalColumn = null;
	  var lastOriginalName = null;
	  this.walk(function (chunk, original) {
	    generated.code += chunk;
	    if (original.source !== null
	        && original.line !== null
	        && original.column !== null) {
	      if(lastOriginalSource !== original.source
	         || lastOriginalLine !== original.line
	         || lastOriginalColumn !== original.column
	         || lastOriginalName !== original.name) {
	        map.addMapping({
	          source: original.source,
	          original: {
	            line: original.line,
	            column: original.column
	          },
	          generated: {
	            line: generated.line,
	            column: generated.column
	          },
	          name: original.name
	        });
	      }
	      lastOriginalSource = original.source;
	      lastOriginalLine = original.line;
	      lastOriginalColumn = original.column;
	      lastOriginalName = original.name;
	      sourceMappingActive = true;
	    } else if (sourceMappingActive) {
	      map.addMapping({
	        generated: {
	          line: generated.line,
	          column: generated.column
	        }
	      });
	      lastOriginalSource = null;
	      sourceMappingActive = false;
	    }
	    for (var idx = 0, length = chunk.length; idx < length; idx++) {
	      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
	        generated.line++;
	        generated.column = 0;
	        if (idx + 1 === length) {
	          lastOriginalSource = null;
	          sourceMappingActive = false;
	        } else if (sourceMappingActive) {
	          map.addMapping({
	            source: original.source,
	            original: {
	              line: original.line,
	              column: original.column
	            },
	            generated: {
	              line: generated.line,
	              column: generated.column
	            },
	            name: original.name
	          });
	        }
	      } else {
	        generated.column++;
	      }
	    }
	  });
	  this.walkSourceContents(function (sourceFile, sourceContent) {
	    map.setSourceContent(sourceFile, sourceContent);
	  });
	  return { code: generated.code, map: map };
	};
	sourceNode.SourceNode = SourceNode;
	return sourceNode;
}

/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var hasRequiredSourceMap;

function requireSourceMap () {
	if (hasRequiredSourceMap) return sourceMap;
	hasRequiredSourceMap = 1;
	sourceMap.SourceMapGenerator = requireSourceMapGenerator().SourceMapGenerator;
	sourceMap.SourceMapConsumer = requireSourceMapConsumer().SourceMapConsumer;
	sourceMap.SourceNode = requireSourceNode().SourceNode;
	return sourceMap;
}

var version = "2.1.0";
var require$$3 = {
	version: version};

/*
  Copyright (C) 2012-2014 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2015 Ingvar Stepanyan <me@rreverser.com>
  Copyright (C) 2014 Ivan Nikulin <ifaaan@gmail.com>
  Copyright (C) 2012-2013 Michael Ficarra <escodegen.copyright@michael.ficarra.me>
  Copyright (C) 2012-2013 Mathias Bynens <mathias@qiwi.be>
  Copyright (C) 2013 Irakli Gozalishvili <rfobic@gmail.com>
  Copyright (C) 2012 Robert Gust-Bardon <donate@robert.gust-bardon.org>
  Copyright (C) 2012 John Freeman <jfreeman08@gmail.com>
  Copyright (C) 2011-2012 Ariya Hidayat <ariya.hidayat@gmail.com>
  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>
  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>
  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>
  Copyright (C) 2020 Apple Inc. All rights reserved.
  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

var hasRequiredEscodegen;

function requireEscodegen () {
	if (hasRequiredEscodegen) return escodegen;
	hasRequiredEscodegen = 1;
	(function (exports) {
		(function () {
		    var Syntax,
		        Precedence,
		        BinaryPrecedence,
		        SourceNode,
		        estraverse,
		        esutils,
		        base,
		        indent,
		        json,
		        renumber,
		        hexadecimal,
		        quotes,
		        escapeless,
		        newline,
		        space,
		        parentheses,
		        semicolons,
		        safeConcatenation,
		        directive,
		        extra,
		        parse,
		        sourceMap,
		        sourceCode,
		        preserveBlankLines,
		        FORMAT_MINIFY,
		        FORMAT_DEFAULTS;
		    estraverse = requireEstraverse();
		    esutils = requireUtils();
		    Syntax = estraverse.Syntax;
		    function isExpression(node) {
		        return CodeGenerator.Expression.hasOwnProperty(node.type);
		    }
		    function isStatement(node) {
		        return CodeGenerator.Statement.hasOwnProperty(node.type);
		    }
		    Precedence = {
		        Sequence: 0,
		        Yield: 1,
		        Assignment: 1,
		        Conditional: 2,
		        ArrowFunction: 2,
		        Coalesce: 3,
		        LogicalOR: 4,
		        LogicalAND: 5,
		        BitwiseOR: 6,
		        BitwiseXOR: 7,
		        BitwiseAND: 8,
		        Equality: 9,
		        Relational: 10,
		        BitwiseSHIFT: 11,
		        Additive: 12,
		        Multiplicative: 13,
		        Exponentiation: 14,
		        Await: 15,
		        Unary: 15,
		        Postfix: 16,
		        OptionalChaining: 17,
		        Call: 18,
		        New: 19,
		        TaggedTemplate: 20,
		        Member: 21,
		        Primary: 22
		    };
		    BinaryPrecedence = {
		        '??': Precedence.Coalesce,
		        '||': Precedence.LogicalOR,
		        '&&': Precedence.LogicalAND,
		        '|': Precedence.BitwiseOR,
		        '^': Precedence.BitwiseXOR,
		        '&': Precedence.BitwiseAND,
		        '==': Precedence.Equality,
		        '!=': Precedence.Equality,
		        '===': Precedence.Equality,
		        '!==': Precedence.Equality,
		        'is': Precedence.Equality,
		        'isnt': Precedence.Equality,
		        '<': Precedence.Relational,
		        '>': Precedence.Relational,
		        '<=': Precedence.Relational,
		        '>=': Precedence.Relational,
		        'in': Precedence.Relational,
		        'instanceof': Precedence.Relational,
		        '<<': Precedence.BitwiseSHIFT,
		        '>>': Precedence.BitwiseSHIFT,
		        '>>>': Precedence.BitwiseSHIFT,
		        '+': Precedence.Additive,
		        '-': Precedence.Additive,
		        '*': Precedence.Multiplicative,
		        '%': Precedence.Multiplicative,
		        '/': Precedence.Multiplicative,
		        '**': Precedence.Exponentiation
		    };
		    var F_ALLOW_IN = 1,
		        F_ALLOW_CALL = 1 << 1,
		        F_ALLOW_UNPARATH_NEW = 1 << 2,
		        F_FUNC_BODY = 1 << 3,
		        F_DIRECTIVE_CTX = 1 << 4,
		        F_SEMICOLON_OPT = 1 << 5,
		        F_FOUND_COALESCE = 1 << 6;
		    var E_FTT = F_ALLOW_CALL | F_ALLOW_UNPARATH_NEW,
		        E_TTF = F_ALLOW_IN | F_ALLOW_CALL,
		        E_TTT = F_ALLOW_IN | F_ALLOW_CALL | F_ALLOW_UNPARATH_NEW,
		        E_TFF = F_ALLOW_IN,
		        E_FFT = F_ALLOW_UNPARATH_NEW,
		        E_TFT = F_ALLOW_IN | F_ALLOW_UNPARATH_NEW;
		    var S_TFFF = F_ALLOW_IN,
		        S_TFFT = F_ALLOW_IN | F_SEMICOLON_OPT,
		        S_FFFF = 0x00,
		        S_TFTF = F_ALLOW_IN | F_DIRECTIVE_CTX,
		        S_TTFF = F_ALLOW_IN | F_FUNC_BODY;
		    function getDefaultOptions() {
		        return {
		            indent: null,
		            base: null,
		            parse: null,
		            comment: false,
		            format: {
		                indent: {
		                    style: '    ',
		                    base: 0,
		                    adjustMultilineComment: false
		                },
		                newline: '\n',
		                space: ' ',
		                json: false,
		                renumber: false,
		                hexadecimal: false,
		                quotes: 'single',
		                escapeless: false,
		                compact: false,
		                parentheses: true,
		                semicolons: true,
		                safeConcatenation: false,
		                preserveBlankLines: false
		            },
		            moz: {
		                comprehensionExpressionStartsWithAssignment: false,
		                starlessGenerator: false
		            },
		            sourceMap: null,
		            sourceMapRoot: null,
		            sourceMapWithCode: false,
		            directive: false,
		            raw: true,
		            verbatim: null,
		            sourceCode: null
		        };
		    }
		    function stringRepeat(str, num) {
		        var result = '';
		        for (num |= 0; num > 0; num >>>= 1, str += str) {
		            if (num & 1) {
		                result += str;
		            }
		        }
		        return result;
		    }
		    function hasLineTerminator(str) {
		        return (/[\r\n]/g).test(str);
		    }
		    function endsWithLineTerminator(str) {
		        var len = str.length;
		        return len && esutils.code.isLineTerminator(str.charCodeAt(len - 1));
		    }
		    function merge(target, override) {
		        var key;
		        for (key in override) {
		            if (override.hasOwnProperty(key)) {
		                target[key] = override[key];
		            }
		        }
		        return target;
		    }
		    function updateDeeply(target, override) {
		        var key, val;
		        function isHashObject(target) {
		            return typeof target === 'object' && target instanceof Object && !(target instanceof RegExp);
		        }
		        for (key in override) {
		            if (override.hasOwnProperty(key)) {
		                val = override[key];
		                if (isHashObject(val)) {
		                    if (isHashObject(target[key])) {
		                        updateDeeply(target[key], val);
		                    } else {
		                        target[key] = updateDeeply({}, val);
		                    }
		                } else {
		                    target[key] = val;
		                }
		            }
		        }
		        return target;
		    }
		    function generateNumber(value) {
		        var result, point, temp, exponent, pos;
		        if (value !== value) {
		            throw new Error('Numeric literal whose value is NaN');
		        }
		        if (value < 0 || (value === 0 && 1 / value < 0)) {
		            throw new Error('Numeric literal whose value is negative');
		        }
		        if (value === 1 / 0) {
		            return json ? 'null' : renumber ? '1e400' : '1e+400';
		        }
		        result = '' + value;
		        if (!renumber || result.length < 3) {
		            return result;
		        }
		        point = result.indexOf('.');
		        if (!json && result.charCodeAt(0) === 0x30   && point === 1) {
		            point = 0;
		            result = result.slice(1);
		        }
		        temp = result;
		        result = result.replace('e+', 'e');
		        exponent = 0;
		        if ((pos = temp.indexOf('e')) > 0) {
		            exponent = +temp.slice(pos + 1);
		            temp = temp.slice(0, pos);
		        }
		        if (point >= 0) {
		            exponent -= temp.length - point - 1;
		            temp = +(temp.slice(0, point) + temp.slice(point + 1)) + '';
		        }
		        pos = 0;
		        while (temp.charCodeAt(temp.length + pos - 1) === 0x30  ) {
		            --pos;
		        }
		        if (pos !== 0) {
		            exponent -= pos;
		            temp = temp.slice(0, pos);
		        }
		        if (exponent !== 0) {
		            temp += 'e' + exponent;
		        }
		        if ((temp.length < result.length ||
		                    (hexadecimal && value > 1e12 && Math.floor(value) === value && (temp = '0x' + value.toString(16)).length < result.length)) &&
		                +temp === value) {
		            result = temp;
		        }
		        return result;
		    }
		    function escapeRegExpCharacter(ch, previousIsBackslash) {
		        if ((ch & -2) === 0x2028) {
		            return (previousIsBackslash ? 'u' : '\\u') + ((ch === 0x2028) ? '2028' : '2029');
		        } else if (ch === 10 || ch === 13) {
		            return (previousIsBackslash ? '' : '\\') + ((ch === 10) ? 'n' : 'r');
		        }
		        return String.fromCharCode(ch);
		    }
		    function generateRegExp(reg) {
		        var match, result, flags, i, iz, ch, characterInBrack, previousIsBackslash;
		        result = reg.toString();
		        if (reg.source) {
		            match = result.match(/\/([^/]*)$/);
		            if (!match) {
		                return result;
		            }
		            flags = match[1];
		            result = '';
		            characterInBrack = false;
		            previousIsBackslash = false;
		            for (i = 0, iz = reg.source.length; i < iz; ++i) {
		                ch = reg.source.charCodeAt(i);
		                if (!previousIsBackslash) {
		                    if (characterInBrack) {
		                        if (ch === 93) {
		                            characterInBrack = false;
		                        }
		                    } else {
		                        if (ch === 47) {
		                            result += '\\';
		                        } else if (ch === 91) {
		                            characterInBrack = true;
		                        }
		                    }
		                    result += escapeRegExpCharacter(ch, previousIsBackslash);
		                    previousIsBackslash = ch === 92;
		                } else {
		                    result += escapeRegExpCharacter(ch, previousIsBackslash);
		                    previousIsBackslash = false;
		                }
		            }
		            return '/' + result + '/' + flags;
		        }
		        return result;
		    }
		    function escapeAllowedCharacter(code, next) {
		        var hex;
		        if (code === 0x08  ) {
		            return '\\b';
		        }
		        if (code === 0x0C  ) {
		            return '\\f';
		        }
		        if (code === 0x09  ) {
		            return '\\t';
		        }
		        hex = code.toString(16).toUpperCase();
		        if (json || code > 0xFF) {
		            return '\\u' + '0000'.slice(hex.length) + hex;
		        } else if (code === 0x0000 && !esutils.code.isDecimalDigit(next)) {
		            return '\\0';
		        } else if (code === 0x000B  ) {
		            return '\\x0B';
		        } else {
		            return '\\x' + '00'.slice(hex.length) + hex;
		        }
		    }
		    function escapeDisallowedCharacter(code) {
		        if (code === 0x5C  ) {
		            return '\\\\';
		        }
		        if (code === 0x0A  ) {
		            return '\\n';
		        }
		        if (code === 0x0D  ) {
		            return '\\r';
		        }
		        if (code === 0x2028) {
		            return '\\u2028';
		        }
		        if (code === 0x2029) {
		            return '\\u2029';
		        }
		        throw new Error('Incorrectly classified character');
		    }
		    function escapeDirective(str) {
		        var i, iz, code, quote;
		        quote = quotes === 'double' ? '"' : '\'';
		        for (i = 0, iz = str.length; i < iz; ++i) {
		            code = str.charCodeAt(i);
		            if (code === 0x27  ) {
		                quote = '"';
		                break;
		            } else if (code === 0x22  ) {
		                quote = '\'';
		                break;
		            } else if (code === 0x5C  ) {
		                ++i;
		            }
		        }
		        return quote + str + quote;
		    }
		    function escapeString(str) {
		        var result = '', i, len, code, singleQuotes = 0, doubleQuotes = 0, single, quote;
		        for (i = 0, len = str.length; i < len; ++i) {
		            code = str.charCodeAt(i);
		            if (code === 0x27  ) {
		                ++singleQuotes;
		            } else if (code === 0x22  ) {
		                ++doubleQuotes;
		            } else if (code === 0x2F   && json) {
		                result += '\\';
		            } else if (esutils.code.isLineTerminator(code) || code === 0x5C  ) {
		                result += escapeDisallowedCharacter(code);
		                continue;
		            } else if (!esutils.code.isIdentifierPartES5(code) && (json && code < 0x20   || !json && !escapeless && (code < 0x20   || code > 0x7E  ))) {
		                result += escapeAllowedCharacter(code, str.charCodeAt(i + 1));
		                continue;
		            }
		            result += String.fromCharCode(code);
		        }
		        single = !(quotes === 'double' || (quotes === 'auto' && doubleQuotes < singleQuotes));
		        quote = single ? '\'' : '"';
		        if (!(single ? singleQuotes : doubleQuotes)) {
		            return quote + result + quote;
		        }
		        str = result;
		        result = quote;
		        for (i = 0, len = str.length; i < len; ++i) {
		            code = str.charCodeAt(i);
		            if ((code === 0x27   && single) || (code === 0x22   && !single)) {
		                result += '\\';
		            }
		            result += String.fromCharCode(code);
		        }
		        return result + quote;
		    }
		    function flattenToString(arr) {
		        var i, iz, elem, result = '';
		        for (i = 0, iz = arr.length; i < iz; ++i) {
		            elem = arr[i];
		            result += Array.isArray(elem) ? flattenToString(elem) : elem;
		        }
		        return result;
		    }
		    function toSourceNodeWhenNeeded(generated, node) {
		        if (!sourceMap) {
		            if (Array.isArray(generated)) {
		                return flattenToString(generated);
		            } else {
		                return generated;
		            }
		        }
		        if (node == null) {
		            if (generated instanceof SourceNode) {
		                return generated;
		            } else {
		                node = {};
		            }
		        }
		        if (node.loc == null) {
		            return new SourceNode(null, null, sourceMap, generated, node.name || null);
		        }
		        return new SourceNode(node.loc.start.line, node.loc.start.column, (sourceMap === true ? node.loc.source || null : sourceMap), generated, node.name || null);
		    }
		    function noEmptySpace() {
		        return (space) ? space : ' ';
		    }
		    function join(left, right) {
		        var leftSource,
		            rightSource,
		            leftCharCode,
		            rightCharCode;
		        leftSource = toSourceNodeWhenNeeded(left).toString();
		        if (leftSource.length === 0) {
		            return [right];
		        }
		        rightSource = toSourceNodeWhenNeeded(right).toString();
		        if (rightSource.length === 0) {
		            return [left];
		        }
		        leftCharCode = leftSource.charCodeAt(leftSource.length - 1);
		        rightCharCode = rightSource.charCodeAt(0);
		        if ((leftCharCode === 0x2B   || leftCharCode === 0x2D  ) && leftCharCode === rightCharCode ||
		            esutils.code.isIdentifierPartES5(leftCharCode) && esutils.code.isIdentifierPartES5(rightCharCode) ||
		            leftCharCode === 0x2F   && rightCharCode === 0x69  ) {
		            return [left, noEmptySpace(), right];
		        } else if (esutils.code.isWhiteSpace(leftCharCode) || esutils.code.isLineTerminator(leftCharCode) ||
		                esutils.code.isWhiteSpace(rightCharCode) || esutils.code.isLineTerminator(rightCharCode)) {
		            return [left, right];
		        }
		        return [left, space, right];
		    }
		    function addIndent(stmt) {
		        return [base, stmt];
		    }
		    function withIndent(fn) {
		        var previousBase;
		        previousBase = base;
		        base += indent;
		        fn(base);
		        base = previousBase;
		    }
		    function calculateSpaces(str) {
		        var i;
		        for (i = str.length - 1; i >= 0; --i) {
		            if (esutils.code.isLineTerminator(str.charCodeAt(i))) {
		                break;
		            }
		        }
		        return (str.length - 1) - i;
		    }
		    function adjustMultilineComment(value, specialBase) {
		        var array, i, len, line, j, spaces, previousBase, sn;
		        array = value.split(/\r\n|[\r\n]/);
		        spaces = Number.MAX_VALUE;
		        for (i = 1, len = array.length; i < len; ++i) {
		            line = array[i];
		            j = 0;
		            while (j < line.length && esutils.code.isWhiteSpace(line.charCodeAt(j))) {
		                ++j;
		            }
		            if (spaces > j) {
		                spaces = j;
		            }
		        }
		        if (typeof specialBase !== 'undefined') {
		            previousBase = base;
		            if (array[1][spaces] === '*') {
		                specialBase += ' ';
		            }
		            base = specialBase;
		        } else {
		            if (spaces & 1) {
		                --spaces;
		            }
		            previousBase = base;
		        }
		        for (i = 1, len = array.length; i < len; ++i) {
		            sn = toSourceNodeWhenNeeded(addIndent(array[i].slice(spaces)));
		            array[i] = sourceMap ? sn.join('') : sn;
		        }
		        base = previousBase;
		        return array.join('\n');
		    }
		    function generateComment(comment, specialBase) {
		        if (comment.type === 'Line') {
		            if (endsWithLineTerminator(comment.value)) {
		                return '//' + comment.value;
		            } else {
		                var result = '//' + comment.value;
		                if (!preserveBlankLines) {
		                    result += '\n';
		                }
		                return result;
		            }
		        }
		        if (extra.format.indent.adjustMultilineComment && /[\n\r]/.test(comment.value)) {
		            return adjustMultilineComment('/*' + comment.value + '*/', specialBase);
		        }
		        return '/*' + comment.value + '*/';
		    }
		    function addComments(stmt, result) {
		        var i, len, comment, save, tailingToStatement, specialBase, fragment,
		            extRange, range, prevRange, prefix, infix, suffix, count;
		        if (stmt.leadingComments && stmt.leadingComments.length > 0) {
		            save = result;
		            if (preserveBlankLines) {
		                comment = stmt.leadingComments[0];
		                result = [];
		                extRange = comment.extendedRange;
		                range = comment.range;
		                prefix = sourceCode.substring(extRange[0], range[0]);
		                count = (prefix.match(/\n/g) || []).length;
		                if (count > 0) {
		                    result.push(stringRepeat('\n', count));
		                    result.push(addIndent(generateComment(comment)));
		                } else {
		                    result.push(prefix);
		                    result.push(generateComment(comment));
		                }
		                prevRange = range;
		                for (i = 1, len = stmt.leadingComments.length; i < len; i++) {
		                    comment = stmt.leadingComments[i];
		                    range = comment.range;
		                    infix = sourceCode.substring(prevRange[1], range[0]);
		                    count = (infix.match(/\n/g) || []).length;
		                    result.push(stringRepeat('\n', count));
		                    result.push(addIndent(generateComment(comment)));
		                    prevRange = range;
		                }
		                suffix = sourceCode.substring(range[1], extRange[1]);
		                count = (suffix.match(/\n/g) || []).length;
		                result.push(stringRepeat('\n', count));
		            } else {
		                comment = stmt.leadingComments[0];
		                result = [];
		                if (safeConcatenation && stmt.type === Syntax.Program && stmt.body.length === 0) {
		                    result.push('\n');
		                }
		                result.push(generateComment(comment));
		                if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
		                    result.push('\n');
		                }
		                for (i = 1, len = stmt.leadingComments.length; i < len; ++i) {
		                    comment = stmt.leadingComments[i];
		                    fragment = [generateComment(comment)];
		                    if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
		                        fragment.push('\n');
		                    }
		                    result.push(addIndent(fragment));
		                }
		            }
		            result.push(addIndent(save));
		        }
		        if (stmt.trailingComments) {
		            if (preserveBlankLines) {
		                comment = stmt.trailingComments[0];
		                extRange = comment.extendedRange;
		                range = comment.range;
		                prefix = sourceCode.substring(extRange[0], range[0]);
		                count = (prefix.match(/\n/g) || []).length;
		                if (count > 0) {
		                    result.push(stringRepeat('\n', count));
		                    result.push(addIndent(generateComment(comment)));
		                } else {
		                    result.push(prefix);
		                    result.push(generateComment(comment));
		                }
		            } else {
		                tailingToStatement = !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());
		                specialBase = stringRepeat(' ', calculateSpaces(toSourceNodeWhenNeeded([base, result, indent]).toString()));
		                for (i = 0, len = stmt.trailingComments.length; i < len; ++i) {
		                    comment = stmt.trailingComments[i];
		                    if (tailingToStatement) {
		                        if (i === 0) {
		                            result = [result, indent];
		                        } else {
		                            result = [result, specialBase];
		                        }
		                        result.push(generateComment(comment, specialBase));
		                    } else {
		                        result = [result, addIndent(generateComment(comment))];
		                    }
		                    if (i !== len - 1 && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
		                        result = [result, '\n'];
		                    }
		                }
		            }
		        }
		        return result;
		    }
		    function generateBlankLines(start, end, result) {
		        var j, newlineCount = 0;
		        for (j = start; j < end; j++) {
		            if (sourceCode[j] === '\n') {
		                newlineCount++;
		            }
		        }
		        for (j = 1; j < newlineCount; j++) {
		            result.push(newline);
		        }
		    }
		    function parenthesize(text, current, should) {
		        if (current < should) {
		            return ['(', text, ')'];
		        }
		        return text;
		    }
		    function generateVerbatimString(string) {
		        var i, iz, result;
		        result = string.split(/\r\n|\n/);
		        for (i = 1, iz = result.length; i < iz; i++) {
		            result[i] = newline + base + result[i];
		        }
		        return result;
		    }
		    function generateVerbatim(expr, precedence) {
		        var verbatim, result, prec;
		        verbatim = expr[extra.verbatim];
		        if (typeof verbatim === 'string') {
		            result = parenthesize(generateVerbatimString(verbatim), Precedence.Sequence, precedence);
		        } else {
		            result = generateVerbatimString(verbatim.content);
		            prec = (verbatim.precedence != null) ? verbatim.precedence : Precedence.Sequence;
		            result = parenthesize(result, prec, precedence);
		        }
		        return toSourceNodeWhenNeeded(result, expr);
		    }
		    function CodeGenerator() {
		    }
		    CodeGenerator.prototype.maybeBlock = function(stmt, flags) {
		        var result, noLeadingComment, that = this;
		        noLeadingComment = !extra.comment || !stmt.leadingComments;
		        if (stmt.type === Syntax.BlockStatement && noLeadingComment) {
		            return [space, this.generateStatement(stmt, flags)];
		        }
		        if (stmt.type === Syntax.EmptyStatement && noLeadingComment) {
		            return ';';
		        }
		        withIndent(function () {
		            result = [
		                newline,
		                addIndent(that.generateStatement(stmt, flags))
		            ];
		        });
		        return result;
		    };
		    CodeGenerator.prototype.maybeBlockSuffix = function (stmt, result) {
		        var ends = endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());
		        if (stmt.type === Syntax.BlockStatement && (!extra.comment || !stmt.leadingComments) && !ends) {
		            return [result, space];
		        }
		        if (ends) {
		            return [result, base];
		        }
		        return [result, newline, base];
		    };
		    function generateIdentifier(node) {
		        return toSourceNodeWhenNeeded(node.name, node);
		    }
		    function generateAsyncPrefix(node, spaceRequired) {
		        return node.async ? 'async' + (spaceRequired ? noEmptySpace() : space) : '';
		    }
		    function generateStarSuffix(node) {
		        var isGenerator = node.generator && !extra.moz.starlessGenerator;
		        return isGenerator ? '*' + space : '';
		    }
		    function generateMethodPrefix(prop) {
		        var func = prop.value, prefix = '';
		        if (func.async) {
		            prefix += generateAsyncPrefix(func, !prop.computed);
		        }
		        if (func.generator) {
		            prefix += generateStarSuffix(func) ? '*' : '';
		        }
		        return prefix;
		    }
		    CodeGenerator.prototype.generatePattern = function (node, precedence, flags) {
		        if (node.type === Syntax.Identifier) {
		            return generateIdentifier(node);
		        }
		        return this.generateExpression(node, precedence, flags);
		    };
		    CodeGenerator.prototype.generateFunctionParams = function (node) {
		        var i, iz, result, hasDefault;
		        hasDefault = false;
		        if (node.type === Syntax.ArrowFunctionExpression &&
		                !node.rest && (!node.defaults || node.defaults.length === 0) &&
		                node.params.length === 1 && node.params[0].type === Syntax.Identifier) {
		            result = [generateAsyncPrefix(node, true), generateIdentifier(node.params[0])];
		        } else {
		            result = node.type === Syntax.ArrowFunctionExpression ? [generateAsyncPrefix(node, false)] : [];
		            result.push('(');
		            if (node.defaults) {
		                hasDefault = true;
		            }
		            for (i = 0, iz = node.params.length; i < iz; ++i) {
		                if (hasDefault && node.defaults[i]) {
		                    result.push(this.generateAssignment(node.params[i], node.defaults[i], '=', Precedence.Assignment, E_TTT));
		                } else {
		                    result.push(this.generatePattern(node.params[i], Precedence.Assignment, E_TTT));
		                }
		                if (i + 1 < iz) {
		                    result.push(',' + space);
		                }
		            }
		            if (node.rest) {
		                if (node.params.length) {
		                    result.push(',' + space);
		                }
		                result.push('...');
		                result.push(generateIdentifier(node.rest));
		            }
		            result.push(')');
		        }
		        return result;
		    };
		    CodeGenerator.prototype.generateFunctionBody = function (node) {
		        var result, expr;
		        result = this.generateFunctionParams(node);
		        if (node.type === Syntax.ArrowFunctionExpression) {
		            result.push(space);
		            result.push('=>');
		        }
		        if (node.expression) {
		            result.push(space);
		            expr = this.generateExpression(node.body, Precedence.Assignment, E_TTT);
		            if (expr.toString().charAt(0) === '{') {
		                expr = ['(', expr, ')'];
		            }
		            result.push(expr);
		        } else {
		            result.push(this.maybeBlock(node.body, S_TTFF));
		        }
		        return result;
		    };
		    CodeGenerator.prototype.generateIterationForStatement = function (operator, stmt, flags) {
		        var result = ['for' + (stmt.await ? noEmptySpace() + 'await' : '') + space + '('], that = this;
		        withIndent(function () {
		            if (stmt.left.type === Syntax.VariableDeclaration) {
		                withIndent(function () {
		                    result.push(stmt.left.kind + noEmptySpace());
		                    result.push(that.generateStatement(stmt.left.declarations[0], S_FFFF));
		                });
		            } else {
		                result.push(that.generateExpression(stmt.left, Precedence.Call, E_TTT));
		            }
		            result = join(result, operator);
		            result = [join(
		                result,
		                that.generateExpression(stmt.right, Precedence.Assignment, E_TTT)
		            ), ')'];
		        });
		        result.push(this.maybeBlock(stmt.body, flags));
		        return result;
		    };
		    CodeGenerator.prototype.generatePropertyKey = function (expr, computed) {
		        var result = [];
		        if (computed) {
		            result.push('[');
		        }
		        result.push(this.generateExpression(expr, Precedence.Assignment, E_TTT));
		        if (computed) {
		            result.push(']');
		        }
		        return result;
		    };
		    CodeGenerator.prototype.generateAssignment = function (left, right, operator, precedence, flags) {
		        if (Precedence.Assignment < precedence) {
		            flags |= F_ALLOW_IN;
		        }
		        return parenthesize(
		            [
		                this.generateExpression(left, Precedence.Call, flags),
		                space + operator + space,
		                this.generateExpression(right, Precedence.Assignment, flags)
		            ],
		            Precedence.Assignment,
		            precedence
		        );
		    };
		    CodeGenerator.prototype.semicolon = function (flags) {
		        if (!semicolons && flags & F_SEMICOLON_OPT) {
		            return '';
		        }
		        return ';';
		    };
		    CodeGenerator.Statement = {
		        BlockStatement: function (stmt, flags) {
		            var range, content, result = ['{', newline], that = this;
		            withIndent(function () {
		                if (stmt.body.length === 0 && preserveBlankLines) {
		                    range = stmt.range;
		                    if (range[1] - range[0] > 2) {
		                        content = sourceCode.substring(range[0] + 1, range[1] - 1);
		                        if (content[0] === '\n') {
		                            result = ['{'];
		                        }
		                        result.push(content);
		                    }
		                }
		                var i, iz, fragment, bodyFlags;
		                bodyFlags = S_TFFF;
		                if (flags & F_FUNC_BODY) {
		                    bodyFlags |= F_DIRECTIVE_CTX;
		                }
		                for (i = 0, iz = stmt.body.length; i < iz; ++i) {
		                    if (preserveBlankLines) {
		                        if (i === 0) {
		                            if (stmt.body[0].leadingComments) {
		                                range = stmt.body[0].leadingComments[0].extendedRange;
		                                content = sourceCode.substring(range[0], range[1]);
		                                if (content[0] === '\n') {
		                                    result = ['{'];
		                                }
		                            }
		                            if (!stmt.body[0].leadingComments) {
		                                generateBlankLines(stmt.range[0], stmt.body[0].range[0], result);
		                            }
		                        }
		                        if (i > 0) {
		                            if (!stmt.body[i - 1].trailingComments  && !stmt.body[i].leadingComments) {
		                                generateBlankLines(stmt.body[i - 1].range[1], stmt.body[i].range[0], result);
		                            }
		                        }
		                    }
		                    if (i === iz - 1) {
		                        bodyFlags |= F_SEMICOLON_OPT;
		                    }
		                    if (stmt.body[i].leadingComments && preserveBlankLines) {
		                        fragment = that.generateStatement(stmt.body[i], bodyFlags);
		                    } else {
		                        fragment = addIndent(that.generateStatement(stmt.body[i], bodyFlags));
		                    }
		                    result.push(fragment);
		                    if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
		                        if (preserveBlankLines && i < iz - 1) {
		                            if (!stmt.body[i + 1].leadingComments) {
		                                result.push(newline);
		                            }
		                        } else {
		                            result.push(newline);
		                        }
		                    }
		                    if (preserveBlankLines) {
		                        if (i === iz - 1) {
		                            if (!stmt.body[i].trailingComments) {
		                                generateBlankLines(stmt.body[i].range[1], stmt.range[1], result);
		                            }
		                        }
		                    }
		                }
		            });
		            result.push(addIndent('}'));
		            return result;
		        },
		        BreakStatement: function (stmt, flags) {
		            if (stmt.label) {
		                return 'break ' + stmt.label.name + this.semicolon(flags);
		            }
		            return 'break' + this.semicolon(flags);
		        },
		        ContinueStatement: function (stmt, flags) {
		            if (stmt.label) {
		                return 'continue ' + stmt.label.name + this.semicolon(flags);
		            }
		            return 'continue' + this.semicolon(flags);
		        },
		        ClassBody: function (stmt, flags) {
		            var result = [ '{', newline], that = this;
		            withIndent(function (indent) {
		                var i, iz;
		                for (i = 0, iz = stmt.body.length; i < iz; ++i) {
		                    result.push(indent);
		                    result.push(that.generateExpression(stmt.body[i], Precedence.Sequence, E_TTT));
		                    if (i + 1 < iz) {
		                        result.push(newline);
		                    }
		                }
		            });
		            if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
		                result.push(newline);
		            }
		            result.push(base);
		            result.push('}');
		            return result;
		        },
		        ClassDeclaration: function (stmt, flags) {
		            var result, fragment;
		            result  = ['class'];
		            if (stmt.id) {
		                result = join(result, this.generateExpression(stmt.id, Precedence.Sequence, E_TTT));
		            }
		            if (stmt.superClass) {
		                fragment = join('extends', this.generateExpression(stmt.superClass, Precedence.Unary, E_TTT));
		                result = join(result, fragment);
		            }
		            result.push(space);
		            result.push(this.generateStatement(stmt.body, S_TFFT));
		            return result;
		        },
		        DirectiveStatement: function (stmt, flags) {
		            if (extra.raw && stmt.raw) {
		                return stmt.raw + this.semicolon(flags);
		            }
		            return escapeDirective(stmt.directive) + this.semicolon(flags);
		        },
		        DoWhileStatement: function (stmt, flags) {
		            var result = join('do', this.maybeBlock(stmt.body, S_TFFF));
		            result = this.maybeBlockSuffix(stmt.body, result);
		            return join(result, [
		                'while' + space + '(',
		                this.generateExpression(stmt.test, Precedence.Sequence, E_TTT),
		                ')' + this.semicolon(flags)
		            ]);
		        },
		        CatchClause: function (stmt, flags) {
		            var result, that = this;
		            withIndent(function () {
		                var guard;
		                if (stmt.param) {
		                    result = [
		                        'catch' + space + '(',
		                        that.generateExpression(stmt.param, Precedence.Sequence, E_TTT),
		                        ')'
		                    ];
		                    if (stmt.guard) {
		                        guard = that.generateExpression(stmt.guard, Precedence.Sequence, E_TTT);
		                        result.splice(2, 0, ' if ', guard);
		                    }
		                } else {
		                    result = ['catch'];
		                }
		            });
		            result.push(this.maybeBlock(stmt.body, S_TFFF));
		            return result;
		        },
		        DebuggerStatement: function (stmt, flags) {
		            return 'debugger' + this.semicolon(flags);
		        },
		        EmptyStatement: function (stmt, flags) {
		            return ';';
		        },
		        ExportDefaultDeclaration: function (stmt, flags) {
		            var result = [ 'export' ], bodyFlags;
		            bodyFlags = (flags & F_SEMICOLON_OPT) ? S_TFFT : S_TFFF;
		            result = join(result, 'default');
		            if (isStatement(stmt.declaration)) {
		                result = join(result, this.generateStatement(stmt.declaration, bodyFlags));
		            } else {
		                result = join(result, this.generateExpression(stmt.declaration, Precedence.Assignment, E_TTT) + this.semicolon(flags));
		            }
		            return result;
		        },
		        ExportNamedDeclaration: function (stmt, flags) {
		            var result = [ 'export' ], bodyFlags, that = this;
		            bodyFlags = (flags & F_SEMICOLON_OPT) ? S_TFFT : S_TFFF;
		            if (stmt.declaration) {
		                return join(result, this.generateStatement(stmt.declaration, bodyFlags));
		            }
		            if (stmt.specifiers) {
		                if (stmt.specifiers.length === 0) {
		                    result = join(result, '{' + space + '}');
		                } else if (stmt.specifiers[0].type === Syntax.ExportBatchSpecifier) {
		                    result = join(result, this.generateExpression(stmt.specifiers[0], Precedence.Sequence, E_TTT));
		                } else {
		                    result = join(result, '{');
		                    withIndent(function (indent) {
		                        var i, iz;
		                        result.push(newline);
		                        for (i = 0, iz = stmt.specifiers.length; i < iz; ++i) {
		                            result.push(indent);
		                            result.push(that.generateExpression(stmt.specifiers[i], Precedence.Sequence, E_TTT));
		                            if (i + 1 < iz) {
		                                result.push(',' + newline);
		                            }
		                        }
		                    });
		                    if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
		                        result.push(newline);
		                    }
		                    result.push(base + '}');
		                }
		                if (stmt.source) {
		                    result = join(result, [
		                        'from' + space,
		                        this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
		                        this.semicolon(flags)
		                    ]);
		                } else {
		                    result.push(this.semicolon(flags));
		                }
		            }
		            return result;
		        },
		        ExportAllDeclaration: function (stmt, flags) {
		            return [
		                'export' + space,
		                '*' + space,
		                'from' + space,
		                this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
		                this.semicolon(flags)
		            ];
		        },
		        ExpressionStatement: function (stmt, flags) {
		            var result, fragment;
		            function isClassPrefixed(fragment) {
		                var code;
		                if (fragment.slice(0, 5) !== 'class') {
		                    return false;
		                }
		                code = fragment.charCodeAt(5);
		                return code === 0x7B   || esutils.code.isWhiteSpace(code) || esutils.code.isLineTerminator(code);
		            }
		            function isFunctionPrefixed(fragment) {
		                var code;
		                if (fragment.slice(0, 8) !== 'function') {
		                    return false;
		                }
		                code = fragment.charCodeAt(8);
		                return code === 0x28  || esutils.code.isWhiteSpace(code) || code === 0x2A   || esutils.code.isLineTerminator(code);
		            }
		            function isAsyncPrefixed(fragment) {
		                var code, i, iz;
		                if (fragment.slice(0, 5) !== 'async') {
		                    return false;
		                }
		                if (!esutils.code.isWhiteSpace(fragment.charCodeAt(5))) {
		                    return false;
		                }
		                for (i = 6, iz = fragment.length; i < iz; ++i) {
		                    if (!esutils.code.isWhiteSpace(fragment.charCodeAt(i))) {
		                        break;
		                    }
		                }
		                if (i === iz) {
		                    return false;
		                }
		                if (fragment.slice(i, i + 8) !== 'function') {
		                    return false;
		                }
		                code = fragment.charCodeAt(i + 8);
		                return code === 0x28  || esutils.code.isWhiteSpace(code) || code === 0x2A   || esutils.code.isLineTerminator(code);
		            }
		            result = [this.generateExpression(stmt.expression, Precedence.Sequence, E_TTT)];
		            fragment = toSourceNodeWhenNeeded(result).toString();
		            if (fragment.charCodeAt(0) === 0x7B   ||
		                    isClassPrefixed(fragment) ||
		                    isFunctionPrefixed(fragment) ||
		                    isAsyncPrefixed(fragment) ||
		                    (directive && (flags & F_DIRECTIVE_CTX) && stmt.expression.type === Syntax.Literal && typeof stmt.expression.value === 'string')) {
		                result = ['(', result, ')' + this.semicolon(flags)];
		            } else {
		                result.push(this.semicolon(flags));
		            }
		            return result;
		        },
		        ImportDeclaration: function (stmt, flags) {
		            var result, cursor, that = this;
		            if (stmt.specifiers.length === 0) {
		                return [
		                    'import',
		                    space,
		                    this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
		                    this.semicolon(flags)
		                ];
		            }
		            result = [
		                'import'
		            ];
		            cursor = 0;
		            if (stmt.specifiers[cursor].type === Syntax.ImportDefaultSpecifier) {
		                result = join(result, [
		                        this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT)
		                ]);
		                ++cursor;
		            }
		            if (stmt.specifiers[cursor]) {
		                if (cursor !== 0) {
		                    result.push(',');
		                }
		                if (stmt.specifiers[cursor].type === Syntax.ImportNamespaceSpecifier) {
		                    result = join(result, [
		                            space,
		                            this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT)
		                    ]);
		                } else {
		                    result.push(space + '{');
		                    if ((stmt.specifiers.length - cursor) === 1) {
		                        result.push(space);
		                        result.push(this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT));
		                        result.push(space + '}' + space);
		                    } else {
		                        withIndent(function (indent) {
		                            var i, iz;
		                            result.push(newline);
		                            for (i = cursor, iz = stmt.specifiers.length; i < iz; ++i) {
		                                result.push(indent);
		                                result.push(that.generateExpression(stmt.specifiers[i], Precedence.Sequence, E_TTT));
		                                if (i + 1 < iz) {
		                                    result.push(',' + newline);
		                                }
		                            }
		                        });
		                        if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
		                            result.push(newline);
		                        }
		                        result.push(base + '}' + space);
		                    }
		                }
		            }
		            result = join(result, [
		                'from' + space,
		                this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
		                this.semicolon(flags)
		            ]);
		            return result;
		        },
		        VariableDeclarator: function (stmt, flags) {
		            var itemFlags = (flags & F_ALLOW_IN) ? E_TTT : E_FTT;
		            if (stmt.init) {
		                return [
		                    this.generateExpression(stmt.id, Precedence.Assignment, itemFlags),
		                    space,
		                    '=',
		                    space,
		                    this.generateExpression(stmt.init, Precedence.Assignment, itemFlags)
		                ];
		            }
		            return this.generatePattern(stmt.id, Precedence.Assignment, itemFlags);
		        },
		        VariableDeclaration: function (stmt, flags) {
		            var result, i, iz, node, bodyFlags, that = this;
		            result = [ stmt.kind ];
		            bodyFlags = (flags & F_ALLOW_IN) ? S_TFFF : S_FFFF;
		            function block() {
		                node = stmt.declarations[0];
		                if (extra.comment && node.leadingComments) {
		                    result.push('\n');
		                    result.push(addIndent(that.generateStatement(node, bodyFlags)));
		                } else {
		                    result.push(noEmptySpace());
		                    result.push(that.generateStatement(node, bodyFlags));
		                }
		                for (i = 1, iz = stmt.declarations.length; i < iz; ++i) {
		                    node = stmt.declarations[i];
		                    if (extra.comment && node.leadingComments) {
		                        result.push(',' + newline);
		                        result.push(addIndent(that.generateStatement(node, bodyFlags)));
		                    } else {
		                        result.push(',' + space);
		                        result.push(that.generateStatement(node, bodyFlags));
		                    }
		                }
		            }
		            if (stmt.declarations.length > 1) {
		                withIndent(block);
		            } else {
		                block();
		            }
		            result.push(this.semicolon(flags));
		            return result;
		        },
		        ThrowStatement: function (stmt, flags) {
		            return [join(
		                'throw',
		                this.generateExpression(stmt.argument, Precedence.Sequence, E_TTT)
		            ), this.semicolon(flags)];
		        },
		        TryStatement: function (stmt, flags) {
		            var result, i, iz, guardedHandlers;
		            result = ['try', this.maybeBlock(stmt.block, S_TFFF)];
		            result = this.maybeBlockSuffix(stmt.block, result);
		            if (stmt.handlers) {
		                for (i = 0, iz = stmt.handlers.length; i < iz; ++i) {
		                    result = join(result, this.generateStatement(stmt.handlers[i], S_TFFF));
		                    if (stmt.finalizer || i + 1 !== iz) {
		                        result = this.maybeBlockSuffix(stmt.handlers[i].body, result);
		                    }
		                }
		            } else {
		                guardedHandlers = stmt.guardedHandlers || [];
		                for (i = 0, iz = guardedHandlers.length; i < iz; ++i) {
		                    result = join(result, this.generateStatement(guardedHandlers[i], S_TFFF));
		                    if (stmt.finalizer || i + 1 !== iz) {
		                        result = this.maybeBlockSuffix(guardedHandlers[i].body, result);
		                    }
		                }
		                if (stmt.handler) {
		                    if (Array.isArray(stmt.handler)) {
		                        for (i = 0, iz = stmt.handler.length; i < iz; ++i) {
		                            result = join(result, this.generateStatement(stmt.handler[i], S_TFFF));
		                            if (stmt.finalizer || i + 1 !== iz) {
		                                result = this.maybeBlockSuffix(stmt.handler[i].body, result);
		                            }
		                        }
		                    } else {
		                        result = join(result, this.generateStatement(stmt.handler, S_TFFF));
		                        if (stmt.finalizer) {
		                            result = this.maybeBlockSuffix(stmt.handler.body, result);
		                        }
		                    }
		                }
		            }
		            if (stmt.finalizer) {
		                result = join(result, ['finally', this.maybeBlock(stmt.finalizer, S_TFFF)]);
		            }
		            return result;
		        },
		        SwitchStatement: function (stmt, flags) {
		            var result, fragment, i, iz, bodyFlags, that = this;
		            withIndent(function () {
		                result = [
		                    'switch' + space + '(',
		                    that.generateExpression(stmt.discriminant, Precedence.Sequence, E_TTT),
		                    ')' + space + '{' + newline
		                ];
		            });
		            if (stmt.cases) {
		                bodyFlags = S_TFFF;
		                for (i = 0, iz = stmt.cases.length; i < iz; ++i) {
		                    if (i === iz - 1) {
		                        bodyFlags |= F_SEMICOLON_OPT;
		                    }
		                    fragment = addIndent(this.generateStatement(stmt.cases[i], bodyFlags));
		                    result.push(fragment);
		                    if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
		                        result.push(newline);
		                    }
		                }
		            }
		            result.push(addIndent('}'));
		            return result;
		        },
		        SwitchCase: function (stmt, flags) {
		            var result, fragment, i, iz, bodyFlags, that = this;
		            withIndent(function () {
		                if (stmt.test) {
		                    result = [
		                        join('case', that.generateExpression(stmt.test, Precedence.Sequence, E_TTT)),
		                        ':'
		                    ];
		                } else {
		                    result = ['default:'];
		                }
		                i = 0;
		                iz = stmt.consequent.length;
		                if (iz && stmt.consequent[0].type === Syntax.BlockStatement) {
		                    fragment = that.maybeBlock(stmt.consequent[0], S_TFFF);
		                    result.push(fragment);
		                    i = 1;
		                }
		                if (i !== iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
		                    result.push(newline);
		                }
		                bodyFlags = S_TFFF;
		                for (; i < iz; ++i) {
		                    if (i === iz - 1 && flags & F_SEMICOLON_OPT) {
		                        bodyFlags |= F_SEMICOLON_OPT;
		                    }
		                    fragment = addIndent(that.generateStatement(stmt.consequent[i], bodyFlags));
		                    result.push(fragment);
		                    if (i + 1 !== iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
		                        result.push(newline);
		                    }
		                }
		            });
		            return result;
		        },
		        IfStatement: function (stmt, flags) {
		            var result, bodyFlags, semicolonOptional, that = this;
		            withIndent(function () {
		                result = [
		                    'if' + space + '(',
		                    that.generateExpression(stmt.test, Precedence.Sequence, E_TTT),
		                    ')'
		                ];
		            });
		            semicolonOptional = flags & F_SEMICOLON_OPT;
		            bodyFlags = S_TFFF;
		            if (semicolonOptional) {
		                bodyFlags |= F_SEMICOLON_OPT;
		            }
		            if (stmt.alternate) {
		                result.push(this.maybeBlock(stmt.consequent, S_TFFF));
		                result = this.maybeBlockSuffix(stmt.consequent, result);
		                if (stmt.alternate.type === Syntax.IfStatement) {
		                    result = join(result, ['else ', this.generateStatement(stmt.alternate, bodyFlags)]);
		                } else {
		                    result = join(result, join('else', this.maybeBlock(stmt.alternate, bodyFlags)));
		                }
		            } else {
		                result.push(this.maybeBlock(stmt.consequent, bodyFlags));
		            }
		            return result;
		        },
		        ForStatement: function (stmt, flags) {
		            var result, that = this;
		            withIndent(function () {
		                result = ['for' + space + '('];
		                if (stmt.init) {
		                    if (stmt.init.type === Syntax.VariableDeclaration) {
		                        result.push(that.generateStatement(stmt.init, S_FFFF));
		                    } else {
		                        result.push(that.generateExpression(stmt.init, Precedence.Sequence, E_FTT));
		                        result.push(';');
		                    }
		                } else {
		                    result.push(';');
		                }
		                if (stmt.test) {
		                    result.push(space);
		                    result.push(that.generateExpression(stmt.test, Precedence.Sequence, E_TTT));
		                    result.push(';');
		                } else {
		                    result.push(';');
		                }
		                if (stmt.update) {
		                    result.push(space);
		                    result.push(that.generateExpression(stmt.update, Precedence.Sequence, E_TTT));
		                    result.push(')');
		                } else {
		                    result.push(')');
		                }
		            });
		            result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));
		            return result;
		        },
		        ForInStatement: function (stmt, flags) {
		            return this.generateIterationForStatement('in', stmt, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF);
		        },
		        ForOfStatement: function (stmt, flags) {
		            return this.generateIterationForStatement('of', stmt, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF);
		        },
		        LabeledStatement: function (stmt, flags) {
		            return [stmt.label.name + ':', this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF)];
		        },
		        Program: function (stmt, flags) {
		            var result, fragment, i, iz, bodyFlags;
		            iz = stmt.body.length;
		            result = [safeConcatenation && iz > 0 ? '\n' : ''];
		            bodyFlags = S_TFTF;
		            for (i = 0; i < iz; ++i) {
		                if (!safeConcatenation && i === iz - 1) {
		                    bodyFlags |= F_SEMICOLON_OPT;
		                }
		                if (preserveBlankLines) {
		                    if (i === 0) {
		                        if (!stmt.body[0].leadingComments) {
		                            generateBlankLines(stmt.range[0], stmt.body[i].range[0], result);
		                        }
		                    }
		                    if (i > 0) {
		                        if (!stmt.body[i - 1].trailingComments && !stmt.body[i].leadingComments) {
		                            generateBlankLines(stmt.body[i - 1].range[1], stmt.body[i].range[0], result);
		                        }
		                    }
		                }
		                fragment = addIndent(this.generateStatement(stmt.body[i], bodyFlags));
		                result.push(fragment);
		                if (i + 1 < iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
		                    if (preserveBlankLines) {
		                        if (!stmt.body[i + 1].leadingComments) {
		                            result.push(newline);
		                        }
		                    } else {
		                        result.push(newline);
		                    }
		                }
		                if (preserveBlankLines) {
		                    if (i === iz - 1) {
		                        if (!stmt.body[i].trailingComments) {
		                            generateBlankLines(stmt.body[i].range[1], stmt.range[1], result);
		                        }
		                    }
		                }
		            }
		            return result;
		        },
		        FunctionDeclaration: function (stmt, flags) {
		            return [
		                generateAsyncPrefix(stmt, true),
		                'function',
		                generateStarSuffix(stmt) || noEmptySpace(),
		                stmt.id ? generateIdentifier(stmt.id) : '',
		                this.generateFunctionBody(stmt)
		            ];
		        },
		        ReturnStatement: function (stmt, flags) {
		            if (stmt.argument) {
		                return [join(
		                    'return',
		                    this.generateExpression(stmt.argument, Precedence.Sequence, E_TTT)
		                ), this.semicolon(flags)];
		            }
		            return ['return' + this.semicolon(flags)];
		        },
		        WhileStatement: function (stmt, flags) {
		            var result, that = this;
		            withIndent(function () {
		                result = [
		                    'while' + space + '(',
		                    that.generateExpression(stmt.test, Precedence.Sequence, E_TTT),
		                    ')'
		                ];
		            });
		            result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));
		            return result;
		        },
		        WithStatement: function (stmt, flags) {
		            var result, that = this;
		            withIndent(function () {
		                result = [
		                    'with' + space + '(',
		                    that.generateExpression(stmt.object, Precedence.Sequence, E_TTT),
		                    ')'
		                ];
		            });
		            result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));
		            return result;
		        }
		    };
		    merge(CodeGenerator.prototype, CodeGenerator.Statement);
		    CodeGenerator.Expression = {
		        SequenceExpression: function (expr, precedence, flags) {
		            var result, i, iz;
		            if (Precedence.Sequence < precedence) {
		                flags |= F_ALLOW_IN;
		            }
		            result = [];
		            for (i = 0, iz = expr.expressions.length; i < iz; ++i) {
		                result.push(this.generateExpression(expr.expressions[i], Precedence.Assignment, flags));
		                if (i + 1 < iz) {
		                    result.push(',' + space);
		                }
		            }
		            return parenthesize(result, Precedence.Sequence, precedence);
		        },
		        AssignmentExpression: function (expr, precedence, flags) {
		            return this.generateAssignment(expr.left, expr.right, expr.operator, precedence, flags);
		        },
		        ArrowFunctionExpression: function (expr, precedence, flags) {
		            return parenthesize(this.generateFunctionBody(expr), Precedence.ArrowFunction, precedence);
		        },
		        ConditionalExpression: function (expr, precedence, flags) {
		            if (Precedence.Conditional < precedence) {
		                flags |= F_ALLOW_IN;
		            }
		            return parenthesize(
		                [
		                    this.generateExpression(expr.test, Precedence.Coalesce, flags),
		                    space + '?' + space,
		                    this.generateExpression(expr.consequent, Precedence.Assignment, flags),
		                    space + ':' + space,
		                    this.generateExpression(expr.alternate, Precedence.Assignment, flags)
		                ],
		                Precedence.Conditional,
		                precedence
		            );
		        },
		        LogicalExpression: function (expr, precedence, flags) {
		            if (expr.operator === '??') {
		                flags |= F_FOUND_COALESCE;
		            }
		            return this.BinaryExpression(expr, precedence, flags);
		        },
		        BinaryExpression: function (expr, precedence, flags) {
		            var result, leftPrecedence, rightPrecedence, currentPrecedence, fragment, leftSource;
		            currentPrecedence = BinaryPrecedence[expr.operator];
		            leftPrecedence = expr.operator === '**' ? Precedence.Postfix : currentPrecedence;
		            rightPrecedence = expr.operator === '**' ? currentPrecedence : currentPrecedence + 1;
		            if (currentPrecedence < precedence) {
		                flags |= F_ALLOW_IN;
		            }
		            fragment = this.generateExpression(expr.left, leftPrecedence, flags);
		            leftSource = fragment.toString();
		            if (leftSource.charCodeAt(leftSource.length - 1) === 0x2F  && esutils.code.isIdentifierPartES5(expr.operator.charCodeAt(0))) {
		                result = [fragment, noEmptySpace(), expr.operator];
		            } else {
		                result = join(fragment, expr.operator);
		            }
		            fragment = this.generateExpression(expr.right, rightPrecedence, flags);
		            if (expr.operator === '/' && fragment.toString().charAt(0) === '/' ||
		            expr.operator.slice(-1) === '<' && fragment.toString().slice(0, 3) === '!--') {
		                result.push(noEmptySpace());
		                result.push(fragment);
		            } else {
		                result = join(result, fragment);
		            }
		            if (expr.operator === 'in' && !(flags & F_ALLOW_IN)) {
		                return ['(', result, ')'];
		            }
		            if ((expr.operator === '||' || expr.operator === '&&') && (flags & F_FOUND_COALESCE)) {
		                return ['(', result, ')'];
		            }
		            return parenthesize(result, currentPrecedence, precedence);
		        },
		        CallExpression: function (expr, precedence, flags) {
		            var result, i, iz;
		            result = [this.generateExpression(expr.callee, Precedence.Call, E_TTF)];
		            if (expr.optional) {
		                result.push('?.');
		            }
		            result.push('(');
		            for (i = 0, iz = expr['arguments'].length; i < iz; ++i) {
		                result.push(this.generateExpression(expr['arguments'][i], Precedence.Assignment, E_TTT));
		                if (i + 1 < iz) {
		                    result.push(',' + space);
		                }
		            }
		            result.push(')');
		            if (!(flags & F_ALLOW_CALL)) {
		                return ['(', result, ')'];
		            }
		            return parenthesize(result, Precedence.Call, precedence);
		        },
		        ChainExpression: function (expr, precedence, flags) {
		            if (Precedence.OptionalChaining < precedence) {
		                flags |= F_ALLOW_CALL;
		            }
		            var result = this.generateExpression(expr.expression, Precedence.OptionalChaining, flags);
		            return parenthesize(result, Precedence.OptionalChaining, precedence);
		        },
		        NewExpression: function (expr, precedence, flags) {
		            var result, length, i, iz, itemFlags;
		            length = expr['arguments'].length;
		            itemFlags = (flags & F_ALLOW_UNPARATH_NEW && !parentheses && length === 0) ? E_TFT : E_TFF;
		            result = join(
		                'new',
		                this.generateExpression(expr.callee, Precedence.New, itemFlags)
		            );
		            if (!(flags & F_ALLOW_UNPARATH_NEW) || parentheses || length > 0) {
		                result.push('(');
		                for (i = 0, iz = length; i < iz; ++i) {
		                    result.push(this.generateExpression(expr['arguments'][i], Precedence.Assignment, E_TTT));
		                    if (i + 1 < iz) {
		                        result.push(',' + space);
		                    }
		                }
		                result.push(')');
		            }
		            return parenthesize(result, Precedence.New, precedence);
		        },
		        MemberExpression: function (expr, precedence, flags) {
		            var result, fragment;
		            result = [this.generateExpression(expr.object, Precedence.Call, (flags & F_ALLOW_CALL) ? E_TTF : E_TFF)];
		            if (expr.computed) {
		                if (expr.optional) {
		                    result.push('?.');
		                }
		                result.push('[');
		                result.push(this.generateExpression(expr.property, Precedence.Sequence, flags & F_ALLOW_CALL ? E_TTT : E_TFT));
		                result.push(']');
		            } else {
		                if (!expr.optional && expr.object.type === Syntax.Literal && typeof expr.object.value === 'number') {
		                    fragment = toSourceNodeWhenNeeded(result).toString();
		                    if (
		                            fragment.indexOf('.') < 0 &&
		                            !/[eExX]/.test(fragment) &&
		                            esutils.code.isDecimalDigit(fragment.charCodeAt(fragment.length - 1)) &&
		                            !(fragment.length >= 2 && fragment.charCodeAt(0) === 48)
		                            ) {
		                        result.push(' ');
		                    }
		                }
		                result.push(expr.optional ? '?.' : '.');
		                result.push(generateIdentifier(expr.property));
		            }
		            return parenthesize(result, Precedence.Member, precedence);
		        },
		        MetaProperty: function (expr, precedence, flags) {
		            var result;
		            result = [];
		            result.push(typeof expr.meta === "string" ? expr.meta : generateIdentifier(expr.meta));
		            result.push('.');
		            result.push(typeof expr.property === "string" ? expr.property : generateIdentifier(expr.property));
		            return parenthesize(result, Precedence.Member, precedence);
		        },
		        UnaryExpression: function (expr, precedence, flags) {
		            var result, fragment, rightCharCode, leftSource, leftCharCode;
		            fragment = this.generateExpression(expr.argument, Precedence.Unary, E_TTT);
		            if (space === '') {
		                result = join(expr.operator, fragment);
		            } else {
		                result = [expr.operator];
		                if (expr.operator.length > 2) {
		                    result = join(result, fragment);
		                } else {
		                    leftSource = toSourceNodeWhenNeeded(result).toString();
		                    leftCharCode = leftSource.charCodeAt(leftSource.length - 1);
		                    rightCharCode = fragment.toString().charCodeAt(0);
		                    if (((leftCharCode === 0x2B   || leftCharCode === 0x2D  ) && leftCharCode === rightCharCode) ||
		                            (esutils.code.isIdentifierPartES5(leftCharCode) && esutils.code.isIdentifierPartES5(rightCharCode))) {
		                        result.push(noEmptySpace());
		                        result.push(fragment);
		                    } else {
		                        result.push(fragment);
		                    }
		                }
		            }
		            return parenthesize(result, Precedence.Unary, precedence);
		        },
		        YieldExpression: function (expr, precedence, flags) {
		            var result;
		            if (expr.delegate) {
		                result = 'yield*';
		            } else {
		                result = 'yield';
		            }
		            if (expr.argument) {
		                result = join(
		                    result,
		                    this.generateExpression(expr.argument, Precedence.Yield, E_TTT)
		                );
		            }
		            return parenthesize(result, Precedence.Yield, precedence);
		        },
		        AwaitExpression: function (expr, precedence, flags) {
		            var result = join(
		                expr.all ? 'await*' : 'await',
		                this.generateExpression(expr.argument, Precedence.Await, E_TTT)
		            );
		            return parenthesize(result, Precedence.Await, precedence);
		        },
		        UpdateExpression: function (expr, precedence, flags) {
		            if (expr.prefix) {
		                return parenthesize(
		                    [
		                        expr.operator,
		                        this.generateExpression(expr.argument, Precedence.Unary, E_TTT)
		                    ],
		                    Precedence.Unary,
		                    precedence
		                );
		            }
		            return parenthesize(
		                [
		                    this.generateExpression(expr.argument, Precedence.Postfix, E_TTT),
		                    expr.operator
		                ],
		                Precedence.Postfix,
		                precedence
		            );
		        },
		        FunctionExpression: function (expr, precedence, flags) {
		            var result = [
		                generateAsyncPrefix(expr, true),
		                'function'
		            ];
		            if (expr.id) {
		                result.push(generateStarSuffix(expr) || noEmptySpace());
		                result.push(generateIdentifier(expr.id));
		            } else {
		                result.push(generateStarSuffix(expr) || space);
		            }
		            result.push(this.generateFunctionBody(expr));
		            return result;
		        },
		        ArrayPattern: function (expr, precedence, flags) {
		            return this.ArrayExpression(expr, precedence, flags, true);
		        },
		        ArrayExpression: function (expr, precedence, flags, isPattern) {
		            var result, multiline, that = this;
		            if (!expr.elements.length) {
		                return '[]';
		            }
		            multiline = isPattern ? false : expr.elements.length > 1;
		            result = ['[', multiline ? newline : ''];
		            withIndent(function (indent) {
		                var i, iz;
		                for (i = 0, iz = expr.elements.length; i < iz; ++i) {
		                    if (!expr.elements[i]) {
		                        if (multiline) {
		                            result.push(indent);
		                        }
		                        if (i + 1 === iz) {
		                            result.push(',');
		                        }
		                    } else {
		                        result.push(multiline ? indent : '');
		                        result.push(that.generateExpression(expr.elements[i], Precedence.Assignment, E_TTT));
		                    }
		                    if (i + 1 < iz) {
		                        result.push(',' + (multiline ? newline : space));
		                    }
		                }
		            });
		            if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
		                result.push(newline);
		            }
		            result.push(multiline ? base : '');
		            result.push(']');
		            return result;
		        },
		        RestElement: function(expr, precedence, flags) {
		            return '...' + this.generatePattern(expr.argument);
		        },
		        ClassExpression: function (expr, precedence, flags) {
		            var result, fragment;
		            result = ['class'];
		            if (expr.id) {
		                result = join(result, this.generateExpression(expr.id, Precedence.Sequence, E_TTT));
		            }
		            if (expr.superClass) {
		                fragment = join('extends', this.generateExpression(expr.superClass, Precedence.Unary, E_TTT));
		                result = join(result, fragment);
		            }
		            result.push(space);
		            result.push(this.generateStatement(expr.body, S_TFFT));
		            return result;
		        },
		        MethodDefinition: function (expr, precedence, flags) {
		            var result, fragment;
		            if (expr['static']) {
		                result = ['static' + space];
		            } else {
		                result = [];
		            }
		            if (expr.kind === 'get' || expr.kind === 'set') {
		                fragment = [
		                    join(expr.kind, this.generatePropertyKey(expr.key, expr.computed)),
		                    this.generateFunctionBody(expr.value)
		                ];
		            } else {
		                fragment = [
		                    generateMethodPrefix(expr),
		                    this.generatePropertyKey(expr.key, expr.computed),
		                    this.generateFunctionBody(expr.value)
		                ];
		            }
		            return join(result, fragment);
		        },
		        Property: function (expr, precedence, flags) {
		            if (expr.kind === 'get' || expr.kind === 'set') {
		                return [
		                    expr.kind, noEmptySpace(),
		                    this.generatePropertyKey(expr.key, expr.computed),
		                    this.generateFunctionBody(expr.value)
		                ];
		            }
		            if (expr.shorthand) {
		                if (expr.value.type === "AssignmentPattern") {
		                    return this.AssignmentPattern(expr.value, Precedence.Sequence, E_TTT);
		                }
		                return this.generatePropertyKey(expr.key, expr.computed);
		            }
		            if (expr.method) {
		                return [
		                    generateMethodPrefix(expr),
		                    this.generatePropertyKey(expr.key, expr.computed),
		                    this.generateFunctionBody(expr.value)
		                ];
		            }
		            return [
		                this.generatePropertyKey(expr.key, expr.computed),
		                ':' + space,
		                this.generateExpression(expr.value, Precedence.Assignment, E_TTT)
		            ];
		        },
		        ObjectExpression: function (expr, precedence, flags) {
		            var multiline, result, fragment, that = this;
		            if (!expr.properties.length) {
		                return '{}';
		            }
		            multiline = expr.properties.length > 1;
		            withIndent(function () {
		                fragment = that.generateExpression(expr.properties[0], Precedence.Sequence, E_TTT);
		            });
		            if (!multiline) {
		                if (!hasLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
		                    return [ '{', space, fragment, space, '}' ];
		                }
		            }
		            withIndent(function (indent) {
		                var i, iz;
		                result = [ '{', newline, indent, fragment ];
		                if (multiline) {
		                    result.push(',' + newline);
		                    for (i = 1, iz = expr.properties.length; i < iz; ++i) {
		                        result.push(indent);
		                        result.push(that.generateExpression(expr.properties[i], Precedence.Sequence, E_TTT));
		                        if (i + 1 < iz) {
		                            result.push(',' + newline);
		                        }
		                    }
		                }
		            });
		            if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
		                result.push(newline);
		            }
		            result.push(base);
		            result.push('}');
		            return result;
		        },
		        AssignmentPattern: function(expr, precedence, flags) {
		            return this.generateAssignment(expr.left, expr.right, '=', precedence, flags);
		        },
		        ObjectPattern: function (expr, precedence, flags) {
		            var result, i, iz, multiline, property, that = this;
		            if (!expr.properties.length) {
		                return '{}';
		            }
		            multiline = false;
		            if (expr.properties.length === 1) {
		                property = expr.properties[0];
		                if (
		                    property.type === Syntax.Property
		                    && property.value.type !== Syntax.Identifier
		                ) {
		                    multiline = true;
		                }
		            } else {
		                for (i = 0, iz = expr.properties.length; i < iz; ++i) {
		                    property = expr.properties[i];
		                    if (
		                        property.type === Syntax.Property
		                        && !property.shorthand
		                    ) {
		                        multiline = true;
		                        break;
		                    }
		                }
		            }
		            result = ['{', multiline ? newline : '' ];
		            withIndent(function (indent) {
		                var i, iz;
		                for (i = 0, iz = expr.properties.length; i < iz; ++i) {
		                    result.push(multiline ? indent : '');
		                    result.push(that.generateExpression(expr.properties[i], Precedence.Sequence, E_TTT));
		                    if (i + 1 < iz) {
		                        result.push(',' + (multiline ? newline : space));
		                    }
		                }
		            });
		            if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
		                result.push(newline);
		            }
		            result.push(multiline ? base : '');
		            result.push('}');
		            return result;
		        },
		        ThisExpression: function (expr, precedence, flags) {
		            return 'this';
		        },
		        Super: function (expr, precedence, flags) {
		            return 'super';
		        },
		        Identifier: function (expr, precedence, flags) {
		            return generateIdentifier(expr);
		        },
		        ImportDefaultSpecifier: function (expr, precedence, flags) {
		            return generateIdentifier(expr.id || expr.local);
		        },
		        ImportNamespaceSpecifier: function (expr, precedence, flags) {
		            var result = ['*'];
		            var id = expr.id || expr.local;
		            if (id) {
		                result.push(space + 'as' + noEmptySpace() + generateIdentifier(id));
		            }
		            return result;
		        },
		        ImportSpecifier: function (expr, precedence, flags) {
		            var imported = expr.imported;
		            var result = [ imported.name ];
		            var local = expr.local;
		            if (local && local.name !== imported.name) {
		                result.push(noEmptySpace() + 'as' + noEmptySpace() + generateIdentifier(local));
		            }
		            return result;
		        },
		        ExportSpecifier: function (expr, precedence, flags) {
		            var local = expr.local;
		            var result = [ local.name ];
		            var exported = expr.exported;
		            if (exported && exported.name !== local.name) {
		                result.push(noEmptySpace() + 'as' + noEmptySpace() + generateIdentifier(exported));
		            }
		            return result;
		        },
		        Literal: function (expr, precedence, flags) {
		            var raw;
		            if (expr.hasOwnProperty('raw') && parse && extra.raw) {
		                try {
		                    raw = parse(expr.raw).body[0].expression;
		                    if (raw.type === Syntax.Literal) {
		                        if (raw.value === expr.value) {
		                            return expr.raw;
		                        }
		                    }
		                } catch (e) {
		                }
		            }
		            if (expr.regex) {
		              return '/' + expr.regex.pattern + '/' + expr.regex.flags;
		            }
		            if (typeof expr.value === 'bigint') {
		                return expr.value.toString() + 'n';
		            }
		            if (expr.bigint) {
		                return expr.bigint + 'n';
		            }
		            if (expr.value === null) {
		                return 'null';
		            }
		            if (typeof expr.value === 'string') {
		                return escapeString(expr.value);
		            }
		            if (typeof expr.value === 'number') {
		                return generateNumber(expr.value);
		            }
		            if (typeof expr.value === 'boolean') {
		                return expr.value ? 'true' : 'false';
		            }
		            return generateRegExp(expr.value);
		        },
		        GeneratorExpression: function (expr, precedence, flags) {
		            return this.ComprehensionExpression(expr, precedence, flags);
		        },
		        ComprehensionExpression: function (expr, precedence, flags) {
		            var result, i, iz, fragment, that = this;
		            result = (expr.type === Syntax.GeneratorExpression) ? ['('] : ['['];
		            if (extra.moz.comprehensionExpressionStartsWithAssignment) {
		                fragment = this.generateExpression(expr.body, Precedence.Assignment, E_TTT);
		                result.push(fragment);
		            }
		            if (expr.blocks) {
		                withIndent(function () {
		                    for (i = 0, iz = expr.blocks.length; i < iz; ++i) {
		                        fragment = that.generateExpression(expr.blocks[i], Precedence.Sequence, E_TTT);
		                        if (i > 0 || extra.moz.comprehensionExpressionStartsWithAssignment) {
		                            result = join(result, fragment);
		                        } else {
		                            result.push(fragment);
		                        }
		                    }
		                });
		            }
		            if (expr.filter) {
		                result = join(result, 'if' + space);
		                fragment = this.generateExpression(expr.filter, Precedence.Sequence, E_TTT);
		                result = join(result, [ '(', fragment, ')' ]);
		            }
		            if (!extra.moz.comprehensionExpressionStartsWithAssignment) {
		                fragment = this.generateExpression(expr.body, Precedence.Assignment, E_TTT);
		                result = join(result, fragment);
		            }
		            result.push((expr.type === Syntax.GeneratorExpression) ? ')' : ']');
		            return result;
		        },
		        ComprehensionBlock: function (expr, precedence, flags) {
		            var fragment;
		            if (expr.left.type === Syntax.VariableDeclaration) {
		                fragment = [
		                    expr.left.kind, noEmptySpace(),
		                    this.generateStatement(expr.left.declarations[0], S_FFFF)
		                ];
		            } else {
		                fragment = this.generateExpression(expr.left, Precedence.Call, E_TTT);
		            }
		            fragment = join(fragment, expr.of ? 'of' : 'in');
		            fragment = join(fragment, this.generateExpression(expr.right, Precedence.Sequence, E_TTT));
		            return [ 'for' + space + '(', fragment, ')' ];
		        },
		        SpreadElement: function (expr, precedence, flags) {
		            return [
		                '...',
		                this.generateExpression(expr.argument, Precedence.Assignment, E_TTT)
		            ];
		        },
		        TaggedTemplateExpression: function (expr, precedence, flags) {
		            var itemFlags = E_TTF;
		            if (!(flags & F_ALLOW_CALL)) {
		                itemFlags = E_TFF;
		            }
		            var result = [
		                this.generateExpression(expr.tag, Precedence.Call, itemFlags),
		                this.generateExpression(expr.quasi, Precedence.Primary, E_FFT)
		            ];
		            return parenthesize(result, Precedence.TaggedTemplate, precedence);
		        },
		        TemplateElement: function (expr, precedence, flags) {
		            return expr.value.raw;
		        },
		        TemplateLiteral: function (expr, precedence, flags) {
		            var result, i, iz;
		            result = [ '`' ];
		            for (i = 0, iz = expr.quasis.length; i < iz; ++i) {
		                result.push(this.generateExpression(expr.quasis[i], Precedence.Primary, E_TTT));
		                if (i + 1 < iz) {
		                    result.push('${' + space);
		                    result.push(this.generateExpression(expr.expressions[i], Precedence.Sequence, E_TTT));
		                    result.push(space + '}');
		                }
		            }
		            result.push('`');
		            return result;
		        },
		        ModuleSpecifier: function (expr, precedence, flags) {
		            return this.Literal(expr, precedence, flags);
		        },
		        ImportExpression: function(expr, precedence, flag) {
		            return parenthesize([
		                'import(',
		                this.generateExpression(expr.source, Precedence.Assignment, E_TTT),
		                ')'
		            ], Precedence.Call, precedence);
		        }
		    };
		    merge(CodeGenerator.prototype, CodeGenerator.Expression);
		    CodeGenerator.prototype.generateExpression = function (expr, precedence, flags) {
		        var result, type;
		        type = expr.type || Syntax.Property;
		        if (extra.verbatim && expr.hasOwnProperty(extra.verbatim)) {
		            return generateVerbatim(expr, precedence);
		        }
		        result = this[type](expr, precedence, flags);
		        if (extra.comment) {
		            result = addComments(expr, result);
		        }
		        return toSourceNodeWhenNeeded(result, expr);
		    };
		    CodeGenerator.prototype.generateStatement = function (stmt, flags) {
		        var result,
		            fragment;
		        result = this[stmt.type](stmt, flags);
		        if (extra.comment) {
		            result = addComments(stmt, result);
		        }
		        fragment = toSourceNodeWhenNeeded(result).toString();
		        if (stmt.type === Syntax.Program && !safeConcatenation && newline === '' &&  fragment.charAt(fragment.length - 1) === '\n') {
		            result = sourceMap ? toSourceNodeWhenNeeded(result).replaceRight(/\s+$/, '') : fragment.replace(/\s+$/, '');
		        }
		        return toSourceNodeWhenNeeded(result, stmt);
		    };
		    function generateInternal(node) {
		        var codegen;
		        codegen = new CodeGenerator();
		        if (isStatement(node)) {
		            return codegen.generateStatement(node, S_TFFF);
		        }
		        if (isExpression(node)) {
		            return codegen.generateExpression(node, Precedence.Sequence, E_TTT);
		        }
		        throw new Error('Unknown node type: ' + node.type);
		    }
		    function generate(node, options) {
		        var defaultOptions = getDefaultOptions(), result, pair;
		        if (options != null) {
		            if (typeof options.indent === 'string') {
		                defaultOptions.format.indent.style = options.indent;
		            }
		            if (typeof options.base === 'number') {
		                defaultOptions.format.indent.base = options.base;
		            }
		            options = updateDeeply(defaultOptions, options);
		            indent = options.format.indent.style;
		            if (typeof options.base === 'string') {
		                base = options.base;
		            } else {
		                base = stringRepeat(indent, options.format.indent.base);
		            }
		        } else {
		            options = defaultOptions;
		            indent = options.format.indent.style;
		            base = stringRepeat(indent, options.format.indent.base);
		        }
		        json = options.format.json;
		        renumber = options.format.renumber;
		        hexadecimal = json ? false : options.format.hexadecimal;
		        quotes = json ? 'double' : options.format.quotes;
		        escapeless = options.format.escapeless;
		        newline = options.format.newline;
		        space = options.format.space;
		        if (options.format.compact) {
		            newline = space = indent = base = '';
		        }
		        parentheses = options.format.parentheses;
		        semicolons = options.format.semicolons;
		        safeConcatenation = options.format.safeConcatenation;
		        directive = options.directive;
		        parse = json ? null : options.parse;
		        sourceMap = options.sourceMap;
		        sourceCode = options.sourceCode;
		        preserveBlankLines = options.format.preserveBlankLines && sourceCode !== null;
		        extra = options;
		        if (sourceMap) {
		            if (!exports.browser) {
		                SourceNode = requireSourceMap().SourceNode;
		            } else {
		                SourceNode = commonjsGlobal.sourceMap.SourceNode;
		            }
		        }
		        result = generateInternal(node);
		        if (!sourceMap) {
		            pair = {code: result.toString(), map: null};
		            return options.sourceMapWithCode ? pair : pair.code;
		        }
		        pair = result.toStringWithSourceMap({
		            file: options.file,
		            sourceRoot: options.sourceMapRoot
		        });
		        if (options.sourceContent) {
		            pair.map.setSourceContent(options.sourceMap,
		                                      options.sourceContent);
		        }
		        if (options.sourceMapWithCode) {
		            return pair;
		        }
		        return pair.map.toString();
		    }
		    FORMAT_MINIFY = {
		        indent: {
		            style: '',
		            base: 0
		        },
		        renumber: true,
		        hexadecimal: true,
		        quotes: 'auto',
		        escapeless: true,
		        compact: true,
		        parentheses: false,
		        semicolons: false
		    };
		    FORMAT_DEFAULTS = getDefaultOptions().format;
		    exports.version = require$$3.version;
		    exports.generate = generate;
		    exports.attachComments = estraverse.attachComments;
		    exports.Precedence = updateDeeply({}, Precedence);
		    exports.browser = false;
		    exports.FORMAT_MINIFY = FORMAT_MINIFY;
		    exports.FORMAT_DEFAULTS = FORMAT_DEFAULTS;
		}()); 
	} (escodegen));
	return escodegen;
}

var esprima$2 = {exports: {}};

var esprima$1 = esprima$2.exports;

var hasRequiredEsprima$1;

function requireEsprima$1 () {
	if (hasRequiredEsprima$1) return esprima$2.exports;
	hasRequiredEsprima$1 = 1;
	(function (module, exports) {
		(function webpackUniversalModuleDefinition(root, factory) {
			module.exports = factory();
		})(esprima$1, function() {
		return  (function(modules) {
		 	var installedModules = {};
		 	function __webpack_require__(moduleId) {
		 		if(installedModules[moduleId])
		 			return installedModules[moduleId].exports;
		 		var module = installedModules[moduleId] = {
		 			exports: {},
		 			id: moduleId,
		 			loaded: false
		 		};
		 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
		 		module.loaded = true;
		 		return module.exports;
		 	}
		 	__webpack_require__.m = modules;
		 	__webpack_require__.c = installedModules;
		 	__webpack_require__.p = "";
		 	return __webpack_require__(0);
		 })
		 ([
		 function(module, exports, __webpack_require__) {
			/*
			  Copyright JS Foundation and other contributors, https://js.foundation/
			  Redistribution and use in source and binary forms, with or without
			  modification, are permitted provided that the following conditions are met:
			    * Redistributions of source code must retain the above copyright
			      notice, this list of conditions and the following disclaimer.
			    * Redistributions in binary form must reproduce the above copyright
			      notice, this list of conditions and the following disclaimer in the
			      documentation and/or other materials provided with the distribution.
			  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
			  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
			  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
			  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
			  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
			  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
			  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
			  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
			  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
			  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
			*/
			Object.defineProperty(exports, "__esModule", { value: true });
			var comment_handler_1 = __webpack_require__(1);
			var jsx_parser_1 = __webpack_require__(3);
			var parser_1 = __webpack_require__(8);
			var tokenizer_1 = __webpack_require__(15);
			function parse(code, options, delegate) {
			    var commentHandler = null;
			    var proxyDelegate = function (node, metadata) {
			        if (delegate) {
			            delegate(node, metadata);
			        }
			        if (commentHandler) {
			            commentHandler.visit(node, metadata);
			        }
			    };
			    var parserDelegate = (typeof delegate === 'function') ? proxyDelegate : null;
			    var collectComment = false;
			    if (options) {
			        collectComment = (typeof options.comment === 'boolean' && options.comment);
			        var attachComment = (typeof options.attachComment === 'boolean' && options.attachComment);
			        if (collectComment || attachComment) {
			            commentHandler = new comment_handler_1.CommentHandler();
			            commentHandler.attach = attachComment;
			            options.comment = true;
			            parserDelegate = proxyDelegate;
			        }
			    }
			    var isModule = false;
			    if (options && typeof options.sourceType === 'string') {
			        isModule = (options.sourceType === 'module');
			    }
			    var parser;
			    if (options && typeof options.jsx === 'boolean' && options.jsx) {
			        parser = new jsx_parser_1.JSXParser(code, options, parserDelegate);
			    }
			    else {
			        parser = new parser_1.Parser(code, options, parserDelegate);
			    }
			    var program = isModule ? parser.parseModule() : parser.parseScript();
			    var ast = program;
			    if (collectComment && commentHandler) {
			        ast.comments = commentHandler.comments;
			    }
			    if (parser.config.tokens) {
			        ast.tokens = parser.tokens;
			    }
			    if (parser.config.tolerant) {
			        ast.errors = parser.errorHandler.errors;
			    }
			    return ast;
			}
			exports.parse = parse;
			function parseModule(code, options, delegate) {
			    var parsingOptions = options || {};
			    parsingOptions.sourceType = 'module';
			    return parse(code, parsingOptions, delegate);
			}
			exports.parseModule = parseModule;
			function parseScript(code, options, delegate) {
			    var parsingOptions = options || {};
			    parsingOptions.sourceType = 'script';
			    return parse(code, parsingOptions, delegate);
			}
			exports.parseScript = parseScript;
			function tokenize(code, options, delegate) {
			    var tokenizer = new tokenizer_1.Tokenizer(code, options);
			    var tokens;
			    tokens = [];
			    try {
			        while (true) {
			            var token = tokenizer.getNextToken();
			            if (!token) {
			                break;
			            }
			            if (delegate) {
			                token = delegate(token);
			            }
			            tokens.push(token);
			        }
			    }
			    catch (e) {
			        tokenizer.errorHandler.tolerate(e);
			    }
			    if (tokenizer.errorHandler.tolerant) {
			        tokens.errors = tokenizer.errors();
			    }
			    return tokens;
			}
			exports.tokenize = tokenize;
			var syntax_1 = __webpack_require__(2);
			exports.Syntax = syntax_1.Syntax;
			exports.version = '4.0.1';
		 },
		 function(module, exports, __webpack_require__) {
			Object.defineProperty(exports, "__esModule", { value: true });
			var syntax_1 = __webpack_require__(2);
			var CommentHandler = (function () {
			    function CommentHandler() {
			        this.attach = false;
			        this.comments = [];
			        this.stack = [];
			        this.leading = [];
			        this.trailing = [];
			    }
			    CommentHandler.prototype.insertInnerComments = function (node, metadata) {
			        if (node.type === syntax_1.Syntax.BlockStatement && node.body.length === 0) {
			            var innerComments = [];
			            for (var i = this.leading.length - 1; i >= 0; --i) {
			                var entry = this.leading[i];
			                if (metadata.end.offset >= entry.start) {
			                    innerComments.unshift(entry.comment);
			                    this.leading.splice(i, 1);
			                    this.trailing.splice(i, 1);
			                }
			            }
			            if (innerComments.length) {
			                node.innerComments = innerComments;
			            }
			        }
			    };
			    CommentHandler.prototype.findTrailingComments = function (metadata) {
			        var trailingComments = [];
			        if (this.trailing.length > 0) {
			            for (var i = this.trailing.length - 1; i >= 0; --i) {
			                var entry_1 = this.trailing[i];
			                if (entry_1.start >= metadata.end.offset) {
			                    trailingComments.unshift(entry_1.comment);
			                }
			            }
			            this.trailing.length = 0;
			            return trailingComments;
			        }
			        var entry = this.stack[this.stack.length - 1];
			        if (entry && entry.node.trailingComments) {
			            var firstComment = entry.node.trailingComments[0];
			            if (firstComment && firstComment.range[0] >= metadata.end.offset) {
			                trailingComments = entry.node.trailingComments;
			                delete entry.node.trailingComments;
			            }
			        }
			        return trailingComments;
			    };
			    CommentHandler.prototype.findLeadingComments = function (metadata) {
			        var leadingComments = [];
			        var target;
			        while (this.stack.length > 0) {
			            var entry = this.stack[this.stack.length - 1];
			            if (entry && entry.start >= metadata.start.offset) {
			                target = entry.node;
			                this.stack.pop();
			            }
			            else {
			                break;
			            }
			        }
			        if (target) {
			            var count = target.leadingComments ? target.leadingComments.length : 0;
			            for (var i = count - 1; i >= 0; --i) {
			                var comment = target.leadingComments[i];
			                if (comment.range[1] <= metadata.start.offset) {
			                    leadingComments.unshift(comment);
			                    target.leadingComments.splice(i, 1);
			                }
			            }
			            if (target.leadingComments && target.leadingComments.length === 0) {
			                delete target.leadingComments;
			            }
			            return leadingComments;
			        }
			        for (var i = this.leading.length - 1; i >= 0; --i) {
			            var entry = this.leading[i];
			            if (entry.start <= metadata.start.offset) {
			                leadingComments.unshift(entry.comment);
			                this.leading.splice(i, 1);
			            }
			        }
			        return leadingComments;
			    };
			    CommentHandler.prototype.visitNode = function (node, metadata) {
			        if (node.type === syntax_1.Syntax.Program && node.body.length > 0) {
			            return;
			        }
			        this.insertInnerComments(node, metadata);
			        var trailingComments = this.findTrailingComments(metadata);
			        var leadingComments = this.findLeadingComments(metadata);
			        if (leadingComments.length > 0) {
			            node.leadingComments = leadingComments;
			        }
			        if (trailingComments.length > 0) {
			            node.trailingComments = trailingComments;
			        }
			        this.stack.push({
			            node: node,
			            start: metadata.start.offset
			        });
			    };
			    CommentHandler.prototype.visitComment = function (node, metadata) {
			        var type = (node.type[0] === 'L') ? 'Line' : 'Block';
			        var comment = {
			            type: type,
			            value: node.value
			        };
			        if (node.range) {
			            comment.range = node.range;
			        }
			        if (node.loc) {
			            comment.loc = node.loc;
			        }
			        this.comments.push(comment);
			        if (this.attach) {
			            var entry = {
			                comment: {
			                    type: type,
			                    value: node.value,
			                    range: [metadata.start.offset, metadata.end.offset]
			                },
			                start: metadata.start.offset
			            };
			            if (node.loc) {
			                entry.comment.loc = node.loc;
			            }
			            node.type = type;
			            this.leading.push(entry);
			            this.trailing.push(entry);
			        }
			    };
			    CommentHandler.prototype.visit = function (node, metadata) {
			        if (node.type === 'LineComment') {
			            this.visitComment(node, metadata);
			        }
			        else if (node.type === 'BlockComment') {
			            this.visitComment(node, metadata);
			        }
			        else if (this.attach) {
			            this.visitNode(node, metadata);
			        }
			    };
			    return CommentHandler;
			}());
			exports.CommentHandler = CommentHandler;
		 },
		 function(module, exports) {
			Object.defineProperty(exports, "__esModule", { value: true });
			exports.Syntax = {
			    AssignmentExpression: 'AssignmentExpression',
			    AssignmentPattern: 'AssignmentPattern',
			    ArrayExpression: 'ArrayExpression',
			    ArrayPattern: 'ArrayPattern',
			    ArrowFunctionExpression: 'ArrowFunctionExpression',
			    AwaitExpression: 'AwaitExpression',
			    BlockStatement: 'BlockStatement',
			    BinaryExpression: 'BinaryExpression',
			    BreakStatement: 'BreakStatement',
			    CallExpression: 'CallExpression',
			    CatchClause: 'CatchClause',
			    ClassBody: 'ClassBody',
			    ClassDeclaration: 'ClassDeclaration',
			    ClassExpression: 'ClassExpression',
			    ConditionalExpression: 'ConditionalExpression',
			    ContinueStatement: 'ContinueStatement',
			    DoWhileStatement: 'DoWhileStatement',
			    DebuggerStatement: 'DebuggerStatement',
			    EmptyStatement: 'EmptyStatement',
			    ExportAllDeclaration: 'ExportAllDeclaration',
			    ExportDefaultDeclaration: 'ExportDefaultDeclaration',
			    ExportNamedDeclaration: 'ExportNamedDeclaration',
			    ExportSpecifier: 'ExportSpecifier',
			    ExpressionStatement: 'ExpressionStatement',
			    ForStatement: 'ForStatement',
			    ForOfStatement: 'ForOfStatement',
			    ForInStatement: 'ForInStatement',
			    FunctionDeclaration: 'FunctionDeclaration',
			    FunctionExpression: 'FunctionExpression',
			    Identifier: 'Identifier',
			    IfStatement: 'IfStatement',
			    ImportDeclaration: 'ImportDeclaration',
			    ImportDefaultSpecifier: 'ImportDefaultSpecifier',
			    ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
			    ImportSpecifier: 'ImportSpecifier',
			    Literal: 'Literal',
			    LabeledStatement: 'LabeledStatement',
			    LogicalExpression: 'LogicalExpression',
			    MemberExpression: 'MemberExpression',
			    MetaProperty: 'MetaProperty',
			    MethodDefinition: 'MethodDefinition',
			    NewExpression: 'NewExpression',
			    ObjectExpression: 'ObjectExpression',
			    ObjectPattern: 'ObjectPattern',
			    Program: 'Program',
			    Property: 'Property',
			    RestElement: 'RestElement',
			    ReturnStatement: 'ReturnStatement',
			    SequenceExpression: 'SequenceExpression',
			    SpreadElement: 'SpreadElement',
			    Super: 'Super',
			    SwitchCase: 'SwitchCase',
			    SwitchStatement: 'SwitchStatement',
			    TaggedTemplateExpression: 'TaggedTemplateExpression',
			    TemplateElement: 'TemplateElement',
			    TemplateLiteral: 'TemplateLiteral',
			    ThisExpression: 'ThisExpression',
			    ThrowStatement: 'ThrowStatement',
			    TryStatement: 'TryStatement',
			    UnaryExpression: 'UnaryExpression',
			    UpdateExpression: 'UpdateExpression',
			    VariableDeclaration: 'VariableDeclaration',
			    VariableDeclarator: 'VariableDeclarator',
			    WhileStatement: 'WhileStatement',
			    WithStatement: 'WithStatement',
			    YieldExpression: 'YieldExpression'
			};
		 },
		 function(module, exports, __webpack_require__) {
			var __extends = (this && this.__extends) || (function () {
			    var extendStatics = Object.setPrototypeOf ||
			        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
			        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
			    return function (d, b) {
			        extendStatics(d, b);
			        function __() { this.constructor = d; }
			        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
			    };
			})();
			Object.defineProperty(exports, "__esModule", { value: true });
			var character_1 = __webpack_require__(4);
			var JSXNode = __webpack_require__(5);
			var jsx_syntax_1 = __webpack_require__(6);
			var Node = __webpack_require__(7);
			var parser_1 = __webpack_require__(8);
			var token_1 = __webpack_require__(13);
			var xhtml_entities_1 = __webpack_require__(14);
			token_1.TokenName[100 ] = 'JSXIdentifier';
			token_1.TokenName[101 ] = 'JSXText';
			function getQualifiedElementName(elementName) {
			    var qualifiedName;
			    switch (elementName.type) {
			        case jsx_syntax_1.JSXSyntax.JSXIdentifier:
			            var id = elementName;
			            qualifiedName = id.name;
			            break;
			        case jsx_syntax_1.JSXSyntax.JSXNamespacedName:
			            var ns = elementName;
			            qualifiedName = getQualifiedElementName(ns.namespace) + ':' +
			                getQualifiedElementName(ns.name);
			            break;
			        case jsx_syntax_1.JSXSyntax.JSXMemberExpression:
			            var expr = elementName;
			            qualifiedName = getQualifiedElementName(expr.object) + '.' +
			                getQualifiedElementName(expr.property);
			            break;
			    }
			    return qualifiedName;
			}
			var JSXParser = (function (_super) {
			    __extends(JSXParser, _super);
			    function JSXParser(code, options, delegate) {
			        return _super.call(this, code, options, delegate) || this;
			    }
			    JSXParser.prototype.parsePrimaryExpression = function () {
			        return this.match('<') ? this.parseJSXRoot() : _super.prototype.parsePrimaryExpression.call(this);
			    };
			    JSXParser.prototype.startJSX = function () {
			        this.scanner.index = this.startMarker.index;
			        this.scanner.lineNumber = this.startMarker.line;
			        this.scanner.lineStart = this.startMarker.index - this.startMarker.column;
			    };
			    JSXParser.prototype.finishJSX = function () {
			        this.nextToken();
			    };
			    JSXParser.prototype.reenterJSX = function () {
			        this.startJSX();
			        this.expectJSX('}');
			        if (this.config.tokens) {
			            this.tokens.pop();
			        }
			    };
			    JSXParser.prototype.createJSXNode = function () {
			        this.collectComments();
			        return {
			            index: this.scanner.index,
			            line: this.scanner.lineNumber,
			            column: this.scanner.index - this.scanner.lineStart
			        };
			    };
			    JSXParser.prototype.createJSXChildNode = function () {
			        return {
			            index: this.scanner.index,
			            line: this.scanner.lineNumber,
			            column: this.scanner.index - this.scanner.lineStart
			        };
			    };
			    JSXParser.prototype.scanXHTMLEntity = function (quote) {
			        var result = '&';
			        var valid = true;
			        var terminated = false;
			        var numeric = false;
			        var hex = false;
			        while (!this.scanner.eof() && valid && !terminated) {
			            var ch = this.scanner.source[this.scanner.index];
			            if (ch === quote) {
			                break;
			            }
			            terminated = (ch === ';');
			            result += ch;
			            ++this.scanner.index;
			            if (!terminated) {
			                switch (result.length) {
			                    case 2:
			                        numeric = (ch === '#');
			                        break;
			                    case 3:
			                        if (numeric) {
			                            hex = (ch === 'x');
			                            valid = hex || character_1.Character.isDecimalDigit(ch.charCodeAt(0));
			                            numeric = numeric && !hex;
			                        }
			                        break;
			                    default:
			                        valid = valid && !(numeric && !character_1.Character.isDecimalDigit(ch.charCodeAt(0)));
			                        valid = valid && !(hex && !character_1.Character.isHexDigit(ch.charCodeAt(0)));
			                        break;
			                }
			            }
			        }
			        if (valid && terminated && result.length > 2) {
			            var str = result.substr(1, result.length - 2);
			            if (numeric && str.length > 1) {
			                result = String.fromCharCode(parseInt(str.substr(1), 10));
			            }
			            else if (hex && str.length > 2) {
			                result = String.fromCharCode(parseInt('0' + str.substr(1), 16));
			            }
			            else if (!numeric && !hex && xhtml_entities_1.XHTMLEntities[str]) {
			                result = xhtml_entities_1.XHTMLEntities[str];
			            }
			        }
			        return result;
			    };
			    JSXParser.prototype.lexJSX = function () {
			        var cp = this.scanner.source.charCodeAt(this.scanner.index);
			        if (cp === 60 || cp === 62 || cp === 47 || cp === 58 || cp === 61 || cp === 123 || cp === 125) {
			            var value = this.scanner.source[this.scanner.index++];
			            return {
			                type: 7 ,
			                value: value,
			                lineNumber: this.scanner.lineNumber,
			                lineStart: this.scanner.lineStart,
			                start: this.scanner.index - 1,
			                end: this.scanner.index
			            };
			        }
			        if (cp === 34 || cp === 39) {
			            var start = this.scanner.index;
			            var quote = this.scanner.source[this.scanner.index++];
			            var str = '';
			            while (!this.scanner.eof()) {
			                var ch = this.scanner.source[this.scanner.index++];
			                if (ch === quote) {
			                    break;
			                }
			                else if (ch === '&') {
			                    str += this.scanXHTMLEntity(quote);
			                }
			                else {
			                    str += ch;
			                }
			            }
			            return {
			                type: 8 ,
			                value: str,
			                lineNumber: this.scanner.lineNumber,
			                lineStart: this.scanner.lineStart,
			                start: start,
			                end: this.scanner.index
			            };
			        }
			        if (cp === 46) {
			            var n1 = this.scanner.source.charCodeAt(this.scanner.index + 1);
			            var n2 = this.scanner.source.charCodeAt(this.scanner.index + 2);
			            var value = (n1 === 46 && n2 === 46) ? '...' : '.';
			            var start = this.scanner.index;
			            this.scanner.index += value.length;
			            return {
			                type: 7 ,
			                value: value,
			                lineNumber: this.scanner.lineNumber,
			                lineStart: this.scanner.lineStart,
			                start: start,
			                end: this.scanner.index
			            };
			        }
			        if (cp === 96) {
			            return {
			                type: 10 ,
			                value: '',
			                lineNumber: this.scanner.lineNumber,
			                lineStart: this.scanner.lineStart,
			                start: this.scanner.index,
			                end: this.scanner.index
			            };
			        }
			        if (character_1.Character.isIdentifierStart(cp) && (cp !== 92)) {
			            var start = this.scanner.index;
			            ++this.scanner.index;
			            while (!this.scanner.eof()) {
			                var ch = this.scanner.source.charCodeAt(this.scanner.index);
			                if (character_1.Character.isIdentifierPart(ch) && (ch !== 92)) {
			                    ++this.scanner.index;
			                }
			                else if (ch === 45) {
			                    ++this.scanner.index;
			                }
			                else {
			                    break;
			                }
			            }
			            var id = this.scanner.source.slice(start, this.scanner.index);
			            return {
			                type: 100 ,
			                value: id,
			                lineNumber: this.scanner.lineNumber,
			                lineStart: this.scanner.lineStart,
			                start: start,
			                end: this.scanner.index
			            };
			        }
			        return this.scanner.lex();
			    };
			    JSXParser.prototype.nextJSXToken = function () {
			        this.collectComments();
			        this.startMarker.index = this.scanner.index;
			        this.startMarker.line = this.scanner.lineNumber;
			        this.startMarker.column = this.scanner.index - this.scanner.lineStart;
			        var token = this.lexJSX();
			        this.lastMarker.index = this.scanner.index;
			        this.lastMarker.line = this.scanner.lineNumber;
			        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
			        if (this.config.tokens) {
			            this.tokens.push(this.convertToken(token));
			        }
			        return token;
			    };
			    JSXParser.prototype.nextJSXText = function () {
			        this.startMarker.index = this.scanner.index;
			        this.startMarker.line = this.scanner.lineNumber;
			        this.startMarker.column = this.scanner.index - this.scanner.lineStart;
			        var start = this.scanner.index;
			        var text = '';
			        while (!this.scanner.eof()) {
			            var ch = this.scanner.source[this.scanner.index];
			            if (ch === '{' || ch === '<') {
			                break;
			            }
			            ++this.scanner.index;
			            text += ch;
			            if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
			                ++this.scanner.lineNumber;
			                if (ch === '\r' && this.scanner.source[this.scanner.index] === '\n') {
			                    ++this.scanner.index;
			                }
			                this.scanner.lineStart = this.scanner.index;
			            }
			        }
			        this.lastMarker.index = this.scanner.index;
			        this.lastMarker.line = this.scanner.lineNumber;
			        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
			        var token = {
			            type: 101 ,
			            value: text,
			            lineNumber: this.scanner.lineNumber,
			            lineStart: this.scanner.lineStart,
			            start: start,
			            end: this.scanner.index
			        };
			        if ((text.length > 0) && this.config.tokens) {
			            this.tokens.push(this.convertToken(token));
			        }
			        return token;
			    };
			    JSXParser.prototype.peekJSXToken = function () {
			        var state = this.scanner.saveState();
			        this.scanner.scanComments();
			        var next = this.lexJSX();
			        this.scanner.restoreState(state);
			        return next;
			    };
			    JSXParser.prototype.expectJSX = function (value) {
			        var token = this.nextJSXToken();
			        if (token.type !== 7  || token.value !== value) {
			            this.throwUnexpectedToken(token);
			        }
			    };
			    JSXParser.prototype.matchJSX = function (value) {
			        var next = this.peekJSXToken();
			        return next.type === 7  && next.value === value;
			    };
			    JSXParser.prototype.parseJSXIdentifier = function () {
			        var node = this.createJSXNode();
			        var token = this.nextJSXToken();
			        if (token.type !== 100 ) {
			            this.throwUnexpectedToken(token);
			        }
			        return this.finalize(node, new JSXNode.JSXIdentifier(token.value));
			    };
			    JSXParser.prototype.parseJSXElementName = function () {
			        var node = this.createJSXNode();
			        var elementName = this.parseJSXIdentifier();
			        if (this.matchJSX(':')) {
			            var namespace = elementName;
			            this.expectJSX(':');
			            var name_1 = this.parseJSXIdentifier();
			            elementName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_1));
			        }
			        else if (this.matchJSX('.')) {
			            while (this.matchJSX('.')) {
			                var object = elementName;
			                this.expectJSX('.');
			                var property = this.parseJSXIdentifier();
			                elementName = this.finalize(node, new JSXNode.JSXMemberExpression(object, property));
			            }
			        }
			        return elementName;
			    };
			    JSXParser.prototype.parseJSXAttributeName = function () {
			        var node = this.createJSXNode();
			        var attributeName;
			        var identifier = this.parseJSXIdentifier();
			        if (this.matchJSX(':')) {
			            var namespace = identifier;
			            this.expectJSX(':');
			            var name_2 = this.parseJSXIdentifier();
			            attributeName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_2));
			        }
			        else {
			            attributeName = identifier;
			        }
			        return attributeName;
			    };
			    JSXParser.prototype.parseJSXStringLiteralAttribute = function () {
			        var node = this.createJSXNode();
			        var token = this.nextJSXToken();
			        if (token.type !== 8 ) {
			            this.throwUnexpectedToken(token);
			        }
			        var raw = this.getTokenRaw(token);
			        return this.finalize(node, new Node.Literal(token.value, raw));
			    };
			    JSXParser.prototype.parseJSXExpressionAttribute = function () {
			        var node = this.createJSXNode();
			        this.expectJSX('{');
			        this.finishJSX();
			        if (this.match('}')) {
			            this.tolerateError('JSX attributes must only be assigned a non-empty expression');
			        }
			        var expression = this.parseAssignmentExpression();
			        this.reenterJSX();
			        return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
			    };
			    JSXParser.prototype.parseJSXAttributeValue = function () {
			        return this.matchJSX('{') ? this.parseJSXExpressionAttribute() :
			            this.matchJSX('<') ? this.parseJSXElement() : this.parseJSXStringLiteralAttribute();
			    };
			    JSXParser.prototype.parseJSXNameValueAttribute = function () {
			        var node = this.createJSXNode();
			        var name = this.parseJSXAttributeName();
			        var value = null;
			        if (this.matchJSX('=')) {
			            this.expectJSX('=');
			            value = this.parseJSXAttributeValue();
			        }
			        return this.finalize(node, new JSXNode.JSXAttribute(name, value));
			    };
			    JSXParser.prototype.parseJSXSpreadAttribute = function () {
			        var node = this.createJSXNode();
			        this.expectJSX('{');
			        this.expectJSX('...');
			        this.finishJSX();
			        var argument = this.parseAssignmentExpression();
			        this.reenterJSX();
			        return this.finalize(node, new JSXNode.JSXSpreadAttribute(argument));
			    };
			    JSXParser.prototype.parseJSXAttributes = function () {
			        var attributes = [];
			        while (!this.matchJSX('/') && !this.matchJSX('>')) {
			            var attribute = this.matchJSX('{') ? this.parseJSXSpreadAttribute() :
			                this.parseJSXNameValueAttribute();
			            attributes.push(attribute);
			        }
			        return attributes;
			    };
			    JSXParser.prototype.parseJSXOpeningElement = function () {
			        var node = this.createJSXNode();
			        this.expectJSX('<');
			        var name = this.parseJSXElementName();
			        var attributes = this.parseJSXAttributes();
			        var selfClosing = this.matchJSX('/');
			        if (selfClosing) {
			            this.expectJSX('/');
			        }
			        this.expectJSX('>');
			        return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
			    };
			    JSXParser.prototype.parseJSXBoundaryElement = function () {
			        var node = this.createJSXNode();
			        this.expectJSX('<');
			        if (this.matchJSX('/')) {
			            this.expectJSX('/');
			            var name_3 = this.parseJSXElementName();
			            this.expectJSX('>');
			            return this.finalize(node, new JSXNode.JSXClosingElement(name_3));
			        }
			        var name = this.parseJSXElementName();
			        var attributes = this.parseJSXAttributes();
			        var selfClosing = this.matchJSX('/');
			        if (selfClosing) {
			            this.expectJSX('/');
			        }
			        this.expectJSX('>');
			        return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
			    };
			    JSXParser.prototype.parseJSXEmptyExpression = function () {
			        var node = this.createJSXChildNode();
			        this.collectComments();
			        this.lastMarker.index = this.scanner.index;
			        this.lastMarker.line = this.scanner.lineNumber;
			        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
			        return this.finalize(node, new JSXNode.JSXEmptyExpression());
			    };
			    JSXParser.prototype.parseJSXExpressionContainer = function () {
			        var node = this.createJSXNode();
			        this.expectJSX('{');
			        var expression;
			        if (this.matchJSX('}')) {
			            expression = this.parseJSXEmptyExpression();
			            this.expectJSX('}');
			        }
			        else {
			            this.finishJSX();
			            expression = this.parseAssignmentExpression();
			            this.reenterJSX();
			        }
			        return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
			    };
			    JSXParser.prototype.parseJSXChildren = function () {
			        var children = [];
			        while (!this.scanner.eof()) {
			            var node = this.createJSXChildNode();
			            var token = this.nextJSXText();
			            if (token.start < token.end) {
			                var raw = this.getTokenRaw(token);
			                var child = this.finalize(node, new JSXNode.JSXText(token.value, raw));
			                children.push(child);
			            }
			            if (this.scanner.source[this.scanner.index] === '{') {
			                var container = this.parseJSXExpressionContainer();
			                children.push(container);
			            }
			            else {
			                break;
			            }
			        }
			        return children;
			    };
			    JSXParser.prototype.parseComplexJSXElement = function (el) {
			        var stack = [];
			        while (!this.scanner.eof()) {
			            el.children = el.children.concat(this.parseJSXChildren());
			            var node = this.createJSXChildNode();
			            var element = this.parseJSXBoundaryElement();
			            if (element.type === jsx_syntax_1.JSXSyntax.JSXOpeningElement) {
			                var opening = element;
			                if (opening.selfClosing) {
			                    var child = this.finalize(node, new JSXNode.JSXElement(opening, [], null));
			                    el.children.push(child);
			                }
			                else {
			                    stack.push(el);
			                    el = { node: node, opening: opening, closing: null, children: [] };
			                }
			            }
			            if (element.type === jsx_syntax_1.JSXSyntax.JSXClosingElement) {
			                el.closing = element;
			                var open_1 = getQualifiedElementName(el.opening.name);
			                var close_1 = getQualifiedElementName(el.closing.name);
			                if (open_1 !== close_1) {
			                    this.tolerateError('Expected corresponding JSX closing tag for %0', open_1);
			                }
			                if (stack.length > 0) {
			                    var child = this.finalize(el.node, new JSXNode.JSXElement(el.opening, el.children, el.closing));
			                    el = stack[stack.length - 1];
			                    el.children.push(child);
			                    stack.pop();
			                }
			                else {
			                    break;
			                }
			            }
			        }
			        return el;
			    };
			    JSXParser.prototype.parseJSXElement = function () {
			        var node = this.createJSXNode();
			        var opening = this.parseJSXOpeningElement();
			        var children = [];
			        var closing = null;
			        if (!opening.selfClosing) {
			            var el = this.parseComplexJSXElement({ node: node, opening: opening, closing: closing, children: children });
			            children = el.children;
			            closing = el.closing;
			        }
			        return this.finalize(node, new JSXNode.JSXElement(opening, children, closing));
			    };
			    JSXParser.prototype.parseJSXRoot = function () {
			        if (this.config.tokens) {
			            this.tokens.pop();
			        }
			        this.startJSX();
			        var element = this.parseJSXElement();
			        this.finishJSX();
			        return element;
			    };
			    JSXParser.prototype.isStartOfExpression = function () {
			        return _super.prototype.isStartOfExpression.call(this) || this.match('<');
			    };
			    return JSXParser;
			}(parser_1.Parser));
			exports.JSXParser = JSXParser;
		 },
		 function(module, exports) {
			Object.defineProperty(exports, "__esModule", { value: true });
			var Regex = {
			    NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
			    NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
			};
			exports.Character = {
			    fromCodePoint: function (cp) {
			        return (cp < 0x10000) ? String.fromCharCode(cp) :
			            String.fromCharCode(0xD800 + ((cp - 0x10000) >> 10)) +
			                String.fromCharCode(0xDC00 + ((cp - 0x10000) & 1023));
			    },
			    isWhiteSpace: function (cp) {
			        return (cp === 0x20) || (cp === 0x09) || (cp === 0x0B) || (cp === 0x0C) || (cp === 0xA0) ||
			            (cp >= 0x1680 && [0x1680, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(cp) >= 0);
			    },
			    isLineTerminator: function (cp) {
			        return (cp === 0x0A) || (cp === 0x0D) || (cp === 0x2028) || (cp === 0x2029);
			    },
			    isIdentifierStart: function (cp) {
			        return (cp === 0x24) || (cp === 0x5F) ||
			            (cp >= 0x41 && cp <= 0x5A) ||
			            (cp >= 0x61 && cp <= 0x7A) ||
			            (cp === 0x5C) ||
			            ((cp >= 0x80) && Regex.NonAsciiIdentifierStart.test(exports.Character.fromCodePoint(cp)));
			    },
			    isIdentifierPart: function (cp) {
			        return (cp === 0x24) || (cp === 0x5F) ||
			            (cp >= 0x41 && cp <= 0x5A) ||
			            (cp >= 0x61 && cp <= 0x7A) ||
			            (cp >= 0x30 && cp <= 0x39) ||
			            (cp === 0x5C) ||
			            ((cp >= 0x80) && Regex.NonAsciiIdentifierPart.test(exports.Character.fromCodePoint(cp)));
			    },
			    isDecimalDigit: function (cp) {
			        return (cp >= 0x30 && cp <= 0x39);
			    },
			    isHexDigit: function (cp) {
			        return (cp >= 0x30 && cp <= 0x39) ||
			            (cp >= 0x41 && cp <= 0x46) ||
			            (cp >= 0x61 && cp <= 0x66);
			    },
			    isOctalDigit: function (cp) {
			        return (cp >= 0x30 && cp <= 0x37);
			    }
			};
		 },
		 function(module, exports, __webpack_require__) {
			Object.defineProperty(exports, "__esModule", { value: true });
			var jsx_syntax_1 = __webpack_require__(6);
			var JSXClosingElement = (function () {
			    function JSXClosingElement(name) {
			        this.type = jsx_syntax_1.JSXSyntax.JSXClosingElement;
			        this.name = name;
			    }
			    return JSXClosingElement;
			}());
			exports.JSXClosingElement = JSXClosingElement;
			var JSXElement = (function () {
			    function JSXElement(openingElement, children, closingElement) {
			        this.type = jsx_syntax_1.JSXSyntax.JSXElement;
			        this.openingElement = openingElement;
			        this.children = children;
			        this.closingElement = closingElement;
			    }
			    return JSXElement;
			}());
			exports.JSXElement = JSXElement;
			var JSXEmptyExpression = (function () {
			    function JSXEmptyExpression() {
			        this.type = jsx_syntax_1.JSXSyntax.JSXEmptyExpression;
			    }
			    return JSXEmptyExpression;
			}());
			exports.JSXEmptyExpression = JSXEmptyExpression;
			var JSXExpressionContainer = (function () {
			    function JSXExpressionContainer(expression) {
			        this.type = jsx_syntax_1.JSXSyntax.JSXExpressionContainer;
			        this.expression = expression;
			    }
			    return JSXExpressionContainer;
			}());
			exports.JSXExpressionContainer = JSXExpressionContainer;
			var JSXIdentifier = (function () {
			    function JSXIdentifier(name) {
			        this.type = jsx_syntax_1.JSXSyntax.JSXIdentifier;
			        this.name = name;
			    }
			    return JSXIdentifier;
			}());
			exports.JSXIdentifier = JSXIdentifier;
			var JSXMemberExpression = (function () {
			    function JSXMemberExpression(object, property) {
			        this.type = jsx_syntax_1.JSXSyntax.JSXMemberExpression;
			        this.object = object;
			        this.property = property;
			    }
			    return JSXMemberExpression;
			}());
			exports.JSXMemberExpression = JSXMemberExpression;
			var JSXAttribute = (function () {
			    function JSXAttribute(name, value) {
			        this.type = jsx_syntax_1.JSXSyntax.JSXAttribute;
			        this.name = name;
			        this.value = value;
			    }
			    return JSXAttribute;
			}());
			exports.JSXAttribute = JSXAttribute;
			var JSXNamespacedName = (function () {
			    function JSXNamespacedName(namespace, name) {
			        this.type = jsx_syntax_1.JSXSyntax.JSXNamespacedName;
			        this.namespace = namespace;
			        this.name = name;
			    }
			    return JSXNamespacedName;
			}());
			exports.JSXNamespacedName = JSXNamespacedName;
			var JSXOpeningElement = (function () {
			    function JSXOpeningElement(name, selfClosing, attributes) {
			        this.type = jsx_syntax_1.JSXSyntax.JSXOpeningElement;
			        this.name = name;
			        this.selfClosing = selfClosing;
			        this.attributes = attributes;
			    }
			    return JSXOpeningElement;
			}());
			exports.JSXOpeningElement = JSXOpeningElement;
			var JSXSpreadAttribute = (function () {
			    function JSXSpreadAttribute(argument) {
			        this.type = jsx_syntax_1.JSXSyntax.JSXSpreadAttribute;
			        this.argument = argument;
			    }
			    return JSXSpreadAttribute;
			}());
			exports.JSXSpreadAttribute = JSXSpreadAttribute;
			var JSXText = (function () {
			    function JSXText(value, raw) {
			        this.type = jsx_syntax_1.JSXSyntax.JSXText;
			        this.value = value;
			        this.raw = raw;
			    }
			    return JSXText;
			}());
			exports.JSXText = JSXText;
		 },
		 function(module, exports) {
			Object.defineProperty(exports, "__esModule", { value: true });
			exports.JSXSyntax = {
			    JSXAttribute: 'JSXAttribute',
			    JSXClosingElement: 'JSXClosingElement',
			    JSXElement: 'JSXElement',
			    JSXEmptyExpression: 'JSXEmptyExpression',
			    JSXExpressionContainer: 'JSXExpressionContainer',
			    JSXIdentifier: 'JSXIdentifier',
			    JSXMemberExpression: 'JSXMemberExpression',
			    JSXNamespacedName: 'JSXNamespacedName',
			    JSXOpeningElement: 'JSXOpeningElement',
			    JSXSpreadAttribute: 'JSXSpreadAttribute',
			    JSXText: 'JSXText'
			};
		 },
		 function(module, exports, __webpack_require__) {
			Object.defineProperty(exports, "__esModule", { value: true });
			var syntax_1 = __webpack_require__(2);
			var ArrayExpression = (function () {
			    function ArrayExpression(elements) {
			        this.type = syntax_1.Syntax.ArrayExpression;
			        this.elements = elements;
			    }
			    return ArrayExpression;
			}());
			exports.ArrayExpression = ArrayExpression;
			var ArrayPattern = (function () {
			    function ArrayPattern(elements) {
			        this.type = syntax_1.Syntax.ArrayPattern;
			        this.elements = elements;
			    }
			    return ArrayPattern;
			}());
			exports.ArrayPattern = ArrayPattern;
			var ArrowFunctionExpression = (function () {
			    function ArrowFunctionExpression(params, body, expression) {
			        this.type = syntax_1.Syntax.ArrowFunctionExpression;
			        this.id = null;
			        this.params = params;
			        this.body = body;
			        this.generator = false;
			        this.expression = expression;
			        this.async = false;
			    }
			    return ArrowFunctionExpression;
			}());
			exports.ArrowFunctionExpression = ArrowFunctionExpression;
			var AssignmentExpression = (function () {
			    function AssignmentExpression(operator, left, right) {
			        this.type = syntax_1.Syntax.AssignmentExpression;
			        this.operator = operator;
			        this.left = left;
			        this.right = right;
			    }
			    return AssignmentExpression;
			}());
			exports.AssignmentExpression = AssignmentExpression;
			var AssignmentPattern = (function () {
			    function AssignmentPattern(left, right) {
			        this.type = syntax_1.Syntax.AssignmentPattern;
			        this.left = left;
			        this.right = right;
			    }
			    return AssignmentPattern;
			}());
			exports.AssignmentPattern = AssignmentPattern;
			var AsyncArrowFunctionExpression = (function () {
			    function AsyncArrowFunctionExpression(params, body, expression) {
			        this.type = syntax_1.Syntax.ArrowFunctionExpression;
			        this.id = null;
			        this.params = params;
			        this.body = body;
			        this.generator = false;
			        this.expression = expression;
			        this.async = true;
			    }
			    return AsyncArrowFunctionExpression;
			}());
			exports.AsyncArrowFunctionExpression = AsyncArrowFunctionExpression;
			var AsyncFunctionDeclaration = (function () {
			    function AsyncFunctionDeclaration(id, params, body) {
			        this.type = syntax_1.Syntax.FunctionDeclaration;
			        this.id = id;
			        this.params = params;
			        this.body = body;
			        this.generator = false;
			        this.expression = false;
			        this.async = true;
			    }
			    return AsyncFunctionDeclaration;
			}());
			exports.AsyncFunctionDeclaration = AsyncFunctionDeclaration;
			var AsyncFunctionExpression = (function () {
			    function AsyncFunctionExpression(id, params, body) {
			        this.type = syntax_1.Syntax.FunctionExpression;
			        this.id = id;
			        this.params = params;
			        this.body = body;
			        this.generator = false;
			        this.expression = false;
			        this.async = true;
			    }
			    return AsyncFunctionExpression;
			}());
			exports.AsyncFunctionExpression = AsyncFunctionExpression;
			var AwaitExpression = (function () {
			    function AwaitExpression(argument) {
			        this.type = syntax_1.Syntax.AwaitExpression;
			        this.argument = argument;
			    }
			    return AwaitExpression;
			}());
			exports.AwaitExpression = AwaitExpression;
			var BinaryExpression = (function () {
			    function BinaryExpression(operator, left, right) {
			        var logical = (operator === '||' || operator === '&&');
			        this.type = logical ? syntax_1.Syntax.LogicalExpression : syntax_1.Syntax.BinaryExpression;
			        this.operator = operator;
			        this.left = left;
			        this.right = right;
			    }
			    return BinaryExpression;
			}());
			exports.BinaryExpression = BinaryExpression;
			var BlockStatement = (function () {
			    function BlockStatement(body) {
			        this.type = syntax_1.Syntax.BlockStatement;
			        this.body = body;
			    }
			    return BlockStatement;
			}());
			exports.BlockStatement = BlockStatement;
			var BreakStatement = (function () {
			    function BreakStatement(label) {
			        this.type = syntax_1.Syntax.BreakStatement;
			        this.label = label;
			    }
			    return BreakStatement;
			}());
			exports.BreakStatement = BreakStatement;
			var CallExpression = (function () {
			    function CallExpression(callee, args) {
			        this.type = syntax_1.Syntax.CallExpression;
			        this.callee = callee;
			        this.arguments = args;
			    }
			    return CallExpression;
			}());
			exports.CallExpression = CallExpression;
			var CatchClause = (function () {
			    function CatchClause(param, body) {
			        this.type = syntax_1.Syntax.CatchClause;
			        this.param = param;
			        this.body = body;
			    }
			    return CatchClause;
			}());
			exports.CatchClause = CatchClause;
			var ClassBody = (function () {
			    function ClassBody(body) {
			        this.type = syntax_1.Syntax.ClassBody;
			        this.body = body;
			    }
			    return ClassBody;
			}());
			exports.ClassBody = ClassBody;
			var ClassDeclaration = (function () {
			    function ClassDeclaration(id, superClass, body) {
			        this.type = syntax_1.Syntax.ClassDeclaration;
			        this.id = id;
			        this.superClass = superClass;
			        this.body = body;
			    }
			    return ClassDeclaration;
			}());
			exports.ClassDeclaration = ClassDeclaration;
			var ClassExpression = (function () {
			    function ClassExpression(id, superClass, body) {
			        this.type = syntax_1.Syntax.ClassExpression;
			        this.id = id;
			        this.superClass = superClass;
			        this.body = body;
			    }
			    return ClassExpression;
			}());
			exports.ClassExpression = ClassExpression;
			var ComputedMemberExpression = (function () {
			    function ComputedMemberExpression(object, property) {
			        this.type = syntax_1.Syntax.MemberExpression;
			        this.computed = true;
			        this.object = object;
			        this.property = property;
			    }
			    return ComputedMemberExpression;
			}());
			exports.ComputedMemberExpression = ComputedMemberExpression;
			var ConditionalExpression = (function () {
			    function ConditionalExpression(test, consequent, alternate) {
			        this.type = syntax_1.Syntax.ConditionalExpression;
			        this.test = test;
			        this.consequent = consequent;
			        this.alternate = alternate;
			    }
			    return ConditionalExpression;
			}());
			exports.ConditionalExpression = ConditionalExpression;
			var ContinueStatement = (function () {
			    function ContinueStatement(label) {
			        this.type = syntax_1.Syntax.ContinueStatement;
			        this.label = label;
			    }
			    return ContinueStatement;
			}());
			exports.ContinueStatement = ContinueStatement;
			var DebuggerStatement = (function () {
			    function DebuggerStatement() {
			        this.type = syntax_1.Syntax.DebuggerStatement;
			    }
			    return DebuggerStatement;
			}());
			exports.DebuggerStatement = DebuggerStatement;
			var Directive = (function () {
			    function Directive(expression, directive) {
			        this.type = syntax_1.Syntax.ExpressionStatement;
			        this.expression = expression;
			        this.directive = directive;
			    }
			    return Directive;
			}());
			exports.Directive = Directive;
			var DoWhileStatement = (function () {
			    function DoWhileStatement(body, test) {
			        this.type = syntax_1.Syntax.DoWhileStatement;
			        this.body = body;
			        this.test = test;
			    }
			    return DoWhileStatement;
			}());
			exports.DoWhileStatement = DoWhileStatement;
			var EmptyStatement = (function () {
			    function EmptyStatement() {
			        this.type = syntax_1.Syntax.EmptyStatement;
			    }
			    return EmptyStatement;
			}());
			exports.EmptyStatement = EmptyStatement;
			var ExportAllDeclaration = (function () {
			    function ExportAllDeclaration(source) {
			        this.type = syntax_1.Syntax.ExportAllDeclaration;
			        this.source = source;
			    }
			    return ExportAllDeclaration;
			}());
			exports.ExportAllDeclaration = ExportAllDeclaration;
			var ExportDefaultDeclaration = (function () {
			    function ExportDefaultDeclaration(declaration) {
			        this.type = syntax_1.Syntax.ExportDefaultDeclaration;
			        this.declaration = declaration;
			    }
			    return ExportDefaultDeclaration;
			}());
			exports.ExportDefaultDeclaration = ExportDefaultDeclaration;
			var ExportNamedDeclaration = (function () {
			    function ExportNamedDeclaration(declaration, specifiers, source) {
			        this.type = syntax_1.Syntax.ExportNamedDeclaration;
			        this.declaration = declaration;
			        this.specifiers = specifiers;
			        this.source = source;
			    }
			    return ExportNamedDeclaration;
			}());
			exports.ExportNamedDeclaration = ExportNamedDeclaration;
			var ExportSpecifier = (function () {
			    function ExportSpecifier(local, exported) {
			        this.type = syntax_1.Syntax.ExportSpecifier;
			        this.exported = exported;
			        this.local = local;
			    }
			    return ExportSpecifier;
			}());
			exports.ExportSpecifier = ExportSpecifier;
			var ExpressionStatement = (function () {
			    function ExpressionStatement(expression) {
			        this.type = syntax_1.Syntax.ExpressionStatement;
			        this.expression = expression;
			    }
			    return ExpressionStatement;
			}());
			exports.ExpressionStatement = ExpressionStatement;
			var ForInStatement = (function () {
			    function ForInStatement(left, right, body) {
			        this.type = syntax_1.Syntax.ForInStatement;
			        this.left = left;
			        this.right = right;
			        this.body = body;
			        this.each = false;
			    }
			    return ForInStatement;
			}());
			exports.ForInStatement = ForInStatement;
			var ForOfStatement = (function () {
			    function ForOfStatement(left, right, body) {
			        this.type = syntax_1.Syntax.ForOfStatement;
			        this.left = left;
			        this.right = right;
			        this.body = body;
			    }
			    return ForOfStatement;
			}());
			exports.ForOfStatement = ForOfStatement;
			var ForStatement = (function () {
			    function ForStatement(init, test, update, body) {
			        this.type = syntax_1.Syntax.ForStatement;
			        this.init = init;
			        this.test = test;
			        this.update = update;
			        this.body = body;
			    }
			    return ForStatement;
			}());
			exports.ForStatement = ForStatement;
			var FunctionDeclaration = (function () {
			    function FunctionDeclaration(id, params, body, generator) {
			        this.type = syntax_1.Syntax.FunctionDeclaration;
			        this.id = id;
			        this.params = params;
			        this.body = body;
			        this.generator = generator;
			        this.expression = false;
			        this.async = false;
			    }
			    return FunctionDeclaration;
			}());
			exports.FunctionDeclaration = FunctionDeclaration;
			var FunctionExpression = (function () {
			    function FunctionExpression(id, params, body, generator) {
			        this.type = syntax_1.Syntax.FunctionExpression;
			        this.id = id;
			        this.params = params;
			        this.body = body;
			        this.generator = generator;
			        this.expression = false;
			        this.async = false;
			    }
			    return FunctionExpression;
			}());
			exports.FunctionExpression = FunctionExpression;
			var Identifier = (function () {
			    function Identifier(name) {
			        this.type = syntax_1.Syntax.Identifier;
			        this.name = name;
			    }
			    return Identifier;
			}());
			exports.Identifier = Identifier;
			var IfStatement = (function () {
			    function IfStatement(test, consequent, alternate) {
			        this.type = syntax_1.Syntax.IfStatement;
			        this.test = test;
			        this.consequent = consequent;
			        this.alternate = alternate;
			    }
			    return IfStatement;
			}());
			exports.IfStatement = IfStatement;
			var ImportDeclaration = (function () {
			    function ImportDeclaration(specifiers, source) {
			        this.type = syntax_1.Syntax.ImportDeclaration;
			        this.specifiers = specifiers;
			        this.source = source;
			    }
			    return ImportDeclaration;
			}());
			exports.ImportDeclaration = ImportDeclaration;
			var ImportDefaultSpecifier = (function () {
			    function ImportDefaultSpecifier(local) {
			        this.type = syntax_1.Syntax.ImportDefaultSpecifier;
			        this.local = local;
			    }
			    return ImportDefaultSpecifier;
			}());
			exports.ImportDefaultSpecifier = ImportDefaultSpecifier;
			var ImportNamespaceSpecifier = (function () {
			    function ImportNamespaceSpecifier(local) {
			        this.type = syntax_1.Syntax.ImportNamespaceSpecifier;
			        this.local = local;
			    }
			    return ImportNamespaceSpecifier;
			}());
			exports.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
			var ImportSpecifier = (function () {
			    function ImportSpecifier(local, imported) {
			        this.type = syntax_1.Syntax.ImportSpecifier;
			        this.local = local;
			        this.imported = imported;
			    }
			    return ImportSpecifier;
			}());
			exports.ImportSpecifier = ImportSpecifier;
			var LabeledStatement = (function () {
			    function LabeledStatement(label, body) {
			        this.type = syntax_1.Syntax.LabeledStatement;
			        this.label = label;
			        this.body = body;
			    }
			    return LabeledStatement;
			}());
			exports.LabeledStatement = LabeledStatement;
			var Literal = (function () {
			    function Literal(value, raw) {
			        this.type = syntax_1.Syntax.Literal;
			        this.value = value;
			        this.raw = raw;
			    }
			    return Literal;
			}());
			exports.Literal = Literal;
			var MetaProperty = (function () {
			    function MetaProperty(meta, property) {
			        this.type = syntax_1.Syntax.MetaProperty;
			        this.meta = meta;
			        this.property = property;
			    }
			    return MetaProperty;
			}());
			exports.MetaProperty = MetaProperty;
			var MethodDefinition = (function () {
			    function MethodDefinition(key, computed, value, kind, isStatic) {
			        this.type = syntax_1.Syntax.MethodDefinition;
			        this.key = key;
			        this.computed = computed;
			        this.value = value;
			        this.kind = kind;
			        this.static = isStatic;
			    }
			    return MethodDefinition;
			}());
			exports.MethodDefinition = MethodDefinition;
			var Module = (function () {
			    function Module(body) {
			        this.type = syntax_1.Syntax.Program;
			        this.body = body;
			        this.sourceType = 'module';
			    }
			    return Module;
			}());
			exports.Module = Module;
			var NewExpression = (function () {
			    function NewExpression(callee, args) {
			        this.type = syntax_1.Syntax.NewExpression;
			        this.callee = callee;
			        this.arguments = args;
			    }
			    return NewExpression;
			}());
			exports.NewExpression = NewExpression;
			var ObjectExpression = (function () {
			    function ObjectExpression(properties) {
			        this.type = syntax_1.Syntax.ObjectExpression;
			        this.properties = properties;
			    }
			    return ObjectExpression;
			}());
			exports.ObjectExpression = ObjectExpression;
			var ObjectPattern = (function () {
			    function ObjectPattern(properties) {
			        this.type = syntax_1.Syntax.ObjectPattern;
			        this.properties = properties;
			    }
			    return ObjectPattern;
			}());
			exports.ObjectPattern = ObjectPattern;
			var Property = (function () {
			    function Property(kind, key, computed, value, method, shorthand) {
			        this.type = syntax_1.Syntax.Property;
			        this.key = key;
			        this.computed = computed;
			        this.value = value;
			        this.kind = kind;
			        this.method = method;
			        this.shorthand = shorthand;
			    }
			    return Property;
			}());
			exports.Property = Property;
			var RegexLiteral = (function () {
			    function RegexLiteral(value, raw, pattern, flags) {
			        this.type = syntax_1.Syntax.Literal;
			        this.value = value;
			        this.raw = raw;
			        this.regex = { pattern: pattern, flags: flags };
			    }
			    return RegexLiteral;
			}());
			exports.RegexLiteral = RegexLiteral;
			var RestElement = (function () {
			    function RestElement(argument) {
			        this.type = syntax_1.Syntax.RestElement;
			        this.argument = argument;
			    }
			    return RestElement;
			}());
			exports.RestElement = RestElement;
			var ReturnStatement = (function () {
			    function ReturnStatement(argument) {
			        this.type = syntax_1.Syntax.ReturnStatement;
			        this.argument = argument;
			    }
			    return ReturnStatement;
			}());
			exports.ReturnStatement = ReturnStatement;
			var Script = (function () {
			    function Script(body) {
			        this.type = syntax_1.Syntax.Program;
			        this.body = body;
			        this.sourceType = 'script';
			    }
			    return Script;
			}());
			exports.Script = Script;
			var SequenceExpression = (function () {
			    function SequenceExpression(expressions) {
			        this.type = syntax_1.Syntax.SequenceExpression;
			        this.expressions = expressions;
			    }
			    return SequenceExpression;
			}());
			exports.SequenceExpression = SequenceExpression;
			var SpreadElement = (function () {
			    function SpreadElement(argument) {
			        this.type = syntax_1.Syntax.SpreadElement;
			        this.argument = argument;
			    }
			    return SpreadElement;
			}());
			exports.SpreadElement = SpreadElement;
			var StaticMemberExpression = (function () {
			    function StaticMemberExpression(object, property) {
			        this.type = syntax_1.Syntax.MemberExpression;
			        this.computed = false;
			        this.object = object;
			        this.property = property;
			    }
			    return StaticMemberExpression;
			}());
			exports.StaticMemberExpression = StaticMemberExpression;
			var Super = (function () {
			    function Super() {
			        this.type = syntax_1.Syntax.Super;
			    }
			    return Super;
			}());
			exports.Super = Super;
			var SwitchCase = (function () {
			    function SwitchCase(test, consequent) {
			        this.type = syntax_1.Syntax.SwitchCase;
			        this.test = test;
			        this.consequent = consequent;
			    }
			    return SwitchCase;
			}());
			exports.SwitchCase = SwitchCase;
			var SwitchStatement = (function () {
			    function SwitchStatement(discriminant, cases) {
			        this.type = syntax_1.Syntax.SwitchStatement;
			        this.discriminant = discriminant;
			        this.cases = cases;
			    }
			    return SwitchStatement;
			}());
			exports.SwitchStatement = SwitchStatement;
			var TaggedTemplateExpression = (function () {
			    function TaggedTemplateExpression(tag, quasi) {
			        this.type = syntax_1.Syntax.TaggedTemplateExpression;
			        this.tag = tag;
			        this.quasi = quasi;
			    }
			    return TaggedTemplateExpression;
			}());
			exports.TaggedTemplateExpression = TaggedTemplateExpression;
			var TemplateElement = (function () {
			    function TemplateElement(value, tail) {
			        this.type = syntax_1.Syntax.TemplateElement;
			        this.value = value;
			        this.tail = tail;
			    }
			    return TemplateElement;
			}());
			exports.TemplateElement = TemplateElement;
			var TemplateLiteral = (function () {
			    function TemplateLiteral(quasis, expressions) {
			        this.type = syntax_1.Syntax.TemplateLiteral;
			        this.quasis = quasis;
			        this.expressions = expressions;
			    }
			    return TemplateLiteral;
			}());
			exports.TemplateLiteral = TemplateLiteral;
			var ThisExpression = (function () {
			    function ThisExpression() {
			        this.type = syntax_1.Syntax.ThisExpression;
			    }
			    return ThisExpression;
			}());
			exports.ThisExpression = ThisExpression;
			var ThrowStatement = (function () {
			    function ThrowStatement(argument) {
			        this.type = syntax_1.Syntax.ThrowStatement;
			        this.argument = argument;
			    }
			    return ThrowStatement;
			}());
			exports.ThrowStatement = ThrowStatement;
			var TryStatement = (function () {
			    function TryStatement(block, handler, finalizer) {
			        this.type = syntax_1.Syntax.TryStatement;
			        this.block = block;
			        this.handler = handler;
			        this.finalizer = finalizer;
			    }
			    return TryStatement;
			}());
			exports.TryStatement = TryStatement;
			var UnaryExpression = (function () {
			    function UnaryExpression(operator, argument) {
			        this.type = syntax_1.Syntax.UnaryExpression;
			        this.operator = operator;
			        this.argument = argument;
			        this.prefix = true;
			    }
			    return UnaryExpression;
			}());
			exports.UnaryExpression = UnaryExpression;
			var UpdateExpression = (function () {
			    function UpdateExpression(operator, argument, prefix) {
			        this.type = syntax_1.Syntax.UpdateExpression;
			        this.operator = operator;
			        this.argument = argument;
			        this.prefix = prefix;
			    }
			    return UpdateExpression;
			}());
			exports.UpdateExpression = UpdateExpression;
			var VariableDeclaration = (function () {
			    function VariableDeclaration(declarations, kind) {
			        this.type = syntax_1.Syntax.VariableDeclaration;
			        this.declarations = declarations;
			        this.kind = kind;
			    }
			    return VariableDeclaration;
			}());
			exports.VariableDeclaration = VariableDeclaration;
			var VariableDeclarator = (function () {
			    function VariableDeclarator(id, init) {
			        this.type = syntax_1.Syntax.VariableDeclarator;
			        this.id = id;
			        this.init = init;
			    }
			    return VariableDeclarator;
			}());
			exports.VariableDeclarator = VariableDeclarator;
			var WhileStatement = (function () {
			    function WhileStatement(test, body) {
			        this.type = syntax_1.Syntax.WhileStatement;
			        this.test = test;
			        this.body = body;
			    }
			    return WhileStatement;
			}());
			exports.WhileStatement = WhileStatement;
			var WithStatement = (function () {
			    function WithStatement(object, body) {
			        this.type = syntax_1.Syntax.WithStatement;
			        this.object = object;
			        this.body = body;
			    }
			    return WithStatement;
			}());
			exports.WithStatement = WithStatement;
			var YieldExpression = (function () {
			    function YieldExpression(argument, delegate) {
			        this.type = syntax_1.Syntax.YieldExpression;
			        this.argument = argument;
			        this.delegate = delegate;
			    }
			    return YieldExpression;
			}());
			exports.YieldExpression = YieldExpression;
		 },
		 function(module, exports, __webpack_require__) {
			Object.defineProperty(exports, "__esModule", { value: true });
			var assert_1 = __webpack_require__(9);
			var error_handler_1 = __webpack_require__(10);
			var messages_1 = __webpack_require__(11);
			var Node = __webpack_require__(7);
			var scanner_1 = __webpack_require__(12);
			var syntax_1 = __webpack_require__(2);
			var token_1 = __webpack_require__(13);
			var ArrowParameterPlaceHolder = 'ArrowParameterPlaceHolder';
			var Parser = (function () {
			    function Parser(code, options, delegate) {
			        if (options === void 0) { options = {}; }
			        this.config = {
			            range: (typeof options.range === 'boolean') && options.range,
			            loc: (typeof options.loc === 'boolean') && options.loc,
			            source: null,
			            tokens: (typeof options.tokens === 'boolean') && options.tokens,
			            comment: (typeof options.comment === 'boolean') && options.comment,
			            tolerant: (typeof options.tolerant === 'boolean') && options.tolerant
			        };
			        if (this.config.loc && options.source && options.source !== null) {
			            this.config.source = String(options.source);
			        }
			        this.delegate = delegate;
			        this.errorHandler = new error_handler_1.ErrorHandler();
			        this.errorHandler.tolerant = this.config.tolerant;
			        this.scanner = new scanner_1.Scanner(code, this.errorHandler);
			        this.scanner.trackComment = this.config.comment;
			        this.operatorPrecedence = {
			            ')': 0,
			            ';': 0,
			            ',': 0,
			            '=': 0,
			            ']': 0,
			            '||': 1,
			            '&&': 2,
			            '|': 3,
			            '^': 4,
			            '&': 5,
			            '==': 6,
			            '!=': 6,
			            '===': 6,
			            '!==': 6,
			            '<': 7,
			            '>': 7,
			            '<=': 7,
			            '>=': 7,
			            '<<': 8,
			            '>>': 8,
			            '>>>': 8,
			            '+': 9,
			            '-': 9,
			            '*': 11,
			            '/': 11,
			            '%': 11
			        };
			        this.lookahead = {
			            type: 2 ,
			            value: '',
			            lineNumber: this.scanner.lineNumber,
			            lineStart: 0,
			            start: 0,
			            end: 0
			        };
			        this.hasLineTerminator = false;
			        this.context = {
			            isModule: false,
			            await: false,
			            allowIn: true,
			            allowStrictDirective: true,
			            allowYield: true,
			            firstCoverInitializedNameError: null,
			            isAssignmentTarget: false,
			            isBindingElement: false,
			            inFunctionBody: false,
			            inIteration: false,
			            inSwitch: false,
			            labelSet: {},
			            strict: false
			        };
			        this.tokens = [];
			        this.startMarker = {
			            index: 0,
			            line: this.scanner.lineNumber,
			            column: 0
			        };
			        this.lastMarker = {
			            index: 0,
			            line: this.scanner.lineNumber,
			            column: 0
			        };
			        this.nextToken();
			        this.lastMarker = {
			            index: this.scanner.index,
			            line: this.scanner.lineNumber,
			            column: this.scanner.index - this.scanner.lineStart
			        };
			    }
			    Parser.prototype.throwError = function (messageFormat) {
			        var args = Array.prototype.slice.call(arguments, 1);
			        var msg = messageFormat.replace(/%(\d)/g, function (whole, idx) {
			            assert_1.assert(idx < args.length, 'Message reference must be in range');
			            return args[idx];
			        });
			        var index = this.lastMarker.index;
			        var line = this.lastMarker.line;
			        var column = this.lastMarker.column + 1;
			        throw this.errorHandler.createError(index, line, column, msg);
			    };
			    Parser.prototype.tolerateError = function (messageFormat) {
			        var args = Array.prototype.slice.call(arguments, 1);
			        var msg = messageFormat.replace(/%(\d)/g, function (whole, idx) {
			            assert_1.assert(idx < args.length, 'Message reference must be in range');
			            return args[idx];
			        });
			        var index = this.lastMarker.index;
			        var line = this.scanner.lineNumber;
			        var column = this.lastMarker.column + 1;
			        this.errorHandler.tolerateError(index, line, column, msg);
			    };
			    Parser.prototype.unexpectedTokenError = function (token, message) {
			        var msg = message || messages_1.Messages.UnexpectedToken;
			        var value;
			        if (token) {
			            if (!message) {
			                msg = (token.type === 2 ) ? messages_1.Messages.UnexpectedEOS :
			                    (token.type === 3 ) ? messages_1.Messages.UnexpectedIdentifier :
			                        (token.type === 6 ) ? messages_1.Messages.UnexpectedNumber :
			                            (token.type === 8 ) ? messages_1.Messages.UnexpectedString :
			                                (token.type === 10 ) ? messages_1.Messages.UnexpectedTemplate :
			                                    messages_1.Messages.UnexpectedToken;
			                if (token.type === 4 ) {
			                    if (this.scanner.isFutureReservedWord(token.value)) {
			                        msg = messages_1.Messages.UnexpectedReserved;
			                    }
			                    else if (this.context.strict && this.scanner.isStrictModeReservedWord(token.value)) {
			                        msg = messages_1.Messages.StrictReservedWord;
			                    }
			                }
			            }
			            value = token.value;
			        }
			        else {
			            value = 'ILLEGAL';
			        }
			        msg = msg.replace('%0', value);
			        if (token && typeof token.lineNumber === 'number') {
			            var index = token.start;
			            var line = token.lineNumber;
			            var lastMarkerLineStart = this.lastMarker.index - this.lastMarker.column;
			            var column = token.start - lastMarkerLineStart + 1;
			            return this.errorHandler.createError(index, line, column, msg);
			        }
			        else {
			            var index = this.lastMarker.index;
			            var line = this.lastMarker.line;
			            var column = this.lastMarker.column + 1;
			            return this.errorHandler.createError(index, line, column, msg);
			        }
			    };
			    Parser.prototype.throwUnexpectedToken = function (token, message) {
			        throw this.unexpectedTokenError(token, message);
			    };
			    Parser.prototype.tolerateUnexpectedToken = function (token, message) {
			        this.errorHandler.tolerate(this.unexpectedTokenError(token, message));
			    };
			    Parser.prototype.collectComments = function () {
			        if (!this.config.comment) {
			            this.scanner.scanComments();
			        }
			        else {
			            var comments = this.scanner.scanComments();
			            if (comments.length > 0 && this.delegate) {
			                for (var i = 0; i < comments.length; ++i) {
			                    var e = comments[i];
			                    var node = void 0;
			                    node = {
			                        type: e.multiLine ? 'BlockComment' : 'LineComment',
			                        value: this.scanner.source.slice(e.slice[0], e.slice[1])
			                    };
			                    if (this.config.range) {
			                        node.range = e.range;
			                    }
			                    if (this.config.loc) {
			                        node.loc = e.loc;
			                    }
			                    var metadata = {
			                        start: {
			                            line: e.loc.start.line,
			                            column: e.loc.start.column,
			                            offset: e.range[0]
			                        },
			                        end: {
			                            line: e.loc.end.line,
			                            column: e.loc.end.column,
			                            offset: e.range[1]
			                        }
			                    };
			                    this.delegate(node, metadata);
			                }
			            }
			        }
			    };
			    Parser.prototype.getTokenRaw = function (token) {
			        return this.scanner.source.slice(token.start, token.end);
			    };
			    Parser.prototype.convertToken = function (token) {
			        var t = {
			            type: token_1.TokenName[token.type],
			            value: this.getTokenRaw(token)
			        };
			        if (this.config.range) {
			            t.range = [token.start, token.end];
			        }
			        if (this.config.loc) {
			            t.loc = {
			                start: {
			                    line: this.startMarker.line,
			                    column: this.startMarker.column
			                },
			                end: {
			                    line: this.scanner.lineNumber,
			                    column: this.scanner.index - this.scanner.lineStart
			                }
			            };
			        }
			        if (token.type === 9 ) {
			            var pattern = token.pattern;
			            var flags = token.flags;
			            t.regex = { pattern: pattern, flags: flags };
			        }
			        return t;
			    };
			    Parser.prototype.nextToken = function () {
			        var token = this.lookahead;
			        this.lastMarker.index = this.scanner.index;
			        this.lastMarker.line = this.scanner.lineNumber;
			        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
			        this.collectComments();
			        if (this.scanner.index !== this.startMarker.index) {
			            this.startMarker.index = this.scanner.index;
			            this.startMarker.line = this.scanner.lineNumber;
			            this.startMarker.column = this.scanner.index - this.scanner.lineStart;
			        }
			        var next = this.scanner.lex();
			        this.hasLineTerminator = (token.lineNumber !== next.lineNumber);
			        if (next && this.context.strict && next.type === 3 ) {
			            if (this.scanner.isStrictModeReservedWord(next.value)) {
			                next.type = 4 ;
			            }
			        }
			        this.lookahead = next;
			        if (this.config.tokens && next.type !== 2 ) {
			            this.tokens.push(this.convertToken(next));
			        }
			        return token;
			    };
			    Parser.prototype.nextRegexToken = function () {
			        this.collectComments();
			        var token = this.scanner.scanRegExp();
			        if (this.config.tokens) {
			            this.tokens.pop();
			            this.tokens.push(this.convertToken(token));
			        }
			        this.lookahead = token;
			        this.nextToken();
			        return token;
			    };
			    Parser.prototype.createNode = function () {
			        return {
			            index: this.startMarker.index,
			            line: this.startMarker.line,
			            column: this.startMarker.column
			        };
			    };
			    Parser.prototype.startNode = function (token, lastLineStart) {
			        if (lastLineStart === void 0) { lastLineStart = 0; }
			        var column = token.start - token.lineStart;
			        var line = token.lineNumber;
			        if (column < 0) {
			            column += lastLineStart;
			            line--;
			        }
			        return {
			            index: token.start,
			            line: line,
			            column: column
			        };
			    };
			    Parser.prototype.finalize = function (marker, node) {
			        if (this.config.range) {
			            node.range = [marker.index, this.lastMarker.index];
			        }
			        if (this.config.loc) {
			            node.loc = {
			                start: {
			                    line: marker.line,
			                    column: marker.column,
			                },
			                end: {
			                    line: this.lastMarker.line,
			                    column: this.lastMarker.column
			                }
			            };
			            if (this.config.source) {
			                node.loc.source = this.config.source;
			            }
			        }
			        if (this.delegate) {
			            var metadata = {
			                start: {
			                    line: marker.line,
			                    column: marker.column,
			                    offset: marker.index
			                },
			                end: {
			                    line: this.lastMarker.line,
			                    column: this.lastMarker.column,
			                    offset: this.lastMarker.index
			                }
			            };
			            this.delegate(node, metadata);
			        }
			        return node;
			    };
			    Parser.prototype.expect = function (value) {
			        var token = this.nextToken();
			        if (token.type !== 7  || token.value !== value) {
			            this.throwUnexpectedToken(token);
			        }
			    };
			    Parser.prototype.expectCommaSeparator = function () {
			        if (this.config.tolerant) {
			            var token = this.lookahead;
			            if (token.type === 7  && token.value === ',') {
			                this.nextToken();
			            }
			            else if (token.type === 7  && token.value === ';') {
			                this.nextToken();
			                this.tolerateUnexpectedToken(token);
			            }
			            else {
			                this.tolerateUnexpectedToken(token, messages_1.Messages.UnexpectedToken);
			            }
			        }
			        else {
			            this.expect(',');
			        }
			    };
			    Parser.prototype.expectKeyword = function (keyword) {
			        var token = this.nextToken();
			        if (token.type !== 4  || token.value !== keyword) {
			            this.throwUnexpectedToken(token);
			        }
			    };
			    Parser.prototype.match = function (value) {
			        return this.lookahead.type === 7  && this.lookahead.value === value;
			    };
			    Parser.prototype.matchKeyword = function (keyword) {
			        return this.lookahead.type === 4  && this.lookahead.value === keyword;
			    };
			    Parser.prototype.matchContextualKeyword = function (keyword) {
			        return this.lookahead.type === 3  && this.lookahead.value === keyword;
			    };
			    Parser.prototype.matchAssign = function () {
			        if (this.lookahead.type !== 7 ) {
			            return false;
			        }
			        var op = this.lookahead.value;
			        return op === '=' ||
			            op === '*=' ||
			            op === '**=' ||
			            op === '/=' ||
			            op === '%=' ||
			            op === '+=' ||
			            op === '-=' ||
			            op === '<<=' ||
			            op === '>>=' ||
			            op === '>>>=' ||
			            op === '&=' ||
			            op === '^=' ||
			            op === '|=';
			    };
			    Parser.prototype.isolateCoverGrammar = function (parseFunction) {
			        var previousIsBindingElement = this.context.isBindingElement;
			        var previousIsAssignmentTarget = this.context.isAssignmentTarget;
			        var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
			        this.context.isBindingElement = true;
			        this.context.isAssignmentTarget = true;
			        this.context.firstCoverInitializedNameError = null;
			        var result = parseFunction.call(this);
			        if (this.context.firstCoverInitializedNameError !== null) {
			            this.throwUnexpectedToken(this.context.firstCoverInitializedNameError);
			        }
			        this.context.isBindingElement = previousIsBindingElement;
			        this.context.isAssignmentTarget = previousIsAssignmentTarget;
			        this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError;
			        return result;
			    };
			    Parser.prototype.inheritCoverGrammar = function (parseFunction) {
			        var previousIsBindingElement = this.context.isBindingElement;
			        var previousIsAssignmentTarget = this.context.isAssignmentTarget;
			        var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
			        this.context.isBindingElement = true;
			        this.context.isAssignmentTarget = true;
			        this.context.firstCoverInitializedNameError = null;
			        var result = parseFunction.call(this);
			        this.context.isBindingElement = this.context.isBindingElement && previousIsBindingElement;
			        this.context.isAssignmentTarget = this.context.isAssignmentTarget && previousIsAssignmentTarget;
			        this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError || this.context.firstCoverInitializedNameError;
			        return result;
			    };
			    Parser.prototype.consumeSemicolon = function () {
			        if (this.match(';')) {
			            this.nextToken();
			        }
			        else if (!this.hasLineTerminator) {
			            if (this.lookahead.type !== 2  && !this.match('}')) {
			                this.throwUnexpectedToken(this.lookahead);
			            }
			            this.lastMarker.index = this.startMarker.index;
			            this.lastMarker.line = this.startMarker.line;
			            this.lastMarker.column = this.startMarker.column;
			        }
			    };
			    Parser.prototype.parsePrimaryExpression = function () {
			        var node = this.createNode();
			        var expr;
			        var token, raw;
			        switch (this.lookahead.type) {
			            case 3 :
			                if ((this.context.isModule || this.context.await) && this.lookahead.value === 'await') {
			                    this.tolerateUnexpectedToken(this.lookahead);
			                }
			                expr = this.matchAsyncFunction() ? this.parseFunctionExpression() : this.finalize(node, new Node.Identifier(this.nextToken().value));
			                break;
			            case 6 :
			            case 8 :
			                if (this.context.strict && this.lookahead.octal) {
			                    this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.StrictOctalLiteral);
			                }
			                this.context.isAssignmentTarget = false;
			                this.context.isBindingElement = false;
			                token = this.nextToken();
			                raw = this.getTokenRaw(token);
			                expr = this.finalize(node, new Node.Literal(token.value, raw));
			                break;
			            case 1 :
			                this.context.isAssignmentTarget = false;
			                this.context.isBindingElement = false;
			                token = this.nextToken();
			                raw = this.getTokenRaw(token);
			                expr = this.finalize(node, new Node.Literal(token.value === 'true', raw));
			                break;
			            case 5 :
			                this.context.isAssignmentTarget = false;
			                this.context.isBindingElement = false;
			                token = this.nextToken();
			                raw = this.getTokenRaw(token);
			                expr = this.finalize(node, new Node.Literal(null, raw));
			                break;
			            case 10 :
			                expr = this.parseTemplateLiteral();
			                break;
			            case 7 :
			                switch (this.lookahead.value) {
			                    case '(':
			                        this.context.isBindingElement = false;
			                        expr = this.inheritCoverGrammar(this.parseGroupExpression);
			                        break;
			                    case '[':
			                        expr = this.inheritCoverGrammar(this.parseArrayInitializer);
			                        break;
			                    case '{':
			                        expr = this.inheritCoverGrammar(this.parseObjectInitializer);
			                        break;
			                    case '/':
			                    case '/=':
			                        this.context.isAssignmentTarget = false;
			                        this.context.isBindingElement = false;
			                        this.scanner.index = this.startMarker.index;
			                        token = this.nextRegexToken();
			                        raw = this.getTokenRaw(token);
			                        expr = this.finalize(node, new Node.RegexLiteral(token.regex, raw, token.pattern, token.flags));
			                        break;
			                    default:
			                        expr = this.throwUnexpectedToken(this.nextToken());
			                }
			                break;
			            case 4 :
			                if (!this.context.strict && this.context.allowYield && this.matchKeyword('yield')) {
			                    expr = this.parseIdentifierName();
			                }
			                else if (!this.context.strict && this.matchKeyword('let')) {
			                    expr = this.finalize(node, new Node.Identifier(this.nextToken().value));
			                }
			                else {
			                    this.context.isAssignmentTarget = false;
			                    this.context.isBindingElement = false;
			                    if (this.matchKeyword('function')) {
			                        expr = this.parseFunctionExpression();
			                    }
			                    else if (this.matchKeyword('this')) {
			                        this.nextToken();
			                        expr = this.finalize(node, new Node.ThisExpression());
			                    }
			                    else if (this.matchKeyword('class')) {
			                        expr = this.parseClassExpression();
			                    }
			                    else {
			                        expr = this.throwUnexpectedToken(this.nextToken());
			                    }
			                }
			                break;
			            default:
			                expr = this.throwUnexpectedToken(this.nextToken());
			        }
			        return expr;
			    };
			    Parser.prototype.parseSpreadElement = function () {
			        var node = this.createNode();
			        this.expect('...');
			        var arg = this.inheritCoverGrammar(this.parseAssignmentExpression);
			        return this.finalize(node, new Node.SpreadElement(arg));
			    };
			    Parser.prototype.parseArrayInitializer = function () {
			        var node = this.createNode();
			        var elements = [];
			        this.expect('[');
			        while (!this.match(']')) {
			            if (this.match(',')) {
			                this.nextToken();
			                elements.push(null);
			            }
			            else if (this.match('...')) {
			                var element = this.parseSpreadElement();
			                if (!this.match(']')) {
			                    this.context.isAssignmentTarget = false;
			                    this.context.isBindingElement = false;
			                    this.expect(',');
			                }
			                elements.push(element);
			            }
			            else {
			                elements.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
			                if (!this.match(']')) {
			                    this.expect(',');
			                }
			            }
			        }
			        this.expect(']');
			        return this.finalize(node, new Node.ArrayExpression(elements));
			    };
			    Parser.prototype.parsePropertyMethod = function (params) {
			        this.context.isAssignmentTarget = false;
			        this.context.isBindingElement = false;
			        var previousStrict = this.context.strict;
			        var previousAllowStrictDirective = this.context.allowStrictDirective;
			        this.context.allowStrictDirective = params.simple;
			        var body = this.isolateCoverGrammar(this.parseFunctionSourceElements);
			        if (this.context.strict && params.firstRestricted) {
			            this.tolerateUnexpectedToken(params.firstRestricted, params.message);
			        }
			        if (this.context.strict && params.stricted) {
			            this.tolerateUnexpectedToken(params.stricted, params.message);
			        }
			        this.context.strict = previousStrict;
			        this.context.allowStrictDirective = previousAllowStrictDirective;
			        return body;
			    };
			    Parser.prototype.parsePropertyMethodFunction = function () {
			        var isGenerator = false;
			        var node = this.createNode();
			        var previousAllowYield = this.context.allowYield;
			        this.context.allowYield = true;
			        var params = this.parseFormalParameters();
			        var method = this.parsePropertyMethod(params);
			        this.context.allowYield = previousAllowYield;
			        return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
			    };
			    Parser.prototype.parsePropertyMethodAsyncFunction = function () {
			        var node = this.createNode();
			        var previousAllowYield = this.context.allowYield;
			        var previousAwait = this.context.await;
			        this.context.allowYield = false;
			        this.context.await = true;
			        var params = this.parseFormalParameters();
			        var method = this.parsePropertyMethod(params);
			        this.context.allowYield = previousAllowYield;
			        this.context.await = previousAwait;
			        return this.finalize(node, new Node.AsyncFunctionExpression(null, params.params, method));
			    };
			    Parser.prototype.parseObjectPropertyKey = function () {
			        var node = this.createNode();
			        var token = this.nextToken();
			        var key;
			        switch (token.type) {
			            case 8 :
			            case 6 :
			                if (this.context.strict && token.octal) {
			                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictOctalLiteral);
			                }
			                var raw = this.getTokenRaw(token);
			                key = this.finalize(node, new Node.Literal(token.value, raw));
			                break;
			            case 3 :
			            case 1 :
			            case 5 :
			            case 4 :
			                key = this.finalize(node, new Node.Identifier(token.value));
			                break;
			            case 7 :
			                if (token.value === '[') {
			                    key = this.isolateCoverGrammar(this.parseAssignmentExpression);
			                    this.expect(']');
			                }
			                else {
			                    key = this.throwUnexpectedToken(token);
			                }
			                break;
			            default:
			                key = this.throwUnexpectedToken(token);
			        }
			        return key;
			    };
			    Parser.prototype.isPropertyKey = function (key, value) {
			        return (key.type === syntax_1.Syntax.Identifier && key.name === value) ||
			            (key.type === syntax_1.Syntax.Literal && key.value === value);
			    };
			    Parser.prototype.parseObjectProperty = function (hasProto) {
			        var node = this.createNode();
			        var token = this.lookahead;
			        var kind;
			        var key = null;
			        var value = null;
			        var computed = false;
			        var method = false;
			        var shorthand = false;
			        var isAsync = false;
			        if (token.type === 3 ) {
			            var id = token.value;
			            this.nextToken();
			            computed = this.match('[');
			            isAsync = !this.hasLineTerminator && (id === 'async') &&
			                !this.match(':') && !this.match('(') && !this.match('*') && !this.match(',');
			            key = isAsync ? this.parseObjectPropertyKey() : this.finalize(node, new Node.Identifier(id));
			        }
			        else if (this.match('*')) {
			            this.nextToken();
			        }
			        else {
			            computed = this.match('[');
			            key = this.parseObjectPropertyKey();
			        }
			        var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
			        if (token.type === 3  && !isAsync && token.value === 'get' && lookaheadPropertyKey) {
			            kind = 'get';
			            computed = this.match('[');
			            key = this.parseObjectPropertyKey();
			            this.context.allowYield = false;
			            value = this.parseGetterMethod();
			        }
			        else if (token.type === 3  && !isAsync && token.value === 'set' && lookaheadPropertyKey) {
			            kind = 'set';
			            computed = this.match('[');
			            key = this.parseObjectPropertyKey();
			            value = this.parseSetterMethod();
			        }
			        else if (token.type === 7  && token.value === '*' && lookaheadPropertyKey) {
			            kind = 'init';
			            computed = this.match('[');
			            key = this.parseObjectPropertyKey();
			            value = this.parseGeneratorMethod();
			            method = true;
			        }
			        else {
			            if (!key) {
			                this.throwUnexpectedToken(this.lookahead);
			            }
			            kind = 'init';
			            if (this.match(':') && !isAsync) {
			                if (!computed && this.isPropertyKey(key, '__proto__')) {
			                    if (hasProto.value) {
			                        this.tolerateError(messages_1.Messages.DuplicateProtoProperty);
			                    }
			                    hasProto.value = true;
			                }
			                this.nextToken();
			                value = this.inheritCoverGrammar(this.parseAssignmentExpression);
			            }
			            else if (this.match('(')) {
			                value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
			                method = true;
			            }
			            else if (token.type === 3 ) {
			                var id = this.finalize(node, new Node.Identifier(token.value));
			                if (this.match('=')) {
			                    this.context.firstCoverInitializedNameError = this.lookahead;
			                    this.nextToken();
			                    shorthand = true;
			                    var init = this.isolateCoverGrammar(this.parseAssignmentExpression);
			                    value = this.finalize(node, new Node.AssignmentPattern(id, init));
			                }
			                else {
			                    shorthand = true;
			                    value = id;
			                }
			            }
			            else {
			                this.throwUnexpectedToken(this.nextToken());
			            }
			        }
			        return this.finalize(node, new Node.Property(kind, key, computed, value, method, shorthand));
			    };
			    Parser.prototype.parseObjectInitializer = function () {
			        var node = this.createNode();
			        this.expect('{');
			        var properties = [];
			        var hasProto = { value: false };
			        while (!this.match('}')) {
			            properties.push(this.parseObjectProperty(hasProto));
			            if (!this.match('}')) {
			                this.expectCommaSeparator();
			            }
			        }
			        this.expect('}');
			        return this.finalize(node, new Node.ObjectExpression(properties));
			    };
			    Parser.prototype.parseTemplateHead = function () {
			        assert_1.assert(this.lookahead.head, 'Template literal must start with a template head');
			        var node = this.createNode();
			        var token = this.nextToken();
			        var raw = token.value;
			        var cooked = token.cooked;
			        return this.finalize(node, new Node.TemplateElement({ raw: raw, cooked: cooked }, token.tail));
			    };
			    Parser.prototype.parseTemplateElement = function () {
			        if (this.lookahead.type !== 10 ) {
			            this.throwUnexpectedToken();
			        }
			        var node = this.createNode();
			        var token = this.nextToken();
			        var raw = token.value;
			        var cooked = token.cooked;
			        return this.finalize(node, new Node.TemplateElement({ raw: raw, cooked: cooked }, token.tail));
			    };
			    Parser.prototype.parseTemplateLiteral = function () {
			        var node = this.createNode();
			        var expressions = [];
			        var quasis = [];
			        var quasi = this.parseTemplateHead();
			        quasis.push(quasi);
			        while (!quasi.tail) {
			            expressions.push(this.parseExpression());
			            quasi = this.parseTemplateElement();
			            quasis.push(quasi);
			        }
			        return this.finalize(node, new Node.TemplateLiteral(quasis, expressions));
			    };
			    Parser.prototype.reinterpretExpressionAsPattern = function (expr) {
			        switch (expr.type) {
			            case syntax_1.Syntax.Identifier:
			            case syntax_1.Syntax.MemberExpression:
			            case syntax_1.Syntax.RestElement:
			            case syntax_1.Syntax.AssignmentPattern:
			                break;
			            case syntax_1.Syntax.SpreadElement:
			                expr.type = syntax_1.Syntax.RestElement;
			                this.reinterpretExpressionAsPattern(expr.argument);
			                break;
			            case syntax_1.Syntax.ArrayExpression:
			                expr.type = syntax_1.Syntax.ArrayPattern;
			                for (var i = 0; i < expr.elements.length; i++) {
			                    if (expr.elements[i] !== null) {
			                        this.reinterpretExpressionAsPattern(expr.elements[i]);
			                    }
			                }
			                break;
			            case syntax_1.Syntax.ObjectExpression:
			                expr.type = syntax_1.Syntax.ObjectPattern;
			                for (var i = 0; i < expr.properties.length; i++) {
			                    this.reinterpretExpressionAsPattern(expr.properties[i].value);
			                }
			                break;
			            case syntax_1.Syntax.AssignmentExpression:
			                expr.type = syntax_1.Syntax.AssignmentPattern;
			                delete expr.operator;
			                this.reinterpretExpressionAsPattern(expr.left);
			                break;
			        }
			    };
			    Parser.prototype.parseGroupExpression = function () {
			        var expr;
			        this.expect('(');
			        if (this.match(')')) {
			            this.nextToken();
			            if (!this.match('=>')) {
			                this.expect('=>');
			            }
			            expr = {
			                type: ArrowParameterPlaceHolder,
			                params: [],
			                async: false
			            };
			        }
			        else {
			            var startToken = this.lookahead;
			            var params = [];
			            if (this.match('...')) {
			                expr = this.parseRestElement(params);
			                this.expect(')');
			                if (!this.match('=>')) {
			                    this.expect('=>');
			                }
			                expr = {
			                    type: ArrowParameterPlaceHolder,
			                    params: [expr],
			                    async: false
			                };
			            }
			            else {
			                var arrow = false;
			                this.context.isBindingElement = true;
			                expr = this.inheritCoverGrammar(this.parseAssignmentExpression);
			                if (this.match(',')) {
			                    var expressions = [];
			                    this.context.isAssignmentTarget = false;
			                    expressions.push(expr);
			                    while (this.lookahead.type !== 2 ) {
			                        if (!this.match(',')) {
			                            break;
			                        }
			                        this.nextToken();
			                        if (this.match(')')) {
			                            this.nextToken();
			                            for (var i = 0; i < expressions.length; i++) {
			                                this.reinterpretExpressionAsPattern(expressions[i]);
			                            }
			                            arrow = true;
			                            expr = {
			                                type: ArrowParameterPlaceHolder,
			                                params: expressions,
			                                async: false
			                            };
			                        }
			                        else if (this.match('...')) {
			                            if (!this.context.isBindingElement) {
			                                this.throwUnexpectedToken(this.lookahead);
			                            }
			                            expressions.push(this.parseRestElement(params));
			                            this.expect(')');
			                            if (!this.match('=>')) {
			                                this.expect('=>');
			                            }
			                            this.context.isBindingElement = false;
			                            for (var i = 0; i < expressions.length; i++) {
			                                this.reinterpretExpressionAsPattern(expressions[i]);
			                            }
			                            arrow = true;
			                            expr = {
			                                type: ArrowParameterPlaceHolder,
			                                params: expressions,
			                                async: false
			                            };
			                        }
			                        else {
			                            expressions.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
			                        }
			                        if (arrow) {
			                            break;
			                        }
			                    }
			                    if (!arrow) {
			                        expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
			                    }
			                }
			                if (!arrow) {
			                    this.expect(')');
			                    if (this.match('=>')) {
			                        if (expr.type === syntax_1.Syntax.Identifier && expr.name === 'yield') {
			                            arrow = true;
			                            expr = {
			                                type: ArrowParameterPlaceHolder,
			                                params: [expr],
			                                async: false
			                            };
			                        }
			                        if (!arrow) {
			                            if (!this.context.isBindingElement) {
			                                this.throwUnexpectedToken(this.lookahead);
			                            }
			                            if (expr.type === syntax_1.Syntax.SequenceExpression) {
			                                for (var i = 0; i < expr.expressions.length; i++) {
			                                    this.reinterpretExpressionAsPattern(expr.expressions[i]);
			                                }
			                            }
			                            else {
			                                this.reinterpretExpressionAsPattern(expr);
			                            }
			                            var parameters = (expr.type === syntax_1.Syntax.SequenceExpression ? expr.expressions : [expr]);
			                            expr = {
			                                type: ArrowParameterPlaceHolder,
			                                params: parameters,
			                                async: false
			                            };
			                        }
			                    }
			                    this.context.isBindingElement = false;
			                }
			            }
			        }
			        return expr;
			    };
			    Parser.prototype.parseArguments = function () {
			        this.expect('(');
			        var args = [];
			        if (!this.match(')')) {
			            while (true) {
			                var expr = this.match('...') ? this.parseSpreadElement() :
			                    this.isolateCoverGrammar(this.parseAssignmentExpression);
			                args.push(expr);
			                if (this.match(')')) {
			                    break;
			                }
			                this.expectCommaSeparator();
			                if (this.match(')')) {
			                    break;
			                }
			            }
			        }
			        this.expect(')');
			        return args;
			    };
			    Parser.prototype.isIdentifierName = function (token) {
			        return token.type === 3  ||
			            token.type === 4  ||
			            token.type === 1  ||
			            token.type === 5 ;
			    };
			    Parser.prototype.parseIdentifierName = function () {
			        var node = this.createNode();
			        var token = this.nextToken();
			        if (!this.isIdentifierName(token)) {
			            this.throwUnexpectedToken(token);
			        }
			        return this.finalize(node, new Node.Identifier(token.value));
			    };
			    Parser.prototype.parseNewExpression = function () {
			        var node = this.createNode();
			        var id = this.parseIdentifierName();
			        assert_1.assert(id.name === 'new', 'New expression must start with `new`');
			        var expr;
			        if (this.match('.')) {
			            this.nextToken();
			            if (this.lookahead.type === 3  && this.context.inFunctionBody && this.lookahead.value === 'target') {
			                var property = this.parseIdentifierName();
			                expr = new Node.MetaProperty(id, property);
			            }
			            else {
			                this.throwUnexpectedToken(this.lookahead);
			            }
			        }
			        else {
			            var callee = this.isolateCoverGrammar(this.parseLeftHandSideExpression);
			            var args = this.match('(') ? this.parseArguments() : [];
			            expr = new Node.NewExpression(callee, args);
			            this.context.isAssignmentTarget = false;
			            this.context.isBindingElement = false;
			        }
			        return this.finalize(node, expr);
			    };
			    Parser.prototype.parseAsyncArgument = function () {
			        var arg = this.parseAssignmentExpression();
			        this.context.firstCoverInitializedNameError = null;
			        return arg;
			    };
			    Parser.prototype.parseAsyncArguments = function () {
			        this.expect('(');
			        var args = [];
			        if (!this.match(')')) {
			            while (true) {
			                var expr = this.match('...') ? this.parseSpreadElement() :
			                    this.isolateCoverGrammar(this.parseAsyncArgument);
			                args.push(expr);
			                if (this.match(')')) {
			                    break;
			                }
			                this.expectCommaSeparator();
			                if (this.match(')')) {
			                    break;
			                }
			            }
			        }
			        this.expect(')');
			        return args;
			    };
			    Parser.prototype.parseLeftHandSideExpressionAllowCall = function () {
			        var startToken = this.lookahead;
			        var maybeAsync = this.matchContextualKeyword('async');
			        var previousAllowIn = this.context.allowIn;
			        this.context.allowIn = true;
			        var expr;
			        if (this.matchKeyword('super') && this.context.inFunctionBody) {
			            expr = this.createNode();
			            this.nextToken();
			            expr = this.finalize(expr, new Node.Super());
			            if (!this.match('(') && !this.match('.') && !this.match('[')) {
			                this.throwUnexpectedToken(this.lookahead);
			            }
			        }
			        else {
			            expr = this.inheritCoverGrammar(this.matchKeyword('new') ? this.parseNewExpression : this.parsePrimaryExpression);
			        }
			        while (true) {
			            if (this.match('.')) {
			                this.context.isBindingElement = false;
			                this.context.isAssignmentTarget = true;
			                this.expect('.');
			                var property = this.parseIdentifierName();
			                expr = this.finalize(this.startNode(startToken), new Node.StaticMemberExpression(expr, property));
			            }
			            else if (this.match('(')) {
			                var asyncArrow = maybeAsync && (startToken.lineNumber === this.lookahead.lineNumber);
			                this.context.isBindingElement = false;
			                this.context.isAssignmentTarget = false;
			                var args = asyncArrow ? this.parseAsyncArguments() : this.parseArguments();
			                expr = this.finalize(this.startNode(startToken), new Node.CallExpression(expr, args));
			                if (asyncArrow && this.match('=>')) {
			                    for (var i = 0; i < args.length; ++i) {
			                        this.reinterpretExpressionAsPattern(args[i]);
			                    }
			                    expr = {
			                        type: ArrowParameterPlaceHolder,
			                        params: args,
			                        async: true
			                    };
			                }
			            }
			            else if (this.match('[')) {
			                this.context.isBindingElement = false;
			                this.context.isAssignmentTarget = true;
			                this.expect('[');
			                var property = this.isolateCoverGrammar(this.parseExpression);
			                this.expect(']');
			                expr = this.finalize(this.startNode(startToken), new Node.ComputedMemberExpression(expr, property));
			            }
			            else if (this.lookahead.type === 10  && this.lookahead.head) {
			                var quasi = this.parseTemplateLiteral();
			                expr = this.finalize(this.startNode(startToken), new Node.TaggedTemplateExpression(expr, quasi));
			            }
			            else {
			                break;
			            }
			        }
			        this.context.allowIn = previousAllowIn;
			        return expr;
			    };
			    Parser.prototype.parseSuper = function () {
			        var node = this.createNode();
			        this.expectKeyword('super');
			        if (!this.match('[') && !this.match('.')) {
			            this.throwUnexpectedToken(this.lookahead);
			        }
			        return this.finalize(node, new Node.Super());
			    };
			    Parser.prototype.parseLeftHandSideExpression = function () {
			        assert_1.assert(this.context.allowIn, 'callee of new expression always allow in keyword.');
			        var node = this.startNode(this.lookahead);
			        var expr = (this.matchKeyword('super') && this.context.inFunctionBody) ? this.parseSuper() :
			            this.inheritCoverGrammar(this.matchKeyword('new') ? this.parseNewExpression : this.parsePrimaryExpression);
			        while (true) {
			            if (this.match('[')) {
			                this.context.isBindingElement = false;
			                this.context.isAssignmentTarget = true;
			                this.expect('[');
			                var property = this.isolateCoverGrammar(this.parseExpression);
			                this.expect(']');
			                expr = this.finalize(node, new Node.ComputedMemberExpression(expr, property));
			            }
			            else if (this.match('.')) {
			                this.context.isBindingElement = false;
			                this.context.isAssignmentTarget = true;
			                this.expect('.');
			                var property = this.parseIdentifierName();
			                expr = this.finalize(node, new Node.StaticMemberExpression(expr, property));
			            }
			            else if (this.lookahead.type === 10  && this.lookahead.head) {
			                var quasi = this.parseTemplateLiteral();
			                expr = this.finalize(node, new Node.TaggedTemplateExpression(expr, quasi));
			            }
			            else {
			                break;
			            }
			        }
			        return expr;
			    };
			    Parser.prototype.parseUpdateExpression = function () {
			        var expr;
			        var startToken = this.lookahead;
			        if (this.match('++') || this.match('--')) {
			            var node = this.startNode(startToken);
			            var token = this.nextToken();
			            expr = this.inheritCoverGrammar(this.parseUnaryExpression);
			            if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
			                this.tolerateError(messages_1.Messages.StrictLHSPrefix);
			            }
			            if (!this.context.isAssignmentTarget) {
			                this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
			            }
			            var prefix = true;
			            expr = this.finalize(node, new Node.UpdateExpression(token.value, expr, prefix));
			            this.context.isAssignmentTarget = false;
			            this.context.isBindingElement = false;
			        }
			        else {
			            expr = this.inheritCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
			            if (!this.hasLineTerminator && this.lookahead.type === 7 ) {
			                if (this.match('++') || this.match('--')) {
			                    if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
			                        this.tolerateError(messages_1.Messages.StrictLHSPostfix);
			                    }
			                    if (!this.context.isAssignmentTarget) {
			                        this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
			                    }
			                    this.context.isAssignmentTarget = false;
			                    this.context.isBindingElement = false;
			                    var operator = this.nextToken().value;
			                    var prefix = false;
			                    expr = this.finalize(this.startNode(startToken), new Node.UpdateExpression(operator, expr, prefix));
			                }
			            }
			        }
			        return expr;
			    };
			    Parser.prototype.parseAwaitExpression = function () {
			        var node = this.createNode();
			        this.nextToken();
			        var argument = this.parseUnaryExpression();
			        return this.finalize(node, new Node.AwaitExpression(argument));
			    };
			    Parser.prototype.parseUnaryExpression = function () {
			        var expr;
			        if (this.match('+') || this.match('-') || this.match('~') || this.match('!') ||
			            this.matchKeyword('delete') || this.matchKeyword('void') || this.matchKeyword('typeof')) {
			            var node = this.startNode(this.lookahead);
			            var token = this.nextToken();
			            expr = this.inheritCoverGrammar(this.parseUnaryExpression);
			            expr = this.finalize(node, new Node.UnaryExpression(token.value, expr));
			            if (this.context.strict && expr.operator === 'delete' && expr.argument.type === syntax_1.Syntax.Identifier) {
			                this.tolerateError(messages_1.Messages.StrictDelete);
			            }
			            this.context.isAssignmentTarget = false;
			            this.context.isBindingElement = false;
			        }
			        else if (this.context.await && this.matchContextualKeyword('await')) {
			            expr = this.parseAwaitExpression();
			        }
			        else {
			            expr = this.parseUpdateExpression();
			        }
			        return expr;
			    };
			    Parser.prototype.parseExponentiationExpression = function () {
			        var startToken = this.lookahead;
			        var expr = this.inheritCoverGrammar(this.parseUnaryExpression);
			        if (expr.type !== syntax_1.Syntax.UnaryExpression && this.match('**')) {
			            this.nextToken();
			            this.context.isAssignmentTarget = false;
			            this.context.isBindingElement = false;
			            var left = expr;
			            var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
			            expr = this.finalize(this.startNode(startToken), new Node.BinaryExpression('**', left, right));
			        }
			        return expr;
			    };
			    Parser.prototype.binaryPrecedence = function (token) {
			        var op = token.value;
			        var precedence;
			        if (token.type === 7 ) {
			            precedence = this.operatorPrecedence[op] || 0;
			        }
			        else if (token.type === 4 ) {
			            precedence = (op === 'instanceof' || (this.context.allowIn && op === 'in')) ? 7 : 0;
			        }
			        else {
			            precedence = 0;
			        }
			        return precedence;
			    };
			    Parser.prototype.parseBinaryExpression = function () {
			        var startToken = this.lookahead;
			        var expr = this.inheritCoverGrammar(this.parseExponentiationExpression);
			        var token = this.lookahead;
			        var prec = this.binaryPrecedence(token);
			        if (prec > 0) {
			            this.nextToken();
			            this.context.isAssignmentTarget = false;
			            this.context.isBindingElement = false;
			            var markers = [startToken, this.lookahead];
			            var left = expr;
			            var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
			            var stack = [left, token.value, right];
			            var precedences = [prec];
			            while (true) {
			                prec = this.binaryPrecedence(this.lookahead);
			                if (prec <= 0) {
			                    break;
			                }
			                while ((stack.length > 2) && (prec <= precedences[precedences.length - 1])) {
			                    right = stack.pop();
			                    var operator = stack.pop();
			                    precedences.pop();
			                    left = stack.pop();
			                    markers.pop();
			                    var node = this.startNode(markers[markers.length - 1]);
			                    stack.push(this.finalize(node, new Node.BinaryExpression(operator, left, right)));
			                }
			                stack.push(this.nextToken().value);
			                precedences.push(prec);
			                markers.push(this.lookahead);
			                stack.push(this.isolateCoverGrammar(this.parseExponentiationExpression));
			            }
			            var i = stack.length - 1;
			            expr = stack[i];
			            var lastMarker = markers.pop();
			            while (i > 1) {
			                var marker = markers.pop();
			                var lastLineStart = lastMarker && lastMarker.lineStart;
			                var node = this.startNode(marker, lastLineStart);
			                var operator = stack[i - 1];
			                expr = this.finalize(node, new Node.BinaryExpression(operator, stack[i - 2], expr));
			                i -= 2;
			                lastMarker = marker;
			            }
			        }
			        return expr;
			    };
			    Parser.prototype.parseConditionalExpression = function () {
			        var startToken = this.lookahead;
			        var expr = this.inheritCoverGrammar(this.parseBinaryExpression);
			        if (this.match('?')) {
			            this.nextToken();
			            var previousAllowIn = this.context.allowIn;
			            this.context.allowIn = true;
			            var consequent = this.isolateCoverGrammar(this.parseAssignmentExpression);
			            this.context.allowIn = previousAllowIn;
			            this.expect(':');
			            var alternate = this.isolateCoverGrammar(this.parseAssignmentExpression);
			            expr = this.finalize(this.startNode(startToken), new Node.ConditionalExpression(expr, consequent, alternate));
			            this.context.isAssignmentTarget = false;
			            this.context.isBindingElement = false;
			        }
			        return expr;
			    };
			    Parser.prototype.checkPatternParam = function (options, param) {
			        switch (param.type) {
			            case syntax_1.Syntax.Identifier:
			                this.validateParam(options, param, param.name);
			                break;
			            case syntax_1.Syntax.RestElement:
			                this.checkPatternParam(options, param.argument);
			                break;
			            case syntax_1.Syntax.AssignmentPattern:
			                this.checkPatternParam(options, param.left);
			                break;
			            case syntax_1.Syntax.ArrayPattern:
			                for (var i = 0; i < param.elements.length; i++) {
			                    if (param.elements[i] !== null) {
			                        this.checkPatternParam(options, param.elements[i]);
			                    }
			                }
			                break;
			            case syntax_1.Syntax.ObjectPattern:
			                for (var i = 0; i < param.properties.length; i++) {
			                    this.checkPatternParam(options, param.properties[i].value);
			                }
			                break;
			        }
			        options.simple = options.simple && (param instanceof Node.Identifier);
			    };
			    Parser.prototype.reinterpretAsCoverFormalsList = function (expr) {
			        var params = [expr];
			        var options;
			        var asyncArrow = false;
			        switch (expr.type) {
			            case syntax_1.Syntax.Identifier:
			                break;
			            case ArrowParameterPlaceHolder:
			                params = expr.params;
			                asyncArrow = expr.async;
			                break;
			            default:
			                return null;
			        }
			        options = {
			            simple: true,
			            paramSet: {}
			        };
			        for (var i = 0; i < params.length; ++i) {
			            var param = params[i];
			            if (param.type === syntax_1.Syntax.AssignmentPattern) {
			                if (param.right.type === syntax_1.Syntax.YieldExpression) {
			                    if (param.right.argument) {
			                        this.throwUnexpectedToken(this.lookahead);
			                    }
			                    param.right.type = syntax_1.Syntax.Identifier;
			                    param.right.name = 'yield';
			                    delete param.right.argument;
			                    delete param.right.delegate;
			                }
			            }
			            else if (asyncArrow && param.type === syntax_1.Syntax.Identifier && param.name === 'await') {
			                this.throwUnexpectedToken(this.lookahead);
			            }
			            this.checkPatternParam(options, param);
			            params[i] = param;
			        }
			        if (this.context.strict || !this.context.allowYield) {
			            for (var i = 0; i < params.length; ++i) {
			                var param = params[i];
			                if (param.type === syntax_1.Syntax.YieldExpression) {
			                    this.throwUnexpectedToken(this.lookahead);
			                }
			            }
			        }
			        if (options.message === messages_1.Messages.StrictParamDupe) {
			            var token = this.context.strict ? options.stricted : options.firstRestricted;
			            this.throwUnexpectedToken(token, options.message);
			        }
			        return {
			            simple: options.simple,
			            params: params,
			            stricted: options.stricted,
			            firstRestricted: options.firstRestricted,
			            message: options.message
			        };
			    };
			    Parser.prototype.parseAssignmentExpression = function () {
			        var expr;
			        if (!this.context.allowYield && this.matchKeyword('yield')) {
			            expr = this.parseYieldExpression();
			        }
			        else {
			            var startToken = this.lookahead;
			            var token = startToken;
			            expr = this.parseConditionalExpression();
			            if (token.type === 3  && (token.lineNumber === this.lookahead.lineNumber) && token.value === 'async') {
			                if (this.lookahead.type === 3  || this.matchKeyword('yield')) {
			                    var arg = this.parsePrimaryExpression();
			                    this.reinterpretExpressionAsPattern(arg);
			                    expr = {
			                        type: ArrowParameterPlaceHolder,
			                        params: [arg],
			                        async: true
			                    };
			                }
			            }
			            if (expr.type === ArrowParameterPlaceHolder || this.match('=>')) {
			                this.context.isAssignmentTarget = false;
			                this.context.isBindingElement = false;
			                var isAsync = expr.async;
			                var list = this.reinterpretAsCoverFormalsList(expr);
			                if (list) {
			                    if (this.hasLineTerminator) {
			                        this.tolerateUnexpectedToken(this.lookahead);
			                    }
			                    this.context.firstCoverInitializedNameError = null;
			                    var previousStrict = this.context.strict;
			                    var previousAllowStrictDirective = this.context.allowStrictDirective;
			                    this.context.allowStrictDirective = list.simple;
			                    var previousAllowYield = this.context.allowYield;
			                    var previousAwait = this.context.await;
			                    this.context.allowYield = true;
			                    this.context.await = isAsync;
			                    var node = this.startNode(startToken);
			                    this.expect('=>');
			                    var body = void 0;
			                    if (this.match('{')) {
			                        var previousAllowIn = this.context.allowIn;
			                        this.context.allowIn = true;
			                        body = this.parseFunctionSourceElements();
			                        this.context.allowIn = previousAllowIn;
			                    }
			                    else {
			                        body = this.isolateCoverGrammar(this.parseAssignmentExpression);
			                    }
			                    var expression = body.type !== syntax_1.Syntax.BlockStatement;
			                    if (this.context.strict && list.firstRestricted) {
			                        this.throwUnexpectedToken(list.firstRestricted, list.message);
			                    }
			                    if (this.context.strict && list.stricted) {
			                        this.tolerateUnexpectedToken(list.stricted, list.message);
			                    }
			                    expr = isAsync ? this.finalize(node, new Node.AsyncArrowFunctionExpression(list.params, body, expression)) :
			                        this.finalize(node, new Node.ArrowFunctionExpression(list.params, body, expression));
			                    this.context.strict = previousStrict;
			                    this.context.allowStrictDirective = previousAllowStrictDirective;
			                    this.context.allowYield = previousAllowYield;
			                    this.context.await = previousAwait;
			                }
			            }
			            else {
			                if (this.matchAssign()) {
			                    if (!this.context.isAssignmentTarget) {
			                        this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
			                    }
			                    if (this.context.strict && expr.type === syntax_1.Syntax.Identifier) {
			                        var id = expr;
			                        if (this.scanner.isRestrictedWord(id.name)) {
			                            this.tolerateUnexpectedToken(token, messages_1.Messages.StrictLHSAssignment);
			                        }
			                        if (this.scanner.isStrictModeReservedWord(id.name)) {
			                            this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
			                        }
			                    }
			                    if (!this.match('=')) {
			                        this.context.isAssignmentTarget = false;
			                        this.context.isBindingElement = false;
			                    }
			                    else {
			                        this.reinterpretExpressionAsPattern(expr);
			                    }
			                    token = this.nextToken();
			                    var operator = token.value;
			                    var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
			                    expr = this.finalize(this.startNode(startToken), new Node.AssignmentExpression(operator, expr, right));
			                    this.context.firstCoverInitializedNameError = null;
			                }
			            }
			        }
			        return expr;
			    };
			    Parser.prototype.parseExpression = function () {
			        var startToken = this.lookahead;
			        var expr = this.isolateCoverGrammar(this.parseAssignmentExpression);
			        if (this.match(',')) {
			            var expressions = [];
			            expressions.push(expr);
			            while (this.lookahead.type !== 2 ) {
			                if (!this.match(',')) {
			                    break;
			                }
			                this.nextToken();
			                expressions.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
			            }
			            expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
			        }
			        return expr;
			    };
			    Parser.prototype.parseStatementListItem = function () {
			        var statement;
			        this.context.isAssignmentTarget = true;
			        this.context.isBindingElement = true;
			        if (this.lookahead.type === 4 ) {
			            switch (this.lookahead.value) {
			                case 'export':
			                    if (!this.context.isModule) {
			                        this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalExportDeclaration);
			                    }
			                    statement = this.parseExportDeclaration();
			                    break;
			                case 'import':
			                    if (!this.context.isModule) {
			                        this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalImportDeclaration);
			                    }
			                    statement = this.parseImportDeclaration();
			                    break;
			                case 'const':
			                    statement = this.parseLexicalDeclaration({ inFor: false });
			                    break;
			                case 'function':
			                    statement = this.parseFunctionDeclaration();
			                    break;
			                case 'class':
			                    statement = this.parseClassDeclaration();
			                    break;
			                case 'let':
			                    statement = this.isLexicalDeclaration() ? this.parseLexicalDeclaration({ inFor: false }) : this.parseStatement();
			                    break;
			                default:
			                    statement = this.parseStatement();
			                    break;
			            }
			        }
			        else {
			            statement = this.parseStatement();
			        }
			        return statement;
			    };
			    Parser.prototype.parseBlock = function () {
			        var node = this.createNode();
			        this.expect('{');
			        var block = [];
			        while (true) {
			            if (this.match('}')) {
			                break;
			            }
			            block.push(this.parseStatementListItem());
			        }
			        this.expect('}');
			        return this.finalize(node, new Node.BlockStatement(block));
			    };
			    Parser.prototype.parseLexicalBinding = function (kind, options) {
			        var node = this.createNode();
			        var params = [];
			        var id = this.parsePattern(params, kind);
			        if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
			            if (this.scanner.isRestrictedWord(id.name)) {
			                this.tolerateError(messages_1.Messages.StrictVarName);
			            }
			        }
			        var init = null;
			        if (kind === 'const') {
			            if (!this.matchKeyword('in') && !this.matchContextualKeyword('of')) {
			                if (this.match('=')) {
			                    this.nextToken();
			                    init = this.isolateCoverGrammar(this.parseAssignmentExpression);
			                }
			                else {
			                    this.throwError(messages_1.Messages.DeclarationMissingInitializer, 'const');
			                }
			            }
			        }
			        else if ((!options.inFor && id.type !== syntax_1.Syntax.Identifier) || this.match('=')) {
			            this.expect('=');
			            init = this.isolateCoverGrammar(this.parseAssignmentExpression);
			        }
			        return this.finalize(node, new Node.VariableDeclarator(id, init));
			    };
			    Parser.prototype.parseBindingList = function (kind, options) {
			        var list = [this.parseLexicalBinding(kind, options)];
			        while (this.match(',')) {
			            this.nextToken();
			            list.push(this.parseLexicalBinding(kind, options));
			        }
			        return list;
			    };
			    Parser.prototype.isLexicalDeclaration = function () {
			        var state = this.scanner.saveState();
			        this.scanner.scanComments();
			        var next = this.scanner.lex();
			        this.scanner.restoreState(state);
			        return (next.type === 3 ) ||
			            (next.type === 7  && next.value === '[') ||
			            (next.type === 7  && next.value === '{') ||
			            (next.type === 4  && next.value === 'let') ||
			            (next.type === 4  && next.value === 'yield');
			    };
			    Parser.prototype.parseLexicalDeclaration = function (options) {
			        var node = this.createNode();
			        var kind = this.nextToken().value;
			        assert_1.assert(kind === 'let' || kind === 'const', 'Lexical declaration must be either let or const');
			        var declarations = this.parseBindingList(kind, options);
			        this.consumeSemicolon();
			        return this.finalize(node, new Node.VariableDeclaration(declarations, kind));
			    };
			    Parser.prototype.parseBindingRestElement = function (params, kind) {
			        var node = this.createNode();
			        this.expect('...');
			        var arg = this.parsePattern(params, kind);
			        return this.finalize(node, new Node.RestElement(arg));
			    };
			    Parser.prototype.parseArrayPattern = function (params, kind) {
			        var node = this.createNode();
			        this.expect('[');
			        var elements = [];
			        while (!this.match(']')) {
			            if (this.match(',')) {
			                this.nextToken();
			                elements.push(null);
			            }
			            else {
			                if (this.match('...')) {
			                    elements.push(this.parseBindingRestElement(params, kind));
			                    break;
			                }
			                else {
			                    elements.push(this.parsePatternWithDefault(params, kind));
			                }
			                if (!this.match(']')) {
			                    this.expect(',');
			                }
			            }
			        }
			        this.expect(']');
			        return this.finalize(node, new Node.ArrayPattern(elements));
			    };
			    Parser.prototype.parsePropertyPattern = function (params, kind) {
			        var node = this.createNode();
			        var computed = false;
			        var shorthand = false;
			        var method = false;
			        var key;
			        var value;
			        if (this.lookahead.type === 3 ) {
			            var keyToken = this.lookahead;
			            key = this.parseVariableIdentifier();
			            var init = this.finalize(node, new Node.Identifier(keyToken.value));
			            if (this.match('=')) {
			                params.push(keyToken);
			                shorthand = true;
			                this.nextToken();
			                var expr = this.parseAssignmentExpression();
			                value = this.finalize(this.startNode(keyToken), new Node.AssignmentPattern(init, expr));
			            }
			            else if (!this.match(':')) {
			                params.push(keyToken);
			                shorthand = true;
			                value = init;
			            }
			            else {
			                this.expect(':');
			                value = this.parsePatternWithDefault(params, kind);
			            }
			        }
			        else {
			            computed = this.match('[');
			            key = this.parseObjectPropertyKey();
			            this.expect(':');
			            value = this.parsePatternWithDefault(params, kind);
			        }
			        return this.finalize(node, new Node.Property('init', key, computed, value, method, shorthand));
			    };
			    Parser.prototype.parseObjectPattern = function (params, kind) {
			        var node = this.createNode();
			        var properties = [];
			        this.expect('{');
			        while (!this.match('}')) {
			            properties.push(this.parsePropertyPattern(params, kind));
			            if (!this.match('}')) {
			                this.expect(',');
			            }
			        }
			        this.expect('}');
			        return this.finalize(node, new Node.ObjectPattern(properties));
			    };
			    Parser.prototype.parsePattern = function (params, kind) {
			        var pattern;
			        if (this.match('[')) {
			            pattern = this.parseArrayPattern(params, kind);
			        }
			        else if (this.match('{')) {
			            pattern = this.parseObjectPattern(params, kind);
			        }
			        else {
			            if (this.matchKeyword('let') && (kind === 'const' || kind === 'let')) {
			                this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.LetInLexicalBinding);
			            }
			            params.push(this.lookahead);
			            pattern = this.parseVariableIdentifier(kind);
			        }
			        return pattern;
			    };
			    Parser.prototype.parsePatternWithDefault = function (params, kind) {
			        var startToken = this.lookahead;
			        var pattern = this.parsePattern(params, kind);
			        if (this.match('=')) {
			            this.nextToken();
			            var previousAllowYield = this.context.allowYield;
			            this.context.allowYield = true;
			            var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
			            this.context.allowYield = previousAllowYield;
			            pattern = this.finalize(this.startNode(startToken), new Node.AssignmentPattern(pattern, right));
			        }
			        return pattern;
			    };
			    Parser.prototype.parseVariableIdentifier = function (kind) {
			        var node = this.createNode();
			        var token = this.nextToken();
			        if (token.type === 4  && token.value === 'yield') {
			            if (this.context.strict) {
			                this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
			            }
			            else if (!this.context.allowYield) {
			                this.throwUnexpectedToken(token);
			            }
			        }
			        else if (token.type !== 3 ) {
			            if (this.context.strict && token.type === 4  && this.scanner.isStrictModeReservedWord(token.value)) {
			                this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
			            }
			            else {
			                if (this.context.strict || token.value !== 'let' || kind !== 'var') {
			                    this.throwUnexpectedToken(token);
			                }
			            }
			        }
			        else if ((this.context.isModule || this.context.await) && token.type === 3  && token.value === 'await') {
			            this.tolerateUnexpectedToken(token);
			        }
			        return this.finalize(node, new Node.Identifier(token.value));
			    };
			    Parser.prototype.parseVariableDeclaration = function (options) {
			        var node = this.createNode();
			        var params = [];
			        var id = this.parsePattern(params, 'var');
			        if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
			            if (this.scanner.isRestrictedWord(id.name)) {
			                this.tolerateError(messages_1.Messages.StrictVarName);
			            }
			        }
			        var init = null;
			        if (this.match('=')) {
			            this.nextToken();
			            init = this.isolateCoverGrammar(this.parseAssignmentExpression);
			        }
			        else if (id.type !== syntax_1.Syntax.Identifier && !options.inFor) {
			            this.expect('=');
			        }
			        return this.finalize(node, new Node.VariableDeclarator(id, init));
			    };
			    Parser.prototype.parseVariableDeclarationList = function (options) {
			        var opt = { inFor: options.inFor };
			        var list = [];
			        list.push(this.parseVariableDeclaration(opt));
			        while (this.match(',')) {
			            this.nextToken();
			            list.push(this.parseVariableDeclaration(opt));
			        }
			        return list;
			    };
			    Parser.prototype.parseVariableStatement = function () {
			        var node = this.createNode();
			        this.expectKeyword('var');
			        var declarations = this.parseVariableDeclarationList({ inFor: false });
			        this.consumeSemicolon();
			        return this.finalize(node, new Node.VariableDeclaration(declarations, 'var'));
			    };
			    Parser.prototype.parseEmptyStatement = function () {
			        var node = this.createNode();
			        this.expect(';');
			        return this.finalize(node, new Node.EmptyStatement());
			    };
			    Parser.prototype.parseExpressionStatement = function () {
			        var node = this.createNode();
			        var expr = this.parseExpression();
			        this.consumeSemicolon();
			        return this.finalize(node, new Node.ExpressionStatement(expr));
			    };
			    Parser.prototype.parseIfClause = function () {
			        if (this.context.strict && this.matchKeyword('function')) {
			            this.tolerateError(messages_1.Messages.StrictFunction);
			        }
			        return this.parseStatement();
			    };
			    Parser.prototype.parseIfStatement = function () {
			        var node = this.createNode();
			        var consequent;
			        var alternate = null;
			        this.expectKeyword('if');
			        this.expect('(');
			        var test = this.parseExpression();
			        if (!this.match(')') && this.config.tolerant) {
			            this.tolerateUnexpectedToken(this.nextToken());
			            consequent = this.finalize(this.createNode(), new Node.EmptyStatement());
			        }
			        else {
			            this.expect(')');
			            consequent = this.parseIfClause();
			            if (this.matchKeyword('else')) {
			                this.nextToken();
			                alternate = this.parseIfClause();
			            }
			        }
			        return this.finalize(node, new Node.IfStatement(test, consequent, alternate));
			    };
			    Parser.prototype.parseDoWhileStatement = function () {
			        var node = this.createNode();
			        this.expectKeyword('do');
			        var previousInIteration = this.context.inIteration;
			        this.context.inIteration = true;
			        var body = this.parseStatement();
			        this.context.inIteration = previousInIteration;
			        this.expectKeyword('while');
			        this.expect('(');
			        var test = this.parseExpression();
			        if (!this.match(')') && this.config.tolerant) {
			            this.tolerateUnexpectedToken(this.nextToken());
			        }
			        else {
			            this.expect(')');
			            if (this.match(';')) {
			                this.nextToken();
			            }
			        }
			        return this.finalize(node, new Node.DoWhileStatement(body, test));
			    };
			    Parser.prototype.parseWhileStatement = function () {
			        var node = this.createNode();
			        var body;
			        this.expectKeyword('while');
			        this.expect('(');
			        var test = this.parseExpression();
			        if (!this.match(')') && this.config.tolerant) {
			            this.tolerateUnexpectedToken(this.nextToken());
			            body = this.finalize(this.createNode(), new Node.EmptyStatement());
			        }
			        else {
			            this.expect(')');
			            var previousInIteration = this.context.inIteration;
			            this.context.inIteration = true;
			            body = this.parseStatement();
			            this.context.inIteration = previousInIteration;
			        }
			        return this.finalize(node, new Node.WhileStatement(test, body));
			    };
			    Parser.prototype.parseForStatement = function () {
			        var init = null;
			        var test = null;
			        var update = null;
			        var forIn = true;
			        var left, right;
			        var node = this.createNode();
			        this.expectKeyword('for');
			        this.expect('(');
			        if (this.match(';')) {
			            this.nextToken();
			        }
			        else {
			            if (this.matchKeyword('var')) {
			                init = this.createNode();
			                this.nextToken();
			                var previousAllowIn = this.context.allowIn;
			                this.context.allowIn = false;
			                var declarations = this.parseVariableDeclarationList({ inFor: true });
			                this.context.allowIn = previousAllowIn;
			                if (declarations.length === 1 && this.matchKeyword('in')) {
			                    var decl = declarations[0];
			                    if (decl.init && (decl.id.type === syntax_1.Syntax.ArrayPattern || decl.id.type === syntax_1.Syntax.ObjectPattern || this.context.strict)) {
			                        this.tolerateError(messages_1.Messages.ForInOfLoopInitializer, 'for-in');
			                    }
			                    init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
			                    this.nextToken();
			                    left = init;
			                    right = this.parseExpression();
			                    init = null;
			                }
			                else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword('of')) {
			                    init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
			                    this.nextToken();
			                    left = init;
			                    right = this.parseAssignmentExpression();
			                    init = null;
			                    forIn = false;
			                }
			                else {
			                    init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
			                    this.expect(';');
			                }
			            }
			            else if (this.matchKeyword('const') || this.matchKeyword('let')) {
			                init = this.createNode();
			                var kind = this.nextToken().value;
			                if (!this.context.strict && this.lookahead.value === 'in') {
			                    init = this.finalize(init, new Node.Identifier(kind));
			                    this.nextToken();
			                    left = init;
			                    right = this.parseExpression();
			                    init = null;
			                }
			                else {
			                    var previousAllowIn = this.context.allowIn;
			                    this.context.allowIn = false;
			                    var declarations = this.parseBindingList(kind, { inFor: true });
			                    this.context.allowIn = previousAllowIn;
			                    if (declarations.length === 1 && declarations[0].init === null && this.matchKeyword('in')) {
			                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
			                        this.nextToken();
			                        left = init;
			                        right = this.parseExpression();
			                        init = null;
			                    }
			                    else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword('of')) {
			                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
			                        this.nextToken();
			                        left = init;
			                        right = this.parseAssignmentExpression();
			                        init = null;
			                        forIn = false;
			                    }
			                    else {
			                        this.consumeSemicolon();
			                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
			                    }
			                }
			            }
			            else {
			                var initStartToken = this.lookahead;
			                var previousAllowIn = this.context.allowIn;
			                this.context.allowIn = false;
			                init = this.inheritCoverGrammar(this.parseAssignmentExpression);
			                this.context.allowIn = previousAllowIn;
			                if (this.matchKeyword('in')) {
			                    if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
			                        this.tolerateError(messages_1.Messages.InvalidLHSInForIn);
			                    }
			                    this.nextToken();
			                    this.reinterpretExpressionAsPattern(init);
			                    left = init;
			                    right = this.parseExpression();
			                    init = null;
			                }
			                else if (this.matchContextualKeyword('of')) {
			                    if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
			                        this.tolerateError(messages_1.Messages.InvalidLHSInForLoop);
			                    }
			                    this.nextToken();
			                    this.reinterpretExpressionAsPattern(init);
			                    left = init;
			                    right = this.parseAssignmentExpression();
			                    init = null;
			                    forIn = false;
			                }
			                else {
			                    if (this.match(',')) {
			                        var initSeq = [init];
			                        while (this.match(',')) {
			                            this.nextToken();
			                            initSeq.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
			                        }
			                        init = this.finalize(this.startNode(initStartToken), new Node.SequenceExpression(initSeq));
			                    }
			                    this.expect(';');
			                }
			            }
			        }
			        if (typeof left === 'undefined') {
			            if (!this.match(';')) {
			                test = this.parseExpression();
			            }
			            this.expect(';');
			            if (!this.match(')')) {
			                update = this.parseExpression();
			            }
			        }
			        var body;
			        if (!this.match(')') && this.config.tolerant) {
			            this.tolerateUnexpectedToken(this.nextToken());
			            body = this.finalize(this.createNode(), new Node.EmptyStatement());
			        }
			        else {
			            this.expect(')');
			            var previousInIteration = this.context.inIteration;
			            this.context.inIteration = true;
			            body = this.isolateCoverGrammar(this.parseStatement);
			            this.context.inIteration = previousInIteration;
			        }
			        return (typeof left === 'undefined') ?
			            this.finalize(node, new Node.ForStatement(init, test, update, body)) :
			            forIn ? this.finalize(node, new Node.ForInStatement(left, right, body)) :
			                this.finalize(node, new Node.ForOfStatement(left, right, body));
			    };
			    Parser.prototype.parseContinueStatement = function () {
			        var node = this.createNode();
			        this.expectKeyword('continue');
			        var label = null;
			        if (this.lookahead.type === 3  && !this.hasLineTerminator) {
			            var id = this.parseVariableIdentifier();
			            label = id;
			            var key = '$' + id.name;
			            if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
			                this.throwError(messages_1.Messages.UnknownLabel, id.name);
			            }
			        }
			        this.consumeSemicolon();
			        if (label === null && !this.context.inIteration) {
			            this.throwError(messages_1.Messages.IllegalContinue);
			        }
			        return this.finalize(node, new Node.ContinueStatement(label));
			    };
			    Parser.prototype.parseBreakStatement = function () {
			        var node = this.createNode();
			        this.expectKeyword('break');
			        var label = null;
			        if (this.lookahead.type === 3  && !this.hasLineTerminator) {
			            var id = this.parseVariableIdentifier();
			            var key = '$' + id.name;
			            if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
			                this.throwError(messages_1.Messages.UnknownLabel, id.name);
			            }
			            label = id;
			        }
			        this.consumeSemicolon();
			        if (label === null && !this.context.inIteration && !this.context.inSwitch) {
			            this.throwError(messages_1.Messages.IllegalBreak);
			        }
			        return this.finalize(node, new Node.BreakStatement(label));
			    };
			    Parser.prototype.parseReturnStatement = function () {
			        if (!this.context.inFunctionBody) {
			            this.tolerateError(messages_1.Messages.IllegalReturn);
			        }
			        var node = this.createNode();
			        this.expectKeyword('return');
			        var hasArgument = (!this.match(';') && !this.match('}') &&
			            !this.hasLineTerminator && this.lookahead.type !== 2 ) ||
			            this.lookahead.type === 8  ||
			            this.lookahead.type === 10 ;
			        var argument = hasArgument ? this.parseExpression() : null;
			        this.consumeSemicolon();
			        return this.finalize(node, new Node.ReturnStatement(argument));
			    };
			    Parser.prototype.parseWithStatement = function () {
			        if (this.context.strict) {
			            this.tolerateError(messages_1.Messages.StrictModeWith);
			        }
			        var node = this.createNode();
			        var body;
			        this.expectKeyword('with');
			        this.expect('(');
			        var object = this.parseExpression();
			        if (!this.match(')') && this.config.tolerant) {
			            this.tolerateUnexpectedToken(this.nextToken());
			            body = this.finalize(this.createNode(), new Node.EmptyStatement());
			        }
			        else {
			            this.expect(')');
			            body = this.parseStatement();
			        }
			        return this.finalize(node, new Node.WithStatement(object, body));
			    };
			    Parser.prototype.parseSwitchCase = function () {
			        var node = this.createNode();
			        var test;
			        if (this.matchKeyword('default')) {
			            this.nextToken();
			            test = null;
			        }
			        else {
			            this.expectKeyword('case');
			            test = this.parseExpression();
			        }
			        this.expect(':');
			        var consequent = [];
			        while (true) {
			            if (this.match('}') || this.matchKeyword('default') || this.matchKeyword('case')) {
			                break;
			            }
			            consequent.push(this.parseStatementListItem());
			        }
			        return this.finalize(node, new Node.SwitchCase(test, consequent));
			    };
			    Parser.prototype.parseSwitchStatement = function () {
			        var node = this.createNode();
			        this.expectKeyword('switch');
			        this.expect('(');
			        var discriminant = this.parseExpression();
			        this.expect(')');
			        var previousInSwitch = this.context.inSwitch;
			        this.context.inSwitch = true;
			        var cases = [];
			        var defaultFound = false;
			        this.expect('{');
			        while (true) {
			            if (this.match('}')) {
			                break;
			            }
			            var clause = this.parseSwitchCase();
			            if (clause.test === null) {
			                if (defaultFound) {
			                    this.throwError(messages_1.Messages.MultipleDefaultsInSwitch);
			                }
			                defaultFound = true;
			            }
			            cases.push(clause);
			        }
			        this.expect('}');
			        this.context.inSwitch = previousInSwitch;
			        return this.finalize(node, new Node.SwitchStatement(discriminant, cases));
			    };
			    Parser.prototype.parseLabelledStatement = function () {
			        var node = this.createNode();
			        var expr = this.parseExpression();
			        var statement;
			        if ((expr.type === syntax_1.Syntax.Identifier) && this.match(':')) {
			            this.nextToken();
			            var id = expr;
			            var key = '$' + id.name;
			            if (Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
			                this.throwError(messages_1.Messages.Redeclaration, 'Label', id.name);
			            }
			            this.context.labelSet[key] = true;
			            var body = void 0;
			            if (this.matchKeyword('class')) {
			                this.tolerateUnexpectedToken(this.lookahead);
			                body = this.parseClassDeclaration();
			            }
			            else if (this.matchKeyword('function')) {
			                var token = this.lookahead;
			                var declaration = this.parseFunctionDeclaration();
			                if (this.context.strict) {
			                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunction);
			                }
			                else if (declaration.generator) {
			                    this.tolerateUnexpectedToken(token, messages_1.Messages.GeneratorInLegacyContext);
			                }
			                body = declaration;
			            }
			            else {
			                body = this.parseStatement();
			            }
			            delete this.context.labelSet[key];
			            statement = new Node.LabeledStatement(id, body);
			        }
			        else {
			            this.consumeSemicolon();
			            statement = new Node.ExpressionStatement(expr);
			        }
			        return this.finalize(node, statement);
			    };
			    Parser.prototype.parseThrowStatement = function () {
			        var node = this.createNode();
			        this.expectKeyword('throw');
			        if (this.hasLineTerminator) {
			            this.throwError(messages_1.Messages.NewlineAfterThrow);
			        }
			        var argument = this.parseExpression();
			        this.consumeSemicolon();
			        return this.finalize(node, new Node.ThrowStatement(argument));
			    };
			    Parser.prototype.parseCatchClause = function () {
			        var node = this.createNode();
			        this.expectKeyword('catch');
			        this.expect('(');
			        if (this.match(')')) {
			            this.throwUnexpectedToken(this.lookahead);
			        }
			        var params = [];
			        var param = this.parsePattern(params);
			        var paramMap = {};
			        for (var i = 0; i < params.length; i++) {
			            var key = '$' + params[i].value;
			            if (Object.prototype.hasOwnProperty.call(paramMap, key)) {
			                this.tolerateError(messages_1.Messages.DuplicateBinding, params[i].value);
			            }
			            paramMap[key] = true;
			        }
			        if (this.context.strict && param.type === syntax_1.Syntax.Identifier) {
			            if (this.scanner.isRestrictedWord(param.name)) {
			                this.tolerateError(messages_1.Messages.StrictCatchVariable);
			            }
			        }
			        this.expect(')');
			        var body = this.parseBlock();
			        return this.finalize(node, new Node.CatchClause(param, body));
			    };
			    Parser.prototype.parseFinallyClause = function () {
			        this.expectKeyword('finally');
			        return this.parseBlock();
			    };
			    Parser.prototype.parseTryStatement = function () {
			        var node = this.createNode();
			        this.expectKeyword('try');
			        var block = this.parseBlock();
			        var handler = this.matchKeyword('catch') ? this.parseCatchClause() : null;
			        var finalizer = this.matchKeyword('finally') ? this.parseFinallyClause() : null;
			        if (!handler && !finalizer) {
			            this.throwError(messages_1.Messages.NoCatchOrFinally);
			        }
			        return this.finalize(node, new Node.TryStatement(block, handler, finalizer));
			    };
			    Parser.prototype.parseDebuggerStatement = function () {
			        var node = this.createNode();
			        this.expectKeyword('debugger');
			        this.consumeSemicolon();
			        return this.finalize(node, new Node.DebuggerStatement());
			    };
			    Parser.prototype.parseStatement = function () {
			        var statement;
			        switch (this.lookahead.type) {
			            case 1 :
			            case 5 :
			            case 6 :
			            case 8 :
			            case 10 :
			            case 9 :
			                statement = this.parseExpressionStatement();
			                break;
			            case 7 :
			                var value = this.lookahead.value;
			                if (value === '{') {
			                    statement = this.parseBlock();
			                }
			                else if (value === '(') {
			                    statement = this.parseExpressionStatement();
			                }
			                else if (value === ';') {
			                    statement = this.parseEmptyStatement();
			                }
			                else {
			                    statement = this.parseExpressionStatement();
			                }
			                break;
			            case 3 :
			                statement = this.matchAsyncFunction() ? this.parseFunctionDeclaration() : this.parseLabelledStatement();
			                break;
			            case 4 :
			                switch (this.lookahead.value) {
			                    case 'break':
			                        statement = this.parseBreakStatement();
			                        break;
			                    case 'continue':
			                        statement = this.parseContinueStatement();
			                        break;
			                    case 'debugger':
			                        statement = this.parseDebuggerStatement();
			                        break;
			                    case 'do':
			                        statement = this.parseDoWhileStatement();
			                        break;
			                    case 'for':
			                        statement = this.parseForStatement();
			                        break;
			                    case 'function':
			                        statement = this.parseFunctionDeclaration();
			                        break;
			                    case 'if':
			                        statement = this.parseIfStatement();
			                        break;
			                    case 'return':
			                        statement = this.parseReturnStatement();
			                        break;
			                    case 'switch':
			                        statement = this.parseSwitchStatement();
			                        break;
			                    case 'throw':
			                        statement = this.parseThrowStatement();
			                        break;
			                    case 'try':
			                        statement = this.parseTryStatement();
			                        break;
			                    case 'var':
			                        statement = this.parseVariableStatement();
			                        break;
			                    case 'while':
			                        statement = this.parseWhileStatement();
			                        break;
			                    case 'with':
			                        statement = this.parseWithStatement();
			                        break;
			                    default:
			                        statement = this.parseExpressionStatement();
			                        break;
			                }
			                break;
			            default:
			                statement = this.throwUnexpectedToken(this.lookahead);
			        }
			        return statement;
			    };
			    Parser.prototype.parseFunctionSourceElements = function () {
			        var node = this.createNode();
			        this.expect('{');
			        var body = this.parseDirectivePrologues();
			        var previousLabelSet = this.context.labelSet;
			        var previousInIteration = this.context.inIteration;
			        var previousInSwitch = this.context.inSwitch;
			        var previousInFunctionBody = this.context.inFunctionBody;
			        this.context.labelSet = {};
			        this.context.inIteration = false;
			        this.context.inSwitch = false;
			        this.context.inFunctionBody = true;
			        while (this.lookahead.type !== 2 ) {
			            if (this.match('}')) {
			                break;
			            }
			            body.push(this.parseStatementListItem());
			        }
			        this.expect('}');
			        this.context.labelSet = previousLabelSet;
			        this.context.inIteration = previousInIteration;
			        this.context.inSwitch = previousInSwitch;
			        this.context.inFunctionBody = previousInFunctionBody;
			        return this.finalize(node, new Node.BlockStatement(body));
			    };
			    Parser.prototype.validateParam = function (options, param, name) {
			        var key = '$' + name;
			        if (this.context.strict) {
			            if (this.scanner.isRestrictedWord(name)) {
			                options.stricted = param;
			                options.message = messages_1.Messages.StrictParamName;
			            }
			            if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
			                options.stricted = param;
			                options.message = messages_1.Messages.StrictParamDupe;
			            }
			        }
			        else if (!options.firstRestricted) {
			            if (this.scanner.isRestrictedWord(name)) {
			                options.firstRestricted = param;
			                options.message = messages_1.Messages.StrictParamName;
			            }
			            else if (this.scanner.isStrictModeReservedWord(name)) {
			                options.firstRestricted = param;
			                options.message = messages_1.Messages.StrictReservedWord;
			            }
			            else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
			                options.stricted = param;
			                options.message = messages_1.Messages.StrictParamDupe;
			            }
			        }
			        if (typeof Object.defineProperty === 'function') {
			            Object.defineProperty(options.paramSet, key, { value: true, enumerable: true, writable: true, configurable: true });
			        }
			        else {
			            options.paramSet[key] = true;
			        }
			    };
			    Parser.prototype.parseRestElement = function (params) {
			        var node = this.createNode();
			        this.expect('...');
			        var arg = this.parsePattern(params);
			        if (this.match('=')) {
			            this.throwError(messages_1.Messages.DefaultRestParameter);
			        }
			        if (!this.match(')')) {
			            this.throwError(messages_1.Messages.ParameterAfterRestParameter);
			        }
			        return this.finalize(node, new Node.RestElement(arg));
			    };
			    Parser.prototype.parseFormalParameter = function (options) {
			        var params = [];
			        var param = this.match('...') ? this.parseRestElement(params) : this.parsePatternWithDefault(params);
			        for (var i = 0; i < params.length; i++) {
			            this.validateParam(options, params[i], params[i].value);
			        }
			        options.simple = options.simple && (param instanceof Node.Identifier);
			        options.params.push(param);
			    };
			    Parser.prototype.parseFormalParameters = function (firstRestricted) {
			        var options;
			        options = {
			            simple: true,
			            params: [],
			            firstRestricted: firstRestricted
			        };
			        this.expect('(');
			        if (!this.match(')')) {
			            options.paramSet = {};
			            while (this.lookahead.type !== 2 ) {
			                this.parseFormalParameter(options);
			                if (this.match(')')) {
			                    break;
			                }
			                this.expect(',');
			                if (this.match(')')) {
			                    break;
			                }
			            }
			        }
			        this.expect(')');
			        return {
			            simple: options.simple,
			            params: options.params,
			            stricted: options.stricted,
			            firstRestricted: options.firstRestricted,
			            message: options.message
			        };
			    };
			    Parser.prototype.matchAsyncFunction = function () {
			        var match = this.matchContextualKeyword('async');
			        if (match) {
			            var state = this.scanner.saveState();
			            this.scanner.scanComments();
			            var next = this.scanner.lex();
			            this.scanner.restoreState(state);
			            match = (state.lineNumber === next.lineNumber) && (next.type === 4 ) && (next.value === 'function');
			        }
			        return match;
			    };
			    Parser.prototype.parseFunctionDeclaration = function (identifierIsOptional) {
			        var node = this.createNode();
			        var isAsync = this.matchContextualKeyword('async');
			        if (isAsync) {
			            this.nextToken();
			        }
			        this.expectKeyword('function');
			        var isGenerator = isAsync ? false : this.match('*');
			        if (isGenerator) {
			            this.nextToken();
			        }
			        var message;
			        var id = null;
			        var firstRestricted = null;
			        if (!identifierIsOptional || !this.match('(')) {
			            var token = this.lookahead;
			            id = this.parseVariableIdentifier();
			            if (this.context.strict) {
			                if (this.scanner.isRestrictedWord(token.value)) {
			                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
			                }
			            }
			            else {
			                if (this.scanner.isRestrictedWord(token.value)) {
			                    firstRestricted = token;
			                    message = messages_1.Messages.StrictFunctionName;
			                }
			                else if (this.scanner.isStrictModeReservedWord(token.value)) {
			                    firstRestricted = token;
			                    message = messages_1.Messages.StrictReservedWord;
			                }
			            }
			        }
			        var previousAllowAwait = this.context.await;
			        var previousAllowYield = this.context.allowYield;
			        this.context.await = isAsync;
			        this.context.allowYield = !isGenerator;
			        var formalParameters = this.parseFormalParameters(firstRestricted);
			        var params = formalParameters.params;
			        var stricted = formalParameters.stricted;
			        firstRestricted = formalParameters.firstRestricted;
			        if (formalParameters.message) {
			            message = formalParameters.message;
			        }
			        var previousStrict = this.context.strict;
			        var previousAllowStrictDirective = this.context.allowStrictDirective;
			        this.context.allowStrictDirective = formalParameters.simple;
			        var body = this.parseFunctionSourceElements();
			        if (this.context.strict && firstRestricted) {
			            this.throwUnexpectedToken(firstRestricted, message);
			        }
			        if (this.context.strict && stricted) {
			            this.tolerateUnexpectedToken(stricted, message);
			        }
			        this.context.strict = previousStrict;
			        this.context.allowStrictDirective = previousAllowStrictDirective;
			        this.context.await = previousAllowAwait;
			        this.context.allowYield = previousAllowYield;
			        return isAsync ? this.finalize(node, new Node.AsyncFunctionDeclaration(id, params, body)) :
			            this.finalize(node, new Node.FunctionDeclaration(id, params, body, isGenerator));
			    };
			    Parser.prototype.parseFunctionExpression = function () {
			        var node = this.createNode();
			        var isAsync = this.matchContextualKeyword('async');
			        if (isAsync) {
			            this.nextToken();
			        }
			        this.expectKeyword('function');
			        var isGenerator = isAsync ? false : this.match('*');
			        if (isGenerator) {
			            this.nextToken();
			        }
			        var message;
			        var id = null;
			        var firstRestricted;
			        var previousAllowAwait = this.context.await;
			        var previousAllowYield = this.context.allowYield;
			        this.context.await = isAsync;
			        this.context.allowYield = !isGenerator;
			        if (!this.match('(')) {
			            var token = this.lookahead;
			            id = (!this.context.strict && !isGenerator && this.matchKeyword('yield')) ? this.parseIdentifierName() : this.parseVariableIdentifier();
			            if (this.context.strict) {
			                if (this.scanner.isRestrictedWord(token.value)) {
			                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
			                }
			            }
			            else {
			                if (this.scanner.isRestrictedWord(token.value)) {
			                    firstRestricted = token;
			                    message = messages_1.Messages.StrictFunctionName;
			                }
			                else if (this.scanner.isStrictModeReservedWord(token.value)) {
			                    firstRestricted = token;
			                    message = messages_1.Messages.StrictReservedWord;
			                }
			            }
			        }
			        var formalParameters = this.parseFormalParameters(firstRestricted);
			        var params = formalParameters.params;
			        var stricted = formalParameters.stricted;
			        firstRestricted = formalParameters.firstRestricted;
			        if (formalParameters.message) {
			            message = formalParameters.message;
			        }
			        var previousStrict = this.context.strict;
			        var previousAllowStrictDirective = this.context.allowStrictDirective;
			        this.context.allowStrictDirective = formalParameters.simple;
			        var body = this.parseFunctionSourceElements();
			        if (this.context.strict && firstRestricted) {
			            this.throwUnexpectedToken(firstRestricted, message);
			        }
			        if (this.context.strict && stricted) {
			            this.tolerateUnexpectedToken(stricted, message);
			        }
			        this.context.strict = previousStrict;
			        this.context.allowStrictDirective = previousAllowStrictDirective;
			        this.context.await = previousAllowAwait;
			        this.context.allowYield = previousAllowYield;
			        return isAsync ? this.finalize(node, new Node.AsyncFunctionExpression(id, params, body)) :
			            this.finalize(node, new Node.FunctionExpression(id, params, body, isGenerator));
			    };
			    Parser.prototype.parseDirective = function () {
			        var token = this.lookahead;
			        var node = this.createNode();
			        var expr = this.parseExpression();
			        var directive = (expr.type === syntax_1.Syntax.Literal) ? this.getTokenRaw(token).slice(1, -1) : null;
			        this.consumeSemicolon();
			        return this.finalize(node, directive ? new Node.Directive(expr, directive) : new Node.ExpressionStatement(expr));
			    };
			    Parser.prototype.parseDirectivePrologues = function () {
			        var firstRestricted = null;
			        var body = [];
			        while (true) {
			            var token = this.lookahead;
			            if (token.type !== 8 ) {
			                break;
			            }
			            var statement = this.parseDirective();
			            body.push(statement);
			            var directive = statement.directive;
			            if (typeof directive !== 'string') {
			                break;
			            }
			            if (directive === 'use strict') {
			                this.context.strict = true;
			                if (firstRestricted) {
			                    this.tolerateUnexpectedToken(firstRestricted, messages_1.Messages.StrictOctalLiteral);
			                }
			                if (!this.context.allowStrictDirective) {
			                    this.tolerateUnexpectedToken(token, messages_1.Messages.IllegalLanguageModeDirective);
			                }
			            }
			            else {
			                if (!firstRestricted && token.octal) {
			                    firstRestricted = token;
			                }
			            }
			        }
			        return body;
			    };
			    Parser.prototype.qualifiedPropertyName = function (token) {
			        switch (token.type) {
			            case 3 :
			            case 8 :
			            case 1 :
			            case 5 :
			            case 6 :
			            case 4 :
			                return true;
			            case 7 :
			                return token.value === '[';
			        }
			        return false;
			    };
			    Parser.prototype.parseGetterMethod = function () {
			        var node = this.createNode();
			        var isGenerator = false;
			        var previousAllowYield = this.context.allowYield;
			        this.context.allowYield = !isGenerator;
			        var formalParameters = this.parseFormalParameters();
			        if (formalParameters.params.length > 0) {
			            this.tolerateError(messages_1.Messages.BadGetterArity);
			        }
			        var method = this.parsePropertyMethod(formalParameters);
			        this.context.allowYield = previousAllowYield;
			        return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
			    };
			    Parser.prototype.parseSetterMethod = function () {
			        var node = this.createNode();
			        var isGenerator = false;
			        var previousAllowYield = this.context.allowYield;
			        this.context.allowYield = !isGenerator;
			        var formalParameters = this.parseFormalParameters();
			        if (formalParameters.params.length !== 1) {
			            this.tolerateError(messages_1.Messages.BadSetterArity);
			        }
			        else if (formalParameters.params[0] instanceof Node.RestElement) {
			            this.tolerateError(messages_1.Messages.BadSetterRestParameter);
			        }
			        var method = this.parsePropertyMethod(formalParameters);
			        this.context.allowYield = previousAllowYield;
			        return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
			    };
			    Parser.prototype.parseGeneratorMethod = function () {
			        var node = this.createNode();
			        var isGenerator = true;
			        var previousAllowYield = this.context.allowYield;
			        this.context.allowYield = true;
			        var params = this.parseFormalParameters();
			        this.context.allowYield = false;
			        var method = this.parsePropertyMethod(params);
			        this.context.allowYield = previousAllowYield;
			        return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
			    };
			    Parser.prototype.isStartOfExpression = function () {
			        var start = true;
			        var value = this.lookahead.value;
			        switch (this.lookahead.type) {
			            case 7 :
			                start = (value === '[') || (value === '(') || (value === '{') ||
			                    (value === '+') || (value === '-') ||
			                    (value === '!') || (value === '~') ||
			                    (value === '++') || (value === '--') ||
			                    (value === '/') || (value === '/=');
			                break;
			            case 4 :
			                start = (value === 'class') || (value === 'delete') ||
			                    (value === 'function') || (value === 'let') || (value === 'new') ||
			                    (value === 'super') || (value === 'this') || (value === 'typeof') ||
			                    (value === 'void') || (value === 'yield');
			                break;
			        }
			        return start;
			    };
			    Parser.prototype.parseYieldExpression = function () {
			        var node = this.createNode();
			        this.expectKeyword('yield');
			        var argument = null;
			        var delegate = false;
			        if (!this.hasLineTerminator) {
			            var previousAllowYield = this.context.allowYield;
			            this.context.allowYield = false;
			            delegate = this.match('*');
			            if (delegate) {
			                this.nextToken();
			                argument = this.parseAssignmentExpression();
			            }
			            else if (this.isStartOfExpression()) {
			                argument = this.parseAssignmentExpression();
			            }
			            this.context.allowYield = previousAllowYield;
			        }
			        return this.finalize(node, new Node.YieldExpression(argument, delegate));
			    };
			    Parser.prototype.parseClassElement = function (hasConstructor) {
			        var token = this.lookahead;
			        var node = this.createNode();
			        var kind = '';
			        var key = null;
			        var value = null;
			        var computed = false;
			        var method = false;
			        var isStatic = false;
			        var isAsync = false;
			        if (this.match('*')) {
			            this.nextToken();
			        }
			        else {
			            computed = this.match('[');
			            key = this.parseObjectPropertyKey();
			            var id = key;
			            if (id.name === 'static' && (this.qualifiedPropertyName(this.lookahead) || this.match('*'))) {
			                token = this.lookahead;
			                isStatic = true;
			                computed = this.match('[');
			                if (this.match('*')) {
			                    this.nextToken();
			                }
			                else {
			                    key = this.parseObjectPropertyKey();
			                }
			            }
			            if ((token.type === 3 ) && !this.hasLineTerminator && (token.value === 'async')) {
			                var punctuator = this.lookahead.value;
			                if (punctuator !== ':' && punctuator !== '(' && punctuator !== '*') {
			                    isAsync = true;
			                    token = this.lookahead;
			                    key = this.parseObjectPropertyKey();
			                    if (token.type === 3  && token.value === 'constructor') {
			                        this.tolerateUnexpectedToken(token, messages_1.Messages.ConstructorIsAsync);
			                    }
			                }
			            }
			        }
			        var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
			        if (token.type === 3 ) {
			            if (token.value === 'get' && lookaheadPropertyKey) {
			                kind = 'get';
			                computed = this.match('[');
			                key = this.parseObjectPropertyKey();
			                this.context.allowYield = false;
			                value = this.parseGetterMethod();
			            }
			            else if (token.value === 'set' && lookaheadPropertyKey) {
			                kind = 'set';
			                computed = this.match('[');
			                key = this.parseObjectPropertyKey();
			                value = this.parseSetterMethod();
			            }
			        }
			        else if (token.type === 7  && token.value === '*' && lookaheadPropertyKey) {
			            kind = 'init';
			            computed = this.match('[');
			            key = this.parseObjectPropertyKey();
			            value = this.parseGeneratorMethod();
			            method = true;
			        }
			        if (!kind && key && this.match('(')) {
			            kind = 'init';
			            value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
			            method = true;
			        }
			        if (!kind) {
			            this.throwUnexpectedToken(this.lookahead);
			        }
			        if (kind === 'init') {
			            kind = 'method';
			        }
			        if (!computed) {
			            if (isStatic && this.isPropertyKey(key, 'prototype')) {
			                this.throwUnexpectedToken(token, messages_1.Messages.StaticPrototype);
			            }
			            if (!isStatic && this.isPropertyKey(key, 'constructor')) {
			                if (kind !== 'method' || !method || (value && value.generator)) {
			                    this.throwUnexpectedToken(token, messages_1.Messages.ConstructorSpecialMethod);
			                }
			                if (hasConstructor.value) {
			                    this.throwUnexpectedToken(token, messages_1.Messages.DuplicateConstructor);
			                }
			                else {
			                    hasConstructor.value = true;
			                }
			                kind = 'constructor';
			            }
			        }
			        return this.finalize(node, new Node.MethodDefinition(key, computed, value, kind, isStatic));
			    };
			    Parser.prototype.parseClassElementList = function () {
			        var body = [];
			        var hasConstructor = { value: false };
			        this.expect('{');
			        while (!this.match('}')) {
			            if (this.match(';')) {
			                this.nextToken();
			            }
			            else {
			                body.push(this.parseClassElement(hasConstructor));
			            }
			        }
			        this.expect('}');
			        return body;
			    };
			    Parser.prototype.parseClassBody = function () {
			        var node = this.createNode();
			        var elementList = this.parseClassElementList();
			        return this.finalize(node, new Node.ClassBody(elementList));
			    };
			    Parser.prototype.parseClassDeclaration = function (identifierIsOptional) {
			        var node = this.createNode();
			        var previousStrict = this.context.strict;
			        this.context.strict = true;
			        this.expectKeyword('class');
			        var id = (identifierIsOptional && (this.lookahead.type !== 3 )) ? null : this.parseVariableIdentifier();
			        var superClass = null;
			        if (this.matchKeyword('extends')) {
			            this.nextToken();
			            superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
			        }
			        var classBody = this.parseClassBody();
			        this.context.strict = previousStrict;
			        return this.finalize(node, new Node.ClassDeclaration(id, superClass, classBody));
			    };
			    Parser.prototype.parseClassExpression = function () {
			        var node = this.createNode();
			        var previousStrict = this.context.strict;
			        this.context.strict = true;
			        this.expectKeyword('class');
			        var id = (this.lookahead.type === 3 ) ? this.parseVariableIdentifier() : null;
			        var superClass = null;
			        if (this.matchKeyword('extends')) {
			            this.nextToken();
			            superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
			        }
			        var classBody = this.parseClassBody();
			        this.context.strict = previousStrict;
			        return this.finalize(node, new Node.ClassExpression(id, superClass, classBody));
			    };
			    Parser.prototype.parseModule = function () {
			        this.context.strict = true;
			        this.context.isModule = true;
			        this.scanner.isModule = true;
			        var node = this.createNode();
			        var body = this.parseDirectivePrologues();
			        while (this.lookahead.type !== 2 ) {
			            body.push(this.parseStatementListItem());
			        }
			        return this.finalize(node, new Node.Module(body));
			    };
			    Parser.prototype.parseScript = function () {
			        var node = this.createNode();
			        var body = this.parseDirectivePrologues();
			        while (this.lookahead.type !== 2 ) {
			            body.push(this.parseStatementListItem());
			        }
			        return this.finalize(node, new Node.Script(body));
			    };
			    Parser.prototype.parseModuleSpecifier = function () {
			        var node = this.createNode();
			        if (this.lookahead.type !== 8 ) {
			            this.throwError(messages_1.Messages.InvalidModuleSpecifier);
			        }
			        var token = this.nextToken();
			        var raw = this.getTokenRaw(token);
			        return this.finalize(node, new Node.Literal(token.value, raw));
			    };
			    Parser.prototype.parseImportSpecifier = function () {
			        var node = this.createNode();
			        var imported;
			        var local;
			        if (this.lookahead.type === 3 ) {
			            imported = this.parseVariableIdentifier();
			            local = imported;
			            if (this.matchContextualKeyword('as')) {
			                this.nextToken();
			                local = this.parseVariableIdentifier();
			            }
			        }
			        else {
			            imported = this.parseIdentifierName();
			            local = imported;
			            if (this.matchContextualKeyword('as')) {
			                this.nextToken();
			                local = this.parseVariableIdentifier();
			            }
			            else {
			                this.throwUnexpectedToken(this.nextToken());
			            }
			        }
			        return this.finalize(node, new Node.ImportSpecifier(local, imported));
			    };
			    Parser.prototype.parseNamedImports = function () {
			        this.expect('{');
			        var specifiers = [];
			        while (!this.match('}')) {
			            specifiers.push(this.parseImportSpecifier());
			            if (!this.match('}')) {
			                this.expect(',');
			            }
			        }
			        this.expect('}');
			        return specifiers;
			    };
			    Parser.prototype.parseImportDefaultSpecifier = function () {
			        var node = this.createNode();
			        var local = this.parseIdentifierName();
			        return this.finalize(node, new Node.ImportDefaultSpecifier(local));
			    };
			    Parser.prototype.parseImportNamespaceSpecifier = function () {
			        var node = this.createNode();
			        this.expect('*');
			        if (!this.matchContextualKeyword('as')) {
			            this.throwError(messages_1.Messages.NoAsAfterImportNamespace);
			        }
			        this.nextToken();
			        var local = this.parseIdentifierName();
			        return this.finalize(node, new Node.ImportNamespaceSpecifier(local));
			    };
			    Parser.prototype.parseImportDeclaration = function () {
			        if (this.context.inFunctionBody) {
			            this.throwError(messages_1.Messages.IllegalImportDeclaration);
			        }
			        var node = this.createNode();
			        this.expectKeyword('import');
			        var src;
			        var specifiers = [];
			        if (this.lookahead.type === 8 ) {
			            src = this.parseModuleSpecifier();
			        }
			        else {
			            if (this.match('{')) {
			                specifiers = specifiers.concat(this.parseNamedImports());
			            }
			            else if (this.match('*')) {
			                specifiers.push(this.parseImportNamespaceSpecifier());
			            }
			            else if (this.isIdentifierName(this.lookahead) && !this.matchKeyword('default')) {
			                specifiers.push(this.parseImportDefaultSpecifier());
			                if (this.match(',')) {
			                    this.nextToken();
			                    if (this.match('*')) {
			                        specifiers.push(this.parseImportNamespaceSpecifier());
			                    }
			                    else if (this.match('{')) {
			                        specifiers = specifiers.concat(this.parseNamedImports());
			                    }
			                    else {
			                        this.throwUnexpectedToken(this.lookahead);
			                    }
			                }
			            }
			            else {
			                this.throwUnexpectedToken(this.nextToken());
			            }
			            if (!this.matchContextualKeyword('from')) {
			                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
			                this.throwError(message, this.lookahead.value);
			            }
			            this.nextToken();
			            src = this.parseModuleSpecifier();
			        }
			        this.consumeSemicolon();
			        return this.finalize(node, new Node.ImportDeclaration(specifiers, src));
			    };
			    Parser.prototype.parseExportSpecifier = function () {
			        var node = this.createNode();
			        var local = this.parseIdentifierName();
			        var exported = local;
			        if (this.matchContextualKeyword('as')) {
			            this.nextToken();
			            exported = this.parseIdentifierName();
			        }
			        return this.finalize(node, new Node.ExportSpecifier(local, exported));
			    };
			    Parser.prototype.parseExportDeclaration = function () {
			        if (this.context.inFunctionBody) {
			            this.throwError(messages_1.Messages.IllegalExportDeclaration);
			        }
			        var node = this.createNode();
			        this.expectKeyword('export');
			        var exportDeclaration;
			        if (this.matchKeyword('default')) {
			            this.nextToken();
			            if (this.matchKeyword('function')) {
			                var declaration = this.parseFunctionDeclaration(true);
			                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
			            }
			            else if (this.matchKeyword('class')) {
			                var declaration = this.parseClassDeclaration(true);
			                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
			            }
			            else if (this.matchContextualKeyword('async')) {
			                var declaration = this.matchAsyncFunction() ? this.parseFunctionDeclaration(true) : this.parseAssignmentExpression();
			                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
			            }
			            else {
			                if (this.matchContextualKeyword('from')) {
			                    this.throwError(messages_1.Messages.UnexpectedToken, this.lookahead.value);
			                }
			                var declaration = this.match('{') ? this.parseObjectInitializer() :
			                    this.match('[') ? this.parseArrayInitializer() : this.parseAssignmentExpression();
			                this.consumeSemicolon();
			                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
			            }
			        }
			        else if (this.match('*')) {
			            this.nextToken();
			            if (!this.matchContextualKeyword('from')) {
			                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
			                this.throwError(message, this.lookahead.value);
			            }
			            this.nextToken();
			            var src = this.parseModuleSpecifier();
			            this.consumeSemicolon();
			            exportDeclaration = this.finalize(node, new Node.ExportAllDeclaration(src));
			        }
			        else if (this.lookahead.type === 4 ) {
			            var declaration = void 0;
			            switch (this.lookahead.value) {
			                case 'let':
			                case 'const':
			                    declaration = this.parseLexicalDeclaration({ inFor: false });
			                    break;
			                case 'var':
			                case 'class':
			                case 'function':
			                    declaration = this.parseStatementListItem();
			                    break;
			                default:
			                    this.throwUnexpectedToken(this.lookahead);
			            }
			            exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
			        }
			        else if (this.matchAsyncFunction()) {
			            var declaration = this.parseFunctionDeclaration();
			            exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
			        }
			        else {
			            var specifiers = [];
			            var source = null;
			            var isExportFromIdentifier = false;
			            this.expect('{');
			            while (!this.match('}')) {
			                isExportFromIdentifier = isExportFromIdentifier || this.matchKeyword('default');
			                specifiers.push(this.parseExportSpecifier());
			                if (!this.match('}')) {
			                    this.expect(',');
			                }
			            }
			            this.expect('}');
			            if (this.matchContextualKeyword('from')) {
			                this.nextToken();
			                source = this.parseModuleSpecifier();
			                this.consumeSemicolon();
			            }
			            else if (isExportFromIdentifier) {
			                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
			                this.throwError(message, this.lookahead.value);
			            }
			            else {
			                this.consumeSemicolon();
			            }
			            exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(null, specifiers, source));
			        }
			        return exportDeclaration;
			    };
			    return Parser;
			}());
			exports.Parser = Parser;
		 },
		 function(module, exports) {
			Object.defineProperty(exports, "__esModule", { value: true });
			function assert(condition, message) {
			    if (!condition) {
			        throw new Error('ASSERT: ' + message);
			    }
			}
			exports.assert = assert;
		 },
		 function(module, exports) {
			Object.defineProperty(exports, "__esModule", { value: true });
			var ErrorHandler = (function () {
			    function ErrorHandler() {
			        this.errors = [];
			        this.tolerant = false;
			    }
			    ErrorHandler.prototype.recordError = function (error) {
			        this.errors.push(error);
			    };
			    ErrorHandler.prototype.tolerate = function (error) {
			        if (this.tolerant) {
			            this.recordError(error);
			        }
			        else {
			            throw error;
			        }
			    };
			    ErrorHandler.prototype.constructError = function (msg, column) {
			        var error = new Error(msg);
			        try {
			            throw error;
			        }
			        catch (base) {
			            if (Object.create && Object.defineProperty) {
			                error = Object.create(base);
			                Object.defineProperty(error, 'column', { value: column });
			            }
			        }
			        return error;
			    };
			    ErrorHandler.prototype.createError = function (index, line, col, description) {
			        var msg = 'Line ' + line + ': ' + description;
			        var error = this.constructError(msg, col);
			        error.index = index;
			        error.lineNumber = line;
			        error.description = description;
			        return error;
			    };
			    ErrorHandler.prototype.throwError = function (index, line, col, description) {
			        throw this.createError(index, line, col, description);
			    };
			    ErrorHandler.prototype.tolerateError = function (index, line, col, description) {
			        var error = this.createError(index, line, col, description);
			        if (this.tolerant) {
			            this.recordError(error);
			        }
			        else {
			            throw error;
			        }
			    };
			    return ErrorHandler;
			}());
			exports.ErrorHandler = ErrorHandler;
		 },
		 function(module, exports) {
			Object.defineProperty(exports, "__esModule", { value: true });
			exports.Messages = {
			    BadGetterArity: 'Getter must not have any formal parameters',
			    BadSetterArity: 'Setter must have exactly one formal parameter',
			    BadSetterRestParameter: 'Setter function argument must not be a rest parameter',
			    ConstructorIsAsync: 'Class constructor may not be an async method',
			    ConstructorSpecialMethod: 'Class constructor may not be an accessor',
			    DeclarationMissingInitializer: 'Missing initializer in %0 declaration',
			    DefaultRestParameter: 'Unexpected token =',
			    DuplicateBinding: 'Duplicate binding %0',
			    DuplicateConstructor: 'A class may only have one constructor',
			    DuplicateProtoProperty: 'Duplicate __proto__ fields are not allowed in object literals',
			    ForInOfLoopInitializer: '%0 loop variable declaration may not have an initializer',
			    GeneratorInLegacyContext: 'Generator declarations are not allowed in legacy contexts',
			    IllegalBreak: 'Illegal break statement',
			    IllegalContinue: 'Illegal continue statement',
			    IllegalExportDeclaration: 'Unexpected token',
			    IllegalImportDeclaration: 'Unexpected token',
			    IllegalLanguageModeDirective: 'Illegal \'use strict\' directive in function with non-simple parameter list',
			    IllegalReturn: 'Illegal return statement',
			    InvalidEscapedReservedWord: 'Keyword must not contain escaped characters',
			    InvalidHexEscapeSequence: 'Invalid hexadecimal escape sequence',
			    InvalidLHSInAssignment: 'Invalid left-hand side in assignment',
			    InvalidLHSInForIn: 'Invalid left-hand side in for-in',
			    InvalidLHSInForLoop: 'Invalid left-hand side in for-loop',
			    InvalidModuleSpecifier: 'Unexpected token',
			    InvalidRegExp: 'Invalid regular expression',
			    LetInLexicalBinding: 'let is disallowed as a lexically bound name',
			    MissingFromClause: 'Unexpected token',
			    MultipleDefaultsInSwitch: 'More than one default clause in switch statement',
			    NewlineAfterThrow: 'Illegal newline after throw',
			    NoAsAfterImportNamespace: 'Unexpected token',
			    NoCatchOrFinally: 'Missing catch or finally after try',
			    ParameterAfterRestParameter: 'Rest parameter must be last formal parameter',
			    Redeclaration: '%0 \'%1\' has already been declared',
			    StaticPrototype: 'Classes may not have static property named prototype',
			    StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',
			    StrictDelete: 'Delete of an unqualified identifier in strict mode.',
			    StrictFunction: 'In strict mode code, functions can only be declared at top level or inside a block',
			    StrictFunctionName: 'Function name may not be eval or arguments in strict mode',
			    StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',
			    StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',
			    StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',
			    StrictModeWith: 'Strict mode code may not include a with statement',
			    StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',
			    StrictParamDupe: 'Strict mode function may not have duplicate parameter names',
			    StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',
			    StrictReservedWord: 'Use of future reserved word in strict mode',
			    StrictVarName: 'Variable name may not be eval or arguments in strict mode',
			    TemplateOctalLiteral: 'Octal literals are not allowed in template strings.',
			    UnexpectedEOS: 'Unexpected end of input',
			    UnexpectedIdentifier: 'Unexpected identifier',
			    UnexpectedNumber: 'Unexpected number',
			    UnexpectedReserved: 'Unexpected reserved word',
			    UnexpectedString: 'Unexpected string',
			    UnexpectedTemplate: 'Unexpected quasi %0',
			    UnexpectedToken: 'Unexpected token %0',
			    UnexpectedTokenIllegal: 'Unexpected token ILLEGAL',
			    UnknownLabel: 'Undefined label \'%0\'',
			    UnterminatedRegExp: 'Invalid regular expression: missing /'
			};
		 },
		 function(module, exports, __webpack_require__) {
			Object.defineProperty(exports, "__esModule", { value: true });
			var assert_1 = __webpack_require__(9);
			var character_1 = __webpack_require__(4);
			var messages_1 = __webpack_require__(11);
			function hexValue(ch) {
			    return '0123456789abcdef'.indexOf(ch.toLowerCase());
			}
			function octalValue(ch) {
			    return '01234567'.indexOf(ch);
			}
			var Scanner = (function () {
			    function Scanner(code, handler) {
			        this.source = code;
			        this.errorHandler = handler;
			        this.trackComment = false;
			        this.isModule = false;
			        this.length = code.length;
			        this.index = 0;
			        this.lineNumber = (code.length > 0) ? 1 : 0;
			        this.lineStart = 0;
			        this.curlyStack = [];
			    }
			    Scanner.prototype.saveState = function () {
			        return {
			            index: this.index,
			            lineNumber: this.lineNumber,
			            lineStart: this.lineStart
			        };
			    };
			    Scanner.prototype.restoreState = function (state) {
			        this.index = state.index;
			        this.lineNumber = state.lineNumber;
			        this.lineStart = state.lineStart;
			    };
			    Scanner.prototype.eof = function () {
			        return this.index >= this.length;
			    };
			    Scanner.prototype.throwUnexpectedToken = function (message) {
			        if (message === void 0) { message = messages_1.Messages.UnexpectedTokenIllegal; }
			        return this.errorHandler.throwError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
			    };
			    Scanner.prototype.tolerateUnexpectedToken = function (message) {
			        if (message === void 0) { message = messages_1.Messages.UnexpectedTokenIllegal; }
			        this.errorHandler.tolerateError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
			    };
			    Scanner.prototype.skipSingleLineComment = function (offset) {
			        var comments = [];
			        var start, loc;
			        if (this.trackComment) {
			            comments = [];
			            start = this.index - offset;
			            loc = {
			                start: {
			                    line: this.lineNumber,
			                    column: this.index - this.lineStart - offset
			                },
			                end: {}
			            };
			        }
			        while (!this.eof()) {
			            var ch = this.source.charCodeAt(this.index);
			            ++this.index;
			            if (character_1.Character.isLineTerminator(ch)) {
			                if (this.trackComment) {
			                    loc.end = {
			                        line: this.lineNumber,
			                        column: this.index - this.lineStart - 1
			                    };
			                    var entry = {
			                        multiLine: false,
			                        slice: [start + offset, this.index - 1],
			                        range: [start, this.index - 1],
			                        loc: loc
			                    };
			                    comments.push(entry);
			                }
			                if (ch === 13 && this.source.charCodeAt(this.index) === 10) {
			                    ++this.index;
			                }
			                ++this.lineNumber;
			                this.lineStart = this.index;
			                return comments;
			            }
			        }
			        if (this.trackComment) {
			            loc.end = {
			                line: this.lineNumber,
			                column: this.index - this.lineStart
			            };
			            var entry = {
			                multiLine: false,
			                slice: [start + offset, this.index],
			                range: [start, this.index],
			                loc: loc
			            };
			            comments.push(entry);
			        }
			        return comments;
			    };
			    Scanner.prototype.skipMultiLineComment = function () {
			        var comments = [];
			        var start, loc;
			        if (this.trackComment) {
			            comments = [];
			            start = this.index - 2;
			            loc = {
			                start: {
			                    line: this.lineNumber,
			                    column: this.index - this.lineStart - 2
			                },
			                end: {}
			            };
			        }
			        while (!this.eof()) {
			            var ch = this.source.charCodeAt(this.index);
			            if (character_1.Character.isLineTerminator(ch)) {
			                if (ch === 0x0D && this.source.charCodeAt(this.index + 1) === 0x0A) {
			                    ++this.index;
			                }
			                ++this.lineNumber;
			                ++this.index;
			                this.lineStart = this.index;
			            }
			            else if (ch === 0x2A) {
			                if (this.source.charCodeAt(this.index + 1) === 0x2F) {
			                    this.index += 2;
			                    if (this.trackComment) {
			                        loc.end = {
			                            line: this.lineNumber,
			                            column: this.index - this.lineStart
			                        };
			                        var entry = {
			                            multiLine: true,
			                            slice: [start + 2, this.index - 2],
			                            range: [start, this.index],
			                            loc: loc
			                        };
			                        comments.push(entry);
			                    }
			                    return comments;
			                }
			                ++this.index;
			            }
			            else {
			                ++this.index;
			            }
			        }
			        if (this.trackComment) {
			            loc.end = {
			                line: this.lineNumber,
			                column: this.index - this.lineStart
			            };
			            var entry = {
			                multiLine: true,
			                slice: [start + 2, this.index],
			                range: [start, this.index],
			                loc: loc
			            };
			            comments.push(entry);
			        }
			        this.tolerateUnexpectedToken();
			        return comments;
			    };
			    Scanner.prototype.scanComments = function () {
			        var comments;
			        if (this.trackComment) {
			            comments = [];
			        }
			        var start = (this.index === 0);
			        while (!this.eof()) {
			            var ch = this.source.charCodeAt(this.index);
			            if (character_1.Character.isWhiteSpace(ch)) {
			                ++this.index;
			            }
			            else if (character_1.Character.isLineTerminator(ch)) {
			                ++this.index;
			                if (ch === 0x0D && this.source.charCodeAt(this.index) === 0x0A) {
			                    ++this.index;
			                }
			                ++this.lineNumber;
			                this.lineStart = this.index;
			                start = true;
			            }
			            else if (ch === 0x2F) {
			                ch = this.source.charCodeAt(this.index + 1);
			                if (ch === 0x2F) {
			                    this.index += 2;
			                    var comment = this.skipSingleLineComment(2);
			                    if (this.trackComment) {
			                        comments = comments.concat(comment);
			                    }
			                    start = true;
			                }
			                else if (ch === 0x2A) {
			                    this.index += 2;
			                    var comment = this.skipMultiLineComment();
			                    if (this.trackComment) {
			                        comments = comments.concat(comment);
			                    }
			                }
			                else {
			                    break;
			                }
			            }
			            else if (start && ch === 0x2D) {
			                if ((this.source.charCodeAt(this.index + 1) === 0x2D) && (this.source.charCodeAt(this.index + 2) === 0x3E)) {
			                    this.index += 3;
			                    var comment = this.skipSingleLineComment(3);
			                    if (this.trackComment) {
			                        comments = comments.concat(comment);
			                    }
			                }
			                else {
			                    break;
			                }
			            }
			            else if (ch === 0x3C && !this.isModule) {
			                if (this.source.slice(this.index + 1, this.index + 4) === '!--') {
			                    this.index += 4;
			                    var comment = this.skipSingleLineComment(4);
			                    if (this.trackComment) {
			                        comments = comments.concat(comment);
			                    }
			                }
			                else {
			                    break;
			                }
			            }
			            else {
			                break;
			            }
			        }
			        return comments;
			    };
			    Scanner.prototype.isFutureReservedWord = function (id) {
			        switch (id) {
			            case 'enum':
			            case 'export':
			            case 'import':
			            case 'super':
			                return true;
			            default:
			                return false;
			        }
			    };
			    Scanner.prototype.isStrictModeReservedWord = function (id) {
			        switch (id) {
			            case 'implements':
			            case 'interface':
			            case 'package':
			            case 'private':
			            case 'protected':
			            case 'public':
			            case 'static':
			            case 'yield':
			            case 'let':
			                return true;
			            default:
			                return false;
			        }
			    };
			    Scanner.prototype.isRestrictedWord = function (id) {
			        return id === 'eval' || id === 'arguments';
			    };
			    Scanner.prototype.isKeyword = function (id) {
			        switch (id.length) {
			            case 2:
			                return (id === 'if') || (id === 'in') || (id === 'do');
			            case 3:
			                return (id === 'var') || (id === 'for') || (id === 'new') ||
			                    (id === 'try') || (id === 'let');
			            case 4:
			                return (id === 'this') || (id === 'else') || (id === 'case') ||
			                    (id === 'void') || (id === 'with') || (id === 'enum');
			            case 5:
			                return (id === 'while') || (id === 'break') || (id === 'catch') ||
			                    (id === 'throw') || (id === 'const') || (id === 'yield') ||
			                    (id === 'class') || (id === 'super');
			            case 6:
			                return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
			                    (id === 'switch') || (id === 'export') || (id === 'import');
			            case 7:
			                return (id === 'default') || (id === 'finally') || (id === 'extends');
			            case 8:
			                return (id === 'function') || (id === 'continue') || (id === 'debugger');
			            case 10:
			                return (id === 'instanceof');
			            default:
			                return false;
			        }
			    };
			    Scanner.prototype.codePointAt = function (i) {
			        var cp = this.source.charCodeAt(i);
			        if (cp >= 0xD800 && cp <= 0xDBFF) {
			            var second = this.source.charCodeAt(i + 1);
			            if (second >= 0xDC00 && second <= 0xDFFF) {
			                var first = cp;
			                cp = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
			            }
			        }
			        return cp;
			    };
			    Scanner.prototype.scanHexEscape = function (prefix) {
			        var len = (prefix === 'u') ? 4 : 2;
			        var code = 0;
			        for (var i = 0; i < len; ++i) {
			            if (!this.eof() && character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
			                code = code * 16 + hexValue(this.source[this.index++]);
			            }
			            else {
			                return null;
			            }
			        }
			        return String.fromCharCode(code);
			    };
			    Scanner.prototype.scanUnicodeCodePointEscape = function () {
			        var ch = this.source[this.index];
			        var code = 0;
			        if (ch === '}') {
			            this.throwUnexpectedToken();
			        }
			        while (!this.eof()) {
			            ch = this.source[this.index++];
			            if (!character_1.Character.isHexDigit(ch.charCodeAt(0))) {
			                break;
			            }
			            code = code * 16 + hexValue(ch);
			        }
			        if (code > 0x10FFFF || ch !== '}') {
			            this.throwUnexpectedToken();
			        }
			        return character_1.Character.fromCodePoint(code);
			    };
			    Scanner.prototype.getIdentifier = function () {
			        var start = this.index++;
			        while (!this.eof()) {
			            var ch = this.source.charCodeAt(this.index);
			            if (ch === 0x5C) {
			                this.index = start;
			                return this.getComplexIdentifier();
			            }
			            else if (ch >= 0xD800 && ch < 0xDFFF) {
			                this.index = start;
			                return this.getComplexIdentifier();
			            }
			            if (character_1.Character.isIdentifierPart(ch)) {
			                ++this.index;
			            }
			            else {
			                break;
			            }
			        }
			        return this.source.slice(start, this.index);
			    };
			    Scanner.prototype.getComplexIdentifier = function () {
			        var cp = this.codePointAt(this.index);
			        var id = character_1.Character.fromCodePoint(cp);
			        this.index += id.length;
			        var ch;
			        if (cp === 0x5C) {
			            if (this.source.charCodeAt(this.index) !== 0x75) {
			                this.throwUnexpectedToken();
			            }
			            ++this.index;
			            if (this.source[this.index] === '{') {
			                ++this.index;
			                ch = this.scanUnicodeCodePointEscape();
			            }
			            else {
			                ch = this.scanHexEscape('u');
			                if (ch === null || ch === '\\' || !character_1.Character.isIdentifierStart(ch.charCodeAt(0))) {
			                    this.throwUnexpectedToken();
			                }
			            }
			            id = ch;
			        }
			        while (!this.eof()) {
			            cp = this.codePointAt(this.index);
			            if (!character_1.Character.isIdentifierPart(cp)) {
			                break;
			            }
			            ch = character_1.Character.fromCodePoint(cp);
			            id += ch;
			            this.index += ch.length;
			            if (cp === 0x5C) {
			                id = id.substr(0, id.length - 1);
			                if (this.source.charCodeAt(this.index) !== 0x75) {
			                    this.throwUnexpectedToken();
			                }
			                ++this.index;
			                if (this.source[this.index] === '{') {
			                    ++this.index;
			                    ch = this.scanUnicodeCodePointEscape();
			                }
			                else {
			                    ch = this.scanHexEscape('u');
			                    if (ch === null || ch === '\\' || !character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
			                        this.throwUnexpectedToken();
			                    }
			                }
			                id += ch;
			            }
			        }
			        return id;
			    };
			    Scanner.prototype.octalToDecimal = function (ch) {
			        var octal = (ch !== '0');
			        var code = octalValue(ch);
			        if (!this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
			            octal = true;
			            code = code * 8 + octalValue(this.source[this.index++]);
			            if ('0123'.indexOf(ch) >= 0 && !this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
			                code = code * 8 + octalValue(this.source[this.index++]);
			            }
			        }
			        return {
			            code: code,
			            octal: octal
			        };
			    };
			    Scanner.prototype.scanIdentifier = function () {
			        var type;
			        var start = this.index;
			        var id = (this.source.charCodeAt(start) === 0x5C) ? this.getComplexIdentifier() : this.getIdentifier();
			        if (id.length === 1) {
			            type = 3 ;
			        }
			        else if (this.isKeyword(id)) {
			            type = 4 ;
			        }
			        else if (id === 'null') {
			            type = 5 ;
			        }
			        else if (id === 'true' || id === 'false') {
			            type = 1 ;
			        }
			        else {
			            type = 3 ;
			        }
			        if (type !== 3  && (start + id.length !== this.index)) {
			            var restore = this.index;
			            this.index = start;
			            this.tolerateUnexpectedToken(messages_1.Messages.InvalidEscapedReservedWord);
			            this.index = restore;
			        }
			        return {
			            type: type,
			            value: id,
			            lineNumber: this.lineNumber,
			            lineStart: this.lineStart,
			            start: start,
			            end: this.index
			        };
			    };
			    Scanner.prototype.scanPunctuator = function () {
			        var start = this.index;
			        var str = this.source[this.index];
			        switch (str) {
			            case '(':
			            case '{':
			                if (str === '{') {
			                    this.curlyStack.push('{');
			                }
			                ++this.index;
			                break;
			            case '.':
			                ++this.index;
			                if (this.source[this.index] === '.' && this.source[this.index + 1] === '.') {
			                    this.index += 2;
			                    str = '...';
			                }
			                break;
			            case '}':
			                ++this.index;
			                this.curlyStack.pop();
			                break;
			            case ')':
			            case ';':
			            case ',':
			            case '[':
			            case ']':
			            case ':':
			            case '?':
			            case '~':
			                ++this.index;
			                break;
			            default:
			                str = this.source.substr(this.index, 4);
			                if (str === '>>>=') {
			                    this.index += 4;
			                }
			                else {
			                    str = str.substr(0, 3);
			                    if (str === '===' || str === '!==' || str === '>>>' ||
			                        str === '<<=' || str === '>>=' || str === '**=') {
			                        this.index += 3;
			                    }
			                    else {
			                        str = str.substr(0, 2);
			                        if (str === '&&' || str === '||' || str === '==' || str === '!=' ||
			                            str === '+=' || str === '-=' || str === '*=' || str === '/=' ||
			                            str === '++' || str === '--' || str === '<<' || str === '>>' ||
			                            str === '&=' || str === '|=' || str === '^=' || str === '%=' ||
			                            str === '<=' || str === '>=' || str === '=>' || str === '**') {
			                            this.index += 2;
			                        }
			                        else {
			                            str = this.source[this.index];
			                            if ('<>=!+-*%&|^/'.indexOf(str) >= 0) {
			                                ++this.index;
			                            }
			                        }
			                    }
			                }
			        }
			        if (this.index === start) {
			            this.throwUnexpectedToken();
			        }
			        return {
			            type: 7 ,
			            value: str,
			            lineNumber: this.lineNumber,
			            lineStart: this.lineStart,
			            start: start,
			            end: this.index
			        };
			    };
			    Scanner.prototype.scanHexLiteral = function (start) {
			        var num = '';
			        while (!this.eof()) {
			            if (!character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
			                break;
			            }
			            num += this.source[this.index++];
			        }
			        if (num.length === 0) {
			            this.throwUnexpectedToken();
			        }
			        if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
			            this.throwUnexpectedToken();
			        }
			        return {
			            type: 6 ,
			            value: parseInt('0x' + num, 16),
			            lineNumber: this.lineNumber,
			            lineStart: this.lineStart,
			            start: start,
			            end: this.index
			        };
			    };
			    Scanner.prototype.scanBinaryLiteral = function (start) {
			        var num = '';
			        var ch;
			        while (!this.eof()) {
			            ch = this.source[this.index];
			            if (ch !== '0' && ch !== '1') {
			                break;
			            }
			            num += this.source[this.index++];
			        }
			        if (num.length === 0) {
			            this.throwUnexpectedToken();
			        }
			        if (!this.eof()) {
			            ch = this.source.charCodeAt(this.index);
			            if (character_1.Character.isIdentifierStart(ch) || character_1.Character.isDecimalDigit(ch)) {
			                this.throwUnexpectedToken();
			            }
			        }
			        return {
			            type: 6 ,
			            value: parseInt(num, 2),
			            lineNumber: this.lineNumber,
			            lineStart: this.lineStart,
			            start: start,
			            end: this.index
			        };
			    };
			    Scanner.prototype.scanOctalLiteral = function (prefix, start) {
			        var num = '';
			        var octal = false;
			        if (character_1.Character.isOctalDigit(prefix.charCodeAt(0))) {
			            octal = true;
			            num = '0' + this.source[this.index++];
			        }
			        else {
			            ++this.index;
			        }
			        while (!this.eof()) {
			            if (!character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
			                break;
			            }
			            num += this.source[this.index++];
			        }
			        if (!octal && num.length === 0) {
			            this.throwUnexpectedToken();
			        }
			        if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index)) || character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
			            this.throwUnexpectedToken();
			        }
			        return {
			            type: 6 ,
			            value: parseInt(num, 8),
			            octal: octal,
			            lineNumber: this.lineNumber,
			            lineStart: this.lineStart,
			            start: start,
			            end: this.index
			        };
			    };
			    Scanner.prototype.isImplicitOctalLiteral = function () {
			        for (var i = this.index + 1; i < this.length; ++i) {
			            var ch = this.source[i];
			            if (ch === '8' || ch === '9') {
			                return false;
			            }
			            if (!character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
			                return true;
			            }
			        }
			        return true;
			    };
			    Scanner.prototype.scanNumericLiteral = function () {
			        var start = this.index;
			        var ch = this.source[start];
			        assert_1.assert(character_1.Character.isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'), 'Numeric literal must start with a decimal digit or a decimal point');
			        var num = '';
			        if (ch !== '.') {
			            num = this.source[this.index++];
			            ch = this.source[this.index];
			            if (num === '0') {
			                if (ch === 'x' || ch === 'X') {
			                    ++this.index;
			                    return this.scanHexLiteral(start);
			                }
			                if (ch === 'b' || ch === 'B') {
			                    ++this.index;
			                    return this.scanBinaryLiteral(start);
			                }
			                if (ch === 'o' || ch === 'O') {
			                    return this.scanOctalLiteral(ch, start);
			                }
			                if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
			                    if (this.isImplicitOctalLiteral()) {
			                        return this.scanOctalLiteral(ch, start);
			                    }
			                }
			            }
			            while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
			                num += this.source[this.index++];
			            }
			            ch = this.source[this.index];
			        }
			        if (ch === '.') {
			            num += this.source[this.index++];
			            while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
			                num += this.source[this.index++];
			            }
			            ch = this.source[this.index];
			        }
			        if (ch === 'e' || ch === 'E') {
			            num += this.source[this.index++];
			            ch = this.source[this.index];
			            if (ch === '+' || ch === '-') {
			                num += this.source[this.index++];
			            }
			            if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
			                while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
			                    num += this.source[this.index++];
			                }
			            }
			            else {
			                this.throwUnexpectedToken();
			            }
			        }
			        if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
			            this.throwUnexpectedToken();
			        }
			        return {
			            type: 6 ,
			            value: parseFloat(num),
			            lineNumber: this.lineNumber,
			            lineStart: this.lineStart,
			            start: start,
			            end: this.index
			        };
			    };
			    Scanner.prototype.scanStringLiteral = function () {
			        var start = this.index;
			        var quote = this.source[start];
			        assert_1.assert((quote === '\'' || quote === '"'), 'String literal must starts with a quote');
			        ++this.index;
			        var octal = false;
			        var str = '';
			        while (!this.eof()) {
			            var ch = this.source[this.index++];
			            if (ch === quote) {
			                quote = '';
			                break;
			            }
			            else if (ch === '\\') {
			                ch = this.source[this.index++];
			                if (!ch || !character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
			                    switch (ch) {
			                        case 'u':
			                            if (this.source[this.index] === '{') {
			                                ++this.index;
			                                str += this.scanUnicodeCodePointEscape();
			                            }
			                            else {
			                                var unescaped_1 = this.scanHexEscape(ch);
			                                if (unescaped_1 === null) {
			                                    this.throwUnexpectedToken();
			                                }
			                                str += unescaped_1;
			                            }
			                            break;
			                        case 'x':
			                            var unescaped = this.scanHexEscape(ch);
			                            if (unescaped === null) {
			                                this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
			                            }
			                            str += unescaped;
			                            break;
			                        case 'n':
			                            str += '\n';
			                            break;
			                        case 'r':
			                            str += '\r';
			                            break;
			                        case 't':
			                            str += '\t';
			                            break;
			                        case 'b':
			                            str += '\b';
			                            break;
			                        case 'f':
			                            str += '\f';
			                            break;
			                        case 'v':
			                            str += '\x0B';
			                            break;
			                        case '8':
			                        case '9':
			                            str += ch;
			                            this.tolerateUnexpectedToken();
			                            break;
			                        default:
			                            if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
			                                var octToDec = this.octalToDecimal(ch);
			                                octal = octToDec.octal || octal;
			                                str += String.fromCharCode(octToDec.code);
			                            }
			                            else {
			                                str += ch;
			                            }
			                            break;
			                    }
			                }
			                else {
			                    ++this.lineNumber;
			                    if (ch === '\r' && this.source[this.index] === '\n') {
			                        ++this.index;
			                    }
			                    this.lineStart = this.index;
			                }
			            }
			            else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
			                break;
			            }
			            else {
			                str += ch;
			            }
			        }
			        if (quote !== '') {
			            this.index = start;
			            this.throwUnexpectedToken();
			        }
			        return {
			            type: 8 ,
			            value: str,
			            octal: octal,
			            lineNumber: this.lineNumber,
			            lineStart: this.lineStart,
			            start: start,
			            end: this.index
			        };
			    };
			    Scanner.prototype.scanTemplate = function () {
			        var cooked = '';
			        var terminated = false;
			        var start = this.index;
			        var head = (this.source[start] === '`');
			        var tail = false;
			        var rawOffset = 2;
			        ++this.index;
			        while (!this.eof()) {
			            var ch = this.source[this.index++];
			            if (ch === '`') {
			                rawOffset = 1;
			                tail = true;
			                terminated = true;
			                break;
			            }
			            else if (ch === '$') {
			                if (this.source[this.index] === '{') {
			                    this.curlyStack.push('${');
			                    ++this.index;
			                    terminated = true;
			                    break;
			                }
			                cooked += ch;
			            }
			            else if (ch === '\\') {
			                ch = this.source[this.index++];
			                if (!character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
			                    switch (ch) {
			                        case 'n':
			                            cooked += '\n';
			                            break;
			                        case 'r':
			                            cooked += '\r';
			                            break;
			                        case 't':
			                            cooked += '\t';
			                            break;
			                        case 'u':
			                            if (this.source[this.index] === '{') {
			                                ++this.index;
			                                cooked += this.scanUnicodeCodePointEscape();
			                            }
			                            else {
			                                var restore = this.index;
			                                var unescaped_2 = this.scanHexEscape(ch);
			                                if (unescaped_2 !== null) {
			                                    cooked += unescaped_2;
			                                }
			                                else {
			                                    this.index = restore;
			                                    cooked += ch;
			                                }
			                            }
			                            break;
			                        case 'x':
			                            var unescaped = this.scanHexEscape(ch);
			                            if (unescaped === null) {
			                                this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
			                            }
			                            cooked += unescaped;
			                            break;
			                        case 'b':
			                            cooked += '\b';
			                            break;
			                        case 'f':
			                            cooked += '\f';
			                            break;
			                        case 'v':
			                            cooked += '\v';
			                            break;
			                        default:
			                            if (ch === '0') {
			                                if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
			                                    this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
			                                }
			                                cooked += '\0';
			                            }
			                            else if (character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
			                                this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
			                            }
			                            else {
			                                cooked += ch;
			                            }
			                            break;
			                    }
			                }
			                else {
			                    ++this.lineNumber;
			                    if (ch === '\r' && this.source[this.index] === '\n') {
			                        ++this.index;
			                    }
			                    this.lineStart = this.index;
			                }
			            }
			            else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
			                ++this.lineNumber;
			                if (ch === '\r' && this.source[this.index] === '\n') {
			                    ++this.index;
			                }
			                this.lineStart = this.index;
			                cooked += '\n';
			            }
			            else {
			                cooked += ch;
			            }
			        }
			        if (!terminated) {
			            this.throwUnexpectedToken();
			        }
			        if (!head) {
			            this.curlyStack.pop();
			        }
			        return {
			            type: 10 ,
			            value: this.source.slice(start + 1, this.index - rawOffset),
			            cooked: cooked,
			            head: head,
			            tail: tail,
			            lineNumber: this.lineNumber,
			            lineStart: this.lineStart,
			            start: start,
			            end: this.index
			        };
			    };
			    Scanner.prototype.testRegExp = function (pattern, flags) {
			        var astralSubstitute = '\uFFFF';
			        var tmp = pattern;
			        var self = this;
			        if (flags.indexOf('u') >= 0) {
			            tmp = tmp
			                .replace(/\\u\{([0-9a-fA-F]+)\}|\\u([a-fA-F0-9]{4})/g, function ($0, $1, $2) {
			                var codePoint = parseInt($1 || $2, 16);
			                if (codePoint > 0x10FFFF) {
			                    self.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
			                }
			                if (codePoint <= 0xFFFF) {
			                    return String.fromCharCode(codePoint);
			                }
			                return astralSubstitute;
			            })
			                .replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, astralSubstitute);
			        }
			        try {
			            RegExp(tmp);
			        }
			        catch (e) {
			            this.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
			        }
			        try {
			            return new RegExp(pattern, flags);
			        }
			        catch (exception) {
			            return null;
			        }
			    };
			    Scanner.prototype.scanRegExpBody = function () {
			        var ch = this.source[this.index];
			        assert_1.assert(ch === '/', 'Regular expression literal must start with a slash');
			        var str = this.source[this.index++];
			        var classMarker = false;
			        var terminated = false;
			        while (!this.eof()) {
			            ch = this.source[this.index++];
			            str += ch;
			            if (ch === '\\') {
			                ch = this.source[this.index++];
			                if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
			                    this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
			                }
			                str += ch;
			            }
			            else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
			                this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
			            }
			            else if (classMarker) {
			                if (ch === ']') {
			                    classMarker = false;
			                }
			            }
			            else {
			                if (ch === '/') {
			                    terminated = true;
			                    break;
			                }
			                else if (ch === '[') {
			                    classMarker = true;
			                }
			            }
			        }
			        if (!terminated) {
			            this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
			        }
			        return str.substr(1, str.length - 2);
			    };
			    Scanner.prototype.scanRegExpFlags = function () {
			        var str = '';
			        var flags = '';
			        while (!this.eof()) {
			            var ch = this.source[this.index];
			            if (!character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
			                break;
			            }
			            ++this.index;
			            if (ch === '\\' && !this.eof()) {
			                ch = this.source[this.index];
			                if (ch === 'u') {
			                    ++this.index;
			                    var restore = this.index;
			                    var char = this.scanHexEscape('u');
			                    if (char !== null) {
			                        flags += char;
			                        for (str += '\\u'; restore < this.index; ++restore) {
			                            str += this.source[restore];
			                        }
			                    }
			                    else {
			                        this.index = restore;
			                        flags += 'u';
			                        str += '\\u';
			                    }
			                    this.tolerateUnexpectedToken();
			                }
			                else {
			                    str += '\\';
			                    this.tolerateUnexpectedToken();
			                }
			            }
			            else {
			                flags += ch;
			                str += ch;
			            }
			        }
			        return flags;
			    };
			    Scanner.prototype.scanRegExp = function () {
			        var start = this.index;
			        var pattern = this.scanRegExpBody();
			        var flags = this.scanRegExpFlags();
			        var value = this.testRegExp(pattern, flags);
			        return {
			            type: 9 ,
			            value: '',
			            pattern: pattern,
			            flags: flags,
			            regex: value,
			            lineNumber: this.lineNumber,
			            lineStart: this.lineStart,
			            start: start,
			            end: this.index
			        };
			    };
			    Scanner.prototype.lex = function () {
			        if (this.eof()) {
			            return {
			                type: 2 ,
			                value: '',
			                lineNumber: this.lineNumber,
			                lineStart: this.lineStart,
			                start: this.index,
			                end: this.index
			            };
			        }
			        var cp = this.source.charCodeAt(this.index);
			        if (character_1.Character.isIdentifierStart(cp)) {
			            return this.scanIdentifier();
			        }
			        if (cp === 0x28 || cp === 0x29 || cp === 0x3B) {
			            return this.scanPunctuator();
			        }
			        if (cp === 0x27 || cp === 0x22) {
			            return this.scanStringLiteral();
			        }
			        if (cp === 0x2E) {
			            if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index + 1))) {
			                return this.scanNumericLiteral();
			            }
			            return this.scanPunctuator();
			        }
			        if (character_1.Character.isDecimalDigit(cp)) {
			            return this.scanNumericLiteral();
			        }
			        if (cp === 0x60 || (cp === 0x7D && this.curlyStack[this.curlyStack.length - 1] === '${')) {
			            return this.scanTemplate();
			        }
			        if (cp >= 0xD800 && cp < 0xDFFF) {
			            if (character_1.Character.isIdentifierStart(this.codePointAt(this.index))) {
			                return this.scanIdentifier();
			            }
			        }
			        return this.scanPunctuator();
			    };
			    return Scanner;
			}());
			exports.Scanner = Scanner;
		 },
		 function(module, exports) {
			Object.defineProperty(exports, "__esModule", { value: true });
			exports.TokenName = {};
			exports.TokenName[1 ] = 'Boolean';
			exports.TokenName[2 ] = '<end>';
			exports.TokenName[3 ] = 'Identifier';
			exports.TokenName[4 ] = 'Keyword';
			exports.TokenName[5 ] = 'Null';
			exports.TokenName[6 ] = 'Numeric';
			exports.TokenName[7 ] = 'Punctuator';
			exports.TokenName[8 ] = 'String';
			exports.TokenName[9 ] = 'RegularExpression';
			exports.TokenName[10 ] = 'Template';
		 },
		 function(module, exports) {
			Object.defineProperty(exports, "__esModule", { value: true });
			exports.XHTMLEntities = {
			    quot: '\u0022',
			    amp: '\u0026',
			    apos: '\u0027',
			    gt: '\u003E',
			    nbsp: '\u00A0',
			    iexcl: '\u00A1',
			    cent: '\u00A2',
			    pound: '\u00A3',
			    curren: '\u00A4',
			    yen: '\u00A5',
			    brvbar: '\u00A6',
			    sect: '\u00A7',
			    uml: '\u00A8',
			    copy: '\u00A9',
			    ordf: '\u00AA',
			    laquo: '\u00AB',
			    not: '\u00AC',
			    shy: '\u00AD',
			    reg: '\u00AE',
			    macr: '\u00AF',
			    deg: '\u00B0',
			    plusmn: '\u00B1',
			    sup2: '\u00B2',
			    sup3: '\u00B3',
			    acute: '\u00B4',
			    micro: '\u00B5',
			    para: '\u00B6',
			    middot: '\u00B7',
			    cedil: '\u00B8',
			    sup1: '\u00B9',
			    ordm: '\u00BA',
			    raquo: '\u00BB',
			    frac14: '\u00BC',
			    frac12: '\u00BD',
			    frac34: '\u00BE',
			    iquest: '\u00BF',
			    Agrave: '\u00C0',
			    Aacute: '\u00C1',
			    Acirc: '\u00C2',
			    Atilde: '\u00C3',
			    Auml: '\u00C4',
			    Aring: '\u00C5',
			    AElig: '\u00C6',
			    Ccedil: '\u00C7',
			    Egrave: '\u00C8',
			    Eacute: '\u00C9',
			    Ecirc: '\u00CA',
			    Euml: '\u00CB',
			    Igrave: '\u00CC',
			    Iacute: '\u00CD',
			    Icirc: '\u00CE',
			    Iuml: '\u00CF',
			    ETH: '\u00D0',
			    Ntilde: '\u00D1',
			    Ograve: '\u00D2',
			    Oacute: '\u00D3',
			    Ocirc: '\u00D4',
			    Otilde: '\u00D5',
			    Ouml: '\u00D6',
			    times: '\u00D7',
			    Oslash: '\u00D8',
			    Ugrave: '\u00D9',
			    Uacute: '\u00DA',
			    Ucirc: '\u00DB',
			    Uuml: '\u00DC',
			    Yacute: '\u00DD',
			    THORN: '\u00DE',
			    szlig: '\u00DF',
			    agrave: '\u00E0',
			    aacute: '\u00E1',
			    acirc: '\u00E2',
			    atilde: '\u00E3',
			    auml: '\u00E4',
			    aring: '\u00E5',
			    aelig: '\u00E6',
			    ccedil: '\u00E7',
			    egrave: '\u00E8',
			    eacute: '\u00E9',
			    ecirc: '\u00EA',
			    euml: '\u00EB',
			    igrave: '\u00EC',
			    iacute: '\u00ED',
			    icirc: '\u00EE',
			    iuml: '\u00EF',
			    eth: '\u00F0',
			    ntilde: '\u00F1',
			    ograve: '\u00F2',
			    oacute: '\u00F3',
			    ocirc: '\u00F4',
			    otilde: '\u00F5',
			    ouml: '\u00F6',
			    divide: '\u00F7',
			    oslash: '\u00F8',
			    ugrave: '\u00F9',
			    uacute: '\u00FA',
			    ucirc: '\u00FB',
			    uuml: '\u00FC',
			    yacute: '\u00FD',
			    thorn: '\u00FE',
			    yuml: '\u00FF',
			    OElig: '\u0152',
			    oelig: '\u0153',
			    Scaron: '\u0160',
			    scaron: '\u0161',
			    Yuml: '\u0178',
			    fnof: '\u0192',
			    circ: '\u02C6',
			    tilde: '\u02DC',
			    Alpha: '\u0391',
			    Beta: '\u0392',
			    Gamma: '\u0393',
			    Delta: '\u0394',
			    Epsilon: '\u0395',
			    Zeta: '\u0396',
			    Eta: '\u0397',
			    Theta: '\u0398',
			    Iota: '\u0399',
			    Kappa: '\u039A',
			    Lambda: '\u039B',
			    Mu: '\u039C',
			    Nu: '\u039D',
			    Xi: '\u039E',
			    Omicron: '\u039F',
			    Pi: '\u03A0',
			    Rho: '\u03A1',
			    Sigma: '\u03A3',
			    Tau: '\u03A4',
			    Upsilon: '\u03A5',
			    Phi: '\u03A6',
			    Chi: '\u03A7',
			    Psi: '\u03A8',
			    Omega: '\u03A9',
			    alpha: '\u03B1',
			    beta: '\u03B2',
			    gamma: '\u03B3',
			    delta: '\u03B4',
			    epsilon: '\u03B5',
			    zeta: '\u03B6',
			    eta: '\u03B7',
			    theta: '\u03B8',
			    iota: '\u03B9',
			    kappa: '\u03BA',
			    lambda: '\u03BB',
			    mu: '\u03BC',
			    nu: '\u03BD',
			    xi: '\u03BE',
			    omicron: '\u03BF',
			    pi: '\u03C0',
			    rho: '\u03C1',
			    sigmaf: '\u03C2',
			    sigma: '\u03C3',
			    tau: '\u03C4',
			    upsilon: '\u03C5',
			    phi: '\u03C6',
			    chi: '\u03C7',
			    psi: '\u03C8',
			    omega: '\u03C9',
			    thetasym: '\u03D1',
			    upsih: '\u03D2',
			    piv: '\u03D6',
			    ensp: '\u2002',
			    emsp: '\u2003',
			    thinsp: '\u2009',
			    zwnj: '\u200C',
			    zwj: '\u200D',
			    lrm: '\u200E',
			    rlm: '\u200F',
			    ndash: '\u2013',
			    mdash: '\u2014',
			    lsquo: '\u2018',
			    rsquo: '\u2019',
			    sbquo: '\u201A',
			    ldquo: '\u201C',
			    rdquo: '\u201D',
			    bdquo: '\u201E',
			    dagger: '\u2020',
			    Dagger: '\u2021',
			    bull: '\u2022',
			    hellip: '\u2026',
			    permil: '\u2030',
			    prime: '\u2032',
			    Prime: '\u2033',
			    lsaquo: '\u2039',
			    rsaquo: '\u203A',
			    oline: '\u203E',
			    frasl: '\u2044',
			    euro: '\u20AC',
			    image: '\u2111',
			    weierp: '\u2118',
			    real: '\u211C',
			    trade: '\u2122',
			    alefsym: '\u2135',
			    larr: '\u2190',
			    uarr: '\u2191',
			    rarr: '\u2192',
			    darr: '\u2193',
			    harr: '\u2194',
			    crarr: '\u21B5',
			    lArr: '\u21D0',
			    uArr: '\u21D1',
			    rArr: '\u21D2',
			    dArr: '\u21D3',
			    hArr: '\u21D4',
			    forall: '\u2200',
			    part: '\u2202',
			    exist: '\u2203',
			    empty: '\u2205',
			    nabla: '\u2207',
			    isin: '\u2208',
			    notin: '\u2209',
			    ni: '\u220B',
			    prod: '\u220F',
			    sum: '\u2211',
			    minus: '\u2212',
			    lowast: '\u2217',
			    radic: '\u221A',
			    prop: '\u221D',
			    infin: '\u221E',
			    ang: '\u2220',
			    and: '\u2227',
			    or: '\u2228',
			    cap: '\u2229',
			    cup: '\u222A',
			    int: '\u222B',
			    there4: '\u2234',
			    sim: '\u223C',
			    cong: '\u2245',
			    asymp: '\u2248',
			    ne: '\u2260',
			    equiv: '\u2261',
			    le: '\u2264',
			    ge: '\u2265',
			    sub: '\u2282',
			    sup: '\u2283',
			    nsub: '\u2284',
			    sube: '\u2286',
			    supe: '\u2287',
			    oplus: '\u2295',
			    otimes: '\u2297',
			    perp: '\u22A5',
			    sdot: '\u22C5',
			    lceil: '\u2308',
			    rceil: '\u2309',
			    lfloor: '\u230A',
			    rfloor: '\u230B',
			    loz: '\u25CA',
			    spades: '\u2660',
			    clubs: '\u2663',
			    hearts: '\u2665',
			    diams: '\u2666',
			    lang: '\u27E8',
			    rang: '\u27E9'
			};
		 },
		 function(module, exports, __webpack_require__) {
			Object.defineProperty(exports, "__esModule", { value: true });
			var error_handler_1 = __webpack_require__(10);
			var scanner_1 = __webpack_require__(12);
			var token_1 = __webpack_require__(13);
			var Reader = (function () {
			    function Reader() {
			        this.values = [];
			        this.curly = this.paren = -1;
			    }
			    Reader.prototype.beforeFunctionExpression = function (t) {
			        return ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new',
			            'return', 'case', 'delete', 'throw', 'void',
			            '=', '+=', '-=', '*=', '**=', '/=', '%=', '<<=', '>>=', '>>>=',
			            '&=', '|=', '^=', ',',
			            '+', '-', '*', '**', '/', '%', '++', '--', '<<', '>>', '>>>', '&',
			            '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=',
			            '<=', '<', '>', '!=', '!=='].indexOf(t) >= 0;
			    };
			    Reader.prototype.isRegexStart = function () {
			        var previous = this.values[this.values.length - 1];
			        var regex = (previous !== null);
			        switch (previous) {
			            case 'this':
			            case ']':
			                regex = false;
			                break;
			            case ')':
			                var keyword = this.values[this.paren - 1];
			                regex = (keyword === 'if' || keyword === 'while' || keyword === 'for' || keyword === 'with');
			                break;
			            case '}':
			                regex = false;
			                if (this.values[this.curly - 3] === 'function') {
			                    var check = this.values[this.curly - 4];
			                    regex = check ? !this.beforeFunctionExpression(check) : false;
			                }
			                else if (this.values[this.curly - 4] === 'function') {
			                    var check = this.values[this.curly - 5];
			                    regex = check ? !this.beforeFunctionExpression(check) : true;
			                }
			                break;
			        }
			        return regex;
			    };
			    Reader.prototype.push = function (token) {
			        if (token.type === 7  || token.type === 4 ) {
			            if (token.value === '{') {
			                this.curly = this.values.length;
			            }
			            else if (token.value === '(') {
			                this.paren = this.values.length;
			            }
			            this.values.push(token.value);
			        }
			        else {
			            this.values.push(null);
			        }
			    };
			    return Reader;
			}());
			var Tokenizer = (function () {
			    function Tokenizer(code, config) {
			        this.errorHandler = new error_handler_1.ErrorHandler();
			        this.errorHandler.tolerant = config ? (typeof config.tolerant === 'boolean' && config.tolerant) : false;
			        this.scanner = new scanner_1.Scanner(code, this.errorHandler);
			        this.scanner.trackComment = config ? (typeof config.comment === 'boolean' && config.comment) : false;
			        this.trackRange = config ? (typeof config.range === 'boolean' && config.range) : false;
			        this.trackLoc = config ? (typeof config.loc === 'boolean' && config.loc) : false;
			        this.buffer = [];
			        this.reader = new Reader();
			    }
			    Tokenizer.prototype.errors = function () {
			        return this.errorHandler.errors;
			    };
			    Tokenizer.prototype.getNextToken = function () {
			        if (this.buffer.length === 0) {
			            var comments = this.scanner.scanComments();
			            if (this.scanner.trackComment) {
			                for (var i = 0; i < comments.length; ++i) {
			                    var e = comments[i];
			                    var value = this.scanner.source.slice(e.slice[0], e.slice[1]);
			                    var comment = {
			                        type: e.multiLine ? 'BlockComment' : 'LineComment',
			                        value: value
			                    };
			                    if (this.trackRange) {
			                        comment.range = e.range;
			                    }
			                    if (this.trackLoc) {
			                        comment.loc = e.loc;
			                    }
			                    this.buffer.push(comment);
			                }
			            }
			            if (!this.scanner.eof()) {
			                var loc = void 0;
			                if (this.trackLoc) {
			                    loc = {
			                        start: {
			                            line: this.scanner.lineNumber,
			                            column: this.scanner.index - this.scanner.lineStart
			                        },
			                        end: {}
			                    };
			                }
			                var startRegex = (this.scanner.source[this.scanner.index] === '/') && this.reader.isRegexStart();
			                var token = startRegex ? this.scanner.scanRegExp() : this.scanner.lex();
			                this.reader.push(token);
			                var entry = {
			                    type: token_1.TokenName[token.type],
			                    value: this.scanner.source.slice(token.start, token.end)
			                };
			                if (this.trackRange) {
			                    entry.range = [token.start, token.end];
			                }
			                if (this.trackLoc) {
			                    loc.end = {
			                        line: this.scanner.lineNumber,
			                        column: this.scanner.index - this.scanner.lineStart
			                    };
			                    entry.loc = loc;
			                }
			                if (token.type === 9 ) {
			                    var pattern = token.pattern;
			                    var flags = token.flags;
			                    entry.regex = { pattern: pattern, flags: flags };
			                }
			                this.buffer.push(entry);
			            }
			        }
			        return this.buffer.shift();
			    };
			    return Tokenizer;
			}());
			exports.Tokenizer = Tokenizer;
		 }
		 ])
		});
	} (esprima$2));
	return esprima$2.exports;
}

var main = {};

/******************************************************************************
Copyright (c) Microsoft Corporation.
Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.
THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf ||
      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() { this.constructor = d; }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
      return t;
  };
  return __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
      }
  return t;
}
function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param(paramIndex, decorator) {
  return function (target, key) { decorator(target, key, paramIndex); }
}
function __esDecorate$1(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
      var context = {};
      for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
      for (var p in contextIn.access) context.access[p] = contextIn.access[p];
      context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
      var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
      if (kind === "accessor") {
          if (result === void 0) continue;
          if (result === null || typeof result !== "object") throw new TypeError("Object expected");
          if (_ = accept(result.get)) descriptor.get = _;
          if (_ = accept(result.set)) descriptor.set = _;
          if (_ = accept(result.init)) initializers.unshift(_);
      }
      else if (_ = accept(result)) {
          if (kind === "field") initializers.unshift(_);
          else descriptor[key] = _;
      }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
}function __runInitializers$1(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
}function __propKey(x) {
  return typeof x === "symbol" ? x : "".concat(x);
}function __setFunctionName$1(f, name, prefix) {
  if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
  return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
}function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
  return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
      function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
  function verb(n) { return function (v) { return step([n, v]); }; }
  function step(op) {
      if (f) throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
              case 0: case 1: t = op; break;
              case 4: _.label++; return { value: op[1], done: false };
              case 5: _.label++; y = op[1]; op = [0]; continue;
              case 7: op = _.ops.pop(); _.trys.pop(); continue;
              default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                  if (t[2]) _.ops.pop();
                  _.trys.pop(); continue;
          }
          op = body.call(thisArg, _);
      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
  }
}
var __createBinding = Object.create ? (function(o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
  }
  Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
function __exportStar(m, o) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
      next: function () {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
      }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  }
  catch (error) { e = { error: error }; }
  finally {
      try {
          if (r && !r.done && (m = i["return"])) m.call(i);
      }
      finally { if (e) throw e.error; }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
      ar = ar.concat(__read(arguments[i]));
  return ar;
}
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
          r[k] = a[j];
  return r;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
      }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;
  function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }
  function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }
  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
  function fulfill(value) { resume("next", value); }
  function reject(value) { resume("throw", value); }
  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}
function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
  return cooked;
}var __setModuleDefault = Object.create ? (function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
  o["default"] = v;
};
var ownKeys = function(o) {
  ownKeys = Object.getOwnPropertyNames || function (o) {
    var ar = [];
    for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
    return ar;
  };
  return ownKeys(o);
};
function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
  __setModuleDefault(result, mod);
  return result;
}
function __importDefault(mod) {
  return (mod && mod.__esModule) ? mod : { default: mod };
}
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}
function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || (typeof receiver !== "object" && typeof receiver !== "function")) throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state === "function" ? receiver === state : state.has(receiver);
}
function __addDisposableResource(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose, inner;
    if (async) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };
    env.stack.push({ value: value, dispose: dispose, async: async });
  }
  else if (async) {
    env.stack.push({ async: true });
  }
  return value;
}
var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};
function __disposeResources(env) {
  function fail(e) {
    env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
    env.hasError = true;
  }
  var r, s = 0;
  function next() {
    while (r = env.stack.pop()) {
      try {
        if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
        if (r.dispose) {
          var result = r.dispose.call(r.value);
          if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
        }
        else s |= 1;
      }
      catch (e) {
        fail(e);
      }
    }
    if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
    if (env.hasError) throw env.error;
  }
  return next();
}
function __rewriteRelativeImportExtension(path, preserveJsx) {
  if (typeof path === "string" && /^\.\.?\//.test(path)) {
      return path.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function (m, tsx, d, ext, cm) {
          return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : (d + ext + "." + cm.toLowerCase() + "js");
      });
  }
  return path;
}
var tslib_es6 = {
  __extends,
  __assign,
  __rest,
  __decorate,
  __param,
  __esDecorate: __esDecorate$1,
  __runInitializers: __runInitializers$1,
  __propKey,
  __setFunctionName: __setFunctionName$1,
  __metadata,
  __awaiter,
  __generator,
  __createBinding,
  __exportStar,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __classPrivateFieldIn,
  __addDisposableResource,
  __disposeResources,
  __rewriteRelativeImportExtension,
};

var tslib_es6$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	__addDisposableResource: __addDisposableResource,
	get __assign () { return __assign; },
	__asyncDelegator: __asyncDelegator,
	__asyncGenerator: __asyncGenerator,
	__asyncValues: __asyncValues,
	__await: __await,
	__awaiter: __awaiter,
	__classPrivateFieldGet: __classPrivateFieldGet,
	__classPrivateFieldIn: __classPrivateFieldIn,
	__classPrivateFieldSet: __classPrivateFieldSet,
	__createBinding: __createBinding,
	__decorate: __decorate,
	__disposeResources: __disposeResources,
	__esDecorate: __esDecorate$1,
	__exportStar: __exportStar,
	__extends: __extends,
	__generator: __generator,
	__importDefault: __importDefault,
	__importStar: __importStar,
	__makeTemplateObject: __makeTemplateObject,
	__metadata: __metadata,
	__param: __param,
	__propKey: __propKey,
	__read: __read,
	__rest: __rest,
	__rewriteRelativeImportExtension: __rewriteRelativeImportExtension,
	__runInitializers: __runInitializers$1,
	__setFunctionName: __setFunctionName$1,
	__spread: __spread,
	__spreadArray: __spreadArray,
	__spreadArrays: __spreadArrays,
	__values: __values,
	default: tslib_es6
});

var require$$0 = /*@__PURE__*/getAugmentedNamespace(tslib_es6$1);

var fork = {exports: {}};

var types$1 = {};

var hasRequiredTypes$1;

function requireTypes$1 () {
	if (hasRequiredTypes$1) return types$1;
	hasRequiredTypes$1 = 1;
	Object.defineProperty(types$1, "__esModule", { value: true });
	types$1.Def = void 0;
	var tslib_1 = require$$0;
	var Op = Object.prototype;
	var objToStr = Op.toString;
	var hasOwn = Op.hasOwnProperty;
	var BaseType =  (function () {
	    function BaseType() {
	    }
	    BaseType.prototype.assert = function (value, deep) {
	        if (!this.check(value, deep)) {
	            var str = shallowStringify(value);
	            throw new Error(str + " does not match type " + this);
	        }
	        return true;
	    };
	    BaseType.prototype.arrayOf = function () {
	        var elemType = this;
	        return new ArrayType(elemType);
	    };
	    return BaseType;
	}());
	var ArrayType =  (function (_super) {
	    tslib_1.__extends(ArrayType, _super);
	    function ArrayType(elemType) {
	        var _this = _super.call(this) || this;
	        _this.elemType = elemType;
	        _this.kind = "ArrayType";
	        return _this;
	    }
	    ArrayType.prototype.toString = function () {
	        return "[" + this.elemType + "]";
	    };
	    ArrayType.prototype.check = function (value, deep) {
	        var _this = this;
	        return Array.isArray(value) && value.every(function (elem) { return _this.elemType.check(elem, deep); });
	    };
	    return ArrayType;
	}(BaseType));
	var IdentityType =  (function (_super) {
	    tslib_1.__extends(IdentityType, _super);
	    function IdentityType(value) {
	        var _this = _super.call(this) || this;
	        _this.value = value;
	        _this.kind = "IdentityType";
	        return _this;
	    }
	    IdentityType.prototype.toString = function () {
	        return String(this.value);
	    };
	    IdentityType.prototype.check = function (value, deep) {
	        var result = value === this.value;
	        if (!result && typeof deep === "function") {
	            deep(this, value);
	        }
	        return result;
	    };
	    return IdentityType;
	}(BaseType));
	var ObjectType =  (function (_super) {
	    tslib_1.__extends(ObjectType, _super);
	    function ObjectType(fields) {
	        var _this = _super.call(this) || this;
	        _this.fields = fields;
	        _this.kind = "ObjectType";
	        return _this;
	    }
	    ObjectType.prototype.toString = function () {
	        return "{ " + this.fields.join(", ") + " }";
	    };
	    ObjectType.prototype.check = function (value, deep) {
	        return (objToStr.call(value) === objToStr.call({}) &&
	            this.fields.every(function (field) {
	                return field.type.check(value[field.name], deep);
	            }));
	    };
	    return ObjectType;
	}(BaseType));
	var OrType =  (function (_super) {
	    tslib_1.__extends(OrType, _super);
	    function OrType(types) {
	        var _this = _super.call(this) || this;
	        _this.types = types;
	        _this.kind = "OrType";
	        return _this;
	    }
	    OrType.prototype.toString = function () {
	        return this.types.join(" | ");
	    };
	    OrType.prototype.check = function (value, deep) {
	        return this.types.some(function (type) {
	            return type.check(value, deep);
	        });
	    };
	    return OrType;
	}(BaseType));
	var PredicateType =  (function (_super) {
	    tslib_1.__extends(PredicateType, _super);
	    function PredicateType(name, predicate) {
	        var _this = _super.call(this) || this;
	        _this.name = name;
	        _this.predicate = predicate;
	        _this.kind = "PredicateType";
	        return _this;
	    }
	    PredicateType.prototype.toString = function () {
	        return this.name;
	    };
	    PredicateType.prototype.check = function (value, deep) {
	        var result = this.predicate(value, deep);
	        if (!result && typeof deep === "function") {
	            deep(this, value);
	        }
	        return result;
	    };
	    return PredicateType;
	}(BaseType));
	var Def =  (function () {
	    function Def(type, typeName) {
	        this.type = type;
	        this.typeName = typeName;
	        this.baseNames = [];
	        this.ownFields = Object.create(null);
	        this.allSupertypes = Object.create(null);
	        this.supertypeList = [];
	        this.allFields = Object.create(null);
	        this.fieldNames = [];
	        this.finalized = false;
	        this.buildable = false;
	        this.buildParams = [];
	    }
	    Def.prototype.isSupertypeOf = function (that) {
	        if (that instanceof Def) {
	            if (this.finalized !== true ||
	                that.finalized !== true) {
	                throw new Error("");
	            }
	            return hasOwn.call(that.allSupertypes, this.typeName);
	        }
	        else {
	            throw new Error(that + " is not a Def");
	        }
	    };
	    Def.prototype.checkAllFields = function (value, deep) {
	        var allFields = this.allFields;
	        if (this.finalized !== true) {
	            throw new Error("" + this.typeName);
	        }
	        function checkFieldByName(name) {
	            var field = allFields[name];
	            var type = field.type;
	            var child = field.getValue(value);
	            return type.check(child, deep);
	        }
	        return value !== null &&
	            typeof value === "object" &&
	            Object.keys(allFields).every(checkFieldByName);
	    };
	    Def.prototype.bases = function () {
	        var supertypeNames = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            supertypeNames[_i] = arguments[_i];
	        }
	        var bases = this.baseNames;
	        if (this.finalized) {
	            if (supertypeNames.length !== bases.length) {
	                throw new Error("");
	            }
	            for (var i = 0; i < supertypeNames.length; i++) {
	                if (supertypeNames[i] !== bases[i]) {
	                    throw new Error("");
	                }
	            }
	            return this;
	        }
	        supertypeNames.forEach(function (baseName) {
	            if (bases.indexOf(baseName) < 0) {
	                bases.push(baseName);
	            }
	        });
	        return this;
	    };
	    return Def;
	}());
	types$1.Def = Def;
	var Field =  (function () {
	    function Field(name, type, defaultFn, hidden) {
	        this.name = name;
	        this.type = type;
	        this.defaultFn = defaultFn;
	        this.hidden = !!hidden;
	    }
	    Field.prototype.toString = function () {
	        return JSON.stringify(this.name) + ": " + this.type;
	    };
	    Field.prototype.getValue = function (obj) {
	        var value = obj[this.name];
	        if (typeof value !== "undefined") {
	            return value;
	        }
	        if (typeof this.defaultFn === "function") {
	            value = this.defaultFn.call(obj);
	        }
	        return value;
	    };
	    return Field;
	}());
	function shallowStringify(value) {
	    if (Array.isArray(value)) {
	        return "[" + value.map(shallowStringify).join(", ") + "]";
	    }
	    if (value && typeof value === "object") {
	        return "{ " + Object.keys(value).map(function (key) {
	            return key + ": " + value[key];
	        }).join(", ") + " }";
	    }
	    return JSON.stringify(value);
	}
	function typesPlugin(_fork) {
	    var Type = {
	        or: function () {
	            var types = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                types[_i] = arguments[_i];
	            }
	            return new OrType(types.map(function (type) { return Type.from(type); }));
	        },
	        from: function (value, name) {
	            if (value instanceof ArrayType ||
	                value instanceof IdentityType ||
	                value instanceof ObjectType ||
	                value instanceof OrType ||
	                value instanceof PredicateType) {
	                return value;
	            }
	            if (value instanceof Def) {
	                return value.type;
	            }
	            if (isArray.check(value)) {
	                if (value.length !== 1) {
	                    throw new Error("only one element type is permitted for typed arrays");
	                }
	                return new ArrayType(Type.from(value[0]));
	            }
	            if (isObject.check(value)) {
	                return new ObjectType(Object.keys(value).map(function (name) {
	                    return new Field(name, Type.from(value[name], name));
	                }));
	            }
	            if (typeof value === "function") {
	                var bicfIndex = builtInCtorFns.indexOf(value);
	                if (bicfIndex >= 0) {
	                    return builtInCtorTypes[bicfIndex];
	                }
	                if (typeof name !== "string") {
	                    throw new Error("missing name");
	                }
	                return new PredicateType(name, value);
	            }
	            return new IdentityType(value);
	        },
	        def: function (typeName) {
	            return hasOwn.call(defCache, typeName)
	                ? defCache[typeName]
	                : defCache[typeName] = new DefImpl(typeName);
	        },
	        hasDef: function (typeName) {
	            return hasOwn.call(defCache, typeName);
	        }
	    };
	    var builtInCtorFns = [];
	    var builtInCtorTypes = [];
	    function defBuiltInType(name, example) {
	        var objStr = objToStr.call(example);
	        var type = new PredicateType(name, function (value) { return objToStr.call(value) === objStr; });
	        if (example && typeof example.constructor === "function") {
	            builtInCtorFns.push(example.constructor);
	            builtInCtorTypes.push(type);
	        }
	        return type;
	    }
	    var isString = defBuiltInType("string", "truthy");
	    var isFunction = defBuiltInType("function", function () { });
	    var isArray = defBuiltInType("array", []);
	    var isObject = defBuiltInType("object", {});
	    var isRegExp = defBuiltInType("RegExp", /./);
	    var isDate = defBuiltInType("Date", new Date());
	    var isNumber = defBuiltInType("number", 3);
	    var isBoolean = defBuiltInType("boolean", true);
	    var isNull = defBuiltInType("null", null);
	    var isUndefined = defBuiltInType("undefined", undefined);
	    var builtInTypes = {
	        string: isString,
	        function: isFunction,
	        array: isArray,
	        object: isObject,
	        RegExp: isRegExp,
	        Date: isDate,
	        number: isNumber,
	        boolean: isBoolean,
	        null: isNull,
	        undefined: isUndefined,
	    };
	    var defCache = Object.create(null);
	    function defFromValue(value) {
	        if (value && typeof value === "object") {
	            var type = value.type;
	            if (typeof type === "string" &&
	                hasOwn.call(defCache, type)) {
	                var d = defCache[type];
	                if (d.finalized) {
	                    return d;
	                }
	            }
	        }
	        return null;
	    }
	    var DefImpl =  (function (_super) {
	        tslib_1.__extends(DefImpl, _super);
	        function DefImpl(typeName) {
	            var _this = _super.call(this, new PredicateType(typeName, function (value, deep) { return _this.check(value, deep); }), typeName) || this;
	            return _this;
	        }
	        DefImpl.prototype.check = function (value, deep) {
	            if (this.finalized !== true) {
	                throw new Error("prematurely checking unfinalized type " + this.typeName);
	            }
	            if (value === null || typeof value !== "object") {
	                return false;
	            }
	            var vDef = defFromValue(value);
	            if (!vDef) {
	                if (this.typeName === "SourceLocation" ||
	                    this.typeName === "Position") {
	                    return this.checkAllFields(value, deep);
	                }
	                return false;
	            }
	            if (deep && vDef === this) {
	                return this.checkAllFields(value, deep);
	            }
	            if (!this.isSupertypeOf(vDef)) {
	                return false;
	            }
	            if (!deep) {
	                return true;
	            }
	            return vDef.checkAllFields(value, deep)
	                && this.checkAllFields(value, false);
	        };
	        DefImpl.prototype.build = function () {
	            var _this = this;
	            var buildParams = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                buildParams[_i] = arguments[_i];
	            }
	            this.buildParams = buildParams;
	            if (this.buildable) {
	                return this;
	            }
	            this.field("type", String, function () { return _this.typeName; });
	            this.buildable = true;
	            var addParam = function (built, param, arg, isArgAvailable) {
	                if (hasOwn.call(built, param))
	                    return;
	                var all = _this.allFields;
	                if (!hasOwn.call(all, param)) {
	                    throw new Error("" + param);
	                }
	                var field = all[param];
	                var type = field.type;
	                var value;
	                if (isArgAvailable) {
	                    value = arg;
	                }
	                else if (field.defaultFn) {
	                    value = field.defaultFn.call(built);
	                }
	                else {
	                    var message = "no value or default function given for field " +
	                        JSON.stringify(param) + " of " + _this.typeName + "(" +
	                        _this.buildParams.map(function (name) {
	                            return all[name];
	                        }).join(", ") + ")";
	                    throw new Error(message);
	                }
	                if (!type.check(value)) {
	                    throw new Error(shallowStringify(value) +
	                        " does not match field " + field +
	                        " of type " + _this.typeName);
	                }
	                built[param] = value;
	            };
	            var builder = function () {
	                var args = [];
	                for (var _i = 0; _i < arguments.length; _i++) {
	                    args[_i] = arguments[_i];
	                }
	                var argc = args.length;
	                if (!_this.finalized) {
	                    throw new Error("attempting to instantiate unfinalized type " +
	                        _this.typeName);
	                }
	                var built = Object.create(nodePrototype);
	                _this.buildParams.forEach(function (param, i) {
	                    if (i < argc) {
	                        addParam(built, param, args[i], true);
	                    }
	                    else {
	                        addParam(built, param, null, false);
	                    }
	                });
	                Object.keys(_this.allFields).forEach(function (param) {
	                    addParam(built, param, null, false);
	                });
	                if (built.type !== _this.typeName) {
	                    throw new Error("");
	                }
	                return built;
	            };
	            builder.from = function (obj) {
	                if (!_this.finalized) {
	                    throw new Error("attempting to instantiate unfinalized type " +
	                        _this.typeName);
	                }
	                var built = Object.create(nodePrototype);
	                Object.keys(_this.allFields).forEach(function (param) {
	                    if (hasOwn.call(obj, param)) {
	                        addParam(built, param, obj[param], true);
	                    }
	                    else {
	                        addParam(built, param, null, false);
	                    }
	                });
	                if (built.type !== _this.typeName) {
	                    throw new Error("");
	                }
	                return built;
	            };
	            Object.defineProperty(builders, getBuilderName(this.typeName), {
	                enumerable: true,
	                value: builder
	            });
	            return this;
	        };
	        DefImpl.prototype.field = function (name, type, defaultFn, hidden) {
	            if (this.finalized) {
	                console.error("Ignoring attempt to redefine field " +
	                    JSON.stringify(name) + " of finalized type " +
	                    JSON.stringify(this.typeName));
	                return this;
	            }
	            this.ownFields[name] = new Field(name, Type.from(type), defaultFn, hidden);
	            return this;
	        };
	        DefImpl.prototype.finalize = function () {
	            var _this = this;
	            if (!this.finalized) {
	                var allFields = this.allFields;
	                var allSupertypes = this.allSupertypes;
	                this.baseNames.forEach(function (name) {
	                    var def = defCache[name];
	                    if (def instanceof Def) {
	                        def.finalize();
	                        extend(allFields, def.allFields);
	                        extend(allSupertypes, def.allSupertypes);
	                    }
	                    else {
	                        var message = "unknown supertype name " +
	                            JSON.stringify(name) +
	                            " for subtype " +
	                            JSON.stringify(_this.typeName);
	                        throw new Error(message);
	                    }
	                });
	                extend(allFields, this.ownFields);
	                allSupertypes[this.typeName] = this;
	                this.fieldNames.length = 0;
	                for (var fieldName in allFields) {
	                    if (hasOwn.call(allFields, fieldName) &&
	                        !allFields[fieldName].hidden) {
	                        this.fieldNames.push(fieldName);
	                    }
	                }
	                Object.defineProperty(namedTypes, this.typeName, {
	                    enumerable: true,
	                    value: this.type
	                });
	                this.finalized = true;
	                populateSupertypeList(this.typeName, this.supertypeList);
	                if (this.buildable &&
	                    this.supertypeList.lastIndexOf("Expression") >= 0) {
	                    wrapExpressionBuilderWithStatement(this.typeName);
	                }
	            }
	        };
	        return DefImpl;
	    }(Def));
	    function getSupertypeNames(typeName) {
	        if (!hasOwn.call(defCache, typeName)) {
	            throw new Error("");
	        }
	        var d = defCache[typeName];
	        if (d.finalized !== true) {
	            throw new Error("");
	        }
	        return d.supertypeList.slice(1);
	    }
	    function computeSupertypeLookupTable(candidates) {
	        var table = {};
	        var typeNames = Object.keys(defCache);
	        var typeNameCount = typeNames.length;
	        for (var i = 0; i < typeNameCount; ++i) {
	            var typeName = typeNames[i];
	            var d = defCache[typeName];
	            if (d.finalized !== true) {
	                throw new Error("" + typeName);
	            }
	            for (var j = 0; j < d.supertypeList.length; ++j) {
	                var superTypeName = d.supertypeList[j];
	                if (hasOwn.call(candidates, superTypeName)) {
	                    table[typeName] = superTypeName;
	                    break;
	                }
	            }
	        }
	        return table;
	    }
	    var builders = Object.create(null);
	    var nodePrototype = {};
	    function defineMethod(name, func) {
	        var old = nodePrototype[name];
	        if (isUndefined.check(func)) {
	            delete nodePrototype[name];
	        }
	        else {
	            isFunction.assert(func);
	            Object.defineProperty(nodePrototype, name, {
	                enumerable: true,
	                configurable: true,
	                value: func
	            });
	        }
	        return old;
	    }
	    function getBuilderName(typeName) {
	        return typeName.replace(/^[A-Z]+/, function (upperCasePrefix) {
	            var len = upperCasePrefix.length;
	            switch (len) {
	                case 0: return "";
	                case 1: return upperCasePrefix.toLowerCase();
	                default:
	                    return upperCasePrefix.slice(0, len - 1).toLowerCase() +
	                        upperCasePrefix.charAt(len - 1);
	            }
	        });
	    }
	    function getStatementBuilderName(typeName) {
	        typeName = getBuilderName(typeName);
	        return typeName.replace(/(Expression)?$/, "Statement");
	    }
	    var namedTypes = {};
	    function getFieldNames(object) {
	        var d = defFromValue(object);
	        if (d) {
	            return d.fieldNames.slice(0);
	        }
	        if ("type" in object) {
	            throw new Error("did not recognize object of type " +
	                JSON.stringify(object.type));
	        }
	        return Object.keys(object);
	    }
	    function getFieldValue(object, fieldName) {
	        var d = defFromValue(object);
	        if (d) {
	            var field = d.allFields[fieldName];
	            if (field) {
	                return field.getValue(object);
	            }
	        }
	        return object && object[fieldName];
	    }
	    function eachField(object, callback, context) {
	        getFieldNames(object).forEach(function (name) {
	            callback.call(this, name, getFieldValue(object, name));
	        }, context);
	    }
	    function someField(object, callback, context) {
	        return getFieldNames(object).some(function (name) {
	            return callback.call(this, name, getFieldValue(object, name));
	        }, context);
	    }
	    function wrapExpressionBuilderWithStatement(typeName) {
	        var wrapperName = getStatementBuilderName(typeName);
	        if (builders[wrapperName])
	            return;
	        var wrapped = builders[getBuilderName(typeName)];
	        if (!wrapped)
	            return;
	        var builder = function () {
	            var args = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                args[_i] = arguments[_i];
	            }
	            return builders.expressionStatement(wrapped.apply(builders, args));
	        };
	        builder.from = function () {
	            var args = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                args[_i] = arguments[_i];
	            }
	            return builders.expressionStatement(wrapped.from.apply(builders, args));
	        };
	        builders[wrapperName] = builder;
	    }
	    function populateSupertypeList(typeName, list) {
	        list.length = 0;
	        list.push(typeName);
	        var lastSeen = Object.create(null);
	        for (var pos = 0; pos < list.length; ++pos) {
	            typeName = list[pos];
	            var d = defCache[typeName];
	            if (d.finalized !== true) {
	                throw new Error("");
	            }
	            if (hasOwn.call(lastSeen, typeName)) {
	                delete list[lastSeen[typeName]];
	            }
	            lastSeen[typeName] = pos;
	            list.push.apply(list, d.baseNames);
	        }
	        for (var to = 0, from = to, len = list.length; from < len; ++from) {
	            if (hasOwn.call(list, from)) {
	                list[to++] = list[from];
	            }
	        }
	        list.length = to;
	    }
	    function extend(into, from) {
	        Object.keys(from).forEach(function (name) {
	            into[name] = from[name];
	        });
	        return into;
	    }
	    function finalize() {
	        Object.keys(defCache).forEach(function (name) {
	            defCache[name].finalize();
	        });
	    }
	    return {
	        Type: Type,
	        builtInTypes: builtInTypes,
	        getSupertypeNames: getSupertypeNames,
	        computeSupertypeLookupTable: computeSupertypeLookupTable,
	        builders: builders,
	        defineMethod: defineMethod,
	        getBuilderName: getBuilderName,
	        getStatementBuilderName: getStatementBuilderName,
	        namedTypes: namedTypes,
	        getFieldNames: getFieldNames,
	        getFieldValue: getFieldValue,
	        eachField: eachField,
	        someField: someField,
	        finalize: finalize,
	    };
	}
	types$1.default = typesPlugin;
	return types$1;
}

var pathVisitor = {exports: {}};

var nodePath = {exports: {}};

var path = {exports: {}};

var hasRequiredPath;

function requirePath () {
	if (hasRequiredPath) return path.exports;
	hasRequiredPath = 1;
	(function (module, exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		var tslib_1 = require$$0;
		var types_1 = tslib_1.__importDefault(requireTypes$1());
		var Op = Object.prototype;
		var hasOwn = Op.hasOwnProperty;
		function pathPlugin(fork) {
		    var types = fork.use(types_1.default);
		    var isArray = types.builtInTypes.array;
		    var isNumber = types.builtInTypes.number;
		    var Path = function Path(value, parentPath, name) {
		        if (!(this instanceof Path)) {
		            throw new Error("Path constructor cannot be invoked without 'new'");
		        }
		        if (parentPath) {
		            if (!(parentPath instanceof Path)) {
		                throw new Error("");
		            }
		        }
		        else {
		            parentPath = null;
		            name = null;
		        }
		        this.value = value;
		        this.parentPath = parentPath;
		        this.name = name;
		        this.__childCache = null;
		    };
		    var Pp = Path.prototype;
		    function getChildCache(path) {
		        return path.__childCache || (path.__childCache = Object.create(null));
		    }
		    function getChildPath(path, name) {
		        var cache = getChildCache(path);
		        var actualChildValue = path.getValueProperty(name);
		        var childPath = cache[name];
		        if (!hasOwn.call(cache, name) ||
		            childPath.value !== actualChildValue) {
		            childPath = cache[name] = new path.constructor(actualChildValue, path, name);
		        }
		        return childPath;
		    }
		    Pp.getValueProperty = function getValueProperty(name) {
		        return this.value[name];
		    };
		    Pp.get = function get() {
		        var names = [];
		        for (var _i = 0; _i < arguments.length; _i++) {
		            names[_i] = arguments[_i];
		        }
		        var path = this;
		        var count = names.length;
		        for (var i = 0; i < count; ++i) {
		            path = getChildPath(path, names[i]);
		        }
		        return path;
		    };
		    Pp.each = function each(callback, context) {
		        var childPaths = [];
		        var len = this.value.length;
		        var i = 0;
		        for (var i = 0; i < len; ++i) {
		            if (hasOwn.call(this.value, i)) {
		                childPaths[i] = this.get(i);
		            }
		        }
		        context = context || this;
		        for (i = 0; i < len; ++i) {
		            if (hasOwn.call(childPaths, i)) {
		                callback.call(context, childPaths[i]);
		            }
		        }
		    };
		    Pp.map = function map(callback, context) {
		        var result = [];
		        this.each(function (childPath) {
		            result.push(callback.call(this, childPath));
		        }, context);
		        return result;
		    };
		    Pp.filter = function filter(callback, context) {
		        var result = [];
		        this.each(function (childPath) {
		            if (callback.call(this, childPath)) {
		                result.push(childPath);
		            }
		        }, context);
		        return result;
		    };
		    function emptyMoves() { }
		    function getMoves(path, offset, start, end) {
		        isArray.assert(path.value);
		        if (offset === 0) {
		            return emptyMoves;
		        }
		        var length = path.value.length;
		        if (length < 1) {
		            return emptyMoves;
		        }
		        var argc = arguments.length;
		        if (argc === 2) {
		            start = 0;
		            end = length;
		        }
		        else if (argc === 3) {
		            start = Math.max(start, 0);
		            end = length;
		        }
		        else {
		            start = Math.max(start, 0);
		            end = Math.min(end, length);
		        }
		        isNumber.assert(start);
		        isNumber.assert(end);
		        var moves = Object.create(null);
		        var cache = getChildCache(path);
		        for (var i = start; i < end; ++i) {
		            if (hasOwn.call(path.value, i)) {
		                var childPath = path.get(i);
		                if (childPath.name !== i) {
		                    throw new Error("");
		                }
		                var newIndex = i + offset;
		                childPath.name = newIndex;
		                moves[newIndex] = childPath;
		                delete cache[i];
		            }
		        }
		        delete cache.length;
		        return function () {
		            for (var newIndex in moves) {
		                var childPath = moves[newIndex];
		                if (childPath.name !== +newIndex) {
		                    throw new Error("");
		                }
		                cache[newIndex] = childPath;
		                path.value[newIndex] = childPath.value;
		            }
		        };
		    }
		    Pp.shift = function shift() {
		        var move = getMoves(this, -1);
		        var result = this.value.shift();
		        move();
		        return result;
		    };
		    Pp.unshift = function unshift() {
		        var args = [];
		        for (var _i = 0; _i < arguments.length; _i++) {
		            args[_i] = arguments[_i];
		        }
		        var move = getMoves(this, args.length);
		        var result = this.value.unshift.apply(this.value, args);
		        move();
		        return result;
		    };
		    Pp.push = function push() {
		        var args = [];
		        for (var _i = 0; _i < arguments.length; _i++) {
		            args[_i] = arguments[_i];
		        }
		        isArray.assert(this.value);
		        delete getChildCache(this).length;
		        return this.value.push.apply(this.value, args);
		    };
		    Pp.pop = function pop() {
		        isArray.assert(this.value);
		        var cache = getChildCache(this);
		        delete cache[this.value.length - 1];
		        delete cache.length;
		        return this.value.pop();
		    };
		    Pp.insertAt = function insertAt(index) {
		        var argc = arguments.length;
		        var move = getMoves(this, argc - 1, index);
		        if (move === emptyMoves && argc <= 1) {
		            return this;
		        }
		        index = Math.max(index, 0);
		        for (var i = 1; i < argc; ++i) {
		            this.value[index + i - 1] = arguments[i];
		        }
		        move();
		        return this;
		    };
		    Pp.insertBefore = function insertBefore() {
		        var args = [];
		        for (var _i = 0; _i < arguments.length; _i++) {
		            args[_i] = arguments[_i];
		        }
		        var pp = this.parentPath;
		        var argc = args.length;
		        var insertAtArgs = [this.name];
		        for (var i = 0; i < argc; ++i) {
		            insertAtArgs.push(args[i]);
		        }
		        return pp.insertAt.apply(pp, insertAtArgs);
		    };
		    Pp.insertAfter = function insertAfter() {
		        var args = [];
		        for (var _i = 0; _i < arguments.length; _i++) {
		            args[_i] = arguments[_i];
		        }
		        var pp = this.parentPath;
		        var argc = args.length;
		        var insertAtArgs = [this.name + 1];
		        for (var i = 0; i < argc; ++i) {
		            insertAtArgs.push(args[i]);
		        }
		        return pp.insertAt.apply(pp, insertAtArgs);
		    };
		    function repairRelationshipWithParent(path) {
		        if (!(path instanceof Path)) {
		            throw new Error("");
		        }
		        var pp = path.parentPath;
		        if (!pp) {
		            return path;
		        }
		        var parentValue = pp.value;
		        var parentCache = getChildCache(pp);
		        if (parentValue[path.name] === path.value) {
		            parentCache[path.name] = path;
		        }
		        else if (isArray.check(parentValue)) {
		            var i = parentValue.indexOf(path.value);
		            if (i >= 0) {
		                parentCache[path.name = i] = path;
		            }
		        }
		        else {
		            parentValue[path.name] = path.value;
		            parentCache[path.name] = path;
		        }
		        if (parentValue[path.name] !== path.value) {
		            throw new Error("");
		        }
		        if (path.parentPath.get(path.name) !== path) {
		            throw new Error("");
		        }
		        return path;
		    }
		    Pp.replace = function replace(replacement) {
		        var results = [];
		        var parentValue = this.parentPath.value;
		        var parentCache = getChildCache(this.parentPath);
		        var count = arguments.length;
		        repairRelationshipWithParent(this);
		        if (isArray.check(parentValue)) {
		            var originalLength = parentValue.length;
		            var move = getMoves(this.parentPath, count - 1, this.name + 1);
		            var spliceArgs = [this.name, 1];
		            for (var i = 0; i < count; ++i) {
		                spliceArgs.push(arguments[i]);
		            }
		            var splicedOut = parentValue.splice.apply(parentValue, spliceArgs);
		            if (splicedOut[0] !== this.value) {
		                throw new Error("");
		            }
		            if (parentValue.length !== (originalLength - 1 + count)) {
		                throw new Error("");
		            }
		            move();
		            if (count === 0) {
		                delete this.value;
		                delete parentCache[this.name];
		                this.__childCache = null;
		            }
		            else {
		                if (parentValue[this.name] !== replacement) {
		                    throw new Error("");
		                }
		                if (this.value !== replacement) {
		                    this.value = replacement;
		                    this.__childCache = null;
		                }
		                for (i = 0; i < count; ++i) {
		                    results.push(this.parentPath.get(this.name + i));
		                }
		                if (results[0] !== this) {
		                    throw new Error("");
		                }
		            }
		        }
		        else if (count === 1) {
		            if (this.value !== replacement) {
		                this.__childCache = null;
		            }
		            this.value = parentValue[this.name] = replacement;
		            results.push(this);
		        }
		        else if (count === 0) {
		            delete parentValue[this.name];
		            delete this.value;
		            this.__childCache = null;
		        }
		        else {
		            throw new Error("Could not replace path");
		        }
		        return results;
		    };
		    return Path;
		}
		exports.default = pathPlugin;
		module.exports = exports["default"]; 
	} (path, path.exports));
	return path.exports;
}

var scope = {exports: {}};

var hasRequiredScope;

function requireScope () {
	if (hasRequiredScope) return scope.exports;
	hasRequiredScope = 1;
	(function (module, exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		var tslib_1 = require$$0;
		var types_1 = tslib_1.__importDefault(requireTypes$1());
		var hasOwn = Object.prototype.hasOwnProperty;
		function scopePlugin(fork) {
		    var types = fork.use(types_1.default);
		    var Type = types.Type;
		    var namedTypes = types.namedTypes;
		    var Node = namedTypes.Node;
		    var Expression = namedTypes.Expression;
		    var isArray = types.builtInTypes.array;
		    var b = types.builders;
		    var Scope = function Scope(path, parentScope) {
		        if (!(this instanceof Scope)) {
		            throw new Error("Scope constructor cannot be invoked without 'new'");
		        }
		        ScopeType.assert(path.value);
		        var depth;
		        if (parentScope) {
		            if (!(parentScope instanceof Scope)) {
		                throw new Error("");
		            }
		            depth = parentScope.depth + 1;
		        }
		        else {
		            parentScope = null;
		            depth = 0;
		        }
		        Object.defineProperties(this, {
		            path: { value: path },
		            node: { value: path.value },
		            isGlobal: { value: !parentScope, enumerable: true },
		            depth: { value: depth },
		            parent: { value: parentScope },
		            bindings: { value: {} },
		            types: { value: {} },
		        });
		    };
		    var scopeTypes = [
		        namedTypes.Program,
		        namedTypes.Function,
		        namedTypes.CatchClause
		    ];
		    var ScopeType = Type.or.apply(Type, scopeTypes);
		    Scope.isEstablishedBy = function (node) {
		        return ScopeType.check(node);
		    };
		    var Sp = Scope.prototype;
		    Sp.didScan = false;
		    Sp.declares = function (name) {
		        this.scan();
		        return hasOwn.call(this.bindings, name);
		    };
		    Sp.declaresType = function (name) {
		        this.scan();
		        return hasOwn.call(this.types, name);
		    };
		    Sp.declareTemporary = function (prefix) {
		        if (prefix) {
		            if (!/^[a-z$_]/i.test(prefix)) {
		                throw new Error("");
		            }
		        }
		        else {
		            prefix = "t$";
		        }
		        prefix += this.depth.toString(36) + "$";
		        this.scan();
		        var index = 0;
		        while (this.declares(prefix + index)) {
		            ++index;
		        }
		        var name = prefix + index;
		        return this.bindings[name] = types.builders.identifier(name);
		    };
		    Sp.injectTemporary = function (identifier, init) {
		        identifier || (identifier = this.declareTemporary());
		        var bodyPath = this.path.get("body");
		        if (namedTypes.BlockStatement.check(bodyPath.value)) {
		            bodyPath = bodyPath.get("body");
		        }
		        bodyPath.unshift(b.variableDeclaration("var", [b.variableDeclarator(identifier, init || null)]));
		        return identifier;
		    };
		    Sp.scan = function (force) {
		        if (force || !this.didScan) {
		            for (var name in this.bindings) {
		                delete this.bindings[name];
		            }
		            scanScope(this.path, this.bindings, this.types);
		            this.didScan = true;
		        }
		    };
		    Sp.getBindings = function () {
		        this.scan();
		        return this.bindings;
		    };
		    Sp.getTypes = function () {
		        this.scan();
		        return this.types;
		    };
		    function scanScope(path, bindings, scopeTypes) {
		        var node = path.value;
		        ScopeType.assert(node);
		        if (namedTypes.CatchClause.check(node)) {
		            var param = path.get("param");
		            if (param.value) {
		                addPattern(param, bindings);
		            }
		        }
		        else {
		            recursiveScanScope(path, bindings, scopeTypes);
		        }
		    }
		    function recursiveScanScope(path, bindings, scopeTypes) {
		        var node = path.value;
		        if (path.parent &&
		            namedTypes.FunctionExpression.check(path.parent.node) &&
		            path.parent.node.id) {
		            addPattern(path.parent.get("id"), bindings);
		        }
		        if (!node) ;
		        else if (isArray.check(node)) {
		            path.each(function (childPath) {
		                recursiveScanChild(childPath, bindings, scopeTypes);
		            });
		        }
		        else if (namedTypes.Function.check(node)) {
		            path.get("params").each(function (paramPath) {
		                addPattern(paramPath, bindings);
		            });
		            recursiveScanChild(path.get("body"), bindings, scopeTypes);
		        }
		        else if ((namedTypes.TypeAlias && namedTypes.TypeAlias.check(node)) ||
		            (namedTypes.InterfaceDeclaration && namedTypes.InterfaceDeclaration.check(node)) ||
		            (namedTypes.TSTypeAliasDeclaration && namedTypes.TSTypeAliasDeclaration.check(node)) ||
		            (namedTypes.TSInterfaceDeclaration && namedTypes.TSInterfaceDeclaration.check(node))) {
		            addTypePattern(path.get("id"), scopeTypes);
		        }
		        else if (namedTypes.VariableDeclarator.check(node)) {
		            addPattern(path.get("id"), bindings);
		            recursiveScanChild(path.get("init"), bindings, scopeTypes);
		        }
		        else if (node.type === "ImportSpecifier" ||
		            node.type === "ImportNamespaceSpecifier" ||
		            node.type === "ImportDefaultSpecifier") {
		            addPattern(
		            path.get(node.local ? "local" :
		                node.name ? "name" : "id"), bindings);
		        }
		        else if (Node.check(node) && !Expression.check(node)) {
		            types.eachField(node, function (name, child) {
		                var childPath = path.get(name);
		                if (!pathHasValue(childPath, child)) {
		                    throw new Error("");
		                }
		                recursiveScanChild(childPath, bindings, scopeTypes);
		            });
		        }
		    }
		    function pathHasValue(path, value) {
		        if (path.value === value) {
		            return true;
		        }
		        if (Array.isArray(path.value) &&
		            path.value.length === 0 &&
		            Array.isArray(value) &&
		            value.length === 0) {
		            return true;
		        }
		        return false;
		    }
		    function recursiveScanChild(path, bindings, scopeTypes) {
		        var node = path.value;
		        if (!node || Expression.check(node)) ;
		        else if (namedTypes.FunctionDeclaration.check(node) &&
		            node.id !== null) {
		            addPattern(path.get("id"), bindings);
		        }
		        else if (namedTypes.ClassDeclaration &&
		            namedTypes.ClassDeclaration.check(node)) {
		            addPattern(path.get("id"), bindings);
		        }
		        else if (ScopeType.check(node)) {
		            if (namedTypes.CatchClause.check(node) &&
		                namedTypes.Identifier.check(node.param)) {
		                var catchParamName = node.param.name;
		                var hadBinding = hasOwn.call(bindings, catchParamName);
		                recursiveScanScope(path.get("body"), bindings, scopeTypes);
		                if (!hadBinding) {
		                    delete bindings[catchParamName];
		                }
		            }
		        }
		        else {
		            recursiveScanScope(path, bindings, scopeTypes);
		        }
		    }
		    function addPattern(patternPath, bindings) {
		        var pattern = patternPath.value;
		        namedTypes.Pattern.assert(pattern);
		        if (namedTypes.Identifier.check(pattern)) {
		            if (hasOwn.call(bindings, pattern.name)) {
		                bindings[pattern.name].push(patternPath);
		            }
		            else {
		                bindings[pattern.name] = [patternPath];
		            }
		        }
		        else if (namedTypes.AssignmentPattern &&
		            namedTypes.AssignmentPattern.check(pattern)) {
		            addPattern(patternPath.get('left'), bindings);
		        }
		        else if (namedTypes.ObjectPattern &&
		            namedTypes.ObjectPattern.check(pattern)) {
		            patternPath.get('properties').each(function (propertyPath) {
		                var property = propertyPath.value;
		                if (namedTypes.Pattern.check(property)) {
		                    addPattern(propertyPath, bindings);
		                }
		                else if (namedTypes.Property.check(property)) {
		                    addPattern(propertyPath.get('value'), bindings);
		                }
		                else if (namedTypes.SpreadProperty &&
		                    namedTypes.SpreadProperty.check(property)) {
		                    addPattern(propertyPath.get('argument'), bindings);
		                }
		            });
		        }
		        else if (namedTypes.ArrayPattern &&
		            namedTypes.ArrayPattern.check(pattern)) {
		            patternPath.get('elements').each(function (elementPath) {
		                var element = elementPath.value;
		                if (namedTypes.Pattern.check(element)) {
		                    addPattern(elementPath, bindings);
		                }
		                else if (namedTypes.SpreadElement &&
		                    namedTypes.SpreadElement.check(element)) {
		                    addPattern(elementPath.get("argument"), bindings);
		                }
		            });
		        }
		        else if (namedTypes.PropertyPattern &&
		            namedTypes.PropertyPattern.check(pattern)) {
		            addPattern(patternPath.get('pattern'), bindings);
		        }
		        else if ((namedTypes.SpreadElementPattern &&
		            namedTypes.SpreadElementPattern.check(pattern)) ||
		            (namedTypes.SpreadPropertyPattern &&
		                namedTypes.SpreadPropertyPattern.check(pattern))) {
		            addPattern(patternPath.get('argument'), bindings);
		        }
		    }
		    function addTypePattern(patternPath, types) {
		        var pattern = patternPath.value;
		        namedTypes.Pattern.assert(pattern);
		        if (namedTypes.Identifier.check(pattern)) {
		            if (hasOwn.call(types, pattern.name)) {
		                types[pattern.name].push(patternPath);
		            }
		            else {
		                types[pattern.name] = [patternPath];
		            }
		        }
		    }
		    Sp.lookup = function (name) {
		        for (var scope = this; scope; scope = scope.parent)
		            if (scope.declares(name))
		                break;
		        return scope;
		    };
		    Sp.lookupType = function (name) {
		        for (var scope = this; scope; scope = scope.parent)
		            if (scope.declaresType(name))
		                break;
		        return scope;
		    };
		    Sp.getGlobalScope = function () {
		        var scope = this;
		        while (!scope.isGlobal)
		            scope = scope.parent;
		        return scope;
		    };
		    return Scope;
		}
		exports.default = scopePlugin;
		module.exports = exports["default"]; 
	} (scope, scope.exports));
	return scope.exports;
}

var hasRequiredNodePath;

function requireNodePath () {
	if (hasRequiredNodePath) return nodePath.exports;
	hasRequiredNodePath = 1;
	(function (module, exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		var tslib_1 = require$$0;
		var types_1 = tslib_1.__importDefault(requireTypes$1());
		var path_1 = tslib_1.__importDefault(requirePath());
		var scope_1 = tslib_1.__importDefault(requireScope());
		function nodePathPlugin(fork) {
		    var types = fork.use(types_1.default);
		    var n = types.namedTypes;
		    var b = types.builders;
		    var isNumber = types.builtInTypes.number;
		    var isArray = types.builtInTypes.array;
		    var Path = fork.use(path_1.default);
		    var Scope = fork.use(scope_1.default);
		    var NodePath = function NodePath(value, parentPath, name) {
		        if (!(this instanceof NodePath)) {
		            throw new Error("NodePath constructor cannot be invoked without 'new'");
		        }
		        Path.call(this, value, parentPath, name);
		    };
		    var NPp = NodePath.prototype = Object.create(Path.prototype, {
		        constructor: {
		            value: NodePath,
		            enumerable: false,
		            writable: true,
		            configurable: true
		        }
		    });
		    Object.defineProperties(NPp, {
		        node: {
		            get: function () {
		                Object.defineProperty(this, "node", {
		                    configurable: true,
		                    value: this._computeNode()
		                });
		                return this.node;
		            }
		        },
		        parent: {
		            get: function () {
		                Object.defineProperty(this, "parent", {
		                    configurable: true,
		                    value: this._computeParent()
		                });
		                return this.parent;
		            }
		        },
		        scope: {
		            get: function () {
		                Object.defineProperty(this, "scope", {
		                    configurable: true,
		                    value: this._computeScope()
		                });
		                return this.scope;
		            }
		        }
		    });
		    NPp.replace = function () {
		        delete this.node;
		        delete this.parent;
		        delete this.scope;
		        return Path.prototype.replace.apply(this, arguments);
		    };
		    NPp.prune = function () {
		        var remainingNodePath = this.parent;
		        this.replace();
		        return cleanUpNodesAfterPrune(remainingNodePath);
		    };
		    NPp._computeNode = function () {
		        var value = this.value;
		        if (n.Node.check(value)) {
		            return value;
		        }
		        var pp = this.parentPath;
		        return pp && pp.node || null;
		    };
		    NPp._computeParent = function () {
		        var value = this.value;
		        var pp = this.parentPath;
		        if (!n.Node.check(value)) {
		            while (pp && !n.Node.check(pp.value)) {
		                pp = pp.parentPath;
		            }
		            if (pp) {
		                pp = pp.parentPath;
		            }
		        }
		        while (pp && !n.Node.check(pp.value)) {
		            pp = pp.parentPath;
		        }
		        return pp || null;
		    };
		    NPp._computeScope = function () {
		        var value = this.value;
		        var pp = this.parentPath;
		        var scope = pp && pp.scope;
		        if (n.Node.check(value) &&
		            Scope.isEstablishedBy(value)) {
		            scope = new Scope(this, scope);
		        }
		        return scope || null;
		    };
		    NPp.getValueProperty = function (name) {
		        return types.getFieldValue(this.value, name);
		    };
		    NPp.needsParens = function (assumeExpressionContext) {
		        var pp = this.parentPath;
		        if (!pp) {
		            return false;
		        }
		        var node = this.value;
		        if (!n.Expression.check(node)) {
		            return false;
		        }
		        if (node.type === "Identifier") {
		            return false;
		        }
		        while (!n.Node.check(pp.value)) {
		            pp = pp.parentPath;
		            if (!pp) {
		                return false;
		            }
		        }
		        var parent = pp.value;
		        switch (node.type) {
		            case "UnaryExpression":
		            case "SpreadElement":
		            case "SpreadProperty":
		                return parent.type === "MemberExpression"
		                    && this.name === "object"
		                    && parent.object === node;
		            case "BinaryExpression":
		            case "LogicalExpression":
		                switch (parent.type) {
		                    case "CallExpression":
		                        return this.name === "callee"
		                            && parent.callee === node;
		                    case "UnaryExpression":
		                    case "SpreadElement":
		                    case "SpreadProperty":
		                        return true;
		                    case "MemberExpression":
		                        return this.name === "object"
		                            && parent.object === node;
		                    case "BinaryExpression":
		                    case "LogicalExpression": {
		                        var n_1 = node;
		                        var po = parent.operator;
		                        var pp_1 = PRECEDENCE[po];
		                        var no = n_1.operator;
		                        var np = PRECEDENCE[no];
		                        if (pp_1 > np) {
		                            return true;
		                        }
		                        if (pp_1 === np && this.name === "right") {
		                            if (parent.right !== n_1) {
		                                throw new Error("Nodes must be equal");
		                            }
		                            return true;
		                        }
		                    }
		                    default:
		                        return false;
		                }
		            case "SequenceExpression":
		                switch (parent.type) {
		                    case "ForStatement":
		                        return false;
		                    case "ExpressionStatement":
		                        return this.name !== "expression";
		                    default:
		                        return true;
		                }
		            case "YieldExpression":
		                switch (parent.type) {
		                    case "BinaryExpression":
		                    case "LogicalExpression":
		                    case "UnaryExpression":
		                    case "SpreadElement":
		                    case "SpreadProperty":
		                    case "CallExpression":
		                    case "MemberExpression":
		                    case "NewExpression":
		                    case "ConditionalExpression":
		                    case "YieldExpression":
		                        return true;
		                    default:
		                        return false;
		                }
		            case "Literal":
		                return parent.type === "MemberExpression"
		                    && isNumber.check(node.value)
		                    && this.name === "object"
		                    && parent.object === node;
		            case "AssignmentExpression":
		            case "ConditionalExpression":
		                switch (parent.type) {
		                    case "UnaryExpression":
		                    case "SpreadElement":
		                    case "SpreadProperty":
		                    case "BinaryExpression":
		                    case "LogicalExpression":
		                        return true;
		                    case "CallExpression":
		                        return this.name === "callee"
		                            && parent.callee === node;
		                    case "ConditionalExpression":
		                        return this.name === "test"
		                            && parent.test === node;
		                    case "MemberExpression":
		                        return this.name === "object"
		                            && parent.object === node;
		                    default:
		                        return false;
		                }
		            default:
		                if (parent.type === "NewExpression" &&
		                    this.name === "callee" &&
		                    parent.callee === node) {
		                    return containsCallExpression(node);
		                }
		        }
		        if (assumeExpressionContext !== true &&
		            !this.canBeFirstInStatement() &&
		            this.firstInStatement())
		            return true;
		        return false;
		    };
		    function isBinary(node) {
		        return n.BinaryExpression.check(node)
		            || n.LogicalExpression.check(node);
		    }
		    var PRECEDENCE = {};
		    [["||"],
		        ["&&"],
		        ["|"],
		        ["^"],
		        ["&"],
		        ["==", "===", "!=", "!=="],
		        ["<", ">", "<=", ">=", "in", "instanceof"],
		        [">>", "<<", ">>>"],
		        ["+", "-"],
		        ["*", "/", "%"]
		    ].forEach(function (tier, i) {
		        tier.forEach(function (op) {
		            PRECEDENCE[op] = i;
		        });
		    });
		    function containsCallExpression(node) {
		        if (n.CallExpression.check(node)) {
		            return true;
		        }
		        if (isArray.check(node)) {
		            return node.some(containsCallExpression);
		        }
		        if (n.Node.check(node)) {
		            return types.someField(node, function (_name, child) {
		                return containsCallExpression(child);
		            });
		        }
		        return false;
		    }
		    NPp.canBeFirstInStatement = function () {
		        var node = this.node;
		        return !n.FunctionExpression.check(node)
		            && !n.ObjectExpression.check(node);
		    };
		    NPp.firstInStatement = function () {
		        return firstInStatement(this);
		    };
		    function firstInStatement(path) {
		        for (var node, parent; path.parent; path = path.parent) {
		            node = path.node;
		            parent = path.parent.node;
		            if (n.BlockStatement.check(parent) &&
		                path.parent.name === "body" &&
		                path.name === 0) {
		                if (parent.body[0] !== node) {
		                    throw new Error("Nodes must be equal");
		                }
		                return true;
		            }
		            if (n.ExpressionStatement.check(parent) &&
		                path.name === "expression") {
		                if (parent.expression !== node) {
		                    throw new Error("Nodes must be equal");
		                }
		                return true;
		            }
		            if (n.SequenceExpression.check(parent) &&
		                path.parent.name === "expressions" &&
		                path.name === 0) {
		                if (parent.expressions[0] !== node) {
		                    throw new Error("Nodes must be equal");
		                }
		                continue;
		            }
		            if (n.CallExpression.check(parent) &&
		                path.name === "callee") {
		                if (parent.callee !== node) {
		                    throw new Error("Nodes must be equal");
		                }
		                continue;
		            }
		            if (n.MemberExpression.check(parent) &&
		                path.name === "object") {
		                if (parent.object !== node) {
		                    throw new Error("Nodes must be equal");
		                }
		                continue;
		            }
		            if (n.ConditionalExpression.check(parent) &&
		                path.name === "test") {
		                if (parent.test !== node) {
		                    throw new Error("Nodes must be equal");
		                }
		                continue;
		            }
		            if (isBinary(parent) &&
		                path.name === "left") {
		                if (parent.left !== node) {
		                    throw new Error("Nodes must be equal");
		                }
		                continue;
		            }
		            if (n.UnaryExpression.check(parent) &&
		                !parent.prefix &&
		                path.name === "argument") {
		                if (parent.argument !== node) {
		                    throw new Error("Nodes must be equal");
		                }
		                continue;
		            }
		            return false;
		        }
		        return true;
		    }
		    function cleanUpNodesAfterPrune(remainingNodePath) {
		        if (n.VariableDeclaration.check(remainingNodePath.node)) {
		            var declarations = remainingNodePath.get('declarations').value;
		            if (!declarations || declarations.length === 0) {
		                return remainingNodePath.prune();
		            }
		        }
		        else if (n.ExpressionStatement.check(remainingNodePath.node)) {
		            if (!remainingNodePath.get('expression').value) {
		                return remainingNodePath.prune();
		            }
		        }
		        else if (n.IfStatement.check(remainingNodePath.node)) {
		            cleanUpIfStatementAfterPrune(remainingNodePath);
		        }
		        return remainingNodePath;
		    }
		    function cleanUpIfStatementAfterPrune(ifStatement) {
		        var testExpression = ifStatement.get('test').value;
		        var alternate = ifStatement.get('alternate').value;
		        var consequent = ifStatement.get('consequent').value;
		        if (!consequent && !alternate) {
		            var testExpressionStatement = b.expressionStatement(testExpression);
		            ifStatement.replace(testExpressionStatement);
		        }
		        else if (!consequent && alternate) {
		            var negatedTestExpression = b.unaryExpression('!', testExpression, true);
		            if (n.UnaryExpression.check(testExpression) && testExpression.operator === '!') {
		                negatedTestExpression = testExpression.argument;
		            }
		            ifStatement.get("test").replace(negatedTestExpression);
		            ifStatement.get("consequent").replace(alternate);
		            ifStatement.get("alternate").replace();
		        }
		    }
		    return NodePath;
		}
		exports.default = nodePathPlugin;
		module.exports = exports["default"]; 
	} (nodePath, nodePath.exports));
	return nodePath.exports;
}

var hasRequiredPathVisitor;

function requirePathVisitor () {
	if (hasRequiredPathVisitor) return pathVisitor.exports;
	hasRequiredPathVisitor = 1;
	(function (module, exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		var tslib_1 = require$$0;
		var types_1 = tslib_1.__importDefault(requireTypes$1());
		var node_path_1 = tslib_1.__importDefault(requireNodePath());
		var hasOwn = Object.prototype.hasOwnProperty;
		function pathVisitorPlugin(fork) {
		    var types = fork.use(types_1.default);
		    var NodePath = fork.use(node_path_1.default);
		    var isArray = types.builtInTypes.array;
		    var isObject = types.builtInTypes.object;
		    var isFunction = types.builtInTypes.function;
		    var undefined$1;
		    var PathVisitor = function PathVisitor() {
		        if (!(this instanceof PathVisitor)) {
		            throw new Error("PathVisitor constructor cannot be invoked without 'new'");
		        }
		        this._reusableContextStack = [];
		        this._methodNameTable = computeMethodNameTable(this);
		        this._shouldVisitComments =
		            hasOwn.call(this._methodNameTable, "Block") ||
		                hasOwn.call(this._methodNameTable, "Line");
		        this.Context = makeContextConstructor(this);
		        this._visiting = false;
		        this._changeReported = false;
		    };
		    function computeMethodNameTable(visitor) {
		        var typeNames = Object.create(null);
		        for (var methodName in visitor) {
		            if (/^visit[A-Z]/.test(methodName)) {
		                typeNames[methodName.slice("visit".length)] = true;
		            }
		        }
		        var supertypeTable = types.computeSupertypeLookupTable(typeNames);
		        var methodNameTable = Object.create(null);
		        var typeNameKeys = Object.keys(supertypeTable);
		        var typeNameCount = typeNameKeys.length;
		        for (var i = 0; i < typeNameCount; ++i) {
		            var typeName = typeNameKeys[i];
		            methodName = "visit" + supertypeTable[typeName];
		            if (isFunction.check(visitor[methodName])) {
		                methodNameTable[typeName] = methodName;
		            }
		        }
		        return methodNameTable;
		    }
		    PathVisitor.fromMethodsObject = function fromMethodsObject(methods) {
		        if (methods instanceof PathVisitor) {
		            return methods;
		        }
		        if (!isObject.check(methods)) {
		            return new PathVisitor;
		        }
		        var Visitor = function Visitor() {
		            if (!(this instanceof Visitor)) {
		                throw new Error("Visitor constructor cannot be invoked without 'new'");
		            }
		            PathVisitor.call(this);
		        };
		        var Vp = Visitor.prototype = Object.create(PVp);
		        Vp.constructor = Visitor;
		        extend(Vp, methods);
		        extend(Visitor, PathVisitor);
		        isFunction.assert(Visitor.fromMethodsObject);
		        isFunction.assert(Visitor.visit);
		        return new Visitor;
		    };
		    function extend(target, source) {
		        for (var property in source) {
		            if (hasOwn.call(source, property)) {
		                target[property] = source[property];
		            }
		        }
		        return target;
		    }
		    PathVisitor.visit = function visit(node, methods) {
		        return PathVisitor.fromMethodsObject(methods).visit(node);
		    };
		    var PVp = PathVisitor.prototype;
		    PVp.visit = function () {
		        if (this._visiting) {
		            throw new Error("Recursively calling visitor.visit(path) resets visitor state. " +
		                "Try this.visit(path) or this.traverse(path) instead.");
		        }
		        this._visiting = true;
		        this._changeReported = false;
		        this._abortRequested = false;
		        var argc = arguments.length;
		        var args = new Array(argc);
		        for (var i = 0; i < argc; ++i) {
		            args[i] = arguments[i];
		        }
		        if (!(args[0] instanceof NodePath)) {
		            args[0] = new NodePath({ root: args[0] }).get("root");
		        }
		        this.reset.apply(this, args);
		        var didNotThrow;
		        try {
		            var root = this.visitWithoutReset(args[0]);
		            didNotThrow = true;
		        }
		        finally {
		            this._visiting = false;
		            if (!didNotThrow && this._abortRequested) {
		                return args[0].value;
		            }
		        }
		        return root;
		    };
		    PVp.AbortRequest = function AbortRequest() { };
		    PVp.abort = function () {
		        var visitor = this;
		        visitor._abortRequested = true;
		        var request = new visitor.AbortRequest();
		        request.cancel = function () {
		            visitor._abortRequested = false;
		        };
		        throw request;
		    };
		    PVp.reset = function (_path ) {
		    };
		    PVp.visitWithoutReset = function (path) {
		        if (this instanceof this.Context) {
		            return this.visitor.visitWithoutReset(path);
		        }
		        if (!(path instanceof NodePath)) {
		            throw new Error("");
		        }
		        var value = path.value;
		        var methodName = value &&
		            typeof value === "object" &&
		            typeof value.type === "string" &&
		            this._methodNameTable[value.type];
		        if (methodName) {
		            var context = this.acquireContext(path);
		            try {
		                return context.invokeVisitorMethod(methodName);
		            }
		            finally {
		                this.releaseContext(context);
		            }
		        }
		        else {
		            return visitChildren(path, this);
		        }
		    };
		    function visitChildren(path, visitor) {
		        if (!(path instanceof NodePath)) {
		            throw new Error("");
		        }
		        if (!(visitor instanceof PathVisitor)) {
		            throw new Error("");
		        }
		        var value = path.value;
		        if (isArray.check(value)) {
		            path.each(visitor.visitWithoutReset, visitor);
		        }
		        else if (!isObject.check(value)) ;
		        else {
		            var childNames = types.getFieldNames(value);
		            if (visitor._shouldVisitComments &&
		                value.comments &&
		                childNames.indexOf("comments") < 0) {
		                childNames.push("comments");
		            }
		            var childCount = childNames.length;
		            var childPaths = [];
		            for (var i = 0; i < childCount; ++i) {
		                var childName = childNames[i];
		                if (!hasOwn.call(value, childName)) {
		                    value[childName] = types.getFieldValue(value, childName);
		                }
		                childPaths.push(path.get(childName));
		            }
		            for (var i = 0; i < childCount; ++i) {
		                visitor.visitWithoutReset(childPaths[i]);
		            }
		        }
		        return path.value;
		    }
		    PVp.acquireContext = function (path) {
		        if (this._reusableContextStack.length === 0) {
		            return new this.Context(path);
		        }
		        return this._reusableContextStack.pop().reset(path);
		    };
		    PVp.releaseContext = function (context) {
		        if (!(context instanceof this.Context)) {
		            throw new Error("");
		        }
		        this._reusableContextStack.push(context);
		        context.currentPath = null;
		    };
		    PVp.reportChanged = function () {
		        this._changeReported = true;
		    };
		    PVp.wasChangeReported = function () {
		        return this._changeReported;
		    };
		    function makeContextConstructor(visitor) {
		        function Context(path) {
		            if (!(this instanceof Context)) {
		                throw new Error("");
		            }
		            if (!(this instanceof PathVisitor)) {
		                throw new Error("");
		            }
		            if (!(path instanceof NodePath)) {
		                throw new Error("");
		            }
		            Object.defineProperty(this, "visitor", {
		                value: visitor,
		                writable: false,
		                enumerable: true,
		                configurable: false
		            });
		            this.currentPath = path;
		            this.needToCallTraverse = true;
		            Object.seal(this);
		        }
		        if (!(visitor instanceof PathVisitor)) {
		            throw new Error("");
		        }
		        var Cp = Context.prototype = Object.create(visitor);
		        Cp.constructor = Context;
		        extend(Cp, sharedContextProtoMethods);
		        return Context;
		    }
		    var sharedContextProtoMethods = Object.create(null);
		    sharedContextProtoMethods.reset =
		        function reset(path) {
		            if (!(this instanceof this.Context)) {
		                throw new Error("");
		            }
		            if (!(path instanceof NodePath)) {
		                throw new Error("");
		            }
		            this.currentPath = path;
		            this.needToCallTraverse = true;
		            return this;
		        };
		    sharedContextProtoMethods.invokeVisitorMethod =
		        function invokeVisitorMethod(methodName) {
		            if (!(this instanceof this.Context)) {
		                throw new Error("");
		            }
		            if (!(this.currentPath instanceof NodePath)) {
		                throw new Error("");
		            }
		            var result = this.visitor[methodName].call(this, this.currentPath);
		            if (result === false) {
		                this.needToCallTraverse = false;
		            }
		            else if (result !== undefined$1) {
		                this.currentPath = this.currentPath.replace(result)[0];
		                if (this.needToCallTraverse) {
		                    this.traverse(this.currentPath);
		                }
		            }
		            if (this.needToCallTraverse !== false) {
		                throw new Error("Must either call this.traverse or return false in " + methodName);
		            }
		            var path = this.currentPath;
		            return path && path.value;
		        };
		    sharedContextProtoMethods.traverse =
		        function traverse(path, newVisitor) {
		            if (!(this instanceof this.Context)) {
		                throw new Error("");
		            }
		            if (!(path instanceof NodePath)) {
		                throw new Error("");
		            }
		            if (!(this.currentPath instanceof NodePath)) {
		                throw new Error("");
		            }
		            this.needToCallTraverse = false;
		            return visitChildren(path, PathVisitor.fromMethodsObject(newVisitor || this.visitor));
		        };
		    sharedContextProtoMethods.visit =
		        function visit(path, newVisitor) {
		            if (!(this instanceof this.Context)) {
		                throw new Error("");
		            }
		            if (!(path instanceof NodePath)) {
		                throw new Error("");
		            }
		            if (!(this.currentPath instanceof NodePath)) {
		                throw new Error("");
		            }
		            this.needToCallTraverse = false;
		            return PathVisitor.fromMethodsObject(newVisitor || this.visitor).visitWithoutReset(path);
		        };
		    sharedContextProtoMethods.reportChanged = function reportChanged() {
		        this.visitor.reportChanged();
		    };
		    sharedContextProtoMethods.abort = function abort() {
		        this.needToCallTraverse = false;
		        this.visitor.abort();
		    };
		    return PathVisitor;
		}
		exports.default = pathVisitorPlugin;
		module.exports = exports["default"]; 
	} (pathVisitor, pathVisitor.exports));
	return pathVisitor.exports;
}

var equiv = {exports: {}};

var hasRequiredEquiv;

function requireEquiv () {
	if (hasRequiredEquiv) return equiv.exports;
	hasRequiredEquiv = 1;
	(function (module, exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		var tslib_1 = require$$0;
		var types_1 = tslib_1.__importDefault(requireTypes$1());
		function default_1(fork) {
		    var types = fork.use(types_1.default);
		    var getFieldNames = types.getFieldNames;
		    var getFieldValue = types.getFieldValue;
		    var isArray = types.builtInTypes.array;
		    var isObject = types.builtInTypes.object;
		    var isDate = types.builtInTypes.Date;
		    var isRegExp = types.builtInTypes.RegExp;
		    var hasOwn = Object.prototype.hasOwnProperty;
		    function astNodesAreEquivalent(a, b, problemPath) {
		        if (isArray.check(problemPath)) {
		            problemPath.length = 0;
		        }
		        else {
		            problemPath = null;
		        }
		        return areEquivalent(a, b, problemPath);
		    }
		    astNodesAreEquivalent.assert = function (a, b) {
		        var problemPath = [];
		        if (!astNodesAreEquivalent(a, b, problemPath)) {
		            if (problemPath.length === 0) {
		                if (a !== b) {
		                    throw new Error("Nodes must be equal");
		                }
		            }
		            else {
		                throw new Error("Nodes differ in the following path: " +
		                    problemPath.map(subscriptForProperty).join(""));
		            }
		        }
		    };
		    function subscriptForProperty(property) {
		        if (/[_$a-z][_$a-z0-9]*/i.test(property)) {
		            return "." + property;
		        }
		        return "[" + JSON.stringify(property) + "]";
		    }
		    function areEquivalent(a, b, problemPath) {
		        if (a === b) {
		            return true;
		        }
		        if (isArray.check(a)) {
		            return arraysAreEquivalent(a, b, problemPath);
		        }
		        if (isObject.check(a)) {
		            return objectsAreEquivalent(a, b, problemPath);
		        }
		        if (isDate.check(a)) {
		            return isDate.check(b) && (+a === +b);
		        }
		        if (isRegExp.check(a)) {
		            return isRegExp.check(b) && (a.source === b.source &&
		                a.global === b.global &&
		                a.multiline === b.multiline &&
		                a.ignoreCase === b.ignoreCase);
		        }
		        return a == b;
		    }
		    function arraysAreEquivalent(a, b, problemPath) {
		        isArray.assert(a);
		        var aLength = a.length;
		        if (!isArray.check(b) || b.length !== aLength) {
		            if (problemPath) {
		                problemPath.push("length");
		            }
		            return false;
		        }
		        for (var i = 0; i < aLength; ++i) {
		            if (problemPath) {
		                problemPath.push(i);
		            }
		            if (i in a !== i in b) {
		                return false;
		            }
		            if (!areEquivalent(a[i], b[i], problemPath)) {
		                return false;
		            }
		            if (problemPath) {
		                var problemPathTail = problemPath.pop();
		                if (problemPathTail !== i) {
		                    throw new Error("" + problemPathTail);
		                }
		            }
		        }
		        return true;
		    }
		    function objectsAreEquivalent(a, b, problemPath) {
		        isObject.assert(a);
		        if (!isObject.check(b)) {
		            return false;
		        }
		        if (a.type !== b.type) {
		            if (problemPath) {
		                problemPath.push("type");
		            }
		            return false;
		        }
		        var aNames = getFieldNames(a);
		        var aNameCount = aNames.length;
		        var bNames = getFieldNames(b);
		        var bNameCount = bNames.length;
		        if (aNameCount === bNameCount) {
		            for (var i = 0; i < aNameCount; ++i) {
		                var name = aNames[i];
		                var aChild = getFieldValue(a, name);
		                var bChild = getFieldValue(b, name);
		                if (problemPath) {
		                    problemPath.push(name);
		                }
		                if (!areEquivalent(aChild, bChild, problemPath)) {
		                    return false;
		                }
		                if (problemPath) {
		                    var problemPathTail = problemPath.pop();
		                    if (problemPathTail !== name) {
		                        throw new Error("" + problemPathTail);
		                    }
		                }
		            }
		            return true;
		        }
		        if (!problemPath) {
		            return false;
		        }
		        var seenNames = Object.create(null);
		        for (i = 0; i < aNameCount; ++i) {
		            seenNames[aNames[i]] = true;
		        }
		        for (i = 0; i < bNameCount; ++i) {
		            name = bNames[i];
		            if (!hasOwn.call(seenNames, name)) {
		                problemPath.push(name);
		                return false;
		            }
		            delete seenNames[name];
		        }
		        for (name in seenNames) {
		            problemPath.push(name);
		            break;
		        }
		        return false;
		    }
		    return astNodesAreEquivalent;
		}
		exports.default = default_1;
		module.exports = exports["default"]; 
	} (equiv, equiv.exports));
	return equiv.exports;
}

var hasRequiredFork;

function requireFork () {
	if (hasRequiredFork) return fork.exports;
	hasRequiredFork = 1;
	(function (module, exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		var tslib_1 = require$$0;
		var types_1 = tslib_1.__importDefault(requireTypes$1());
		var path_visitor_1 = tslib_1.__importDefault(requirePathVisitor());
		var equiv_1 = tslib_1.__importDefault(requireEquiv());
		var path_1 = tslib_1.__importDefault(requirePath());
		var node_path_1 = tslib_1.__importDefault(requireNodePath());
		function default_1(defs) {
		    var fork = createFork();
		    var types = fork.use(types_1.default);
		    defs.forEach(fork.use);
		    types.finalize();
		    var PathVisitor = fork.use(path_visitor_1.default);
		    return {
		        Type: types.Type,
		        builtInTypes: types.builtInTypes,
		        namedTypes: types.namedTypes,
		        builders: types.builders,
		        defineMethod: types.defineMethod,
		        getFieldNames: types.getFieldNames,
		        getFieldValue: types.getFieldValue,
		        eachField: types.eachField,
		        someField: types.someField,
		        getSupertypeNames: types.getSupertypeNames,
		        getBuilderName: types.getBuilderName,
		        astNodesAreEquivalent: fork.use(equiv_1.default),
		        finalize: types.finalize,
		        Path: fork.use(path_1.default),
		        NodePath: fork.use(node_path_1.default),
		        PathVisitor: PathVisitor,
		        use: fork.use,
		        visit: PathVisitor.visit,
		    };
		}
		exports.default = default_1;
		function createFork() {
		    var used = [];
		    var usedResult = [];
		    function use(plugin) {
		        var idx = used.indexOf(plugin);
		        if (idx === -1) {
		            idx = used.length;
		            used.push(plugin);
		            usedResult[idx] = plugin(fork);
		        }
		        return usedResult[idx];
		    }
		    var fork = { use: use };
		    return fork;
		}
		module.exports = exports["default"]; 
	} (fork, fork.exports));
	return fork.exports;
}

var core = {exports: {}};

var shared = {exports: {}};

var hasRequiredShared;

function requireShared () {
	if (hasRequiredShared) return shared.exports;
	hasRequiredShared = 1;
	(function (module, exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		var tslib_1 = require$$0;
		var types_1 = tslib_1.__importDefault(requireTypes$1());
		function default_1(fork) {
		    var types = fork.use(types_1.default);
		    var Type = types.Type;
		    var builtin = types.builtInTypes;
		    var isNumber = builtin.number;
		    function geq(than) {
		        return Type.from(function (value) { return isNumber.check(value) && value >= than; }, isNumber + " >= " + than);
		    }
		    var defaults = {
		        "null": function () { return null; },
		        "emptyArray": function () { return []; },
		        "false": function () { return false; },
		        "true": function () { return true; },
		        "undefined": function () { },
		        "use strict": function () { return "use strict"; }
		    };
		    var naiveIsPrimitive = Type.or(builtin.string, builtin.number, builtin.boolean, builtin.null, builtin.undefined);
		    var isPrimitive = Type.from(function (value) {
		        if (value === null)
		            return true;
		        var type = typeof value;
		        if (type === "object" ||
		            type === "function") {
		            return false;
		        }
		        return true;
		    }, naiveIsPrimitive.toString());
		    return {
		        geq: geq,
		        defaults: defaults,
		        isPrimitive: isPrimitive,
		    };
		}
		exports.default = default_1;
		module.exports = exports["default"]; 
	} (shared, shared.exports));
	return shared.exports;
}

var hasRequiredCore;

function requireCore () {
	if (hasRequiredCore) return core.exports;
	hasRequiredCore = 1;
	(function (module, exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		var tslib_1 = require$$0;
		var types_1 = tslib_1.__importDefault(requireTypes$1());
		var shared_1 = tslib_1.__importDefault(requireShared());
		function default_1(fork) {
		    var types = fork.use(types_1.default);
		    var Type = types.Type;
		    var def = Type.def;
		    var or = Type.or;
		    var shared = fork.use(shared_1.default);
		    var defaults = shared.defaults;
		    var geq = shared.geq;
		    def("Printable")
		        .field("loc", or(def("SourceLocation"), null), defaults["null"], true);
		    def("Node")
		        .bases("Printable")
		        .field("type", String)
		        .field("comments", or([def("Comment")], null), defaults["null"], true);
		    def("SourceLocation")
		        .field("start", def("Position"))
		        .field("end", def("Position"))
		        .field("source", or(String, null), defaults["null"]);
		    def("Position")
		        .field("line", geq(1))
		        .field("column", geq(0));
		    def("File")
		        .bases("Node")
		        .build("program", "name")
		        .field("program", def("Program"))
		        .field("name", or(String, null), defaults["null"]);
		    def("Program")
		        .bases("Node")
		        .build("body")
		        .field("body", [def("Statement")]);
		    def("Function")
		        .bases("Node")
		        .field("id", or(def("Identifier"), null), defaults["null"])
		        .field("params", [def("Pattern")])
		        .field("body", def("BlockStatement"))
		        .field("generator", Boolean, defaults["false"])
		        .field("async", Boolean, defaults["false"]);
		    def("Statement").bases("Node");
		    def("EmptyStatement").bases("Statement").build();
		    def("BlockStatement")
		        .bases("Statement")
		        .build("body")
		        .field("body", [def("Statement")]);
		    def("ExpressionStatement")
		        .bases("Statement")
		        .build("expression")
		        .field("expression", def("Expression"));
		    def("IfStatement")
		        .bases("Statement")
		        .build("test", "consequent", "alternate")
		        .field("test", def("Expression"))
		        .field("consequent", def("Statement"))
		        .field("alternate", or(def("Statement"), null), defaults["null"]);
		    def("LabeledStatement")
		        .bases("Statement")
		        .build("label", "body")
		        .field("label", def("Identifier"))
		        .field("body", def("Statement"));
		    def("BreakStatement")
		        .bases("Statement")
		        .build("label")
		        .field("label", or(def("Identifier"), null), defaults["null"]);
		    def("ContinueStatement")
		        .bases("Statement")
		        .build("label")
		        .field("label", or(def("Identifier"), null), defaults["null"]);
		    def("WithStatement")
		        .bases("Statement")
		        .build("object", "body")
		        .field("object", def("Expression"))
		        .field("body", def("Statement"));
		    def("SwitchStatement")
		        .bases("Statement")
		        .build("discriminant", "cases", "lexical")
		        .field("discriminant", def("Expression"))
		        .field("cases", [def("SwitchCase")])
		        .field("lexical", Boolean, defaults["false"]);
		    def("ReturnStatement")
		        .bases("Statement")
		        .build("argument")
		        .field("argument", or(def("Expression"), null));
		    def("ThrowStatement")
		        .bases("Statement")
		        .build("argument")
		        .field("argument", def("Expression"));
		    def("TryStatement")
		        .bases("Statement")
		        .build("block", "handler", "finalizer")
		        .field("block", def("BlockStatement"))
		        .field("handler", or(def("CatchClause"), null), function () {
		        return this.handlers && this.handlers[0] || null;
		    })
		        .field("handlers", [def("CatchClause")], function () {
		        return this.handler ? [this.handler] : [];
		    }, true)
		        .field("guardedHandlers", [def("CatchClause")], defaults.emptyArray)
		        .field("finalizer", or(def("BlockStatement"), null), defaults["null"]);
		    def("CatchClause")
		        .bases("Node")
		        .build("param", "guard", "body")
		        .field("param", or(def("Pattern"), null), defaults["null"])
		        .field("guard", or(def("Expression"), null), defaults["null"])
		        .field("body", def("BlockStatement"));
		    def("WhileStatement")
		        .bases("Statement")
		        .build("test", "body")
		        .field("test", def("Expression"))
		        .field("body", def("Statement"));
		    def("DoWhileStatement")
		        .bases("Statement")
		        .build("body", "test")
		        .field("body", def("Statement"))
		        .field("test", def("Expression"));
		    def("ForStatement")
		        .bases("Statement")
		        .build("init", "test", "update", "body")
		        .field("init", or(def("VariableDeclaration"), def("Expression"), null))
		        .field("test", or(def("Expression"), null))
		        .field("update", or(def("Expression"), null))
		        .field("body", def("Statement"));
		    def("ForInStatement")
		        .bases("Statement")
		        .build("left", "right", "body")
		        .field("left", or(def("VariableDeclaration"), def("Expression")))
		        .field("right", def("Expression"))
		        .field("body", def("Statement"));
		    def("DebuggerStatement").bases("Statement").build();
		    def("Declaration").bases("Statement");
		    def("FunctionDeclaration")
		        .bases("Function", "Declaration")
		        .build("id", "params", "body")
		        .field("id", def("Identifier"));
		    def("FunctionExpression")
		        .bases("Function", "Expression")
		        .build("id", "params", "body");
		    def("VariableDeclaration")
		        .bases("Declaration")
		        .build("kind", "declarations")
		        .field("kind", or("var", "let", "const"))
		        .field("declarations", [def("VariableDeclarator")]);
		    def("VariableDeclarator")
		        .bases("Node")
		        .build("id", "init")
		        .field("id", def("Pattern"))
		        .field("init", or(def("Expression"), null), defaults["null"]);
		    def("Expression").bases("Node");
		    def("ThisExpression").bases("Expression").build();
		    def("ArrayExpression")
		        .bases("Expression")
		        .build("elements")
		        .field("elements", [or(def("Expression"), null)]);
		    def("ObjectExpression")
		        .bases("Expression")
		        .build("properties")
		        .field("properties", [def("Property")]);
		    def("Property")
		        .bases("Node")
		        .build("kind", "key", "value")
		        .field("kind", or("init", "get", "set"))
		        .field("key", or(def("Literal"), def("Identifier")))
		        .field("value", def("Expression"));
		    def("SequenceExpression")
		        .bases("Expression")
		        .build("expressions")
		        .field("expressions", [def("Expression")]);
		    var UnaryOperator = or("-", "+", "!", "~", "typeof", "void", "delete");
		    def("UnaryExpression")
		        .bases("Expression")
		        .build("operator", "argument", "prefix")
		        .field("operator", UnaryOperator)
		        .field("argument", def("Expression"))
		        .field("prefix", Boolean, defaults["true"]);
		    var BinaryOperator = or("==", "!=", "===", "!==", "<", "<=", ">", ">=", "<<", ">>", ">>>", "+", "-", "*", "/", "%", "**", "&",
		    "|", "^", "in", "instanceof");
		    def("BinaryExpression")
		        .bases("Expression")
		        .build("operator", "left", "right")
		        .field("operator", BinaryOperator)
		        .field("left", def("Expression"))
		        .field("right", def("Expression"));
		    var AssignmentOperator = or("=", "+=", "-=", "*=", "/=", "%=", "<<=", ">>=", ">>>=", "|=", "^=", "&=");
		    def("AssignmentExpression")
		        .bases("Expression")
		        .build("operator", "left", "right")
		        .field("operator", AssignmentOperator)
		        .field("left", or(def("Pattern"), def("MemberExpression")))
		        .field("right", def("Expression"));
		    var UpdateOperator = or("++", "--");
		    def("UpdateExpression")
		        .bases("Expression")
		        .build("operator", "argument", "prefix")
		        .field("operator", UpdateOperator)
		        .field("argument", def("Expression"))
		        .field("prefix", Boolean);
		    var LogicalOperator = or("||", "&&");
		    def("LogicalExpression")
		        .bases("Expression")
		        .build("operator", "left", "right")
		        .field("operator", LogicalOperator)
		        .field("left", def("Expression"))
		        .field("right", def("Expression"));
		    def("ConditionalExpression")
		        .bases("Expression")
		        .build("test", "consequent", "alternate")
		        .field("test", def("Expression"))
		        .field("consequent", def("Expression"))
		        .field("alternate", def("Expression"));
		    def("NewExpression")
		        .bases("Expression")
		        .build("callee", "arguments")
		        .field("callee", def("Expression"))
		        .field("arguments", [def("Expression")]);
		    def("CallExpression")
		        .bases("Expression")
		        .build("callee", "arguments")
		        .field("callee", def("Expression"))
		        .field("arguments", [def("Expression")]);
		    def("MemberExpression")
		        .bases("Expression")
		        .build("object", "property", "computed")
		        .field("object", def("Expression"))
		        .field("property", or(def("Identifier"), def("Expression")))
		        .field("computed", Boolean, function () {
		        var type = this.property.type;
		        if (type === 'Literal' ||
		            type === 'MemberExpression' ||
		            type === 'BinaryExpression') {
		            return true;
		        }
		        return false;
		    });
		    def("Pattern").bases("Node");
		    def("SwitchCase")
		        .bases("Node")
		        .build("test", "consequent")
		        .field("test", or(def("Expression"), null))
		        .field("consequent", [def("Statement")]);
		    def("Identifier")
		        .bases("Expression", "Pattern")
		        .build("name")
		        .field("name", String)
		        .field("optional", Boolean, defaults["false"]);
		    def("Literal")
		        .bases("Expression")
		        .build("value")
		        .field("value", or(String, Boolean, null, Number, RegExp))
		        .field("regex", or({
		        pattern: String,
		        flags: String
		    }, null), function () {
		        if (this.value instanceof RegExp) {
		            var flags = "";
		            if (this.value.ignoreCase)
		                flags += "i";
		            if (this.value.multiline)
		                flags += "m";
		            if (this.value.global)
		                flags += "g";
		            return {
		                pattern: this.value.source,
		                flags: flags
		            };
		        }
		        return null;
		    });
		    def("Comment")
		        .bases("Printable")
		        .field("value", String)
		        .field("leading", Boolean, defaults["true"])
		        .field("trailing", Boolean, defaults["false"]);
		}
		exports.default = default_1;
		module.exports = exports["default"]; 
	} (core, core.exports));
	return core.exports;
}

var es6 = {exports: {}};

var hasRequiredEs6;

function requireEs6 () {
	if (hasRequiredEs6) return es6.exports;
	hasRequiredEs6 = 1;
	(function (module, exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		var tslib_1 = require$$0;
		var core_1 = tslib_1.__importDefault(requireCore());
		var types_1 = tslib_1.__importDefault(requireTypes$1());
		var shared_1 = tslib_1.__importDefault(requireShared());
		function default_1(fork) {
		    fork.use(core_1.default);
		    var types = fork.use(types_1.default);
		    var def = types.Type.def;
		    var or = types.Type.or;
		    var defaults = fork.use(shared_1.default).defaults;
		    def("Function")
		        .field("generator", Boolean, defaults["false"])
		        .field("expression", Boolean, defaults["false"])
		        .field("defaults", [or(def("Expression"), null)], defaults.emptyArray)
		        .field("rest", or(def("Identifier"), null), defaults["null"]);
		    def("RestElement")
		        .bases("Pattern")
		        .build("argument")
		        .field("argument", def("Pattern"))
		        .field("typeAnnotation",
		    or(def("TypeAnnotation"), def("TSTypeAnnotation"), null), defaults["null"]);
		    def("SpreadElementPattern")
		        .bases("Pattern")
		        .build("argument")
		        .field("argument", def("Pattern"));
		    def("FunctionDeclaration")
		        .build("id", "params", "body", "generator", "expression");
		    def("FunctionExpression")
		        .build("id", "params", "body", "generator", "expression");
		    def("ArrowFunctionExpression")
		        .bases("Function", "Expression")
		        .build("params", "body", "expression")
		        .field("id", null, defaults["null"])
		        .field("body", or(def("BlockStatement"), def("Expression")))
		        .field("generator", false, defaults["false"]);
		    def("ForOfStatement")
		        .bases("Statement")
		        .build("left", "right", "body")
		        .field("left", or(def("VariableDeclaration"), def("Pattern")))
		        .field("right", def("Expression"))
		        .field("body", def("Statement"));
		    def("YieldExpression")
		        .bases("Expression")
		        .build("argument", "delegate")
		        .field("argument", or(def("Expression"), null))
		        .field("delegate", Boolean, defaults["false"]);
		    def("GeneratorExpression")
		        .bases("Expression")
		        .build("body", "blocks", "filter")
		        .field("body", def("Expression"))
		        .field("blocks", [def("ComprehensionBlock")])
		        .field("filter", or(def("Expression"), null));
		    def("ComprehensionExpression")
		        .bases("Expression")
		        .build("body", "blocks", "filter")
		        .field("body", def("Expression"))
		        .field("blocks", [def("ComprehensionBlock")])
		        .field("filter", or(def("Expression"), null));
		    def("ComprehensionBlock")
		        .bases("Node")
		        .build("left", "right", "each")
		        .field("left", def("Pattern"))
		        .field("right", def("Expression"))
		        .field("each", Boolean);
		    def("Property")
		        .field("key", or(def("Literal"), def("Identifier"), def("Expression")))
		        .field("value", or(def("Expression"), def("Pattern")))
		        .field("method", Boolean, defaults["false"])
		        .field("shorthand", Boolean, defaults["false"])
		        .field("computed", Boolean, defaults["false"]);
		    def("ObjectProperty")
		        .field("shorthand", Boolean, defaults["false"]);
		    def("PropertyPattern")
		        .bases("Pattern")
		        .build("key", "pattern")
		        .field("key", or(def("Literal"), def("Identifier"), def("Expression")))
		        .field("pattern", def("Pattern"))
		        .field("computed", Boolean, defaults["false"]);
		    def("ObjectPattern")
		        .bases("Pattern")
		        .build("properties")
		        .field("properties", [or(def("PropertyPattern"), def("Property"))]);
		    def("ArrayPattern")
		        .bases("Pattern")
		        .build("elements")
		        .field("elements", [or(def("Pattern"), null)]);
		    def("MethodDefinition")
		        .bases("Declaration")
		        .build("kind", "key", "value", "static")
		        .field("kind", or("constructor", "method", "get", "set"))
		        .field("key", def("Expression"))
		        .field("value", def("Function"))
		        .field("computed", Boolean, defaults["false"])
		        .field("static", Boolean, defaults["false"]);
		    def("SpreadElement")
		        .bases("Node")
		        .build("argument")
		        .field("argument", def("Expression"));
		    def("ArrayExpression")
		        .field("elements", [or(def("Expression"), def("SpreadElement"), def("RestElement"), null)]);
		    def("NewExpression")
		        .field("arguments", [or(def("Expression"), def("SpreadElement"))]);
		    def("CallExpression")
		        .field("arguments", [or(def("Expression"), def("SpreadElement"))]);
		    def("AssignmentPattern")
		        .bases("Pattern")
		        .build("left", "right")
		        .field("left", def("Pattern"))
		        .field("right", def("Expression"));
		    var ClassBodyElement = or(def("MethodDefinition"), def("VariableDeclarator"), def("ClassPropertyDefinition"), def("ClassProperty"));
		    def("ClassProperty")
		        .bases("Declaration")
		        .build("key")
		        .field("key", or(def("Literal"), def("Identifier"), def("Expression")))
		        .field("computed", Boolean, defaults["false"]);
		    def("ClassPropertyDefinition")
		        .bases("Declaration")
		        .build("definition")
		        .field("definition", ClassBodyElement);
		    def("ClassBody")
		        .bases("Declaration")
		        .build("body")
		        .field("body", [ClassBodyElement]);
		    def("ClassDeclaration")
		        .bases("Declaration")
		        .build("id", "body", "superClass")
		        .field("id", or(def("Identifier"), null))
		        .field("body", def("ClassBody"))
		        .field("superClass", or(def("Expression"), null), defaults["null"]);
		    def("ClassExpression")
		        .bases("Expression")
		        .build("id", "body", "superClass")
		        .field("id", or(def("Identifier"), null), defaults["null"])
		        .field("body", def("ClassBody"))
		        .field("superClass", or(def("Expression"), null), defaults["null"]);
		    def("Specifier").bases("Node");
		    def("ModuleSpecifier")
		        .bases("Specifier")
		        .field("local", or(def("Identifier"), null), defaults["null"])
		        .field("id", or(def("Identifier"), null), defaults["null"])
		        .field("name", or(def("Identifier"), null), defaults["null"]);
		    def("ImportSpecifier")
		        .bases("ModuleSpecifier")
		        .build("id", "name");
		    def("ImportNamespaceSpecifier")
		        .bases("ModuleSpecifier")
		        .build("id");
		    def("ImportDefaultSpecifier")
		        .bases("ModuleSpecifier")
		        .build("id");
		    def("ImportDeclaration")
		        .bases("Declaration")
		        .build("specifiers", "source", "importKind")
		        .field("specifiers", [or(def("ImportSpecifier"), def("ImportNamespaceSpecifier"), def("ImportDefaultSpecifier"))], defaults.emptyArray)
		        .field("source", def("Literal"))
		        .field("importKind", or("value", "type"), function () {
		        return "value";
		    });
		    def("TaggedTemplateExpression")
		        .bases("Expression")
		        .build("tag", "quasi")
		        .field("tag", def("Expression"))
		        .field("quasi", def("TemplateLiteral"));
		    def("TemplateLiteral")
		        .bases("Expression")
		        .build("quasis", "expressions")
		        .field("quasis", [def("TemplateElement")])
		        .field("expressions", [def("Expression")]);
		    def("TemplateElement")
		        .bases("Node")
		        .build("value", "tail")
		        .field("value", { "cooked": String, "raw": String })
		        .field("tail", Boolean);
		}
		exports.default = default_1;
		module.exports = exports["default"]; 
	} (es6, es6.exports));
	return es6.exports;
}

var es7 = {exports: {}};

var hasRequiredEs7;

function requireEs7 () {
	if (hasRequiredEs7) return es7.exports;
	hasRequiredEs7 = 1;
	(function (module, exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		var tslib_1 = require$$0;
		var es6_1 = tslib_1.__importDefault(requireEs6());
		var types_1 = tslib_1.__importDefault(requireTypes$1());
		var shared_1 = tslib_1.__importDefault(requireShared());
		function default_1(fork) {
		    fork.use(es6_1.default);
		    var types = fork.use(types_1.default);
		    var def = types.Type.def;
		    var or = types.Type.or;
		    var defaults = fork.use(shared_1.default).defaults;
		    def("Function")
		        .field("async", Boolean, defaults["false"]);
		    def("SpreadProperty")
		        .bases("Node")
		        .build("argument")
		        .field("argument", def("Expression"));
		    def("ObjectExpression")
		        .field("properties", [or(def("Property"), def("SpreadProperty"), def("SpreadElement"))]);
		    def("SpreadPropertyPattern")
		        .bases("Pattern")
		        .build("argument")
		        .field("argument", def("Pattern"));
		    def("ObjectPattern")
		        .field("properties", [or(def("Property"), def("PropertyPattern"), def("SpreadPropertyPattern"))]);
		    def("AwaitExpression")
		        .bases("Expression")
		        .build("argument", "all")
		        .field("argument", or(def("Expression"), null))
		        .field("all", Boolean, defaults["false"]);
		}
		exports.default = default_1;
		module.exports = exports["default"]; 
	} (es7, es7.exports));
	return es7.exports;
}

var es2020 = {exports: {}};

var hasRequiredEs2020;

function requireEs2020 () {
	if (hasRequiredEs2020) return es2020.exports;
	hasRequiredEs2020 = 1;
	(function (module, exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		var tslib_1 = require$$0;
		var es7_1 = tslib_1.__importDefault(requireEs7());
		var types_1 = tslib_1.__importDefault(requireTypes$1());
		function default_1(fork) {
		    fork.use(es7_1.default);
		    var types = fork.use(types_1.default);
		    var def = types.Type.def;
		    def("ImportExpression")
		        .bases("Expression")
		        .build("source")
		        .field("source", def("Expression"));
		}
		exports.default = default_1;
		module.exports = exports["default"]; 
	} (es2020, es2020.exports));
	return es2020.exports;
}

var jsx = {exports: {}};

var hasRequiredJsx;

function requireJsx () {
	if (hasRequiredJsx) return jsx.exports;
	hasRequiredJsx = 1;
	(function (module, exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		var tslib_1 = require$$0;
		var es7_1 = tslib_1.__importDefault(requireEs7());
		var types_1 = tslib_1.__importDefault(requireTypes$1());
		var shared_1 = tslib_1.__importDefault(requireShared());
		function default_1(fork) {
		    fork.use(es7_1.default);
		    var types = fork.use(types_1.default);
		    var def = types.Type.def;
		    var or = types.Type.or;
		    var defaults = fork.use(shared_1.default).defaults;
		    def("JSXAttribute")
		        .bases("Node")
		        .build("name", "value")
		        .field("name", or(def("JSXIdentifier"), def("JSXNamespacedName")))
		        .field("value", or(def("Literal"),
		    def("JSXExpressionContainer"),
		    null
		    ), defaults["null"]);
		    def("JSXIdentifier")
		        .bases("Identifier")
		        .build("name")
		        .field("name", String);
		    def("JSXNamespacedName")
		        .bases("Node")
		        .build("namespace", "name")
		        .field("namespace", def("JSXIdentifier"))
		        .field("name", def("JSXIdentifier"));
		    def("JSXMemberExpression")
		        .bases("MemberExpression")
		        .build("object", "property")
		        .field("object", or(def("JSXIdentifier"), def("JSXMemberExpression")))
		        .field("property", def("JSXIdentifier"))
		        .field("computed", Boolean, defaults.false);
		    var JSXElementName = or(def("JSXIdentifier"), def("JSXNamespacedName"), def("JSXMemberExpression"));
		    def("JSXSpreadAttribute")
		        .bases("Node")
		        .build("argument")
		        .field("argument", def("Expression"));
		    var JSXAttributes = [or(def("JSXAttribute"), def("JSXSpreadAttribute"))];
		    def("JSXExpressionContainer")
		        .bases("Expression")
		        .build("expression")
		        .field("expression", def("Expression"));
		    def("JSXElement")
		        .bases("Expression")
		        .build("openingElement", "closingElement", "children")
		        .field("openingElement", def("JSXOpeningElement"))
		        .field("closingElement", or(def("JSXClosingElement"), null), defaults["null"])
		        .field("children", [or(def("JSXElement"), def("JSXExpressionContainer"), def("JSXFragment"), def("JSXText"), def("Literal")
		        )], defaults.emptyArray)
		        .field("name", JSXElementName, function () {
		        return this.openingElement.name;
		    }, true)
		        .field("selfClosing", Boolean, function () {
		        return this.openingElement.selfClosing;
		    }, true)
		        .field("attributes", JSXAttributes, function () {
		        return this.openingElement.attributes;
		    }, true);
		    def("JSXOpeningElement")
		        .bases("Node")
		        .build("name", "attributes", "selfClosing")
		        .field("name", JSXElementName)
		        .field("attributes", JSXAttributes, defaults.emptyArray)
		        .field("selfClosing", Boolean, defaults["false"]);
		    def("JSXClosingElement")
		        .bases("Node")
		        .build("name")
		        .field("name", JSXElementName);
		    def("JSXFragment")
		        .bases("Expression")
		        .build("openingElement", "closingElement", "children")
		        .field("openingElement", def("JSXOpeningFragment"))
		        .field("closingElement", def("JSXClosingFragment"))
		        .field("children", [or(def("JSXElement"), def("JSXExpressionContainer"), def("JSXFragment"), def("JSXText"), def("Literal")
		        )], defaults.emptyArray);
		    def("JSXOpeningFragment")
		        .bases("Node")
		        .build();
		    def("JSXClosingFragment")
		        .bases("Node")
		        .build();
		    def("JSXText")
		        .bases("Literal")
		        .build("value")
		        .field("value", String);
		    def("JSXEmptyExpression").bases("Expression").build();
		    def("JSXSpreadChild")
		        .bases("Expression")
		        .build("expression")
		        .field("expression", def("Expression"));
		}
		exports.default = default_1;
		module.exports = exports["default"]; 
	} (jsx, jsx.exports));
	return jsx.exports;
}

var flow = {exports: {}};

var typeAnnotations = {exports: {}};

var hasRequiredTypeAnnotations;

function requireTypeAnnotations () {
	if (hasRequiredTypeAnnotations) return typeAnnotations.exports;
	hasRequiredTypeAnnotations = 1;
	(function (module, exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		var tslib_1 = require$$0;
		var types_1 = tslib_1.__importDefault(requireTypes$1());
		var shared_1 = tslib_1.__importDefault(requireShared());
		function default_1(fork) {
		    var types = fork.use(types_1.default);
		    var def = types.Type.def;
		    var or = types.Type.or;
		    var defaults = fork.use(shared_1.default).defaults;
		    var TypeAnnotation = or(def("TypeAnnotation"), def("TSTypeAnnotation"), null);
		    var TypeParamDecl = or(def("TypeParameterDeclaration"), def("TSTypeParameterDeclaration"), null);
		    def("Identifier")
		        .field("typeAnnotation", TypeAnnotation, defaults["null"]);
		    def("ObjectPattern")
		        .field("typeAnnotation", TypeAnnotation, defaults["null"]);
		    def("Function")
		        .field("returnType", TypeAnnotation, defaults["null"])
		        .field("typeParameters", TypeParamDecl, defaults["null"]);
		    def("ClassProperty")
		        .build("key", "value", "typeAnnotation", "static")
		        .field("value", or(def("Expression"), null))
		        .field("static", Boolean, defaults["false"])
		        .field("typeAnnotation", TypeAnnotation, defaults["null"]);
		    ["ClassDeclaration",
		        "ClassExpression",
		    ].forEach(function (typeName) {
		        def(typeName)
		            .field("typeParameters", TypeParamDecl, defaults["null"])
		            .field("superTypeParameters", or(def("TypeParameterInstantiation"), def("TSTypeParameterInstantiation"), null), defaults["null"])
		            .field("implements", or([def("ClassImplements")], [def("TSExpressionWithTypeArguments")]), defaults.emptyArray);
		    });
		}
		exports.default = default_1;
		module.exports = exports["default"]; 
	} (typeAnnotations, typeAnnotations.exports));
	return typeAnnotations.exports;
}

var hasRequiredFlow;

function requireFlow () {
	if (hasRequiredFlow) return flow.exports;
	hasRequiredFlow = 1;
	(function (module, exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		var tslib_1 = require$$0;
		var es7_1 = tslib_1.__importDefault(requireEs7());
		var type_annotations_1 = tslib_1.__importDefault(requireTypeAnnotations());
		var types_1 = tslib_1.__importDefault(requireTypes$1());
		var shared_1 = tslib_1.__importDefault(requireShared());
		function default_1(fork) {
		    fork.use(es7_1.default);
		    fork.use(type_annotations_1.default);
		    var types = fork.use(types_1.default);
		    var def = types.Type.def;
		    var or = types.Type.or;
		    var defaults = fork.use(shared_1.default).defaults;
		    def("Flow").bases("Node");
		    def("FlowType").bases("Flow");
		    def("AnyTypeAnnotation")
		        .bases("FlowType")
		        .build();
		    def("EmptyTypeAnnotation")
		        .bases("FlowType")
		        .build();
		    def("MixedTypeAnnotation")
		        .bases("FlowType")
		        .build();
		    def("VoidTypeAnnotation")
		        .bases("FlowType")
		        .build();
		    def("NumberTypeAnnotation")
		        .bases("FlowType")
		        .build();
		    def("NumberLiteralTypeAnnotation")
		        .bases("FlowType")
		        .build("value", "raw")
		        .field("value", Number)
		        .field("raw", String);
		    def("NumericLiteralTypeAnnotation")
		        .bases("FlowType")
		        .build("value", "raw")
		        .field("value", Number)
		        .field("raw", String);
		    def("StringTypeAnnotation")
		        .bases("FlowType")
		        .build();
		    def("StringLiteralTypeAnnotation")
		        .bases("FlowType")
		        .build("value", "raw")
		        .field("value", String)
		        .field("raw", String);
		    def("BooleanTypeAnnotation")
		        .bases("FlowType")
		        .build();
		    def("BooleanLiteralTypeAnnotation")
		        .bases("FlowType")
		        .build("value", "raw")
		        .field("value", Boolean)
		        .field("raw", String);
		    def("TypeAnnotation")
		        .bases("Node")
		        .build("typeAnnotation")
		        .field("typeAnnotation", def("FlowType"));
		    def("NullableTypeAnnotation")
		        .bases("FlowType")
		        .build("typeAnnotation")
		        .field("typeAnnotation", def("FlowType"));
		    def("NullLiteralTypeAnnotation")
		        .bases("FlowType")
		        .build();
		    def("NullTypeAnnotation")
		        .bases("FlowType")
		        .build();
		    def("ThisTypeAnnotation")
		        .bases("FlowType")
		        .build();
		    def("ExistsTypeAnnotation")
		        .bases("FlowType")
		        .build();
		    def("ExistentialTypeParam")
		        .bases("FlowType")
		        .build();
		    def("FunctionTypeAnnotation")
		        .bases("FlowType")
		        .build("params", "returnType", "rest", "typeParameters")
		        .field("params", [def("FunctionTypeParam")])
		        .field("returnType", def("FlowType"))
		        .field("rest", or(def("FunctionTypeParam"), null))
		        .field("typeParameters", or(def("TypeParameterDeclaration"), null));
		    def("FunctionTypeParam")
		        .bases("Node")
		        .build("name", "typeAnnotation", "optional")
		        .field("name", def("Identifier"))
		        .field("typeAnnotation", def("FlowType"))
		        .field("optional", Boolean);
		    def("ArrayTypeAnnotation")
		        .bases("FlowType")
		        .build("elementType")
		        .field("elementType", def("FlowType"));
		    def("ObjectTypeAnnotation")
		        .bases("FlowType")
		        .build("properties", "indexers", "callProperties")
		        .field("properties", [
		        or(def("ObjectTypeProperty"), def("ObjectTypeSpreadProperty"))
		    ])
		        .field("indexers", [def("ObjectTypeIndexer")], defaults.emptyArray)
		        .field("callProperties", [def("ObjectTypeCallProperty")], defaults.emptyArray)
		        .field("inexact", or(Boolean, void 0), defaults["undefined"])
		        .field("exact", Boolean, defaults["false"])
		        .field("internalSlots", [def("ObjectTypeInternalSlot")], defaults.emptyArray);
		    def("Variance")
		        .bases("Node")
		        .build("kind")
		        .field("kind", or("plus", "minus"));
		    var LegacyVariance = or(def("Variance"), "plus", "minus", null);
		    def("ObjectTypeProperty")
		        .bases("Node")
		        .build("key", "value", "optional")
		        .field("key", or(def("Literal"), def("Identifier")))
		        .field("value", def("FlowType"))
		        .field("optional", Boolean)
		        .field("variance", LegacyVariance, defaults["null"]);
		    def("ObjectTypeIndexer")
		        .bases("Node")
		        .build("id", "key", "value")
		        .field("id", def("Identifier"))
		        .field("key", def("FlowType"))
		        .field("value", def("FlowType"))
		        .field("variance", LegacyVariance, defaults["null"]);
		    def("ObjectTypeCallProperty")
		        .bases("Node")
		        .build("value")
		        .field("value", def("FunctionTypeAnnotation"))
		        .field("static", Boolean, defaults["false"]);
		    def("QualifiedTypeIdentifier")
		        .bases("Node")
		        .build("qualification", "id")
		        .field("qualification", or(def("Identifier"), def("QualifiedTypeIdentifier")))
		        .field("id", def("Identifier"));
		    def("GenericTypeAnnotation")
		        .bases("FlowType")
		        .build("id", "typeParameters")
		        .field("id", or(def("Identifier"), def("QualifiedTypeIdentifier")))
		        .field("typeParameters", or(def("TypeParameterInstantiation"), null));
		    def("MemberTypeAnnotation")
		        .bases("FlowType")
		        .build("object", "property")
		        .field("object", def("Identifier"))
		        .field("property", or(def("MemberTypeAnnotation"), def("GenericTypeAnnotation")));
		    def("UnionTypeAnnotation")
		        .bases("FlowType")
		        .build("types")
		        .field("types", [def("FlowType")]);
		    def("IntersectionTypeAnnotation")
		        .bases("FlowType")
		        .build("types")
		        .field("types", [def("FlowType")]);
		    def("TypeofTypeAnnotation")
		        .bases("FlowType")
		        .build("argument")
		        .field("argument", def("FlowType"));
		    def("ObjectTypeSpreadProperty")
		        .bases("Node")
		        .build("argument")
		        .field("argument", def("FlowType"));
		    def("ObjectTypeInternalSlot")
		        .bases("Node")
		        .build("id", "value", "optional", "static", "method")
		        .field("id", def("Identifier"))
		        .field("value", def("FlowType"))
		        .field("optional", Boolean)
		        .field("static", Boolean)
		        .field("method", Boolean);
		    def("TypeParameterDeclaration")
		        .bases("Node")
		        .build("params")
		        .field("params", [def("TypeParameter")]);
		    def("TypeParameterInstantiation")
		        .bases("Node")
		        .build("params")
		        .field("params", [def("FlowType")]);
		    def("TypeParameter")
		        .bases("FlowType")
		        .build("name", "variance", "bound")
		        .field("name", String)
		        .field("variance", LegacyVariance, defaults["null"])
		        .field("bound", or(def("TypeAnnotation"), null), defaults["null"]);
		    def("ClassProperty")
		        .field("variance", LegacyVariance, defaults["null"]);
		    def("ClassImplements")
		        .bases("Node")
		        .build("id")
		        .field("id", def("Identifier"))
		        .field("superClass", or(def("Expression"), null), defaults["null"])
		        .field("typeParameters", or(def("TypeParameterInstantiation"), null), defaults["null"]);
		    def("InterfaceTypeAnnotation")
		        .bases("FlowType")
		        .build("body", "extends")
		        .field("body", def("ObjectTypeAnnotation"))
		        .field("extends", or([def("InterfaceExtends")], null), defaults["null"]);
		    def("InterfaceDeclaration")
		        .bases("Declaration")
		        .build("id", "body", "extends")
		        .field("id", def("Identifier"))
		        .field("typeParameters", or(def("TypeParameterDeclaration"), null), defaults["null"])
		        .field("body", def("ObjectTypeAnnotation"))
		        .field("extends", [def("InterfaceExtends")]);
		    def("DeclareInterface")
		        .bases("InterfaceDeclaration")
		        .build("id", "body", "extends");
		    def("InterfaceExtends")
		        .bases("Node")
		        .build("id")
		        .field("id", def("Identifier"))
		        .field("typeParameters", or(def("TypeParameterInstantiation"), null), defaults["null"]);
		    def("TypeAlias")
		        .bases("Declaration")
		        .build("id", "typeParameters", "right")
		        .field("id", def("Identifier"))
		        .field("typeParameters", or(def("TypeParameterDeclaration"), null))
		        .field("right", def("FlowType"));
		    def("OpaqueType")
		        .bases("Declaration")
		        .build("id", "typeParameters", "impltype", "supertype")
		        .field("id", def("Identifier"))
		        .field("typeParameters", or(def("TypeParameterDeclaration"), null))
		        .field("impltype", def("FlowType"))
		        .field("supertype", def("FlowType"));
		    def("DeclareTypeAlias")
		        .bases("TypeAlias")
		        .build("id", "typeParameters", "right");
		    def("DeclareOpaqueType")
		        .bases("TypeAlias")
		        .build("id", "typeParameters", "supertype");
		    def("TypeCastExpression")
		        .bases("Expression")
		        .build("expression", "typeAnnotation")
		        .field("expression", def("Expression"))
		        .field("typeAnnotation", def("TypeAnnotation"));
		    def("TupleTypeAnnotation")
		        .bases("FlowType")
		        .build("types")
		        .field("types", [def("FlowType")]);
		    def("DeclareVariable")
		        .bases("Statement")
		        .build("id")
		        .field("id", def("Identifier"));
		    def("DeclareFunction")
		        .bases("Statement")
		        .build("id")
		        .field("id", def("Identifier"));
		    def("DeclareClass")
		        .bases("InterfaceDeclaration")
		        .build("id");
		    def("DeclareModule")
		        .bases("Statement")
		        .build("id", "body")
		        .field("id", or(def("Identifier"), def("Literal")))
		        .field("body", def("BlockStatement"));
		    def("DeclareModuleExports")
		        .bases("Statement")
		        .build("typeAnnotation")
		        .field("typeAnnotation", def("TypeAnnotation"));
		    def("DeclareExportDeclaration")
		        .bases("Declaration")
		        .build("default", "declaration", "specifiers", "source")
		        .field("default", Boolean)
		        .field("declaration", or(def("DeclareVariable"), def("DeclareFunction"), def("DeclareClass"), def("FlowType"),
		    null))
		        .field("specifiers", [or(def("ExportSpecifier"), def("ExportBatchSpecifier"))], defaults.emptyArray)
		        .field("source", or(def("Literal"), null), defaults["null"]);
		    def("DeclareExportAllDeclaration")
		        .bases("Declaration")
		        .build("source")
		        .field("source", or(def("Literal"), null), defaults["null"]);
		    def("FlowPredicate").bases("Flow");
		    def("InferredPredicate")
		        .bases("FlowPredicate")
		        .build();
		    def("DeclaredPredicate")
		        .bases("FlowPredicate")
		        .build("value")
		        .field("value", def("Expression"));
		    def("CallExpression")
		        .field("typeArguments", or(null, def("TypeParameterInstantiation")), defaults["null"]);
		    def("NewExpression")
		        .field("typeArguments", or(null, def("TypeParameterInstantiation")), defaults["null"]);
		}
		exports.default = default_1;
		module.exports = exports["default"]; 
	} (flow, flow.exports));
	return flow.exports;
}

var esprima = {exports: {}};

var hasRequiredEsprima;

function requireEsprima () {
	if (hasRequiredEsprima) return esprima.exports;
	hasRequiredEsprima = 1;
	(function (module, exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		var tslib_1 = require$$0;
		var es7_1 = tslib_1.__importDefault(requireEs7());
		var types_1 = tslib_1.__importDefault(requireTypes$1());
		var shared_1 = tslib_1.__importDefault(requireShared());
		function default_1(fork) {
		    fork.use(es7_1.default);
		    var types = fork.use(types_1.default);
		    var defaults = fork.use(shared_1.default).defaults;
		    var def = types.Type.def;
		    var or = types.Type.or;
		    def("VariableDeclaration")
		        .field("declarations", [or(def("VariableDeclarator"), def("Identifier")
		        )]);
		    def("Property")
		        .field("value", or(def("Expression"), def("Pattern")
		    ));
		    def("ArrayPattern")
		        .field("elements", [or(def("Pattern"), def("SpreadElement"), null)]);
		    def("ObjectPattern")
		        .field("properties", [or(def("Property"), def("PropertyPattern"), def("SpreadPropertyPattern"), def("SpreadProperty")
		        )]);
		    def("ExportSpecifier")
		        .bases("ModuleSpecifier")
		        .build("id", "name");
		    def("ExportBatchSpecifier")
		        .bases("Specifier")
		        .build();
		    def("ExportDeclaration")
		        .bases("Declaration")
		        .build("default", "declaration", "specifiers", "source")
		        .field("default", Boolean)
		        .field("declaration", or(def("Declaration"), def("Expression"),
		    null))
		        .field("specifiers", [or(def("ExportSpecifier"), def("ExportBatchSpecifier"))], defaults.emptyArray)
		        .field("source", or(def("Literal"), null), defaults["null"]);
		    def("Block")
		        .bases("Comment")
		        .build("value",  "leading", "trailing");
		    def("Line")
		        .bases("Comment")
		        .build("value",  "leading", "trailing");
		}
		exports.default = default_1;
		module.exports = exports["default"]; 
	} (esprima, esprima.exports));
	return esprima.exports;
}

var babel = {exports: {}};

var babelCore = {exports: {}};

var hasRequiredBabelCore;

function requireBabelCore () {
	if (hasRequiredBabelCore) return babelCore.exports;
	hasRequiredBabelCore = 1;
	(function (module, exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		var tslib_1 = require$$0;
		var types_1 = tslib_1.__importDefault(requireTypes$1());
		var shared_1 = tslib_1.__importDefault(requireShared());
		var es7_1 = tslib_1.__importDefault(requireEs7());
		function default_1(fork) {
		    fork.use(es7_1.default);
		    var types = fork.use(types_1.default);
		    var defaults = fork.use(shared_1.default).defaults;
		    var def = types.Type.def;
		    var or = types.Type.or;
		    def("Noop")
		        .bases("Statement")
		        .build();
		    def("DoExpression")
		        .bases("Expression")
		        .build("body")
		        .field("body", [def("Statement")]);
		    def("Super")
		        .bases("Expression")
		        .build();
		    def("BindExpression")
		        .bases("Expression")
		        .build("object", "callee")
		        .field("object", or(def("Expression"), null))
		        .field("callee", def("Expression"));
		    def("Decorator")
		        .bases("Node")
		        .build("expression")
		        .field("expression", def("Expression"));
		    def("Property")
		        .field("decorators", or([def("Decorator")], null), defaults["null"]);
		    def("MethodDefinition")
		        .field("decorators", or([def("Decorator")], null), defaults["null"]);
		    def("MetaProperty")
		        .bases("Expression")
		        .build("meta", "property")
		        .field("meta", def("Identifier"))
		        .field("property", def("Identifier"));
		    def("ParenthesizedExpression")
		        .bases("Expression")
		        .build("expression")
		        .field("expression", def("Expression"));
		    def("ImportSpecifier")
		        .bases("ModuleSpecifier")
		        .build("imported", "local")
		        .field("imported", def("Identifier"));
		    def("ImportDefaultSpecifier")
		        .bases("ModuleSpecifier")
		        .build("local");
		    def("ImportNamespaceSpecifier")
		        .bases("ModuleSpecifier")
		        .build("local");
		    def("ExportDefaultDeclaration")
		        .bases("Declaration")
		        .build("declaration")
		        .field("declaration", or(def("Declaration"), def("Expression")));
		    def("ExportNamedDeclaration")
		        .bases("Declaration")
		        .build("declaration", "specifiers", "source")
		        .field("declaration", or(def("Declaration"), null))
		        .field("specifiers", [def("ExportSpecifier")], defaults.emptyArray)
		        .field("source", or(def("Literal"), null), defaults["null"]);
		    def("ExportSpecifier")
		        .bases("ModuleSpecifier")
		        .build("local", "exported")
		        .field("exported", def("Identifier"));
		    def("ExportNamespaceSpecifier")
		        .bases("Specifier")
		        .build("exported")
		        .field("exported", def("Identifier"));
		    def("ExportDefaultSpecifier")
		        .bases("Specifier")
		        .build("exported")
		        .field("exported", def("Identifier"));
		    def("ExportAllDeclaration")
		        .bases("Declaration")
		        .build("exported", "source")
		        .field("exported", or(def("Identifier"), null))
		        .field("source", def("Literal"));
		    def("CommentBlock")
		        .bases("Comment")
		        .build("value",  "leading", "trailing");
		    def("CommentLine")
		        .bases("Comment")
		        .build("value",  "leading", "trailing");
		    def("Directive")
		        .bases("Node")
		        .build("value")
		        .field("value", def("DirectiveLiteral"));
		    def("DirectiveLiteral")
		        .bases("Node", "Expression")
		        .build("value")
		        .field("value", String, defaults["use strict"]);
		    def("InterpreterDirective")
		        .bases("Node")
		        .build("value")
		        .field("value", String);
		    def("BlockStatement")
		        .bases("Statement")
		        .build("body")
		        .field("body", [def("Statement")])
		        .field("directives", [def("Directive")], defaults.emptyArray);
		    def("Program")
		        .bases("Node")
		        .build("body")
		        .field("body", [def("Statement")])
		        .field("directives", [def("Directive")], defaults.emptyArray)
		        .field("interpreter", or(def("InterpreterDirective"), null), defaults["null"]);
		    def("StringLiteral")
		        .bases("Literal")
		        .build("value")
		        .field("value", String);
		    def("NumericLiteral")
		        .bases("Literal")
		        .build("value")
		        .field("value", Number)
		        .field("raw", or(String, null), defaults["null"])
		        .field("extra", {
		        rawValue: Number,
		        raw: String
		    }, function getDefault() {
		        return {
		            rawValue: this.value,
		            raw: this.value + ""
		        };
		    });
		    def("BigIntLiteral")
		        .bases("Literal")
		        .build("value")
		        .field("value", or(String, Number))
		        .field("extra", {
		        rawValue: String,
		        raw: String
		    }, function getDefault() {
		        return {
		            rawValue: String(this.value),
		            raw: this.value + "n"
		        };
		    });
		    def("NullLiteral")
		        .bases("Literal")
		        .build()
		        .field("value", null, defaults["null"]);
		    def("BooleanLiteral")
		        .bases("Literal")
		        .build("value")
		        .field("value", Boolean);
		    def("RegExpLiteral")
		        .bases("Literal")
		        .build("pattern", "flags")
		        .field("pattern", String)
		        .field("flags", String)
		        .field("value", RegExp, function () {
		        return new RegExp(this.pattern, this.flags);
		    });
		    var ObjectExpressionProperty = or(def("Property"), def("ObjectMethod"), def("ObjectProperty"), def("SpreadProperty"), def("SpreadElement"));
		    def("ObjectExpression")
		        .bases("Expression")
		        .build("properties")
		        .field("properties", [ObjectExpressionProperty]);
		    def("ObjectMethod")
		        .bases("Node", "Function")
		        .build("kind", "key", "params", "body", "computed")
		        .field("kind", or("method", "get", "set"))
		        .field("key", or(def("Literal"), def("Identifier"), def("Expression")))
		        .field("params", [def("Pattern")])
		        .field("body", def("BlockStatement"))
		        .field("computed", Boolean, defaults["false"])
		        .field("generator", Boolean, defaults["false"])
		        .field("async", Boolean, defaults["false"])
		        .field("accessibility",
		    or(def("Literal"), null), defaults["null"])
		        .field("decorators", or([def("Decorator")], null), defaults["null"]);
		    def("ObjectProperty")
		        .bases("Node")
		        .build("key", "value")
		        .field("key", or(def("Literal"), def("Identifier"), def("Expression")))
		        .field("value", or(def("Expression"), def("Pattern")))
		        .field("accessibility",
		    or(def("Literal"), null), defaults["null"])
		        .field("computed", Boolean, defaults["false"]);
		    var ClassBodyElement = or(def("MethodDefinition"), def("VariableDeclarator"), def("ClassPropertyDefinition"), def("ClassProperty"), def("ClassPrivateProperty"), def("ClassMethod"), def("ClassPrivateMethod"));
		    def("ClassBody")
		        .bases("Declaration")
		        .build("body")
		        .field("body", [ClassBodyElement]);
		    def("ClassMethod")
		        .bases("Declaration", "Function")
		        .build("kind", "key", "params", "body", "computed", "static")
		        .field("key", or(def("Literal"), def("Identifier"), def("Expression")));
		    def("ClassPrivateMethod")
		        .bases("Declaration", "Function")
		        .build("key", "params", "body", "kind", "computed", "static")
		        .field("key", def("PrivateName"));
		    ["ClassMethod",
		        "ClassPrivateMethod",
		    ].forEach(function (typeName) {
		        def(typeName)
		            .field("kind", or("get", "set", "method", "constructor"), function () { return "method"; })
		            .field("body", def("BlockStatement"))
		            .field("computed", Boolean, defaults["false"])
		            .field("static", or(Boolean, null), defaults["null"])
		            .field("abstract", or(Boolean, null), defaults["null"])
		            .field("access", or("public", "private", "protected", null), defaults["null"])
		            .field("accessibility", or("public", "private", "protected", null), defaults["null"])
		            .field("decorators", or([def("Decorator")], null), defaults["null"])
		            .field("optional", or(Boolean, null), defaults["null"]);
		    });
		    def("ClassPrivateProperty")
		        .bases("ClassProperty")
		        .build("key", "value")
		        .field("key", def("PrivateName"))
		        .field("value", or(def("Expression"), null), defaults["null"]);
		    def("PrivateName")
		        .bases("Expression", "Pattern")
		        .build("id")
		        .field("id", def("Identifier"));
		    var ObjectPatternProperty = or(def("Property"), def("PropertyPattern"), def("SpreadPropertyPattern"), def("SpreadProperty"),
		    def("ObjectProperty"),
		    def("RestProperty")
		    );
		    def("ObjectPattern")
		        .bases("Pattern")
		        .build("properties")
		        .field("properties", [ObjectPatternProperty])
		        .field("decorators", or([def("Decorator")], null), defaults["null"]);
		    def("SpreadProperty")
		        .bases("Node")
		        .build("argument")
		        .field("argument", def("Expression"));
		    def("RestProperty")
		        .bases("Node")
		        .build("argument")
		        .field("argument", def("Expression"));
		    def("ForAwaitStatement")
		        .bases("Statement")
		        .build("left", "right", "body")
		        .field("left", or(def("VariableDeclaration"), def("Expression")))
		        .field("right", def("Expression"))
		        .field("body", def("Statement"));
		    def("Import")
		        .bases("Expression")
		        .build();
		}
		exports.default = default_1;
		module.exports = exports["default"]; 
	} (babelCore, babelCore.exports));
	return babelCore.exports;
}

var hasRequiredBabel;

function requireBabel () {
	if (hasRequiredBabel) return babel.exports;
	hasRequiredBabel = 1;
	(function (module, exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		var tslib_1 = require$$0;
		var babel_core_1 = tslib_1.__importDefault(requireBabelCore());
		var flow_1 = tslib_1.__importDefault(requireFlow());
		function default_1(fork) {
		    fork.use(babel_core_1.default);
		    fork.use(flow_1.default);
		}
		exports.default = default_1;
		module.exports = exports["default"]; 
	} (babel, babel.exports));
	return babel.exports;
}

var typescript = {exports: {}};

var hasRequiredTypescript;

function requireTypescript () {
	if (hasRequiredTypescript) return typescript.exports;
	hasRequiredTypescript = 1;
	(function (module, exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		var tslib_1 = require$$0;
		var babel_core_1 = tslib_1.__importDefault(requireBabelCore());
		var type_annotations_1 = tslib_1.__importDefault(requireTypeAnnotations());
		var types_1 = tslib_1.__importDefault(requireTypes$1());
		var shared_1 = tslib_1.__importDefault(requireShared());
		function default_1(fork) {
		    fork.use(babel_core_1.default);
		    fork.use(type_annotations_1.default);
		    var types = fork.use(types_1.default);
		    var n = types.namedTypes;
		    var def = types.Type.def;
		    var or = types.Type.or;
		    var defaults = fork.use(shared_1.default).defaults;
		    var StringLiteral = types.Type.from(function (value, deep) {
		        if (n.StringLiteral &&
		            n.StringLiteral.check(value, deep)) {
		            return true;
		        }
		        if (n.Literal &&
		            n.Literal.check(value, deep) &&
		            typeof value.value === "string") {
		            return true;
		        }
		        return false;
		    }, "StringLiteral");
		    def("TSType")
		        .bases("Node");
		    var TSEntityName = or(def("Identifier"), def("TSQualifiedName"));
		    def("TSTypeReference")
		        .bases("TSType", "TSHasOptionalTypeParameterInstantiation")
		        .build("typeName", "typeParameters")
		        .field("typeName", TSEntityName);
		    def("TSHasOptionalTypeParameterInstantiation")
		        .field("typeParameters", or(def("TSTypeParameterInstantiation"), null), defaults["null"]);
		    def("TSHasOptionalTypeParameters")
		        .field("typeParameters", or(def("TSTypeParameterDeclaration"), null, void 0), defaults["null"]);
		    def("TSHasOptionalTypeAnnotation")
		        .field("typeAnnotation", or(def("TSTypeAnnotation"), null), defaults["null"]);
		    def("TSQualifiedName")
		        .bases("Node")
		        .build("left", "right")
		        .field("left", TSEntityName)
		        .field("right", TSEntityName);
		    def("TSAsExpression")
		        .bases("Expression", "Pattern")
		        .build("expression", "typeAnnotation")
		        .field("expression", def("Expression"))
		        .field("typeAnnotation", def("TSType"))
		        .field("extra", or({ parenthesized: Boolean }, null), defaults["null"]);
		    def("TSNonNullExpression")
		        .bases("Expression", "Pattern")
		        .build("expression")
		        .field("expression", def("Expression"));
		    [
		        "TSAnyKeyword",
		        "TSBigIntKeyword",
		        "TSBooleanKeyword",
		        "TSNeverKeyword",
		        "TSNullKeyword",
		        "TSNumberKeyword",
		        "TSObjectKeyword",
		        "TSStringKeyword",
		        "TSSymbolKeyword",
		        "TSUndefinedKeyword",
		        "TSUnknownKeyword",
		        "TSVoidKeyword",
		        "TSThisType",
		    ].forEach(function (keywordType) {
		        def(keywordType)
		            .bases("TSType")
		            .build();
		    });
		    def("TSArrayType")
		        .bases("TSType")
		        .build("elementType")
		        .field("elementType", def("TSType"));
		    def("TSLiteralType")
		        .bases("TSType")
		        .build("literal")
		        .field("literal", or(def("NumericLiteral"), def("StringLiteral"), def("BooleanLiteral"), def("TemplateLiteral"), def("UnaryExpression")));
		    ["TSUnionType",
		        "TSIntersectionType",
		    ].forEach(function (typeName) {
		        def(typeName)
		            .bases("TSType")
		            .build("types")
		            .field("types", [def("TSType")]);
		    });
		    def("TSConditionalType")
		        .bases("TSType")
		        .build("checkType", "extendsType", "trueType", "falseType")
		        .field("checkType", def("TSType"))
		        .field("extendsType", def("TSType"))
		        .field("trueType", def("TSType"))
		        .field("falseType", def("TSType"));
		    def("TSInferType")
		        .bases("TSType")
		        .build("typeParameter")
		        .field("typeParameter", def("TSTypeParameter"));
		    def("TSParenthesizedType")
		        .bases("TSType")
		        .build("typeAnnotation")
		        .field("typeAnnotation", def("TSType"));
		    var ParametersType = [or(def("Identifier"), def("RestElement"), def("ArrayPattern"), def("ObjectPattern"))];
		    ["TSFunctionType",
		        "TSConstructorType",
		    ].forEach(function (typeName) {
		        def(typeName)
		            .bases("TSType", "TSHasOptionalTypeParameters", "TSHasOptionalTypeAnnotation")
		            .build("parameters")
		            .field("parameters", ParametersType);
		    });
		    def("TSDeclareFunction")
		        .bases("Declaration", "TSHasOptionalTypeParameters")
		        .build("id", "params", "returnType")
		        .field("declare", Boolean, defaults["false"])
		        .field("async", Boolean, defaults["false"])
		        .field("generator", Boolean, defaults["false"])
		        .field("id", or(def("Identifier"), null), defaults["null"])
		        .field("params", [def("Pattern")])
		        .field("returnType", or(def("TSTypeAnnotation"), def("Noop"),
		    null), defaults["null"]);
		    def("TSDeclareMethod")
		        .bases("Declaration", "TSHasOptionalTypeParameters")
		        .build("key", "params", "returnType")
		        .field("async", Boolean, defaults["false"])
		        .field("generator", Boolean, defaults["false"])
		        .field("params", [def("Pattern")])
		        .field("abstract", Boolean, defaults["false"])
		        .field("accessibility", or("public", "private", "protected", void 0), defaults["undefined"])
		        .field("static", Boolean, defaults["false"])
		        .field("computed", Boolean, defaults["false"])
		        .field("optional", Boolean, defaults["false"])
		        .field("key", or(def("Identifier"), def("StringLiteral"), def("NumericLiteral"),
		    def("Expression")))
		        .field("kind", or("get", "set", "method", "constructor"), function getDefault() { return "method"; })
		        .field("access",
		    or("public", "private", "protected", void 0), defaults["undefined"])
		        .field("decorators", or([def("Decorator")], null), defaults["null"])
		        .field("returnType", or(def("TSTypeAnnotation"), def("Noop"),
		    null), defaults["null"]);
		    def("TSMappedType")
		        .bases("TSType")
		        .build("typeParameter", "typeAnnotation")
		        .field("readonly", or(Boolean, "+", "-"), defaults["false"])
		        .field("typeParameter", def("TSTypeParameter"))
		        .field("optional", or(Boolean, "+", "-"), defaults["false"])
		        .field("typeAnnotation", or(def("TSType"), null), defaults["null"]);
		    def("TSTupleType")
		        .bases("TSType")
		        .build("elementTypes")
		        .field("elementTypes", [or(def("TSType"), def("TSNamedTupleMember"))]);
		    def("TSNamedTupleMember")
		        .bases("TSType")
		        .build("label", "elementType", "optional")
		        .field("label", def("Identifier"))
		        .field("optional", Boolean, defaults["false"])
		        .field("elementType", def("TSType"));
		    def("TSRestType")
		        .bases("TSType")
		        .build("typeAnnotation")
		        .field("typeAnnotation", def("TSType"));
		    def("TSOptionalType")
		        .bases("TSType")
		        .build("typeAnnotation")
		        .field("typeAnnotation", def("TSType"));
		    def("TSIndexedAccessType")
		        .bases("TSType")
		        .build("objectType", "indexType")
		        .field("objectType", def("TSType"))
		        .field("indexType", def("TSType"));
		    def("TSTypeOperator")
		        .bases("TSType")
		        .build("operator")
		        .field("operator", String)
		        .field("typeAnnotation", def("TSType"));
		    def("TSTypeAnnotation")
		        .bases("Node")
		        .build("typeAnnotation")
		        .field("typeAnnotation", or(def("TSType"), def("TSTypeAnnotation")));
		    def("TSIndexSignature")
		        .bases("Declaration", "TSHasOptionalTypeAnnotation")
		        .build("parameters", "typeAnnotation")
		        .field("parameters", [def("Identifier")])
		        .field("readonly", Boolean, defaults["false"]);
		    def("TSPropertySignature")
		        .bases("Declaration", "TSHasOptionalTypeAnnotation")
		        .build("key", "typeAnnotation", "optional")
		        .field("key", def("Expression"))
		        .field("computed", Boolean, defaults["false"])
		        .field("readonly", Boolean, defaults["false"])
		        .field("optional", Boolean, defaults["false"])
		        .field("initializer", or(def("Expression"), null), defaults["null"]);
		    def("TSMethodSignature")
		        .bases("Declaration", "TSHasOptionalTypeParameters", "TSHasOptionalTypeAnnotation")
		        .build("key", "parameters", "typeAnnotation")
		        .field("key", def("Expression"))
		        .field("computed", Boolean, defaults["false"])
		        .field("optional", Boolean, defaults["false"])
		        .field("parameters", ParametersType);
		    def("TSTypePredicate")
		        .bases("TSTypeAnnotation", "TSType")
		        .build("parameterName", "typeAnnotation", "asserts")
		        .field("parameterName", or(def("Identifier"), def("TSThisType")))
		        .field("typeAnnotation", or(def("TSTypeAnnotation"), null), defaults["null"])
		        .field("asserts", Boolean, defaults["false"]);
		    ["TSCallSignatureDeclaration",
		        "TSConstructSignatureDeclaration",
		    ].forEach(function (typeName) {
		        def(typeName)
		            .bases("Declaration", "TSHasOptionalTypeParameters", "TSHasOptionalTypeAnnotation")
		            .build("parameters", "typeAnnotation")
		            .field("parameters", ParametersType);
		    });
		    def("TSEnumMember")
		        .bases("Node")
		        .build("id", "initializer")
		        .field("id", or(def("Identifier"), StringLiteral))
		        .field("initializer", or(def("Expression"), null), defaults["null"]);
		    def("TSTypeQuery")
		        .bases("TSType")
		        .build("exprName")
		        .field("exprName", or(TSEntityName, def("TSImportType")));
		    var TSTypeMember = or(def("TSCallSignatureDeclaration"), def("TSConstructSignatureDeclaration"), def("TSIndexSignature"), def("TSMethodSignature"), def("TSPropertySignature"));
		    def("TSTypeLiteral")
		        .bases("TSType")
		        .build("members")
		        .field("members", [TSTypeMember]);
		    def("TSTypeParameter")
		        .bases("Identifier")
		        .build("name", "constraint", "default")
		        .field("name", String)
		        .field("constraint", or(def("TSType"), void 0), defaults["undefined"])
		        .field("default", or(def("TSType"), void 0), defaults["undefined"]);
		    def("TSTypeAssertion")
		        .bases("Expression", "Pattern")
		        .build("typeAnnotation", "expression")
		        .field("typeAnnotation", def("TSType"))
		        .field("expression", def("Expression"))
		        .field("extra", or({ parenthesized: Boolean }, null), defaults["null"]);
		    def("TSTypeParameterDeclaration")
		        .bases("Declaration")
		        .build("params")
		        .field("params", [def("TSTypeParameter")]);
		    def("TSTypeParameterInstantiation")
		        .bases("Node")
		        .build("params")
		        .field("params", [def("TSType")]);
		    def("TSEnumDeclaration")
		        .bases("Declaration")
		        .build("id", "members")
		        .field("id", def("Identifier"))
		        .field("const", Boolean, defaults["false"])
		        .field("declare", Boolean, defaults["false"])
		        .field("members", [def("TSEnumMember")])
		        .field("initializer", or(def("Expression"), null), defaults["null"]);
		    def("TSTypeAliasDeclaration")
		        .bases("Declaration", "TSHasOptionalTypeParameters")
		        .build("id", "typeAnnotation")
		        .field("id", def("Identifier"))
		        .field("declare", Boolean, defaults["false"])
		        .field("typeAnnotation", def("TSType"));
		    def("TSModuleBlock")
		        .bases("Node")
		        .build("body")
		        .field("body", [def("Statement")]);
		    def("TSModuleDeclaration")
		        .bases("Declaration")
		        .build("id", "body")
		        .field("id", or(StringLiteral, TSEntityName))
		        .field("declare", Boolean, defaults["false"])
		        .field("global", Boolean, defaults["false"])
		        .field("body", or(def("TSModuleBlock"), def("TSModuleDeclaration"), null), defaults["null"]);
		    def("TSImportType")
		        .bases("TSType", "TSHasOptionalTypeParameterInstantiation")
		        .build("argument", "qualifier", "typeParameters")
		        .field("argument", StringLiteral)
		        .field("qualifier", or(TSEntityName, void 0), defaults["undefined"]);
		    def("TSImportEqualsDeclaration")
		        .bases("Declaration")
		        .build("id", "moduleReference")
		        .field("id", def("Identifier"))
		        .field("isExport", Boolean, defaults["false"])
		        .field("moduleReference", or(TSEntityName, def("TSExternalModuleReference")));
		    def("TSExternalModuleReference")
		        .bases("Declaration")
		        .build("expression")
		        .field("expression", StringLiteral);
		    def("TSExportAssignment")
		        .bases("Statement")
		        .build("expression")
		        .field("expression", def("Expression"));
		    def("TSNamespaceExportDeclaration")
		        .bases("Declaration")
		        .build("id")
		        .field("id", def("Identifier"));
		    def("TSInterfaceBody")
		        .bases("Node")
		        .build("body")
		        .field("body", [TSTypeMember]);
		    def("TSExpressionWithTypeArguments")
		        .bases("TSType", "TSHasOptionalTypeParameterInstantiation")
		        .build("expression", "typeParameters")
		        .field("expression", TSEntityName);
		    def("TSInterfaceDeclaration")
		        .bases("Declaration", "TSHasOptionalTypeParameters")
		        .build("id", "body")
		        .field("id", TSEntityName)
		        .field("declare", Boolean, defaults["false"])
		        .field("extends", or([def("TSExpressionWithTypeArguments")], null), defaults["null"])
		        .field("body", def("TSInterfaceBody"));
		    def("TSParameterProperty")
		        .bases("Pattern")
		        .build("parameter")
		        .field("accessibility", or("public", "private", "protected", void 0), defaults["undefined"])
		        .field("readonly", Boolean, defaults["false"])
		        .field("parameter", or(def("Identifier"), def("AssignmentPattern")));
		    def("ClassProperty")
		        .field("access",
		    or("public", "private", "protected", void 0), defaults["undefined"]);
		    def("ClassBody")
		        .field("body", [or(def("MethodDefinition"), def("VariableDeclarator"), def("ClassPropertyDefinition"), def("ClassProperty"), def("ClassPrivateProperty"), def("ClassMethod"), def("ClassPrivateMethod"),
		        def("TSDeclareMethod"), TSTypeMember)]);
		}
		exports.default = default_1;
		module.exports = exports["default"]; 
	} (typescript, typescript.exports));
	return typescript.exports;
}

var esProposals = {exports: {}};

var hasRequiredEsProposals;

function requireEsProposals () {
	if (hasRequiredEsProposals) return esProposals.exports;
	hasRequiredEsProposals = 1;
	(function (module, exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		var tslib_1 = require$$0;
		var types_1 = tslib_1.__importDefault(requireTypes$1());
		var shared_1 = tslib_1.__importDefault(requireShared());
		var core_1 = tslib_1.__importDefault(requireCore());
		function default_1(fork) {
		    fork.use(core_1.default);
		    var types = fork.use(types_1.default);
		    var Type = types.Type;
		    var def = types.Type.def;
		    var or = Type.or;
		    var shared = fork.use(shared_1.default);
		    var defaults = shared.defaults;
		    def("OptionalMemberExpression")
		        .bases("MemberExpression")
		        .build("object", "property", "computed", "optional")
		        .field("optional", Boolean, defaults["true"]);
		    def("OptionalCallExpression")
		        .bases("CallExpression")
		        .build("callee", "arguments", "optional")
		        .field("optional", Boolean, defaults["true"]);
		    var LogicalOperator = or("||", "&&", "??");
		    def("LogicalExpression")
		        .field("operator", LogicalOperator);
		}
		exports.default = default_1;
		module.exports = exports["default"]; 
	} (esProposals, esProposals.exports));
	return esProposals.exports;
}

var namedTypes = {};

var hasRequiredNamedTypes;

function requireNamedTypes () {
	if (hasRequiredNamedTypes) return namedTypes;
	hasRequiredNamedTypes = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.namedTypes = void 0;
		(function (namedTypes) {
		})(exports.namedTypes || (exports.namedTypes = {})); 
	} (namedTypes));
	return namedTypes;
}

var hasRequiredMain;

function requireMain () {
	if (hasRequiredMain) return main;
	hasRequiredMain = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.visit = exports.use = exports.Type = exports.someField = exports.PathVisitor = exports.Path = exports.NodePath = exports.namedTypes = exports.getSupertypeNames = exports.getFieldValue = exports.getFieldNames = exports.getBuilderName = exports.finalize = exports.eachField = exports.defineMethod = exports.builtInTypes = exports.builders = exports.astNodesAreEquivalent = void 0;
		var tslib_1 = require$$0;
		var fork_1 = tslib_1.__importDefault(requireFork());
		var core_1 = tslib_1.__importDefault(requireCore());
		var es6_1 = tslib_1.__importDefault(requireEs6());
		var es7_1 = tslib_1.__importDefault(requireEs7());
		var es2020_1 = tslib_1.__importDefault(requireEs2020());
		var jsx_1 = tslib_1.__importDefault(requireJsx());
		var flow_1 = tslib_1.__importDefault(requireFlow());
		var esprima_1 = tslib_1.__importDefault(requireEsprima());
		var babel_1 = tslib_1.__importDefault(requireBabel());
		var typescript_1 = tslib_1.__importDefault(requireTypescript());
		var es_proposals_1 = tslib_1.__importDefault(requireEsProposals());
		var namedTypes_1 = requireNamedTypes();
		Object.defineProperty(exports, "namedTypes", { enumerable: true, get: function () { return namedTypes_1.namedTypes; } });
		var _a = fork_1.default([
		    core_1.default,
		    es6_1.default,
		    es7_1.default,
		    es2020_1.default,
		    jsx_1.default,
		    flow_1.default,
		    esprima_1.default,
		    babel_1.default,
		    typescript_1.default,
		    es_proposals_1.default,
		]), astNodesAreEquivalent = _a.astNodesAreEquivalent, builders = _a.builders, builtInTypes = _a.builtInTypes, defineMethod = _a.defineMethod, eachField = _a.eachField, finalize = _a.finalize, getBuilderName = _a.getBuilderName, getFieldNames = _a.getFieldNames, getFieldValue = _a.getFieldValue, getSupertypeNames = _a.getSupertypeNames, n = _a.namedTypes, NodePath = _a.NodePath, Path = _a.Path, PathVisitor = _a.PathVisitor, someField = _a.someField, Type = _a.Type, use = _a.use, visit = _a.visit;
		exports.astNodesAreEquivalent = astNodesAreEquivalent;
		exports.builders = builders;
		exports.builtInTypes = builtInTypes;
		exports.defineMethod = defineMethod;
		exports.eachField = eachField;
		exports.finalize = finalize;
		exports.getBuilderName = getBuilderName;
		exports.getFieldNames = getFieldNames;
		exports.getFieldValue = getFieldValue;
		exports.getSupertypeNames = getSupertypeNames;
		exports.NodePath = NodePath;
		exports.Path = Path;
		exports.PathVisitor = PathVisitor;
		exports.someField = someField;
		exports.Type = Type;
		exports.use = use;
		exports.visit = visit;
		Object.assign(namedTypes_1.namedTypes, n); 
	} (main));
	return main;
}

var hasRequiredDegenerator;

function requireDegenerator () {
	if (hasRequiredDegenerator) return degenerator;
	hasRequiredDegenerator = 1;
	Object.defineProperty(degenerator, "__esModule", { value: true });
	degenerator.degenerator = void 0;
	const util_1 = require$$0$2;
	const escodegen_1 = requireEscodegen();
	const esprima_1 = requireEsprima$1();
	const ast_types_1 = requireMain();
	function degenerator$1(code, _names) {
	    if (!Array.isArray(_names)) {
	        throw new TypeError('an array of async function "names" is required');
	    }
	    const names = _names.slice(0);
	    const ast = (0, esprima_1.parseScript)(code);
	    let lastNamesLength = 0;
	    do {
	        lastNamesLength = names.length;
	        (0, ast_types_1.visit)(ast, {
	            visitVariableDeclaration(path) {
	                if (path.node.declarations) {
	                    for (let i = 0; i < path.node.declarations.length; i++) {
	                        const declaration = path.node.declarations[i];
	                        if (ast_types_1.namedTypes.VariableDeclarator.check(declaration) &&
	                            ast_types_1.namedTypes.Identifier.check(declaration.init) &&
	                            ast_types_1.namedTypes.Identifier.check(declaration.id) &&
	                            checkName(declaration.init.name, names) &&
	                            !checkName(declaration.id.name, names)) {
	                            names.push(declaration.id.name);
	                        }
	                    }
	                }
	                return false;
	            },
	            visitAssignmentExpression(path) {
	                if (ast_types_1.namedTypes.Identifier.check(path.node.left) &&
	                    ast_types_1.namedTypes.Identifier.check(path.node.right) &&
	                    checkName(path.node.right.name, names) &&
	                    !checkName(path.node.left.name, names)) {
	                    names.push(path.node.left.name);
	                }
	                return false;
	            },
	            visitFunction(path) {
	                if (path.node.id) {
	                    let shouldDegenerate = false;
	                    (0, ast_types_1.visit)(path.node, {
	                        visitCallExpression(path) {
	                            if (checkNames(path.node, names)) {
	                                shouldDegenerate = true;
	                            }
	                            return false;
	                        },
	                    });
	                    if (!shouldDegenerate) {
	                        return false;
	                    }
	                    path.node.async = true;
	                    if (!checkName(path.node.id.name, names)) {
	                        names.push(path.node.id.name);
	                    }
	                }
	                this.traverse(path);
	            },
	        });
	    } while (lastNamesLength !== names.length);
	    (0, ast_types_1.visit)(ast, {
	        visitCallExpression(path) {
	            if (checkNames(path.node, names)) {
	                const delegate = false;
	                const { name, parent: { node: pNode }, } = path;
	                const expr = ast_types_1.builders.awaitExpression(path.node, delegate);
	                if (ast_types_1.namedTypes.CallExpression.check(pNode)) {
	                    pNode.arguments[name] = expr;
	                }
	                else {
	                    pNode[name] = expr;
	                }
	            }
	            this.traverse(path);
	        },
	    });
	    return (0, escodegen_1.generate)(ast);
	}
	degenerator.degenerator = degenerator$1;
	function checkNames({ callee }, names) {
	    let name;
	    if (ast_types_1.namedTypes.Identifier.check(callee)) {
	        name = callee.name;
	    }
	    else if (ast_types_1.namedTypes.MemberExpression.check(callee)) {
	        if (ast_types_1.namedTypes.Identifier.check(callee.object) &&
	            ast_types_1.namedTypes.Identifier.check(callee.property)) {
	            name = `${callee.object.name}.${callee.property.name}`;
	        }
	        else {
	            return false;
	        }
	    }
	    else if (ast_types_1.namedTypes.FunctionExpression.check(callee)) {
	        if (callee.id) {
	            name = callee.id.name;
	        }
	        else {
	            return false;
	        }
	    }
	    else {
	        throw new Error(`Don't know how to get name for: ${callee.type}`);
	    }
	    return checkName(name, names);
	}
	function checkName(name, names) {
	    for (let i = 0; i < names.length; i++) {
	        const n = names[i];
	        if (util_1.types.isRegExp(n)) {
	            if (n.test(name)) {
	                return true;
	            }
	        }
	        else if (name === n) {
	            return true;
	        }
	    }
	    return false;
	}
	return degenerator;
}

var compile = {};

var hasRequiredCompile;

function requireCompile () {
	if (hasRequiredCompile) return compile;
	hasRequiredCompile = 1;
	Object.defineProperty(compile, "__esModule", { value: true });
	compile.compile = void 0;
	const util_1 = require$$0$2;
	const degenerator_1 = requireDegenerator();
	function compile$1(qjs, code, returnName, options = {}) {
	    const compiled = (0, degenerator_1.degenerator)(code, options.names ?? []);
	    const vm = qjs.newContext();
	    if (options.sandbox) {
	        for (const [name, value] of Object.entries(options.sandbox)) {
	            if (typeof value !== 'function') {
	                throw new Error(`Expected a "function" for sandbox property \`${name}\`, but got "${typeof value}"`);
	            }
	            const fnHandle = vm.newFunction(name, (...args) => {
	                const result = value(...args.map((arg) => quickJSHandleToHost(vm, arg)));
	                vm.runtime.executePendingJobs();
	                return hostToQuickJSHandle(vm, result);
	            });
	            fnHandle.consume((handle) => vm.setProp(vm.global, name, handle));
	        }
	    }
	    const fnResult = vm.evalCode(`${compiled};${returnName}`, options.filename);
	    const fn = vm.unwrapResult(fnResult);
	    const t = vm.typeof(fn);
	    if (t !== 'function') {
	        throw new Error(`Expected a "function" named \`${returnName}\` to be defined, but got "${t}"`);
	    }
	    const r = async function (...args) {
	        let promiseHandle;
	        let resolvedHandle;
	        try {
	            const result = vm.callFunction(fn, vm.undefined, ...args.map((arg) => hostToQuickJSHandle(vm, arg)));
	            promiseHandle = vm.unwrapResult(result);
	            const resolvedResultP = vm.resolvePromise(promiseHandle);
	            vm.runtime.executePendingJobs();
	            const resolvedResult = await resolvedResultP;
	            resolvedHandle = vm.unwrapResult(resolvedResult);
	            return quickJSHandleToHost(vm, resolvedHandle);
	        }
	        catch (err) {
	            if (err && typeof err === 'object' && 'cause' in err && err.cause) {
	                if (typeof err.cause === 'object' &&
	                    'stack' in err.cause &&
	                    'name' in err.cause &&
	                    'message' in err.cause &&
	                    typeof err.cause.stack === 'string' &&
	                    typeof err.cause.name === 'string' &&
	                    typeof err.cause.message === 'string') {
	                    err.cause.stack = `${err.cause.name}: ${err.cause.message}\n${err.cause.stack}`;
	                }
	                throw err.cause;
	            }
	            throw err;
	        }
	        finally {
	            promiseHandle?.dispose();
	            resolvedHandle?.dispose();
	        }
	    };
	    Object.defineProperty(r, 'toString', {
	        value: () => compiled,
	        enumerable: false,
	    });
	    return r;
	}
	compile.compile = compile$1;
	function quickJSHandleToHost(vm, val) {
	    return vm.dump(val);
	}
	function hostToQuickJSHandle(vm, val) {
	    if (typeof val === 'undefined') {
	        return vm.undefined;
	    }
	    else if (val === null) {
	        return vm.null;
	    }
	    else if (typeof val === 'string') {
	        return vm.newString(val);
	    }
	    else if (typeof val === 'number') {
	        return vm.newNumber(val);
	    }
	    else if (typeof val === 'bigint') {
	        return vm.newBigInt(val);
	    }
	    else if (typeof val === 'boolean') {
	        return val ? vm.true : vm.false;
	    }
	    else if (util_1.types.isPromise(val)) {
	        const promise = vm.newPromise();
	        promise.settled.then(vm.runtime.executePendingJobs);
	        val.then((r) => {
	            promise.resolve(hostToQuickJSHandle(vm, r));
	        }, (err) => {
	            promise.reject(hostToQuickJSHandle(vm, err));
	        });
	        return promise.handle;
	    }
	    else if (util_1.types.isNativeError(val)) {
	        return vm.newError(val);
	    }
	    throw new Error(`Unsupported value: ${val}`);
	}
	return compile;
}

var hasRequiredDist$4;

function requireDist$4 () {
	if (hasRequiredDist$4) return dist$1;
	hasRequiredDist$4 = 1;
	(function (exports) {
		var __createBinding = (dist$1 && dist$1.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (dist$1 && dist$1.__exportStar) || function(m, exports) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		__exportStar(requireDegenerator(), exports);
		__exportStar(requireCompile(), exports); 
	} (dist$1));
	return dist$1;
}

var dateRange = {};

var hasRequiredDateRange;

function requireDateRange () {
	if (hasRequiredDateRange) return dateRange;
	hasRequiredDateRange = 1;
	Object.defineProperty(dateRange, "__esModule", { value: true });
	function dateRange$1() {
	    return false;
	}
	dateRange.default = dateRange$1;
	return dateRange;
}

var dnsDomainIs = {};

var hasRequiredDnsDomainIs;

function requireDnsDomainIs () {
	if (hasRequiredDnsDomainIs) return dnsDomainIs;
	hasRequiredDnsDomainIs = 1;
	Object.defineProperty(dnsDomainIs, "__esModule", { value: true });
	function dnsDomainIs$1(host, domain) {
	    host = String(host);
	    domain = String(domain);
	    return host.substr(domain.length * -1) === domain;
	}
	dnsDomainIs.default = dnsDomainIs$1;
	return dnsDomainIs;
}

var dnsDomainLevels = {};

var hasRequiredDnsDomainLevels;

function requireDnsDomainLevels () {
	if (hasRequiredDnsDomainLevels) return dnsDomainLevels;
	hasRequiredDnsDomainLevels = 1;
	Object.defineProperty(dnsDomainLevels, "__esModule", { value: true });
	function dnsDomainLevels$1(host) {
	    const match = String(host).match(/\./g);
	    let levels = 0;
	    if (match) {
	        levels = match.length;
	    }
	    return levels;
	}
	dnsDomainLevels.default = dnsDomainLevels$1;
	return dnsDomainLevels;
}

var dnsResolve = {};

var util = {};

var hasRequiredUtil;

function requireUtil () {
	if (hasRequiredUtil) return util;
	hasRequiredUtil = 1;
	Object.defineProperty(util, "__esModule", { value: true });
	util.isGMT = util.dnsLookup = void 0;
	const dns_1 = require$$3$1;
	function dnsLookup(host, opts) {
	    return new Promise((resolve, reject) => {
	        (0, dns_1.lookup)(host, opts, (err, res) => {
	            if (err) {
	                reject(err);
	            }
	            else {
	                resolve(res);
	            }
	        });
	    });
	}
	util.dnsLookup = dnsLookup;
	function isGMT(v) {
	    return v === 'GMT';
	}
	util.isGMT = isGMT;
	return util;
}

var hasRequiredDnsResolve;

function requireDnsResolve () {
	if (hasRequiredDnsResolve) return dnsResolve;
	hasRequiredDnsResolve = 1;
	Object.defineProperty(dnsResolve, "__esModule", { value: true });
	const util_1 = requireUtil();
	async function dnsResolve$1(host) {
	    const family = 4;
	    try {
	        const r = await (0, util_1.dnsLookup)(host, { family });
	        if (typeof r === 'string') {
	            return r;
	        }
	    }
	    catch (err) {
	    }
	    return null;
	}
	dnsResolve.default = dnsResolve$1;
	return dnsResolve;
}

var isInNet = {};

var netmask = {};

var hasRequiredNetmask;

function requireNetmask () {
	if (hasRequiredNetmask) return netmask;
	hasRequiredNetmask = 1;
	(function() {
	  var Netmask, atob, chr, chr0, chrA, chra, ip2long, long2ip;
	  long2ip = function(long) {
	    var a, b, c, d;
	    a = (long & (0xff << 24)) >>> 24;
	    b = (long & (0xff << 16)) >>> 16;
	    c = (long & (0xff << 8)) >>> 8;
	    d = long & 0xff;
	    return [a, b, c, d].join('.');
	  };
	  ip2long = function(ip) {
	    var b, c, i, j, n, ref;
	    b = [];
	    for (i = j = 0; j <= 3; i = ++j) {
	      if (ip.length === 0) {
	        break;
	      }
	      if (i > 0) {
	        if (ip[0] !== '.') {
	          throw new Error('Invalid IP');
	        }
	        ip = ip.substring(1);
	      }
	      ref = atob(ip), n = ref[0], c = ref[1];
	      ip = ip.substring(c);
	      b.push(n);
	    }
	    if (ip.length !== 0) {
	      throw new Error('Invalid IP');
	    }
	    switch (b.length) {
	      case 1:
	        if (b[0] > 0xFFFFFFFF) {
	          throw new Error('Invalid IP');
	        }
	        return b[0] >>> 0;
	      case 2:
	        if (b[0] > 0xFF || b[1] > 0xFFFFFF) {
	          throw new Error('Invalid IP');
	        }
	        return (b[0] << 24 | b[1]) >>> 0;
	      case 3:
	        if (b[0] > 0xFF || b[1] > 0xFF || b[2] > 0xFFFF) {
	          throw new Error('Invalid IP');
	        }
	        return (b[0] << 24 | b[1] << 16 | b[2]) >>> 0;
	      case 4:
	        if (b[0] > 0xFF || b[1] > 0xFF || b[2] > 0xFF || b[3] > 0xFF) {
	          throw new Error('Invalid IP');
	        }
	        return (b[0] << 24 | b[1] << 16 | b[2] << 8 | b[3]) >>> 0;
	      default:
	        throw new Error('Invalid IP');
	    }
	  };
	  chr = function(b) {
	    return b.charCodeAt(0);
	  };
	  chr0 = chr('0');
	  chra = chr('a');
	  chrA = chr('A');
	  atob = function(s) {
	    var base, dmax, i, n, start;
	    n = 0;
	    base = 10;
	    dmax = '9';
	    i = 0;
	    if (s.length > 1 && s[i] === '0') {
	      if (s[i + 1] === 'x' || s[i + 1] === 'X') {
	        i += 2;
	        base = 16;
	      } else if ('0' <= s[i + 1] && s[i + 1] <= '9') {
	        i++;
	        base = 8;
	        dmax = '7';
	      }
	    }
	    start = i;
	    while (i < s.length) {
	      if ('0' <= s[i] && s[i] <= dmax) {
	        n = (n * base + (chr(s[i]) - chr0)) >>> 0;
	      } else if (base === 16) {
	        if ('a' <= s[i] && s[i] <= 'f') {
	          n = (n * base + (10 + chr(s[i]) - chra)) >>> 0;
	        } else if ('A' <= s[i] && s[i] <= 'F') {
	          n = (n * base + (10 + chr(s[i]) - chrA)) >>> 0;
	        } else {
	          break;
	        }
	      } else {
	        break;
	      }
	      if (n > 0xFFFFFFFF) {
	        throw new Error('too large');
	      }
	      i++;
	    }
	    if (i === start) {
	      throw new Error('empty octet');
	    }
	    return [n, i];
	  };
	  Netmask = (function() {
	    function Netmask(net, mask) {
	      var i, j, ref;
	      if (typeof net !== 'string') {
	        throw new Error("Missing `net' parameter");
	      }
	      if (!mask) {
	        ref = net.split('/', 2), net = ref[0], mask = ref[1];
	      }
	      if (!mask) {
	        mask = 32;
	      }
	      if (typeof mask === 'string' && mask.indexOf('.') > -1) {
	        try {
	          this.maskLong = ip2long(mask);
	        } catch (error1) {
	          throw new Error("Invalid mask: " + mask);
	        }
	        for (i = j = 32; j >= 0; i = --j) {
	          if (this.maskLong === (0xffffffff << (32 - i)) >>> 0) {
	            this.bitmask = i;
	            break;
	          }
	        }
	      } else if (mask || mask === 0) {
	        this.bitmask = parseInt(mask, 10);
	        this.maskLong = 0;
	        if (this.bitmask > 0) {
	          this.maskLong = (0xffffffff << (32 - this.bitmask)) >>> 0;
	        }
	      } else {
	        throw new Error("Invalid mask: empty");
	      }
	      try {
	        this.netLong = (ip2long(net) & this.maskLong) >>> 0;
	      } catch (error1) {
	        throw new Error("Invalid net address: " + net);
	      }
	      if (!(this.bitmask <= 32)) {
	        throw new Error("Invalid mask for ip4: " + mask);
	      }
	      this.size = Math.pow(2, 32 - this.bitmask);
	      this.base = long2ip(this.netLong);
	      this.mask = long2ip(this.maskLong);
	      this.hostmask = long2ip(~this.maskLong);
	      this.first = this.bitmask <= 30 ? long2ip(this.netLong + 1) : this.base;
	      this.last = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 2) : long2ip(this.netLong + this.size - 1);
	      this.broadcast = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 1) : void 0;
	    }
	    Netmask.prototype.contains = function(ip) {
	      if (typeof ip === 'string' && (ip.indexOf('/') > 0 || ip.split('.').length !== 4)) {
	        ip = new Netmask(ip);
	      }
	      if (ip instanceof Netmask) {
	        return this.contains(ip.base) && this.contains(ip.broadcast || ip.last);
	      } else {
	        return (ip2long(ip) & this.maskLong) >>> 0 === (this.netLong & this.maskLong) >>> 0;
	      }
	    };
	    Netmask.prototype.next = function(count) {
	      if (count == null) {
	        count = 1;
	      }
	      return new Netmask(long2ip(this.netLong + (this.size * count)), this.mask);
	    };
	    Netmask.prototype.forEach = function(fn) {
	      var index, lastLong, long;
	      long = ip2long(this.first);
	      lastLong = ip2long(this.last);
	      index = 0;
	      while (long <= lastLong) {
	        fn(long2ip(long), long, index);
	        index++;
	        long++;
	      }
	    };
	    Netmask.prototype.toString = function() {
	      return this.base + "/" + this.bitmask;
	    };
	    return Netmask;
	  })();
	  netmask.ip2long = ip2long;
	  netmask.long2ip = long2ip;
	  netmask.Netmask = Netmask;
	}).call(netmask);
	return netmask;
}

var hasRequiredIsInNet;

function requireIsInNet () {
	if (hasRequiredIsInNet) return isInNet;
	hasRequiredIsInNet = 1;
	Object.defineProperty(isInNet, "__esModule", { value: true });
	const netmask_1 = requireNetmask();
	const util_1 = requireUtil();
	async function isInNet$1(host, pattern, mask) {
	    const family = 4;
	    try {
	        const ip = await (0, util_1.dnsLookup)(host, { family });
	        if (typeof ip === 'string') {
	            const netmask = new netmask_1.Netmask(pattern, mask);
	            return netmask.contains(ip);
	        }
	    }
	    catch (err) {
	    }
	    return false;
	}
	isInNet.default = isInNet$1;
	return isInNet;
}

var isPlainHostName = {};

var hasRequiredIsPlainHostName;

function requireIsPlainHostName () {
	if (hasRequiredIsPlainHostName) return isPlainHostName;
	hasRequiredIsPlainHostName = 1;
	Object.defineProperty(isPlainHostName, "__esModule", { value: true });
	function isPlainHostName$1(host) {
	    return !/\./.test(host);
	}
	isPlainHostName.default = isPlainHostName$1;
	return isPlainHostName;
}

var isResolvable = {};

var hasRequiredIsResolvable;

function requireIsResolvable () {
	if (hasRequiredIsResolvable) return isResolvable;
	hasRequiredIsResolvable = 1;
	Object.defineProperty(isResolvable, "__esModule", { value: true });
	const util_1 = requireUtil();
	async function isResolvable$1(host) {
	    const family = 4;
	    try {
	        if (await (0, util_1.dnsLookup)(host, { family })) {
	            return true;
	        }
	    }
	    catch (err) {
	    }
	    return false;
	}
	isResolvable.default = isResolvable$1;
	return isResolvable;
}

var localHostOrDomainIs = {};

var hasRequiredLocalHostOrDomainIs;

function requireLocalHostOrDomainIs () {
	if (hasRequiredLocalHostOrDomainIs) return localHostOrDomainIs;
	hasRequiredLocalHostOrDomainIs = 1;
	Object.defineProperty(localHostOrDomainIs, "__esModule", { value: true });
	function localHostOrDomainIs$1(host, hostdom) {
	    const parts = host.split('.');
	    const domparts = hostdom.split('.');
	    let matches = true;
	    for (let i = 0; i < parts.length; i++) {
	        if (parts[i] !== domparts[i]) {
	            matches = false;
	            break;
	        }
	    }
	    return matches;
	}
	localHostOrDomainIs.default = localHostOrDomainIs$1;
	return localHostOrDomainIs;
}

var myIpAddress = {};

var ip = {};

var hasRequiredIp;

function requireIp () {
	if (hasRequiredIp) return ip;
	hasRequiredIp = 1;
	(function (exports) {
		var __importDefault = (ip && ip.__importDefault) || function (mod) {
		    return (mod && mod.__esModule) ? mod : { "default": mod };
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.ip = void 0;
		const os_1 = __importDefault(require$$0$1);
		exports.ip = {
		    address() {
		        const interfaces = os_1.default.networkInterfaces();
		        const family = normalizeFamily();
		        const all = Object.values(interfaces).map((addrs = []) => {
		            const addresses = addrs.filter((details) => {
		                const detailsFamily = normalizeFamily(details.family);
		                if (detailsFamily !== family || exports.ip.isLoopback(details.address)) {
		                    return false;
		                }
		                return true;
		            });
		            return addresses.length ? addresses[0].address : undefined;
		        }).filter(Boolean);
		        return !all.length ? exports.ip.loopback(family) : all[0];
		    },
		    isLoopback(addr) {
		        return /^(::f{4}:)?127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})/
		            .test(addr)
		            || /^fe80::1$/.test(addr)
		            || /^::1$/.test(addr)
		            || /^::$/.test(addr);
		    },
		    loopback(family) {
		        family = normalizeFamily(family);
		        if (family !== 'ipv4' && family !== 'ipv6') {
		            throw new Error('family must be ipv4 or ipv6');
		        }
		        return family === 'ipv4' ? '127.0.0.1' : 'fe80::1';
		    }
		};
		function normalizeFamily(family) {
		    if (family === 4) {
		        return 'ipv4';
		    }
		    if (family === 6) {
		        return 'ipv6';
		    }
		    return family ? family.toLowerCase() : 'ipv4';
		} 
	} (ip));
	return ip;
}

var hasRequiredMyIpAddress;

function requireMyIpAddress () {
	if (hasRequiredMyIpAddress) return myIpAddress;
	hasRequiredMyIpAddress = 1;
	var __importDefault = (myIpAddress && myIpAddress.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(myIpAddress, "__esModule", { value: true });
	const ip_1 = requireIp();
	const net_1 = __importDefault(require$$0$4);
	async function myIpAddress$1() {
	    return new Promise((resolve, reject) => {
	        const socket = net_1.default.connect({ host: '8.8.8.8', port: 53 });
	        const onError = () => {
	            resolve(ip_1.ip.address());
	        };
	        socket.once('error', onError);
	        socket.once('connect', () => {
	            socket.removeListener('error', onError);
	            const addr = socket.address();
	            socket.destroy();
	            if (typeof addr === 'string') {
	                resolve(addr);
	            }
	            else if (addr.address) {
	                resolve(addr.address);
	            }
	            else {
	                reject(new Error('Expected a `string`'));
	            }
	        });
	    });
	}
	myIpAddress.default = myIpAddress$1;
	return myIpAddress;
}

var shExpMatch = {};

var hasRequiredShExpMatch;

function requireShExpMatch () {
	if (hasRequiredShExpMatch) return shExpMatch;
	hasRequiredShExpMatch = 1;
	Object.defineProperty(shExpMatch, "__esModule", { value: true });
	function shExpMatch$1(str, shexp) {
	    const re = toRegExp(shexp);
	    return re.test(str);
	}
	shExpMatch.default = shExpMatch$1;
	function toRegExp(str) {
	    str = String(str)
	        .replace(/\./g, '\\.')
	        .replace(/\?/g, '.')
	        .replace(/\*/g, '.*');
	    return new RegExp(`^${str}$`);
	}
	return shExpMatch;
}

var timeRange = {};

var hasRequiredTimeRange;

function requireTimeRange () {
	if (hasRequiredTimeRange) return timeRange;
	hasRequiredTimeRange = 1;
	Object.defineProperty(timeRange, "__esModule", { value: true });
	function timeRange$1() {
	    const args = Array.prototype.slice.call(arguments);
	    const lastArg = args.pop();
	    const useGMTzone = lastArg === 'GMT';
	    const currentDate = new Date();
	    if (!useGMTzone) {
	        args.push(lastArg);
	    }
	    let result = false;
	    const noOfArgs = args.length;
	    const numericArgs = args.map((n) => parseInt(n, 10));
	    if (noOfArgs === 1) {
	        result = getCurrentHour(useGMTzone, currentDate) === numericArgs[0];
	    }
	    else if (noOfArgs === 2) {
	        const currentHour = getCurrentHour(useGMTzone, currentDate);
	        result = numericArgs[0] <= currentHour && currentHour < numericArgs[1];
	    }
	    else if (noOfArgs === 4) {
	        result = valueInRange(secondsElapsedToday(numericArgs[0], numericArgs[1], 0), secondsElapsedToday(getCurrentHour(useGMTzone, currentDate), getCurrentMinute(useGMTzone, currentDate), 0), secondsElapsedToday(numericArgs[2], numericArgs[3], 59));
	    }
	    else if (noOfArgs === 6) {
	        result = valueInRange(secondsElapsedToday(numericArgs[0], numericArgs[1], numericArgs[2]), secondsElapsedToday(getCurrentHour(useGMTzone, currentDate), getCurrentMinute(useGMTzone, currentDate), getCurrentSecond(useGMTzone, currentDate)), secondsElapsedToday(numericArgs[3], numericArgs[4], numericArgs[5]));
	    }
	    return result;
	}
	timeRange.default = timeRange$1;
	function secondsElapsedToday(hh, mm, ss) {
	    return hh * 3600 + mm * 60 + ss;
	}
	function getCurrentHour(gmt, currentDate) {
	    return gmt ? currentDate.getUTCHours() : currentDate.getHours();
	}
	function getCurrentMinute(gmt, currentDate) {
	    return gmt ? currentDate.getUTCMinutes() : currentDate.getMinutes();
	}
	function getCurrentSecond(gmt, currentDate) {
	    return gmt ? currentDate.getUTCSeconds() : currentDate.getSeconds();
	}
	function valueInRange(start, value, finish) {
	    return start <= value && value <= finish;
	}
	return timeRange;
}

var weekdayRange = {};

var hasRequiredWeekdayRange;

function requireWeekdayRange () {
	if (hasRequiredWeekdayRange) return weekdayRange;
	hasRequiredWeekdayRange = 1;
	Object.defineProperty(weekdayRange, "__esModule", { value: true });
	const util_1 = requireUtil();
	const weekdays = ['SUN', 'MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT'];
	function weekdayRange$1(wd1, wd2, gmt) {
	    let useGMTzone = false;
	    let wd1Index = -1;
	    let wd2Index = -1;
	    let wd2IsGmt = false;
	    if ((0, util_1.isGMT)(gmt)) {
	        useGMTzone = true;
	    }
	    else if ((0, util_1.isGMT)(wd2)) {
	        useGMTzone = true;
	        wd2IsGmt = true;
	    }
	    wd1Index = weekdays.indexOf(wd1);
	    if (!wd2IsGmt && isWeekday(wd2)) {
	        wd2Index = weekdays.indexOf(wd2);
	    }
	    const todaysDay = getTodaysDay(useGMTzone);
	    let result;
	    if (wd2Index < 0) {
	        result = todaysDay === wd1Index;
	    }
	    else if (wd1Index <= wd2Index) {
	        result = valueInRange(wd1Index, todaysDay, wd2Index);
	    }
	    else {
	        result =
	            valueInRange(wd1Index, todaysDay, 6) ||
	                valueInRange(0, todaysDay, wd2Index);
	    }
	    return result;
	}
	weekdayRange.default = weekdayRange$1;
	function getTodaysDay(gmt) {
	    return gmt ? new Date().getUTCDay() : new Date().getDay();
	}
	function valueInRange(start, value, finish) {
	    return start <= value && value <= finish;
	}
	function isWeekday(v) {
	    if (!v)
	        return false;
	    return weekdays.includes(v);
	}
	return weekdayRange;
}

var hasRequiredDist$3;

function requireDist$3 () {
	if (hasRequiredDist$3) return dist$2;
	hasRequiredDist$3 = 1;
	(function (exports) {
		var __importDefault = (dist$2 && dist$2.__importDefault) || function (mod) {
		    return (mod && mod.__esModule) ? mod : { "default": mod };
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.sandbox = exports.createPacResolver = void 0;
		const degenerator_1 = requireDist$4();
		const dateRange_1 = __importDefault(requireDateRange());
		const dnsDomainIs_1 = __importDefault(requireDnsDomainIs());
		const dnsDomainLevels_1 = __importDefault(requireDnsDomainLevels());
		const dnsResolve_1 = __importDefault(requireDnsResolve());
		const isInNet_1 = __importDefault(requireIsInNet());
		const isPlainHostName_1 = __importDefault(requireIsPlainHostName());
		const isResolvable_1 = __importDefault(requireIsResolvable());
		const localHostOrDomainIs_1 = __importDefault(requireLocalHostOrDomainIs());
		const myIpAddress_1 = __importDefault(requireMyIpAddress());
		const shExpMatch_1 = __importDefault(requireShExpMatch());
		const timeRange_1 = __importDefault(requireTimeRange());
		const weekdayRange_1 = __importDefault(requireWeekdayRange());
		function createPacResolver(qjs, _str, _opts = {}) {
		    const str = Buffer.isBuffer(_str) ? _str.toString('utf8') : _str;
		    const context = {
		        ...exports.sandbox,
		        ..._opts.sandbox,
		    };
		    const names = Object.keys(context).filter((k) => isAsyncFunction(context[k]));
		    const opts = {
		        filename: 'proxy.pac',
		        names,
		        ..._opts,
		        sandbox: context,
		    };
		    const resolver = (0, degenerator_1.compile)(qjs, str, 'FindProxyForURL', opts);
		    function FindProxyForURL(url, _host) {
		        const urlObj = typeof url === 'string' ? new URL(url) : url;
		        const host = _host || urlObj.hostname;
		        if (!host) {
		            throw new TypeError('Could not determine `host`');
		        }
		        return resolver(urlObj.href, host);
		    }
		    Object.defineProperty(FindProxyForURL, 'toString', {
		        value: () => resolver.toString(),
		        enumerable: false,
		    });
		    return FindProxyForURL;
		}
		exports.createPacResolver = createPacResolver;
		exports.sandbox = Object.freeze({
		    alert: (message = '') => console.log('%s', message),
		    dateRange: dateRange_1.default,
		    dnsDomainIs: dnsDomainIs_1.default,
		    dnsDomainLevels: dnsDomainLevels_1.default,
		    dnsResolve: dnsResolve_1.default,
		    isInNet: isInNet_1.default,
		    isPlainHostName: isPlainHostName_1.default,
		    isResolvable: isResolvable_1.default,
		    localHostOrDomainIs: localHostOrDomainIs_1.default,
		    myIpAddress: myIpAddress_1.default,
		    shExpMatch: shExpMatch_1.default,
		    timeRange: timeRange_1.default,
		    weekdayRange: weekdayRange_1.default,
		});
		function isAsyncFunction(v) {
		    if (typeof v !== 'function')
		        return false;
		    if (v.constructor.name === 'AsyncFunction')
		        return true;
		    if (String(v).indexOf('__awaiter(') !== -1)
		        return true;
		    return Boolean(v.async);
		} 
	} (dist$2));
	return dist$2;
}

var dist = {};

var variants = {};

var esmHelpers = {};

var hasRequiredEsmHelpers;

function requireEsmHelpers () {
	if (hasRequiredEsmHelpers) return esmHelpers;
	hasRequiredEsmHelpers = 1;
	Object.defineProperty(esmHelpers, "__esModule", { value: true });
	esmHelpers.unwrapJavascript = esmHelpers.unwrapTypescript = void 0;
	function fakeUnwrapDefault(mod) {
	    return mod.default;
	}
	function actualUnwrapDefault(mod) {
	    const maybeUnwrap = mod.default;
	    return maybeUnwrap ?? mod;
	}
	esmHelpers.unwrapTypescript = actualUnwrapDefault;
	esmHelpers.unwrapJavascript = fakeUnwrapDefault;
	return esmHelpers;
}

var module = {};

var debug = {};

var hasRequiredDebug;

function requireDebug () {
	if (hasRequiredDebug) return debug;
	hasRequiredDebug = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.debugLog = exports.QTS_DEBUG = void 0;
		exports.QTS_DEBUG = Boolean(typeof process === "object" && process.env.QTS_DEBUG);
		exports.debugLog = exports.QTS_DEBUG ? console.log.bind(console) : () => { }; 
	} (debug));
	return debug;
}

var errors = {};

var hasRequiredErrors;

function requireErrors () {
	if (hasRequiredErrors) return errors;
	hasRequiredErrors = 1;
	Object.defineProperty(errors, "__esModule", { value: true });
	errors.QuickJSMemoryLeakDetected = errors.QuickJSAsyncifySuspended = errors.QuickJSAsyncifyError = errors.QuickJSNotImplemented = errors.QuickJSUseAfterFree = errors.QuickJSWrongOwner = errors.QuickJSUnwrapError = void 0;
	class QuickJSUnwrapError extends Error {
	    constructor(cause, context) {
	        super(String(cause));
	        this.cause = cause;
	        this.context = context;
	        this.name = "QuickJSUnwrapError";
	    }
	}
	errors.QuickJSUnwrapError = QuickJSUnwrapError;
	class QuickJSWrongOwner extends Error {
	    constructor() {
	        super(...arguments);
	        this.name = "QuickJSWrongOwner";
	    }
	}
	errors.QuickJSWrongOwner = QuickJSWrongOwner;
	class QuickJSUseAfterFree extends Error {
	    constructor() {
	        super(...arguments);
	        this.name = "QuickJSUseAfterFree";
	    }
	}
	errors.QuickJSUseAfterFree = QuickJSUseAfterFree;
	class QuickJSNotImplemented extends Error {
	    constructor() {
	        super(...arguments);
	        this.name = "QuickJSNotImplemented";
	    }
	}
	errors.QuickJSNotImplemented = QuickJSNotImplemented;
	class QuickJSAsyncifyError extends Error {
	    constructor() {
	        super(...arguments);
	        this.name = "QuickJSAsyncifyError";
	    }
	}
	errors.QuickJSAsyncifyError = QuickJSAsyncifyError;
	class QuickJSAsyncifySuspended extends Error {
	    constructor() {
	        super(...arguments);
	        this.name = "QuickJSAsyncifySuspended";
	    }
	}
	errors.QuickJSAsyncifySuspended = QuickJSAsyncifySuspended;
	class QuickJSMemoryLeakDetected extends Error {
	    constructor() {
	        super(...arguments);
	        this.name = "QuickJSMemoryLeakDetected";
	    }
	}
	errors.QuickJSMemoryLeakDetected = QuickJSMemoryLeakDetected;
	return errors;
}

var lifetime = {};

var asyncifyHelpers = {};

var hasRequiredAsyncifyHelpers;

function requireAsyncifyHelpers () {
	if (hasRequiredAsyncifyHelpers) return asyncifyHelpers;
	hasRequiredAsyncifyHelpers = 1;
	Object.defineProperty(asyncifyHelpers, "__esModule", { value: true });
	asyncifyHelpers.awaitEachYieldedPromise = asyncifyHelpers.maybeAsync = asyncifyHelpers.maybeAsyncFn = void 0;
	function* awaitYield(value) {
	    return (yield value);
	}
	function awaitYieldOf(generator) {
	    return awaitYield(awaitEachYieldedPromise(generator));
	}
	const AwaitYield = awaitYield;
	AwaitYield.of = awaitYieldOf;
	function maybeAsyncFn(that, fn) {
	    return (...args) => {
	        const generator = fn.call(that, AwaitYield, ...args);
	        return awaitEachYieldedPromise(generator);
	    };
	}
	asyncifyHelpers.maybeAsyncFn = maybeAsyncFn;
	function maybeAsync(that, startGenerator) {
	    const generator = startGenerator.call(that, AwaitYield);
	    return awaitEachYieldedPromise(generator);
	}
	asyncifyHelpers.maybeAsync = maybeAsync;
	function awaitEachYieldedPromise(gen) {
	    function handleNextStep(step) {
	        if (step.done) {
	            return step.value;
	        }
	        if (step.value instanceof Promise) {
	            return step.value.then((value) => handleNextStep(gen.next(value)), (error) => handleNextStep(gen.throw(error)));
	        }
	        return handleNextStep(gen.next(step.value));
	    }
	    return handleNextStep(gen.next());
	}
	asyncifyHelpers.awaitEachYieldedPromise = awaitEachYieldedPromise;
	return asyncifyHelpers;
}

var hasRequiredLifetime;

function requireLifetime () {
	if (hasRequiredLifetime) return lifetime;
	hasRequiredLifetime = 1;
	Object.defineProperty(lifetime, "__esModule", { value: true });
	lifetime.Scope = lifetime.WeakLifetime = lifetime.StaticLifetime = lifetime.Lifetime = void 0;
	const asyncify_helpers_1 = /*@__PURE__*/ requireAsyncifyHelpers();
	const debug_1 = /*@__PURE__*/ requireDebug();
	const errors_1 = /*@__PURE__*/ requireErrors();
	class Lifetime {
	    constructor(_value, copier, disposer, _owner) {
	        this._value = _value;
	        this.copier = copier;
	        this.disposer = disposer;
	        this._owner = _owner;
	        this._alive = true;
	        this._constructorStack = debug_1.QTS_DEBUG ? new Error("Lifetime constructed").stack : undefined;
	    }
	    get alive() {
	        return this._alive;
	    }
	    get value() {
	        this.assertAlive();
	        return this._value;
	    }
	    get owner() {
	        return this._owner;
	    }
	    get dupable() {
	        return !!this.copier;
	    }
	    dup() {
	        this.assertAlive();
	        if (!this.copier) {
	            throw new Error("Non-dupable lifetime");
	        }
	        return new Lifetime(this.copier(this._value), this.copier, this.disposer, this._owner);
	    }
	    consume(map) {
	        this.assertAlive();
	        const result = map(this);
	        this.dispose();
	        return result;
	    }
	    dispose() {
	        this.assertAlive();
	        if (this.disposer) {
	            this.disposer(this._value);
	        }
	        this._alive = false;
	    }
	    assertAlive() {
	        if (!this.alive) {
	            if (this._constructorStack) {
	                throw new errors_1.QuickJSUseAfterFree(`Lifetime not alive\n${this._constructorStack}\nLifetime used`);
	            }
	            throw new errors_1.QuickJSUseAfterFree("Lifetime not alive");
	        }
	    }
	}
	lifetime.Lifetime = Lifetime;
	class StaticLifetime extends Lifetime {
	    constructor(value, owner) {
	        super(value, undefined, undefined, owner);
	    }
	    get dupable() {
	        return true;
	    }
	    dup() {
	        return this;
	    }
	    dispose() { }
	}
	lifetime.StaticLifetime = StaticLifetime;
	class WeakLifetime extends Lifetime {
	    constructor(value, copier, disposer, owner) {
	        super(value, copier, disposer, owner);
	    }
	    dispose() {
	        this._alive = false;
	    }
	}
	lifetime.WeakLifetime = WeakLifetime;
	function scopeFinally(scope, blockError) {
	    let disposeError;
	    try {
	        scope.dispose();
	    }
	    catch (error) {
	        disposeError = error;
	    }
	    if (blockError && disposeError) {
	        Object.assign(blockError, {
	            message: `${blockError.message}\n Then, failed to dispose scope: ${disposeError.message}`,
	            disposeError,
	        });
	        throw blockError;
	    }
	    if (blockError || disposeError) {
	        throw blockError || disposeError;
	    }
	}
	class Scope {
	    constructor() {
	        this._disposables = new Lifetime(new Set());
	    }
	    static withScope(block) {
	        const scope = new Scope();
	        let blockError;
	        try {
	            return block(scope);
	        }
	        catch (error) {
	            blockError = error;
	            throw error;
	        }
	        finally {
	            scopeFinally(scope, blockError);
	        }
	    }
	    static withScopeMaybeAsync(_this, block) {
	        return (0, asyncify_helpers_1.maybeAsync)(undefined, function* (awaited) {
	            const scope = new Scope();
	            let blockError;
	            try {
	                return yield* awaited.of(block.call(_this, awaited, scope));
	            }
	            catch (error) {
	                blockError = error;
	                throw error;
	            }
	            finally {
	                scopeFinally(scope, blockError);
	            }
	        });
	    }
	    static async withScopeAsync(block) {
	        const scope = new Scope();
	        let blockError;
	        try {
	            return await block(scope);
	        }
	        catch (error) {
	            blockError = error;
	            throw error;
	        }
	        finally {
	            scopeFinally(scope, blockError);
	        }
	    }
	    manage(lifetime) {
	        this._disposables.value.add(lifetime);
	        return lifetime;
	    }
	    get alive() {
	        return this._disposables.alive;
	    }
	    dispose() {
	        const lifetimes = Array.from(this._disposables.value.values()).reverse();
	        for (const lifetime of lifetimes) {
	            if (lifetime.alive) {
	                lifetime.dispose();
	            }
	        }
	        this._disposables.dispose();
	    }
	}
	lifetime.Scope = Scope;
	return lifetime;
}

var runtime = {};

var context = {};

var deferredPromise = {};

var hasRequiredDeferredPromise;

function requireDeferredPromise () {
	if (hasRequiredDeferredPromise) return deferredPromise;
	hasRequiredDeferredPromise = 1;
	Object.defineProperty(deferredPromise, "__esModule", { value: true });
	deferredPromise.QuickJSDeferredPromise = void 0;
	class QuickJSDeferredPromise {
	    constructor(args) {
	        this.resolve = (value) => {
	            if (!this.resolveHandle.alive) {
	                return;
	            }
	            this.context
	                .unwrapResult(this.context.callFunction(this.resolveHandle, this.context.undefined, value || this.context.undefined))
	                .dispose();
	            this.disposeResolvers();
	            this.onSettled();
	        };
	        this.reject = (value) => {
	            if (!this.rejectHandle.alive) {
	                return;
	            }
	            this.context
	                .unwrapResult(this.context.callFunction(this.rejectHandle, this.context.undefined, value || this.context.undefined))
	                .dispose();
	            this.disposeResolvers();
	            this.onSettled();
	        };
	        this.dispose = () => {
	            if (this.handle.alive) {
	                this.handle.dispose();
	            }
	            this.disposeResolvers();
	        };
	        this.context = args.context;
	        this.owner = args.context.runtime;
	        this.handle = args.promiseHandle;
	        this.settled = new Promise((resolve) => {
	            this.onSettled = resolve;
	        });
	        this.resolveHandle = args.resolveHandle;
	        this.rejectHandle = args.rejectHandle;
	    }
	    get alive() {
	        return this.handle.alive || this.resolveHandle.alive || this.rejectHandle.alive;
	    }
	    disposeResolvers() {
	        if (this.resolveHandle.alive) {
	            this.resolveHandle.dispose();
	        }
	        if (this.rejectHandle.alive) {
	            this.rejectHandle.dispose();
	        }
	    }
	}
	deferredPromise.QuickJSDeferredPromise = QuickJSDeferredPromise;
	return deferredPromise;
}

var memory = {};

var hasRequiredMemory;

function requireMemory () {
	if (hasRequiredMemory) return memory;
	hasRequiredMemory = 1;
	Object.defineProperty(memory, "__esModule", { value: true });
	memory.ModuleMemory = void 0;
	const lifetime_1 = /*@__PURE__*/ requireLifetime();
	class ModuleMemory {
	    constructor(module) {
	        this.module = module;
	    }
	    toPointerArray(handleArray) {
	        const typedArray = new Int32Array(handleArray.map((handle) => handle.value));
	        const numBytes = typedArray.length * typedArray.BYTES_PER_ELEMENT;
	        const ptr = this.module._malloc(numBytes);
	        var heapBytes = new Uint8Array(this.module.HEAPU8.buffer, ptr, numBytes);
	        heapBytes.set(new Uint8Array(typedArray.buffer));
	        return new lifetime_1.Lifetime(ptr, undefined, (ptr) => this.module._free(ptr));
	    }
	    newMutablePointerArray(length) {
	        const zeros = new Int32Array(new Array(length).fill(0));
	        const numBytes = zeros.length * zeros.BYTES_PER_ELEMENT;
	        const ptr = this.module._malloc(numBytes);
	        const typedArray = new Int32Array(this.module.HEAPU8.buffer, ptr, length);
	        typedArray.set(zeros);
	        return new lifetime_1.Lifetime({ typedArray, ptr }, undefined, (value) => this.module._free(value.ptr));
	    }
	    newHeapCharPointer(string) {
	        const numBytes = this.module.lengthBytesUTF8(string) + 1;
	        const ptr = this.module._malloc(numBytes);
	        this.module.stringToUTF8(string, ptr, numBytes);
	        return new lifetime_1.Lifetime(ptr, undefined, (value) => this.module._free(value));
	    }
	    consumeHeapCharPointer(ptr) {
	        const str = this.module.UTF8ToString(ptr);
	        this.module._free(ptr);
	        return str;
	    }
	}
	memory.ModuleMemory = ModuleMemory;
	return memory;
}

var types = {};

var typesFfi = {};

var hasRequiredTypesFfi;

function requireTypesFfi () {
	if (hasRequiredTypesFfi) return typesFfi;
	hasRequiredTypesFfi = 1;
	Object.defineProperty(typesFfi, "__esModule", { value: true });
	typesFfi.EvalFlags = typesFfi.assertSync = void 0;
	function assertSync(fn) {
	    return function mustBeSync(...args) {
	        const result = fn(...args);
	        if (result && typeof result === "object" && result instanceof Promise) {
	            throw new Error("Function unexpectedly returned a Promise");
	        }
	        return result;
	    };
	}
	typesFfi.assertSync = assertSync;
	typesFfi.EvalFlags = {
	    JS_EVAL_TYPE_GLOBAL: 0 << 0,
	    JS_EVAL_TYPE_MODULE: 1 << 0,
	    JS_EVAL_TYPE_DIRECT: 2 << 0,
	    JS_EVAL_TYPE_INDIRECT: 3 << 0,
	    JS_EVAL_TYPE_MASK: 3 << 0,
	    JS_EVAL_FLAG_STRICT: 1 << 3,
	    JS_EVAL_FLAG_STRIP: 1 << 4,
	    JS_EVAL_FLAG_COMPILE_ONLY: 1 << 5,
	    JS_EVAL_FLAG_BACKTRACE_BARRIER: 1 << 6,
	};
	return typesFfi;
}

var hasRequiredTypes;

function requireTypes () {
	if (hasRequiredTypes) return types;
	hasRequiredTypes = 1;
	Object.defineProperty(types, "__esModule", { value: true });
	types.concat = types.evalOptionsToFlags = types.DefaultIntrinsics = void 0;
	const types_ffi_1 = /*@__PURE__*/ requireTypesFfi();
	types.DefaultIntrinsics = Symbol("DefaultIntrinsics");
	function evalOptionsToFlags(evalOptions) {
	    if (typeof evalOptions === "number") {
	        return evalOptions;
	    }
	    if (evalOptions === undefined) {
	        return 0;
	    }
	    const { type, strict, strip, compileOnly, backtraceBarrier } = evalOptions;
	    let flags = 0;
	    if (type === "global")
	        flags |= types_ffi_1.EvalFlags.JS_EVAL_TYPE_GLOBAL;
	    if (type === "module")
	        flags |= types_ffi_1.EvalFlags.JS_EVAL_TYPE_MODULE;
	    if (strict)
	        flags |= types_ffi_1.EvalFlags.JS_EVAL_FLAG_STRICT;
	    if (strip)
	        flags |= types_ffi_1.EvalFlags.JS_EVAL_FLAG_STRIP;
	    if (compileOnly)
	        flags |= types_ffi_1.EvalFlags.JS_EVAL_FLAG_COMPILE_ONLY;
	    if (backtraceBarrier)
	        flags |= types_ffi_1.EvalFlags.JS_EVAL_FLAG_BACKTRACE_BARRIER;
	    return flags;
	}
	types.evalOptionsToFlags = evalOptionsToFlags;
	function concat(...values) {
	    let result = [];
	    for (const value of values) {
	        if (value !== undefined) {
	            result = result.concat(value);
	        }
	    }
	    return result;
	}
	types.concat = concat;
	return types;
}

var hasRequiredContext;

function requireContext () {
	if (hasRequiredContext) return context;
	hasRequiredContext = 1;
	Object.defineProperty(context, "__esModule", { value: true });
	context.QuickJSContext = void 0;
	const debug_1 = /*@__PURE__*/ requireDebug();
	const deferred_promise_1 = /*@__PURE__*/ requireDeferredPromise();
	const errors_1 = /*@__PURE__*/ requireErrors();
	const lifetime_1 = /*@__PURE__*/ requireLifetime();
	const memory_1 = /*@__PURE__*/ requireMemory();
	const types_1 = /*@__PURE__*/ requireTypes();
	class ContextMemory extends memory_1.ModuleMemory {
	    constructor(args) {
	        super(args.module);
	        this.scope = new lifetime_1.Scope();
	        this.copyJSValue = (ptr) => {
	            return this.ffi.QTS_DupValuePointer(this.ctx.value, ptr);
	        };
	        this.freeJSValue = (ptr) => {
	            this.ffi.QTS_FreeValuePointer(this.ctx.value, ptr);
	        };
	        args.ownedLifetimes?.forEach((lifetime) => this.scope.manage(lifetime));
	        this.owner = args.owner;
	        this.module = args.module;
	        this.ffi = args.ffi;
	        this.rt = args.rt;
	        this.ctx = this.scope.manage(args.ctx);
	    }
	    get alive() {
	        return this.scope.alive;
	    }
	    dispose() {
	        return this.scope.dispose();
	    }
	    manage(lifetime) {
	        return this.scope.manage(lifetime);
	    }
	    consumeJSCharPointer(ptr) {
	        const str = this.module.UTF8ToString(ptr);
	        this.ffi.QTS_FreeCString(this.ctx.value, ptr);
	        return str;
	    }
	    heapValueHandle(ptr) {
	        return new lifetime_1.Lifetime(ptr, this.copyJSValue, this.freeJSValue, this.owner);
	    }
	}
	class QuickJSContext {
	    constructor(args) {
	        this._undefined = undefined;
	        this._null = undefined;
	        this._false = undefined;
	        this._true = undefined;
	        this._global = undefined;
	        this._BigInt = undefined;
	        this.fnNextId = -32768;
	        this.fnMaps = new Map();
	        this.cToHostCallbacks = {
	            callFunction: (ctx, this_ptr, argc, argv, fn_id) => {
	                if (ctx !== this.ctx.value) {
	                    throw new Error("QuickJSContext instance received C -> JS call with mismatched ctx");
	                }
	                const fn = this.getFunction(fn_id);
	                if (!fn) {
	                    throw new Error(`QuickJSContext had no callback with id ${fn_id}`);
	                }
	                return lifetime_1.Scope.withScopeMaybeAsync(this, function* (awaited, scope) {
	                    const thisHandle = scope.manage(new lifetime_1.WeakLifetime(this_ptr, this.memory.copyJSValue, this.memory.freeJSValue, this.runtime));
	                    const argHandles = new Array(argc);
	                    for (let i = 0; i < argc; i++) {
	                        const ptr = this.ffi.QTS_ArgvGetJSValueConstPointer(argv, i);
	                        argHandles[i] = scope.manage(new lifetime_1.WeakLifetime(ptr, this.memory.copyJSValue, this.memory.freeJSValue, this.runtime));
	                    }
	                    try {
	                        const result = yield* awaited(fn.apply(thisHandle, argHandles));
	                        if (result) {
	                            if ("error" in result && result.error) {
	                                (0, debug_1.debugLog)("throw error", result.error);
	                                throw result.error;
	                            }
	                            const handle = scope.manage(result instanceof lifetime_1.Lifetime ? result : result.value);
	                            return this.ffi.QTS_DupValuePointer(this.ctx.value, handle.value);
	                        }
	                        return 0;
	                    }
	                    catch (error) {
	                        return this.errorToHandle(error).consume((errorHandle) => this.ffi.QTS_Throw(this.ctx.value, errorHandle.value));
	                    }
	                });
	            },
	        };
	        this.runtime = args.runtime;
	        this.module = args.module;
	        this.ffi = args.ffi;
	        this.rt = args.rt;
	        this.ctx = args.ctx;
	        this.memory = new ContextMemory({
	            ...args,
	            owner: this.runtime,
	        });
	        args.callbacks.setContextCallbacks(this.ctx.value, this.cToHostCallbacks);
	        this.dump = this.dump.bind(this);
	        this.getString = this.getString.bind(this);
	        this.getNumber = this.getNumber.bind(this);
	        this.resolvePromise = this.resolvePromise.bind(this);
	    }
	    get alive() {
	        return this.memory.alive;
	    }
	    dispose() {
	        this.memory.dispose();
	    }
	    get undefined() {
	        if (this._undefined) {
	            return this._undefined;
	        }
	        const ptr = this.ffi.QTS_GetUndefined();
	        return (this._undefined = new lifetime_1.StaticLifetime(ptr));
	    }
	    get null() {
	        if (this._null) {
	            return this._null;
	        }
	        const ptr = this.ffi.QTS_GetNull();
	        return (this._null = new lifetime_1.StaticLifetime(ptr));
	    }
	    get true() {
	        if (this._true) {
	            return this._true;
	        }
	        const ptr = this.ffi.QTS_GetTrue();
	        return (this._true = new lifetime_1.StaticLifetime(ptr));
	    }
	    get false() {
	        if (this._false) {
	            return this._false;
	        }
	        const ptr = this.ffi.QTS_GetFalse();
	        return (this._false = new lifetime_1.StaticLifetime(ptr));
	    }
	    get global() {
	        if (this._global) {
	            return this._global;
	        }
	        const ptr = this.ffi.QTS_GetGlobalObject(this.ctx.value);
	        this.memory.manage(this.memory.heapValueHandle(ptr));
	        this._global = new lifetime_1.StaticLifetime(ptr, this.runtime);
	        return this._global;
	    }
	    newNumber(num) {
	        return this.memory.heapValueHandle(this.ffi.QTS_NewFloat64(this.ctx.value, num));
	    }
	    newString(str) {
	        const ptr = this.memory
	            .newHeapCharPointer(str)
	            .consume((charHandle) => this.ffi.QTS_NewString(this.ctx.value, charHandle.value));
	        return this.memory.heapValueHandle(ptr);
	    }
	    newUniqueSymbol(description) {
	        const key = (typeof description === "symbol" ? description.description : description) ?? "";
	        const ptr = this.memory
	            .newHeapCharPointer(key)
	            .consume((charHandle) => this.ffi.QTS_NewSymbol(this.ctx.value, charHandle.value, 0));
	        return this.memory.heapValueHandle(ptr);
	    }
	    newSymbolFor(key) {
	        const description = (typeof key === "symbol" ? key.description : key) ?? "";
	        const ptr = this.memory
	            .newHeapCharPointer(description)
	            .consume((charHandle) => this.ffi.QTS_NewSymbol(this.ctx.value, charHandle.value, 1));
	        return this.memory.heapValueHandle(ptr);
	    }
	    newBigInt(num) {
	        if (!this._BigInt) {
	            const bigIntHandle = this.getProp(this.global, "BigInt");
	            this.memory.manage(bigIntHandle);
	            this._BigInt = new lifetime_1.StaticLifetime(bigIntHandle.value, this.runtime);
	        }
	        const bigIntHandle = this._BigInt;
	        const asString = String(num);
	        return this.newString(asString).consume((handle) => this.unwrapResult(this.callFunction(bigIntHandle, this.undefined, handle)));
	    }
	    newObject(prototype) {
	        if (prototype) {
	            this.runtime.assertOwned(prototype);
	        }
	        const ptr = prototype
	            ? this.ffi.QTS_NewObjectProto(this.ctx.value, prototype.value)
	            : this.ffi.QTS_NewObject(this.ctx.value);
	        return this.memory.heapValueHandle(ptr);
	    }
	    newArray() {
	        const ptr = this.ffi.QTS_NewArray(this.ctx.value);
	        return this.memory.heapValueHandle(ptr);
	    }
	    newPromise(value) {
	        const deferredPromise = lifetime_1.Scope.withScope((scope) => {
	            const mutablePointerArray = scope.manage(this.memory.newMutablePointerArray(2));
	            const promisePtr = this.ffi.QTS_NewPromiseCapability(this.ctx.value, mutablePointerArray.value.ptr);
	            const promiseHandle = this.memory.heapValueHandle(promisePtr);
	            const [resolveHandle, rejectHandle] = Array.from(mutablePointerArray.value.typedArray).map((jsvaluePtr) => this.memory.heapValueHandle(jsvaluePtr));
	            return new deferred_promise_1.QuickJSDeferredPromise({
	                context: this,
	                promiseHandle,
	                resolveHandle,
	                rejectHandle,
	            });
	        });
	        if (value && typeof value === "function") {
	            value = new Promise(value);
	        }
	        if (value) {
	            Promise.resolve(value).then(deferredPromise.resolve, (error) => error instanceof lifetime_1.Lifetime
	                ? deferredPromise.reject(error)
	                : this.newError(error).consume(deferredPromise.reject));
	        }
	        return deferredPromise;
	    }
	    newFunction(name, fn) {
	        const fnId = ++this.fnNextId;
	        this.setFunction(fnId, fn);
	        return this.memory.heapValueHandle(this.ffi.QTS_NewFunction(this.ctx.value, fnId, name));
	    }
	    newError(error) {
	        const errorHandle = this.memory.heapValueHandle(this.ffi.QTS_NewError(this.ctx.value));
	        if (error && typeof error === "object") {
	            if (error.name !== undefined) {
	                this.newString(error.name).consume((handle) => this.setProp(errorHandle, "name", handle));
	            }
	            if (error.message !== undefined) {
	                this.newString(error.message).consume((handle) => this.setProp(errorHandle, "message", handle));
	            }
	        }
	        else if (typeof error === "string") {
	            this.newString(error).consume((handle) => this.setProp(errorHandle, "message", handle));
	        }
	        else if (error !== undefined) {
	            this.newString(String(error)).consume((handle) => this.setProp(errorHandle, "message", handle));
	        }
	        return errorHandle;
	    }
	    typeof(handle) {
	        this.runtime.assertOwned(handle);
	        return this.memory.consumeHeapCharPointer(this.ffi.QTS_Typeof(this.ctx.value, handle.value));
	    }
	    getNumber(handle) {
	        this.runtime.assertOwned(handle);
	        return this.ffi.QTS_GetFloat64(this.ctx.value, handle.value);
	    }
	    getString(handle) {
	        this.runtime.assertOwned(handle);
	        return this.memory.consumeJSCharPointer(this.ffi.QTS_GetString(this.ctx.value, handle.value));
	    }
	    getSymbol(handle) {
	        this.runtime.assertOwned(handle);
	        const key = this.memory.consumeJSCharPointer(this.ffi.QTS_GetSymbolDescriptionOrKey(this.ctx.value, handle.value));
	        const isGlobal = this.ffi.QTS_IsGlobalSymbol(this.ctx.value, handle.value);
	        return isGlobal ? Symbol.for(key) : Symbol(key);
	    }
	    getBigInt(handle) {
	        this.runtime.assertOwned(handle);
	        const asString = this.getString(handle);
	        return BigInt(asString);
	    }
	    resolvePromise(promiseLikeHandle) {
	        this.runtime.assertOwned(promiseLikeHandle);
	        const vmResolveResult = lifetime_1.Scope.withScope((scope) => {
	            const vmPromise = scope.manage(this.getProp(this.global, "Promise"));
	            const vmPromiseResolve = scope.manage(this.getProp(vmPromise, "resolve"));
	            return this.callFunction(vmPromiseResolve, vmPromise, promiseLikeHandle);
	        });
	        if (vmResolveResult.error) {
	            return Promise.resolve(vmResolveResult);
	        }
	        return new Promise((resolve) => {
	            lifetime_1.Scope.withScope((scope) => {
	                const resolveHandle = scope.manage(this.newFunction("resolve", (value) => {
	                    resolve({ value: value && value.dup() });
	                }));
	                const rejectHandle = scope.manage(this.newFunction("reject", (error) => {
	                    resolve({ error: error && error.dup() });
	                }));
	                const promiseHandle = scope.manage(vmResolveResult.value);
	                const promiseThenHandle = scope.manage(this.getProp(promiseHandle, "then"));
	                this.unwrapResult(this.callFunction(promiseThenHandle, promiseHandle, resolveHandle, rejectHandle)).dispose();
	            });
	        });
	    }
	    getProp(handle, key) {
	        this.runtime.assertOwned(handle);
	        const ptr = this.borrowPropertyKey(key).consume((quickJSKey) => this.ffi.QTS_GetProp(this.ctx.value, handle.value, quickJSKey.value));
	        const result = this.memory.heapValueHandle(ptr);
	        return result;
	    }
	    setProp(handle, key, value) {
	        this.runtime.assertOwned(handle);
	        this.borrowPropertyKey(key).consume((quickJSKey) => this.ffi.QTS_SetProp(this.ctx.value, handle.value, quickJSKey.value, value.value));
	    }
	    defineProp(handle, key, descriptor) {
	        this.runtime.assertOwned(handle);
	        lifetime_1.Scope.withScope((scope) => {
	            const quickJSKey = scope.manage(this.borrowPropertyKey(key));
	            const value = descriptor.value || this.undefined;
	            const configurable = Boolean(descriptor.configurable);
	            const enumerable = Boolean(descriptor.enumerable);
	            const hasValue = Boolean(descriptor.value);
	            const get = descriptor.get
	                ? scope.manage(this.newFunction(descriptor.get.name, descriptor.get))
	                : this.undefined;
	            const set = descriptor.set
	                ? scope.manage(this.newFunction(descriptor.set.name, descriptor.set))
	                : this.undefined;
	            this.ffi.QTS_DefineProp(this.ctx.value, handle.value, quickJSKey.value, value.value, get.value, set.value, configurable, enumerable, hasValue);
	        });
	    }
	    callFunction(func, thisVal, ...args) {
	        this.runtime.assertOwned(func);
	        const resultPtr = this.memory
	            .toPointerArray(args)
	            .consume((argsArrayPtr) => this.ffi.QTS_Call(this.ctx.value, func.value, thisVal.value, args.length, argsArrayPtr.value));
	        const errorPtr = this.ffi.QTS_ResolveException(this.ctx.value, resultPtr);
	        if (errorPtr) {
	            this.ffi.QTS_FreeValuePointer(this.ctx.value, resultPtr);
	            return { error: this.memory.heapValueHandle(errorPtr) };
	        }
	        return { value: this.memory.heapValueHandle(resultPtr) };
	    }
	    evalCode(code, filename = "eval.js",
	    options) {
	        const detectModule = (options === undefined ? 1 : 0);
	        const flags = (0, types_1.evalOptionsToFlags)(options);
	        const resultPtr = this.memory
	            .newHeapCharPointer(code)
	            .consume((charHandle) => this.ffi.QTS_Eval(this.ctx.value, charHandle.value, filename, detectModule, flags));
	        const errorPtr = this.ffi.QTS_ResolveException(this.ctx.value, resultPtr);
	        if (errorPtr) {
	            this.ffi.QTS_FreeValuePointer(this.ctx.value, resultPtr);
	            return { error: this.memory.heapValueHandle(errorPtr) };
	        }
	        return { value: this.memory.heapValueHandle(resultPtr) };
	    }
	    throw(error) {
	        return this.errorToHandle(error).consume((handle) => this.ffi.QTS_Throw(this.ctx.value, handle.value));
	    }
	    borrowPropertyKey(key) {
	        if (typeof key === "number") {
	            return this.newNumber(key);
	        }
	        if (typeof key === "string") {
	            return this.newString(key);
	        }
	        return new lifetime_1.StaticLifetime(key.value, this.runtime);
	    }
	    getMemory(rt) {
	        if (rt === this.rt.value) {
	            return this.memory;
	        }
	        else {
	            throw new Error("Private API. Cannot get memory from a different runtime");
	        }
	    }
	    dump(handle) {
	        this.runtime.assertOwned(handle);
	        const type = this.typeof(handle);
	        if (type === "string") {
	            return this.getString(handle);
	        }
	        else if (type === "number") {
	            return this.getNumber(handle);
	        }
	        else if (type === "bigint") {
	            return this.getBigInt(handle);
	        }
	        else if (type === "undefined") {
	            return undefined;
	        }
	        else if (type === "symbol") {
	            return this.getSymbol(handle);
	        }
	        const str = this.memory.consumeJSCharPointer(this.ffi.QTS_Dump(this.ctx.value, handle.value));
	        try {
	            return JSON.parse(str);
	        }
	        catch (err) {
	            return str;
	        }
	    }
	    unwrapResult(result) {
	        if (result.error) {
	            const context = "context" in result.error ? result.error.context : this;
	            const cause = result.error.consume((error) => this.dump(error));
	            if (cause && typeof cause === "object" && typeof cause.message === "string") {
	                const { message, name, stack } = cause;
	                const exception = new errors_1.QuickJSUnwrapError("");
	                const hostStack = exception.stack;
	                if (typeof name === "string") {
	                    exception.name = cause.name;
	                }
	                if (typeof stack === "string") {
	                    exception.stack = `${name}: ${message}\n${cause.stack}Host: ${hostStack}`;
	                }
	                Object.assign(exception, { cause, context, message });
	                throw exception;
	            }
	            throw new errors_1.QuickJSUnwrapError(cause, context);
	        }
	        return result.value;
	    }
	    getFunction(fn_id) {
	        const map_id = fn_id >> 8;
	        const fnMap = this.fnMaps.get(map_id);
	        if (!fnMap) {
	            return undefined;
	        }
	        return fnMap.get(fn_id);
	    }
	    setFunction(fn_id, handle) {
	        const map_id = fn_id >> 8;
	        let fnMap = this.fnMaps.get(map_id);
	        if (!fnMap) {
	            fnMap = new Map();
	            this.fnMaps.set(map_id, fnMap);
	        }
	        return fnMap.set(fn_id, handle);
	    }
	    errorToHandle(error) {
	        if (error instanceof lifetime_1.Lifetime) {
	            return error;
	        }
	        return this.newError(error);
	    }
	}
	context.QuickJSContext = QuickJSContext;
	return context;
}

var hasRequiredRuntime;

function requireRuntime () {
	if (hasRequiredRuntime) return runtime;
	hasRequiredRuntime = 1;
	Object.defineProperty(runtime, "__esModule", { value: true });
	runtime.QuickJSRuntime = void 0;
	const asyncify_helpers_1 = /*@__PURE__*/ requireAsyncifyHelpers();
	const context_1 = /*@__PURE__*/ requireContext();
	const debug_1 = /*@__PURE__*/ requireDebug();
	const errors_1 = /*@__PURE__*/ requireErrors();
	const lifetime_1 = /*@__PURE__*/ requireLifetime();
	const memory_1 = /*@__PURE__*/ requireMemory();
	const types_1 = /*@__PURE__*/ requireTypes();
	class QuickJSRuntime {
	    constructor(args) {
	        this.scope = new lifetime_1.Scope();
	        this.contextMap = new Map();
	        this.cToHostCallbacks = {
	            shouldInterrupt: (rt) => {
	                if (rt !== this.rt.value) {
	                    throw new Error("QuickJSContext instance received C -> JS interrupt with mismatched rt");
	                }
	                const fn = this.interruptHandler;
	                if (!fn) {
	                    throw new Error("QuickJSContext had no interrupt handler");
	                }
	                return fn(this) ? 1 : 0;
	            },
	            loadModuleSource: (0, asyncify_helpers_1.maybeAsyncFn)(this, function* (awaited, rt, ctx, moduleName) {
	                const moduleLoader = this.moduleLoader;
	                if (!moduleLoader) {
	                    throw new Error("Runtime has no module loader");
	                }
	                if (rt !== this.rt.value) {
	                    throw new Error("Runtime pointer mismatch");
	                }
	                const context = this.contextMap.get(ctx) ??
	                    this.newContext({
	                        contextPointer: ctx,
	                    });
	                try {
	                    const result = yield* awaited(moduleLoader(moduleName, context));
	                    if (typeof result === "object" && "error" in result && result.error) {
	                        (0, debug_1.debugLog)("cToHostLoadModule: loader returned error", result.error);
	                        throw result.error;
	                    }
	                    const moduleSource = typeof result === "string" ? result : "value" in result ? result.value : result;
	                    return this.memory.newHeapCharPointer(moduleSource).value;
	                }
	                catch (error) {
	                    (0, debug_1.debugLog)("cToHostLoadModule: caught error", error);
	                    context.throw(error);
	                    return 0;
	                }
	            }),
	            normalizeModule: (0, asyncify_helpers_1.maybeAsyncFn)(this, function* (awaited, rt, ctx, baseModuleName, moduleNameRequest) {
	                const moduleNormalizer = this.moduleNormalizer;
	                if (!moduleNormalizer) {
	                    throw new Error("Runtime has no module normalizer");
	                }
	                if (rt !== this.rt.value) {
	                    throw new Error("Runtime pointer mismatch");
	                }
	                const context = this.contextMap.get(ctx) ??
	                    this.newContext({
	                        contextPointer: ctx,
	                    });
	                try {
	                    const result = yield* awaited(moduleNormalizer(baseModuleName, moduleNameRequest, context));
	                    if (typeof result === "object" && "error" in result && result.error) {
	                        (0, debug_1.debugLog)("cToHostNormalizeModule: normalizer returned error", result.error);
	                        throw result.error;
	                    }
	                    const name = typeof result === "string" ? result : result.value;
	                    return context.getMemory(this.rt.value).newHeapCharPointer(name).value;
	                }
	                catch (error) {
	                    (0, debug_1.debugLog)("normalizeModule: caught error", error);
	                    context.throw(error);
	                    return 0;
	                }
	            }),
	        };
	        args.ownedLifetimes?.forEach((lifetime) => this.scope.manage(lifetime));
	        this.module = args.module;
	        this.memory = new memory_1.ModuleMemory(this.module);
	        this.ffi = args.ffi;
	        this.rt = args.rt;
	        this.callbacks = args.callbacks;
	        this.scope.manage(this.rt);
	        this.callbacks.setRuntimeCallbacks(this.rt.value, this.cToHostCallbacks);
	        this.executePendingJobs = this.executePendingJobs.bind(this);
	    }
	    get alive() {
	        return this.scope.alive;
	    }
	    dispose() {
	        return this.scope.dispose();
	    }
	    newContext(options = {}) {
	        if (options.intrinsics && options.intrinsics !== types_1.DefaultIntrinsics) {
	            throw new Error("TODO: Custom intrinsics are not supported yet");
	        }
	        const ctx = new lifetime_1.Lifetime(options.contextPointer || this.ffi.QTS_NewContext(this.rt.value), undefined, (ctx_ptr) => {
	            this.contextMap.delete(ctx_ptr);
	            this.callbacks.deleteContext(ctx_ptr);
	            this.ffi.QTS_FreeContext(ctx_ptr);
	        });
	        const context = new context_1.QuickJSContext({
	            module: this.module,
	            ctx,
	            ffi: this.ffi,
	            rt: this.rt,
	            ownedLifetimes: options.ownedLifetimes,
	            runtime: this,
	            callbacks: this.callbacks,
	        });
	        this.contextMap.set(ctx.value, context);
	        return context;
	    }
	    setModuleLoader(moduleLoader, moduleNormalizer) {
	        this.moduleLoader = moduleLoader;
	        this.moduleNormalizer = moduleNormalizer;
	        this.ffi.QTS_RuntimeEnableModuleLoader(this.rt.value, this.moduleNormalizer ? 1 : 0);
	    }
	    removeModuleLoader() {
	        this.moduleLoader = undefined;
	        this.ffi.QTS_RuntimeDisableModuleLoader(this.rt.value);
	    }
	    hasPendingJob() {
	        return Boolean(this.ffi.QTS_IsJobPending(this.rt.value));
	    }
	    setInterruptHandler(cb) {
	        const prevInterruptHandler = this.interruptHandler;
	        this.interruptHandler = cb;
	        if (!prevInterruptHandler) {
	            this.ffi.QTS_RuntimeEnableInterruptHandler(this.rt.value);
	        }
	    }
	    removeInterruptHandler() {
	        if (this.interruptHandler) {
	            this.ffi.QTS_RuntimeDisableInterruptHandler(this.rt.value);
	            this.interruptHandler = undefined;
	        }
	    }
	    executePendingJobs(maxJobsToExecute = -1) {
	        const ctxPtrOut = this.memory.newMutablePointerArray(1);
	        const valuePtr = this.ffi.QTS_ExecutePendingJob(this.rt.value, maxJobsToExecute ?? -1, ctxPtrOut.value.ptr);
	        const ctxPtr = ctxPtrOut.value.typedArray[0];
	        ctxPtrOut.dispose();
	        if (ctxPtr === 0) {
	            this.ffi.QTS_FreeValuePointerRuntime(this.rt.value, valuePtr);
	            return { value: 0 };
	        }
	        const context = this.contextMap.get(ctxPtr) ??
	            this.newContext({
	                contextPointer: ctxPtr,
	            });
	        const resultValue = context.getMemory(this.rt.value).heapValueHandle(valuePtr);
	        const typeOfRet = context.typeof(resultValue);
	        if (typeOfRet === "number") {
	            const executedJobs = context.getNumber(resultValue);
	            resultValue.dispose();
	            return { value: executedJobs };
	        }
	        else {
	            const error = Object.assign(resultValue, { context });
	            return {
	                error,
	            };
	        }
	    }
	    setMemoryLimit(limitBytes) {
	        if (limitBytes < 0 && limitBytes !== -1) {
	            throw new Error("Cannot set memory limit to negative number. To unset, pass -1");
	        }
	        this.ffi.QTS_RuntimeSetMemoryLimit(this.rt.value, limitBytes);
	    }
	    computeMemoryUsage() {
	        const serviceContextMemory = this.getSystemContext().getMemory(this.rt.value);
	        return serviceContextMemory.heapValueHandle(this.ffi.QTS_RuntimeComputeMemoryUsage(this.rt.value, serviceContextMemory.ctx.value));
	    }
	    dumpMemoryUsage() {
	        return this.memory.consumeHeapCharPointer(this.ffi.QTS_RuntimeDumpMemoryUsage(this.rt.value));
	    }
	    setMaxStackSize(stackSize) {
	        if (stackSize < 0) {
	            throw new Error("Cannot set memory limit to negative number. To unset, pass 0.");
	        }
	        this.ffi.QTS_RuntimeSetMaxStackSize(this.rt.value, stackSize);
	    }
	    assertOwned(handle) {
	        if (handle.owner && handle.owner.rt !== this.rt) {
	            throw new errors_1.QuickJSWrongOwner(`Handle is not owned by this runtime: ${handle.owner.rt.value} != ${this.rt.value}`);
	        }
	    }
	    getSystemContext() {
	        if (!this.context) {
	            this.context = this.scope.manage(this.newContext());
	        }
	        return this.context;
	    }
	}
	runtime.QuickJSRuntime = QuickJSRuntime;
	return runtime;
}

var hasRequiredModule;

function requireModule () {
	if (hasRequiredModule) return module;
	hasRequiredModule = 1;
	Object.defineProperty(module, "__esModule", { value: true });
	module.QuickJSWASMModule = module.applyModuleEvalRuntimeOptions = module.applyBaseRuntimeOptions = module.QuickJSModuleCallbacks = void 0;
	const debug_1 = /*@__PURE__*/ requireDebug();
	const errors_1 = /*@__PURE__*/ requireErrors();
	const lifetime_1 = /*@__PURE__*/ requireLifetime();
	const runtime_1 = /*@__PURE__*/ requireRuntime();
	const types_1 = /*@__PURE__*/ requireTypes();
	class QuickJSEmscriptenModuleCallbacks {
	    constructor(args) {
	        this.callFunction = args.callFunction;
	        this.shouldInterrupt = args.shouldInterrupt;
	        this.loadModuleSource = args.loadModuleSource;
	        this.normalizeModule = args.normalizeModule;
	    }
	}
	class QuickJSModuleCallbacks {
	    constructor(module) {
	        this.contextCallbacks = new Map();
	        this.runtimeCallbacks = new Map();
	        this.suspendedCount = 0;
	        this.cToHostCallbacks = new QuickJSEmscriptenModuleCallbacks({
	            callFunction: (asyncify, ctx, this_ptr, argc, argv, fn_id) => this.handleAsyncify(asyncify, () => {
	                try {
	                    const vm = this.contextCallbacks.get(ctx);
	                    if (!vm) {
	                        throw new Error(`QuickJSContext(ctx = ${ctx}) not found for C function call "${fn_id}"`);
	                    }
	                    return vm.callFunction(ctx, this_ptr, argc, argv, fn_id);
	                }
	                catch (error) {
	                    console.error("[C to host error: returning null]", error);
	                    return 0;
	                }
	            }),
	            shouldInterrupt: (asyncify, rt) => this.handleAsyncify(asyncify, () => {
	                try {
	                    const vm = this.runtimeCallbacks.get(rt);
	                    if (!vm) {
	                        throw new Error(`QuickJSRuntime(rt = ${rt}) not found for C interrupt`);
	                    }
	                    return vm.shouldInterrupt(rt);
	                }
	                catch (error) {
	                    console.error("[C to host interrupt: returning error]", error);
	                    return 1;
	                }
	            }),
	            loadModuleSource: (asyncify, rt, ctx, moduleName) => this.handleAsyncify(asyncify, () => {
	                try {
	                    const runtimeCallbacks = this.runtimeCallbacks.get(rt);
	                    if (!runtimeCallbacks) {
	                        throw new Error(`QuickJSRuntime(rt = ${rt}) not found for C module loader`);
	                    }
	                    const loadModule = runtimeCallbacks.loadModuleSource;
	                    if (!loadModule) {
	                        throw new Error(`QuickJSRuntime(rt = ${rt}) does not support module loading`);
	                    }
	                    return loadModule(rt, ctx, moduleName);
	                }
	                catch (error) {
	                    console.error("[C to host module loader error: returning null]", error);
	                    return 0;
	                }
	            }),
	            normalizeModule: (asyncify, rt, ctx, moduleBaseName, moduleName) => this.handleAsyncify(asyncify, () => {
	                try {
	                    const runtimeCallbacks = this.runtimeCallbacks.get(rt);
	                    if (!runtimeCallbacks) {
	                        throw new Error(`QuickJSRuntime(rt = ${rt}) not found for C module loader`);
	                    }
	                    const normalizeModule = runtimeCallbacks.normalizeModule;
	                    if (!normalizeModule) {
	                        throw new Error(`QuickJSRuntime(rt = ${rt}) does not support module loading`);
	                    }
	                    return normalizeModule(rt, ctx, moduleBaseName, moduleName);
	                }
	                catch (error) {
	                    console.error("[C to host module loader error: returning null]", error);
	                    return 0;
	                }
	            }),
	        });
	        this.module = module;
	        this.module.callbacks = this.cToHostCallbacks;
	    }
	    setRuntimeCallbacks(rt, callbacks) {
	        this.runtimeCallbacks.set(rt, callbacks);
	    }
	    deleteRuntime(rt) {
	        this.runtimeCallbacks.delete(rt);
	    }
	    setContextCallbacks(ctx, callbacks) {
	        this.contextCallbacks.set(ctx, callbacks);
	    }
	    deleteContext(ctx) {
	        this.contextCallbacks.delete(ctx);
	    }
	    handleAsyncify(asyncify, fn) {
	        if (asyncify) {
	            return asyncify.handleSleep((done) => {
	                try {
	                    const result = fn();
	                    if (!(result instanceof Promise)) {
	                        (0, debug_1.debugLog)("asyncify.handleSleep: not suspending:", result);
	                        done(result);
	                        return;
	                    }
	                    if (this.suspended) {
	                        throw new errors_1.QuickJSAsyncifyError(`Already suspended at: ${this.suspended.stack}\nAttempted to suspend at:`);
	                    }
	                    else {
	                        this.suspended = new errors_1.QuickJSAsyncifySuspended(`(${this.suspendedCount++})`);
	                        (0, debug_1.debugLog)("asyncify.handleSleep: suspending:", this.suspended);
	                    }
	                    result.then((resolvedResult) => {
	                        this.suspended = undefined;
	                        (0, debug_1.debugLog)("asyncify.handleSleep: resolved:", resolvedResult);
	                        done(resolvedResult);
	                    }, (error) => {
	                        (0, debug_1.debugLog)("asyncify.handleSleep: rejected:", error);
	                        console.error("QuickJS: cannot handle error in suspended function", error);
	                        this.suspended = undefined;
	                    });
	                }
	                catch (error) {
	                    (0, debug_1.debugLog)("asyncify.handleSleep: error:", error);
	                    this.suspended = undefined;
	                    throw error;
	                }
	            });
	        }
	        const value = fn();
	        if (value instanceof Promise) {
	            throw new Error("Promise return value not supported in non-asyncify context.");
	        }
	        return value;
	    }
	}
	module.QuickJSModuleCallbacks = QuickJSModuleCallbacks;
	function applyBaseRuntimeOptions(runtime, options) {
	    if (options.interruptHandler) {
	        runtime.setInterruptHandler(options.interruptHandler);
	    }
	    if (options.maxStackSizeBytes !== undefined) {
	        runtime.setMaxStackSize(options.maxStackSizeBytes);
	    }
	    if (options.memoryLimitBytes !== undefined) {
	        runtime.setMemoryLimit(options.memoryLimitBytes);
	    }
	}
	module.applyBaseRuntimeOptions = applyBaseRuntimeOptions;
	function applyModuleEvalRuntimeOptions(runtime, options) {
	    if (options.moduleLoader) {
	        runtime.setModuleLoader(options.moduleLoader);
	    }
	    if (options.shouldInterrupt) {
	        runtime.setInterruptHandler(options.shouldInterrupt);
	    }
	    if (options.memoryLimitBytes !== undefined) {
	        runtime.setMemoryLimit(options.memoryLimitBytes);
	    }
	    if (options.maxStackSizeBytes !== undefined) {
	        runtime.setMaxStackSize(options.maxStackSizeBytes);
	    }
	}
	module.applyModuleEvalRuntimeOptions = applyModuleEvalRuntimeOptions;
	class QuickJSWASMModule {
	    constructor(module, ffi) {
	        this.module = module;
	        this.ffi = ffi;
	        this.callbacks = new QuickJSModuleCallbacks(module);
	    }
	    newRuntime(options = {}) {
	        const rt = new lifetime_1.Lifetime(this.ffi.QTS_NewRuntime(), undefined, (rt_ptr) => {
	            this.callbacks.deleteRuntime(rt_ptr);
	            this.ffi.QTS_FreeRuntime(rt_ptr);
	        });
	        const runtime = new runtime_1.QuickJSRuntime({
	            module: this.module,
	            callbacks: this.callbacks,
	            ffi: this.ffi,
	            rt,
	        });
	        applyBaseRuntimeOptions(runtime, options);
	        if (options.moduleLoader) {
	            runtime.setModuleLoader(options.moduleLoader);
	        }
	        return runtime;
	    }
	    newContext(options = {}) {
	        const runtime = this.newRuntime();
	        const context = runtime.newContext({
	            ...options,
	            ownedLifetimes: (0, types_1.concat)(runtime, options.ownedLifetimes),
	        });
	        runtime.context = context;
	        return context;
	    }
	    evalCode(code, options = {}) {
	        return lifetime_1.Scope.withScope((scope) => {
	            const vm = scope.manage(this.newContext());
	            applyModuleEvalRuntimeOptions(vm.runtime, options);
	            const result = vm.evalCode(code, "eval.js");
	            if (options.memoryLimitBytes !== undefined) {
	                vm.runtime.setMemoryLimit(-1);
	            }
	            if (result.error) {
	                const error = vm.dump(scope.manage(result.error));
	                throw error;
	            }
	            const value = vm.dump(scope.manage(result.value));
	            return value;
	        });
	    }
	    getFFI() {
	        return this.ffi;
	    }
	}
	module.QuickJSWASMModule = QuickJSWASMModule;
	return module;
}

var moduleAsyncify = {};

var runtimeAsyncify = {};

var contextAsyncify = {};

var hasRequiredContextAsyncify;

function requireContextAsyncify () {
	if (hasRequiredContextAsyncify) return contextAsyncify;
	hasRequiredContextAsyncify = 1;
	Object.defineProperty(contextAsyncify, "__esModule", { value: true });
	contextAsyncify.QuickJSAsyncContext = void 0;
	const context_1 = /*@__PURE__*/ requireContext();
	const debug_1 = /*@__PURE__*/ requireDebug();
	const types_1 = /*@__PURE__*/ requireTypes();
	class QuickJSAsyncContext extends context_1.QuickJSContext {
	    async evalCodeAsync(code, filename = "eval.js",
	    options) {
	        const detectModule = (options === undefined ? 1 : 0);
	        const flags = (0, types_1.evalOptionsToFlags)(options);
	        let resultPtr = 0;
	        try {
	            resultPtr = await this.memory
	                .newHeapCharPointer(code)
	                .consume((charHandle) => this.ffi.QTS_Eval_MaybeAsync(this.ctx.value, charHandle.value, filename, detectModule, flags));
	        }
	        catch (error) {
	            (0, debug_1.debugLog)("QTS_Eval_MaybeAsync threw", error);
	            throw error;
	        }
	        const errorPtr = this.ffi.QTS_ResolveException(this.ctx.value, resultPtr);
	        if (errorPtr) {
	            this.ffi.QTS_FreeValuePointer(this.ctx.value, resultPtr);
	            return { error: this.memory.heapValueHandle(errorPtr) };
	        }
	        return { value: this.memory.heapValueHandle(resultPtr) };
	    }
	    newAsyncifiedFunction(name, fn) {
	        return this.newFunction(name, fn);
	    }
	}
	contextAsyncify.QuickJSAsyncContext = QuickJSAsyncContext;
	return contextAsyncify;
}

var hasRequiredRuntimeAsyncify;

function requireRuntimeAsyncify () {
	if (hasRequiredRuntimeAsyncify) return runtimeAsyncify;
	hasRequiredRuntimeAsyncify = 1;
	Object.defineProperty(runtimeAsyncify, "__esModule", { value: true });
	runtimeAsyncify.QuickJSAsyncRuntime = void 0;
	const _1 = /*@__PURE__*/ requireDist$2();
	const context_asyncify_1 = /*@__PURE__*/ requireContextAsyncify();
	const runtime_1 = /*@__PURE__*/ requireRuntime();
	const types_1 = /*@__PURE__*/ requireTypes();
	class QuickJSAsyncRuntime extends runtime_1.QuickJSRuntime {
	    constructor(args) {
	        super(args);
	    }
	    newContext(options = {}) {
	        if (options.intrinsics && options.intrinsics !== types_1.DefaultIntrinsics) {
	            throw new Error("TODO: Custom intrinsics are not supported yet");
	        }
	        const ctx = new _1.Lifetime(this.ffi.QTS_NewContext(this.rt.value), undefined, (ctx_ptr) => {
	            this.contextMap.delete(ctx_ptr);
	            this.callbacks.deleteContext(ctx_ptr);
	            this.ffi.QTS_FreeContext(ctx_ptr);
	        });
	        const context = new context_asyncify_1.QuickJSAsyncContext({
	            module: this.module,
	            ctx,
	            ffi: this.ffi,
	            rt: this.rt,
	            ownedLifetimes: [],
	            runtime: this,
	            callbacks: this.callbacks,
	        });
	        this.contextMap.set(ctx.value, context);
	        return context;
	    }
	    setModuleLoader(moduleLoader, moduleNormalizer) {
	        super.setModuleLoader(moduleLoader, moduleNormalizer);
	    }
	    setMaxStackSize(stackSize) {
	        return super.setMaxStackSize(stackSize);
	    }
	}
	runtimeAsyncify.QuickJSAsyncRuntime = QuickJSAsyncRuntime;
	return runtimeAsyncify;
}

var hasRequiredModuleAsyncify;

function requireModuleAsyncify () {
	if (hasRequiredModuleAsyncify) return moduleAsyncify;
	hasRequiredModuleAsyncify = 1;
	Object.defineProperty(moduleAsyncify, "__esModule", { value: true });
	moduleAsyncify.QuickJSAsyncWASMModule = void 0;
	const errors_1 = /*@__PURE__*/ requireErrors();
	const lifetime_1 = /*@__PURE__*/ requireLifetime();
	const module_1 = /*@__PURE__*/ requireModule();
	const runtime_asyncify_1 = /*@__PURE__*/ requireRuntimeAsyncify();
	class QuickJSAsyncWASMModule extends module_1.QuickJSWASMModule {
	    constructor(module, ffi) {
	        super(module, ffi);
	        this.ffi = ffi;
	        this.module = module;
	    }
	    newRuntime(options = {}) {
	        const rt = new lifetime_1.Lifetime(this.ffi.QTS_NewRuntime(), undefined, (rt_ptr) => {
	            this.callbacks.deleteRuntime(rt_ptr);
	            this.ffi.QTS_FreeRuntime(rt_ptr);
	        });
	        const runtime = new runtime_asyncify_1.QuickJSAsyncRuntime({
	            module: this.module,
	            ffi: this.ffi,
	            rt,
	            callbacks: this.callbacks,
	        });
	        (0, module_1.applyBaseRuntimeOptions)(runtime, options);
	        if (options.moduleLoader) {
	            runtime.setModuleLoader(options.moduleLoader);
	        }
	        return runtime;
	    }
	    newContext(options = {}) {
	        const runtime = this.newRuntime();
	        const lifetimes = options.ownedLifetimes ? options.ownedLifetimes.concat([runtime]) : [runtime];
	        const context = runtime.newContext({ ...options, ownedLifetimes: lifetimes });
	        runtime.context = context;
	        return context;
	    }
	    evalCode() {
	        throw new errors_1.QuickJSNotImplemented("QuickJSWASMModuleAsyncify.evalCode: use evalCodeAsync instead");
	    }
	    evalCodeAsync(code, options) {
	        return lifetime_1.Scope.withScopeAsync(async (scope) => {
	            const vm = scope.manage(this.newContext());
	            (0, module_1.applyModuleEvalRuntimeOptions)(vm.runtime, options);
	            const result = await vm.evalCodeAsync(code, "eval.js");
	            if (options.memoryLimitBytes !== undefined) {
	                vm.runtime.setMemoryLimit(-1);
	            }
	            if (result.error) {
	                const error = vm.dump(scope.manage(result.error));
	                throw error;
	            }
	            const value = vm.dump(scope.manage(result.value));
	            return value;
	        });
	    }
	}
	moduleAsyncify.QuickJSAsyncWASMModule = QuickJSAsyncWASMModule;
	return moduleAsyncify;
}

var ffi_WASM_RELEASE_SYNC = {};

var hasRequiredFfi_WASM_RELEASE_SYNC;

function requireFfi_WASM_RELEASE_SYNC () {
	if (hasRequiredFfi_WASM_RELEASE_SYNC) return ffi_WASM_RELEASE_SYNC;
	hasRequiredFfi_WASM_RELEASE_SYNC = 1;
	Object.defineProperty(ffi_WASM_RELEASE_SYNC, "__esModule", { value: true });
	ffi_WASM_RELEASE_SYNC.QuickJSFFI = void 0;
	class QuickJSFFI {
	    constructor(module) {
	        this.module = module;
	        this.DEBUG = false;
	        this.QTS_Throw = this.module.cwrap("QTS_Throw", "number", ["number", "number"]);
	        this.QTS_NewError = this.module.cwrap("QTS_NewError", "number", ["number"]);
	        this.QTS_RuntimeSetMemoryLimit = this.module.cwrap("QTS_RuntimeSetMemoryLimit", null, ["number", "number"]);
	        this.QTS_RuntimeComputeMemoryUsage = this.module.cwrap("QTS_RuntimeComputeMemoryUsage", "number", ["number", "number"]);
	        this.QTS_RuntimeDumpMemoryUsage = this.module.cwrap("QTS_RuntimeDumpMemoryUsage", "number", ["number"]);
	        this.QTS_RecoverableLeakCheck = this.module.cwrap("QTS_RecoverableLeakCheck", "number", []);
	        this.QTS_BuildIsSanitizeLeak = this.module.cwrap("QTS_BuildIsSanitizeLeak", "number", []);
	        this.QTS_RuntimeSetMaxStackSize = this.module.cwrap("QTS_RuntimeSetMaxStackSize", null, ["number", "number"]);
	        this.QTS_GetUndefined = this.module.cwrap("QTS_GetUndefined", "number", []);
	        this.QTS_GetNull = this.module.cwrap("QTS_GetNull", "number", []);
	        this.QTS_GetFalse = this.module.cwrap("QTS_GetFalse", "number", []);
	        this.QTS_GetTrue = this.module.cwrap("QTS_GetTrue", "number", []);
	        this.QTS_NewRuntime = this.module.cwrap("QTS_NewRuntime", "number", []);
	        this.QTS_FreeRuntime = this.module.cwrap("QTS_FreeRuntime", null, ["number"]);
	        this.QTS_NewContext = this.module.cwrap("QTS_NewContext", "number", ["number"]);
	        this.QTS_FreeContext = this.module.cwrap("QTS_FreeContext", null, ["number"]);
	        this.QTS_FreeValuePointer = this.module.cwrap("QTS_FreeValuePointer", null, ["number", "number"]);
	        this.QTS_FreeValuePointerRuntime = this.module.cwrap("QTS_FreeValuePointerRuntime", null, ["number", "number"]);
	        this.QTS_FreeVoidPointer = this.module.cwrap("QTS_FreeVoidPointer", null, ["number", "number"]);
	        this.QTS_FreeCString = this.module.cwrap("QTS_FreeCString", null, ["number", "number"]);
	        this.QTS_DupValuePointer = this.module.cwrap("QTS_DupValuePointer", "number", ["number", "number"]);
	        this.QTS_NewObject = this.module.cwrap("QTS_NewObject", "number", ["number"]);
	        this.QTS_NewObjectProto = this.module.cwrap("QTS_NewObjectProto", "number", ["number", "number"]);
	        this.QTS_NewArray = this.module.cwrap("QTS_NewArray", "number", ["number"]);
	        this.QTS_NewFloat64 = this.module.cwrap("QTS_NewFloat64", "number", ["number", "number"]);
	        this.QTS_GetFloat64 = this.module.cwrap("QTS_GetFloat64", "number", ["number", "number"]);
	        this.QTS_NewString = this.module.cwrap("QTS_NewString", "number", ["number", "number"]);
	        this.QTS_GetString = this.module.cwrap("QTS_GetString", "number", ["number", "number"]);
	        this.QTS_NewSymbol = this.module.cwrap("QTS_NewSymbol", "number", ["number", "number", "number"]);
	        this.QTS_GetSymbolDescriptionOrKey = this.module.cwrap("QTS_GetSymbolDescriptionOrKey", "number", ["number", "number"]);
	        this.QTS_IsGlobalSymbol = this.module.cwrap("QTS_IsGlobalSymbol", "number", ["number", "number"]);
	        this.QTS_IsJobPending = this.module.cwrap("QTS_IsJobPending", "number", ["number"]);
	        this.QTS_ExecutePendingJob = this.module.cwrap("QTS_ExecutePendingJob", "number", ["number", "number", "number"]);
	        this.QTS_GetProp = this.module.cwrap("QTS_GetProp", "number", ["number", "number", "number"]);
	        this.QTS_SetProp = this.module.cwrap("QTS_SetProp", null, ["number", "number", "number", "number"]);
	        this.QTS_DefineProp = this.module.cwrap("QTS_DefineProp", null, ["number", "number", "number", "number", "number", "number", "boolean", "boolean", "boolean"]);
	        this.QTS_Call = this.module.cwrap("QTS_Call", "number", ["number", "number", "number", "number", "number"]);
	        this.QTS_ResolveException = this.module.cwrap("QTS_ResolveException", "number", ["number", "number"]);
	        this.QTS_Dump = this.module.cwrap("QTS_Dump", "number", ["number", "number"]);
	        this.QTS_Eval = this.module.cwrap("QTS_Eval", "number", ["number", "number", "string", "number", "number"]);
	        this.QTS_Typeof = this.module.cwrap("QTS_Typeof", "number", ["number", "number"]);
	        this.QTS_GetGlobalObject = this.module.cwrap("QTS_GetGlobalObject", "number", ["number"]);
	        this.QTS_NewPromiseCapability = this.module.cwrap("QTS_NewPromiseCapability", "number", ["number", "number"]);
	        this.QTS_TestStringArg = this.module.cwrap("QTS_TestStringArg", null, ["string"]);
	        this.QTS_BuildIsDebug = this.module.cwrap("QTS_BuildIsDebug", "number", []);
	        this.QTS_BuildIsAsyncify = this.module.cwrap("QTS_BuildIsAsyncify", "number", []);
	        this.QTS_NewFunction = this.module.cwrap("QTS_NewFunction", "number", ["number", "number", "string"]);
	        this.QTS_ArgvGetJSValueConstPointer = this.module.cwrap("QTS_ArgvGetJSValueConstPointer", "number", ["number", "number"]);
	        this.QTS_RuntimeEnableInterruptHandler = this.module.cwrap("QTS_RuntimeEnableInterruptHandler", null, ["number"]);
	        this.QTS_RuntimeDisableInterruptHandler = this.module.cwrap("QTS_RuntimeDisableInterruptHandler", null, ["number"]);
	        this.QTS_RuntimeEnableModuleLoader = this.module.cwrap("QTS_RuntimeEnableModuleLoader", null, ["number", "number"]);
	        this.QTS_RuntimeDisableModuleLoader = this.module.cwrap("QTS_RuntimeDisableModuleLoader", null, ["number"]);
	    }
	}
	ffi_WASM_RELEASE_SYNC.QuickJSFFI = QuickJSFFI;
	return ffi_WASM_RELEASE_SYNC;
}

var emscriptenModule_WASM_RELEASE_SYNC = {exports: {}};

var hasRequiredEmscriptenModule_WASM_RELEASE_SYNC;

function requireEmscriptenModule_WASM_RELEASE_SYNC () {
	if (hasRequiredEmscriptenModule_WASM_RELEASE_SYNC) return emscriptenModule_WASM_RELEASE_SYNC.exports;
	hasRequiredEmscriptenModule_WASM_RELEASE_SYNC = 1;
	(function (module, exports) {
		var QuickJSRaw = (() => {
		    var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;
		    if (typeof __filename !== 'undefined')
		        _scriptDir = _scriptDir || __filename;
		    return (function (QuickJSRaw = {}) {
		        var a;
		        a || (a = typeof QuickJSRaw !== 'undefined' ? QuickJSRaw : {});
		        var m, n;
		        a.ready = new Promise(function (b, c) { m = b; n = c; });
		        var p = Object.assign({}, a), t = "./this.program", u = "object" == typeof window, v = "function" == typeof importScripts, w = "object" == typeof process && "object" == typeof process.versions && "string" == typeof process.versions.node, x = "", y, z, A;
		        if (w) {
		            var fs = require$$0$7, B = require$$1$4;
		            x = v ? B.dirname(x) + "/" : __dirname + "/";
		            y = (b, c) => { var d = C(b); if (d)
		                return c ? d : d.toString(); b = b.startsWith("file://") ? new URL(b) : B.normalize(b); return fs.readFileSync(b, c ? void 0 : "utf8"); };
		            A = b => { b = y(b, true); b.buffer || (b = new Uint8Array(b)); return b; };
		            z = (b, c, d) => { var e = C(b); e && c(e); b = b.startsWith("file://") ? new URL(b) : B.normalize(b); fs.readFile(b, function (f, g) { f ? d(f) : c(g.buffer); }); };
		            !a.thisProgram && 1 < process.argv.length && (t = process.argv[1].replace(/\\/g, "/"));
		            process.argv.slice(2);
		            a.inspect = function () { return "[Emscripten Module object]"; };
		        }
		        else if (u || v)
		            v ? x = self.location.href : "undefined" != typeof document && document.currentScript && (x = document.currentScript.src), _scriptDir && (x = _scriptDir), 0 !== x.indexOf("blob:") ? x = x.substr(0, x.replace(/[?#].*/, "").lastIndexOf("/") + 1) : x = "", y = b => {
		                try {
		                    var c = new XMLHttpRequest;
		                    c.open("GET", b, !1);
		                    c.send(null);
		                    return c.responseText;
		                }
		                catch (f) {
		                    if (b = C(b)) {
		                        c = [];
		                        for (var d = 0; d < b.length; d++) {
		                            var e = b[d];
		                            255 < e && (e &= 255);
		                            c.push(String.fromCharCode(e));
		                        }
		                        return c.join("");
		                    }
		                    throw f;
		                }
		            }, v && (A = b => { try {
		                var c = new XMLHttpRequest;
		                c.open("GET", b, !1);
		                c.responseType = "arraybuffer";
		                c.send(null);
		                return new Uint8Array(c.response);
		            }
		            catch (d) {
		                if (b = C(b))
		                    return b;
		                throw d;
		            } }), z = (b, c, d) => { var e = new XMLHttpRequest; e.open("GET", b, true); e.responseType = "arraybuffer"; e.onload = () => { if (200 == e.status || 0 == e.status && e.response)
		                c(e.response);
		            else {
		                var f = C(b);
		                f ? c(f.buffer) : d();
		            } }; e.onerror = d; e.send(null); };
		        var aa = a.print || console.log.bind(console), D = a.printErr || console.warn.bind(console);
		        Object.assign(a, p);
		        p = null;
		        a.thisProgram && (t = a.thisProgram);
		        var E;
		        a.wasmBinary && (E = a.wasmBinary);
		        a.noExitRuntime || true;
		        "object" != typeof WebAssembly && F("no native wasm support detected");
		        var G, H = false, I, J, K, L;
		        function M() { var b = G.buffer; a.HEAP8 = I = new Int8Array(b); a.HEAP16 = new Int16Array(b); a.HEAP32 = K = new Int32Array(b); a.HEAPU8 = J = new Uint8Array(b); a.HEAPU16 = new Uint16Array(b); a.HEAPU32 = L = new Uint32Array(b); a.HEAPF32 = new Float32Array(b); a.HEAPF64 = new Float64Array(b); }
		        var ba = [], ca = [], da = [];
		        function ea() { var b = a.preRun.shift(); ba.unshift(b); }
		        var N = 0, P = null;
		        function F(b) { if (a.onAbort)
		            a.onAbort(b); b = "Aborted(" + b + ")"; D(b); H = true; b = new WebAssembly.RuntimeError(b + ". Build with -sASSERTIONS for more info."); n(b); throw b; }
		        var Q = "data:application/octet-stream;base64,", R;
		        R = "data:application/octet-stream;base64,AGFzbQEAAAAB9QZxYAJ/fwBgA39/fwF/YAR/fn9/AX5gAn9/AX9gAX8Bf2AFf35/f38BfmADf39/AGAEf39/fwF/YAJ/fgF+YAF/AGAFf39/f38Bf2ABfAF8YAJ/fgBgAn9/AX5gAn9+AX9gA39/fgF/YAN/fn8BfmADf35/AGAGf35/f39/AX5gBn9/f39/fwF/YAR/f39/AGADf35/AX9gBn9+fn9/fwF+YAR/f35/AX9gA39+fgF+YAN/f38BfmAFf39/fn4Bf2AEf39/fgF/YAR/f35+AX9gBX9+fn5+AGABfwF+YAN/fn4Bf2AEf39/fwF+YAd/f39/f39/AX9gBX9/f39/AX5gAnx8AXxgAAF/YAV/f39/fwBgBX9+f35/AX9gBX9+fn9/AX5gAX4Bf2AEf35+fwBgB39+f35+fn8Bf2AIf39/f39/f38Bf2AFf35+fn8Bf2AGf35/fn5/AX9gBH9+f34BfmAEf35/fwBgBH9+f34AYAZ/f39/f38BfmAEf35+fwF/YAl/f39/f39/f38Bf2AEf35+fwF+YAR/fn9/AX9gA39+fgBgA35/fwF/YAV/fn5/fwBgA39/fgF+YAd/fn9/f39/AX5gAABgA39/fgBgBH9+f34Bf2AFf39+f38Bf2AEf35+fgF/YAd/f39/f39/AGACfH8BfGABfAF/YAN8fH8BfGACf38BfGAEf39+fwBgBH9+fn4BfmABfgF+YAJ/fAF/YAZ/fH9/f38Bf2AAAXxgBX9+f35/AX5gBn9/fn5+fgF/YAJ+fwBgAn98AGAEf39+fwF+YAV/f39/fgF+YAd/fn5+f39/AX5gBH5+fn4Bf2AHf39/f39/fgF+YAp/f39/f39/f39/AX9gB39/fn5/f38Bf2AFf3x/f38BfmACfn8Bf2AGfH9/f39/AGAFf35/f38AYAV/f35/fwBgBn9+fn5+fwF/YAV/f35+fwF/YAZ/fn9/f38Bf2ADf3x/AX9gBX9+f39/AX9gBX9/fn5+AX5gBX9+fn5+AX9gBn9/fn5/fwF/YAd/f39+fn5/AX9gBH9/f34BfmACfH8Bf2AGf39/f39/AGAIf39/f39/f38AYAN/fnwBfmAAAX5gAnx8AX9gAn5+AXxgAX8BfGADfn5+AX9gA39/fABgCH9+fn5+f35+AX5gCX9/f39/f39/fwACWw8B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rgitCKcIqAimCKUIpAj0B44JjQmKCYgJjAnwB/EH7gfrB+QH4gfhB9MHwQeaB/EEvAmbCZoJmQmYCZcJlgmVCZQJkwmSCZEJiwntCOwInQicCJsImgiZCKAFmAiXCJYIlQiUCJMIkQiQCI8IjgiNCIwIiwiKCIkIiAiHCIYI6QOFCOkDhAiDCIIIgQieCKEIoAifCKII2QP/B/4HkQeQB5kHmAeWB5UHlAeTB5IH4AffB94H6QPdB6AF3AfbB9oH2AerCKoIqQj/BooHiQeIB4cHhgeFB4QHgweCB4EHgAfoB4sHjweOB5sHpAehB6MHogefB54HnQecB6UH5wfmB+UH/gHsB+kH7QfvB/IH9QbPBPQG8wbyBvEGyATwBu8G9wbRBPYG9gf1B/sH+gf5B/gH/QeoCeMGpwnmBqYJpQmkCaMJ4QbfBsYEogmhCaAJsQafCZ4JnQmwBrIJsQmwCa8JrgmtCawJqwmqCbgJnQO3CbYJtQm0CbMJxgnJB8gHxQnECcMJwgnWA8EJwAn3BPgEvwm+CbsJugm5CckJyAnHCdAJzwm9BLwEzgnNCcwJywnKCbQG1AnTCdIJ0Qm4BrcGtga1BroGuQa9BrwGuwbSBtEG0AbPBs4GzQbMBssGygbJBsgGxwbGBsUGxAbDBsEGwAa/Br4G0wbcBoAJ+gj7CNsGgwmECYEJnQT+CPkI6wPMAtoG9QjxCO8I2Qb4CPQI8AiCCf8I/QiXAqcD1gnyCPwI2AbXBtYG1QbUBugG5wblBuQG4gbgBt4G3QbrBuoG6QbtBuwG7gapB6cHpgfPB4EF1weABc4HzQfMB8sHxwfGB8UHxAfDB8IHwAe/B9IH0AfWB9QHtAezB7EHsAevB64HrQesB6sHqge+B70HvAe7B7oHuQe4B7cHtge1B4cJhQmGCdgD8wgK15YXyAk1AQF/AkAgAUIgiKdBdUkNACABpyICIAIoAgAiAkEBazYCACACQQFKDQAgACgCECABEJYECwtNAQJ/IAAoAkAiAkGAAmohAyACKAKcAiAAKAIERwRAIANBwgEQESADIAAoAgQQHSACIAAoAgQ2ApwCCyACIAIoAoQCNgKYAiADIAEQEQsmAQF/IwBBEGsiAiQAIAIgAToADyAAIAJBD2pBARByIAJBEGokAAv/FwIGfwJ+IwBBEGsiAiQAAn8CQCAAKAIA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NwMgIABBgH82AhAMAwsgACACQQxqIAJBCGogBkEAEOoEIgFFDQAgACABNgIgIAIoAgghBSAAQQA2AiggACAFNgIkAkAgAUElSQ0AIAFBLU0EQCAAKAJAIgMtAG5BAXENASABQS1HDQMgAy8BbCIGQQFxDQEgBkGA/gNxQYAGRw0DIAMoAmQNAyADKAIEIgNFDQMgAy0AbEEBcQ0BDAMLIAFBLkcNAiAAKAJEDQAgACgCQCIDLwFsIgZBAnENACAGQYD+A3FBgAZHDQIgAygCZA0CIAMoAgQiA0UNAiADLQBsQQJxRQ0CCyAFBEAgAEGDfzYCECAAQQE2AigMAwsgBCABQdQAazYCAAwCCyAEQap/NgIADAULIARBg382AgALIAAgAigCDDYCOEEADAQLIABBATYCMCAAIANBAWo2AggLIAIoAgwhAQwACwALQX8LIQEgAkEQaiQAIAELFQAgAUHeAU4EQCAAKAIQIAEQ6AULC7oHAgZ/AX4jAEEgayIHJABCgICAgOAAIQsCQAJAAkACQAJAAkACQAJAAkACQCABQiCIpyIGQQFqDggDBQUAAQUFCQILIAAgAkGH1AAQjwEMBgsgACACQff4ABCPAQwFCyAGQXlGDQEMAgsgAachBgwCCyABpyEGIAJBAEgEQCACQf////8HcSIFIAYpAgQiC6dB/////wdxTw0BIAZBEGohAiAAAn8gC0KAgICACINQRQRAIAIgBUEBdGovAQAMAQsgAiAFai0AAAtB//8DcRCfAyELDAULIAJBMEcNACAGKQIEQv////8HgyELDAQLIAAgARCNBKciBkUNAgsgAkH/////B3EhCQNAIAYoAhAiBUEwaiEKIAUgBSgCGCACcUF/c0ECdGooAgAhBQJAA0AgBUUNASACIAogBUEBa0EDdCIFaiIIKAIERwRAIAgoAgBB////H3EhBQwBCwsgBigCFCAFaiEFAkACQAJAAkAgCCgCAEEedkEBaw4DAAECAwsgBSgCACICRQ0GIAIgAigCAEEBajYCACAAIAKtQoCAgIBwhCADQQBBABAvIQsMBwsgBSgCACgCECkDACILQoCAgIBwg0KAgICAwABRBEAgACACENkBDAULIAtCIIinQXVJDQYgC6ciACAAKAIAQQFqNgIADAYLIAAgBiACIAUgCBDIAkUNAgwDCyAFKQMAIgtCIIinQXVJDQQgC6ciACAAKAIAQQFqNgIADAQLAkAgBi0ABSIFQQRxRQ0AIAVBCHEEQCACQQBIBEAgBigCKCAJSwRAIAAgBq1CgICAgHCEIAkQsAEhCwwHCyAGLwEGQSBrQf//A3FB9f8DTw0FDAILIAYvAQZBFWtB//8DcUEKSw0BIAAgAhCeAyIFRQ0BQoCAgIDgAEKAgICAMCAFQQBIGyELDAULIAAoAhAoAkQgBi8BBkEYbGooAhQiBUUNACAFKAIUIggEQCAGIAYoAgBBAWo2AgAgACAGrUKAgICAcIQiASACIAMgCBEuACELIAAgARAPDAULIAUoAgAiBUUNACAGIAYoAgBBAWo2AgAgACAHIAatQoCAgIBwhCIBIAIgBREXACEFIAAgARAPIAVBAEgNAiAFRQ0AIActAABBEHEEQCAAIAcpAxgQDyAAIAcpAxAgA0EAQQAQLyELDAULIAcpAwghCwwECyAGKAIQKAIsIgYNAAtCgICAgDAhCyAERQ0CIAAgAhDHAgtCgICAgOAAIQsMAQtCgICAgDAhCwsgB0EgaiQAIAsLDQAgACABIAJBBBDOAgtfAQN/IwBBEGsiBCQAIAAoAgAhAyAEIAI2AgwgA0EDIAEgAkEAEPAFIAMgAygCECkDgAEgACgCDCAAKAIIIAAoAkAiAQR/IAEoAmhBAEdBAXQFQQALEMoCIARBEGokAAsMACAAQYACaiABECoLKwAgAUHeAU4EQCAAKAIQKAI4IAFBAnRqKAIAIgAgACgCAEEBajYCAAsgAQspACAAIAEgAiADQoCAgIAwQoCAgIAwIARBgM4AchBtIQIgACADEA8gAgsZACAAKAIAIAEQGCEBIABBQGsoAgAgARA5Cy0BAX8CQCAAKAIAIgFFDQAgACgCECIARQ0AIAEoAgAgAEEAIAEoAgQRAQAaCwtcAQF/IABBQGsoAgAiAxDmAkUEQEF/DwsgAkEASARAIAMQMiECCyAAIAFB/wFxEBAgAEFAayIAKAIAIAIQOSAAKAIAKAKkAiACQRRsaiIAIAAoAgBBAWo2AgAgAgsmAQF/IwBBEGsiAiQAIAIgATYCDCAAIAJBDGpBBBByIAJBEGokAAs5ACABQQBOBEAgAEG2ARAQIABBQGsiACgCACABEDkgACgCACIAKAKkAiABQRRsaiAAKAKEAjYCBAsLMwEBfyACBEAgACEDA0AgAyABLQAAOgAAIANBAWohAyABQQFqIQEgAkEBayICDQALCyAACxgBAX4gASkDACEDIAEgAjcDACAAIAMQDwsXACAAIAEgAkKAgICAMCADIARBAhDYAQvABQICfgZ/IwBB4ABrIgkkACADQQAgA0EAShshCwNAIAogC0ZFBEAgACACIApBBHRqIgMoAgAQtAUhBiADLQAEIQdCgICAgDAhBAJAAkACQAJAAkACQAJAAkACQAJAIAMtAAUOCgECAgUHAwQIBQAGCyAAIAMoAggQtAUhCAJ+AkACQAJAIAMoAgxBAWoOAwIAAQkLIAAgACkDwAEiBCAIIARBABAUDAILIAAgACgCKCkDECIEIAggBEEAEBQMAQsgACABIAggAUEAEBQLIQQgACAIEBMgBkHQAUYEQEEBIQcMCAsgBkHZAUcNB0EAIQcMBwsCQCAGQdABRgRAQQEhBwwBCyAGQdkBRw0AQQAhBwsgACABIAZBAiADIAcQlQMaDAcLQoCAgIAwIQUgAygCCARAIAkgAygCADYCECAJQSBqIghBwABBzDwgCUEQahBOGiAAIAMoAgggCEEAQQpBCCADLQAFQQJGGyADLgEGEIIBIQULIAMoAgwEQCAJIAMoAgA2AgAgCUEgaiIIQcAAQcU8IAkQThogACADKAIMIAhBAUELQQkgAy0ABUECRhsgAy4BBhCCASEECyAAIAEgBkKAgICAMCAFIAQgB0GAOnIQbRogACAFEA8gACAEEA8MBgsgAykDCCIEQoCAgIAIfEL/////D1gEQCAEQv////8PgyEEDAULQoCAgIDAfiAEub0iBEKAgICAwIGA/P8AfSAEQv///////////wCDQoCAgICAgID4/wBWGyEEDAQLQoCAgIDAfiADKQMIIgRCgICAgMCBgPz/AH0gBEL///////////8Ag0KAgICAgICA+P8AVhshBAwDCyAAIAEgBkECIAMgBxCVAxoMAwsQAQALIAM1AgghBAsgACABIAYgBCAHEBkaCyAAIAYQEyAKQQFqIQoMAQsLIAlB4ABqJAALMgEBfwJAIAFCIIinQXVJDQAgAaciAiACKAIAIgJBAWs2AgAgAkEBSg0AIAAgARCWBAsLCwAgAEGAMUEAEBULogICAn4BfwJAAkACQAJAAkACQAJAAkACQAJAAkBBByABQiCIpyIEIARBB2tBbkkbQQtqDhMEAgMIBgAAAAAAAQUHAAAAAAEFAAsgAEGVMEEAEBVCgICAgOAADwsgBEF1SQ0IIAGnIgAgACgCAEEBajYCAAwICyAAQSEQdiECDAYLIABBIhB2IQIMBQsgAEEkEHYhAgwECyAAQQQQdiECDAMLIAAgAEEFEHYiAkEwIAGnKQIEQv////8Hg0EAEBkaDAILIABBBhB2IQIMAQsgAEEHEHYhAgtCgICAgOAAIQMgAkKAgICAcINCgICAgOAAUgR+IARBdU8EQCABpyIEIAQoAgBBAWo2AgALIAAgAiABENsBIAIFQoCAgIDgAAsPCyABC9kBAgJ/AX5BfyECAkACQAJAAkACQAJAAkACQCABQiCIpyIDQQtqDhIHBwcFAgUFBQUFBAABAQEFBQYFCyABp0EARw8LIAGnDwsgAacpAgQhBCAAIAEQDyAEQv////8Hg0IAUg8LAAsgAacsAAUhAiAAIAEQDyACQQBODwsgA0EHa0FtTQRAIAFCgICAgMCBgPz/AHxC////////////AINCAX1CgICAgICAgPj/AFQPCyAAIAEQD0EBIQILIAIPCyABpygCDCECIAAgARAPIAJB/////wdqQX5JC6gEAQt/IAAoAgAhBSMAQRBrIgggAjYCDEF/IQkCQANAAkAgCCACIgNBBGoiAjYCDCADKAIAIgdBf0YNACAAKAIEIQoDQCABIgQgCk4NAyAEIAQgBWoiDC0AACIGQQJ0Ig1BgLgBai0AAGoiASAKSg0DIAZBwgFGBEAgDCgAASEJDAELCyAGIAdHBEAgBiAHQf8BcUYgBiAHQQh2Qf8BcUZyIAYgB0EQdkH/AXFGckUgB0EYdiAGR3EgBkUgB0GAAklycg0DIAAgBjYCEAsgBEEBaiEEAkACQAJAAkACQAJAAkACQCANQYO4AWotAABBBWsOGAAJAAkJAQkJAQkJAQEBAgICAgQFBgcJAwkLIAQgBWotAAAhBCAIIANBCGoiAjYCDCADKAIEIgNBf0YEQCAAIAQ2AhQMCQsgAyAERg0IDAkLIAQgBWovAAAhBCAIIANBCGoiAjYCDCADKAIEIgNBf0YEQCAAIAQ2AhQMCAsgAyAERg0HDAgLIAAgBCAFaigAADYCGAwGCyAAIAQgBWoiAygAADYCGCAAIAMvAAQ2AhwMBQsgACAEIAVqKAAANgIgDAQLIAAgBCAFaiIDKAAANgIgIAAgAy0ABDYCHAwDCyAAIAQgBWoiAygAADYCICAAIAMvAAQ2AhwMAgsgACAEIAVqIgMoAAA2AiAgACADKAAENgIYIAAgAy0ACDYCHAwBCwsgACAJNgIMIAAgATYCCEEBIQsLIAsLCwAgACABQQAQjgQLJAEBfyAAKAIQIgJBEGogASACKAIAEQMAIgFFBEAgABB8CyABCyYBAX8jAEEQayICJAAgAiABOwEOIAAgAkEOakECEHIgAkEQaiQACykBAX8gAgRAIAAhAwNAIAMgAToAACADQQFqIQMgAkEBayICDQALCyAACz8BAX8jAEEQayICJAACfyABIAAoAhBHBEAgAiABNgIAIABBoJgBIAIQFkF/DAELIAAQEgshACACQRBqJAAgAAsLACAAIAFBARDmBQvDCgIFfw9+IwBB4ABrIgUkACAEQv///////z+DIQwgAiAEhUKAgICAgICAgIB/gyEKIAJC////////P4MiDUIgiCEOIARCMIinQf//AXEhBwJAAkAgAkIwiKdB//8BcSIJQf//AWtBgoB+TwRAIAdB//8Ba0GBgH5LDQELIAFQIAJC////////////AIMiC0KAgICAgIDA//8AVCALQoCAgICAgMD//wBRG0UEQCACQoCAgICAgCCEIQoMAgsgA1AgBEL///////////8AgyICQoCAgICAgMD//wBUIAJCgICAgICAwP//AFEbRQRAIARCgICAgICAIIQhCiADIQEMAgsgASALQoCAgICAgMD//wCFhFAEQCACIAOEUARAQoCAgICAgOD//wAhCkIAIQEMAwsgCkKAgICAgIDA//8AhCEKQgAhAQwCCyADIAJCgICAgICAwP//AIWEUARAIAEgC4QhAkIAIQEgAlAEQEKAgICAgIDg//8AIQoMAwsgCkKAgICAgIDA//8AhCEKDAILIAEgC4RQBEBCACEBDAILIAIgA4RQBEBCACEBDAILIAtC////////P1gEQCAFQdAAaiABIA0gASANIA1QIgYbeSAGQQZ0rXynIgZBD2sQZ0EQIAZrIQYgBSkDWCINQiCIIQ4gBSkDUCEBCyACQv///////z9WDQAgBUFAayADIAwgAyAMIAxQIggbeSAIQQZ0rXynIghBD2sQZyAGIAhrQRBqIQYgBSkDSCEMIAUpA0AhAwsgA0IPhiILQoCA/v8PgyICIAFCIIgiBH4iECALQiCIIhMgAUL/////D4MiAX58Ig9CIIYiESABIAJ+fCILIBFUrSACIA1C/////w+DIg1+IhUgBCATfnwiESAMQg+GIhIgA0IxiIRC/////w+DIgMgAX58IhQgDyAQVK1CIIYgD0IgiIR8Ig8gAiAOQoCABIQiDH4iFiANIBN+fCIOIBJCIIhCgICAgAiEIgIgAX58IhAgAyAEfnwiEkIghnwiF3whASAHIAlqIAZqQf//AGshBgJAIAIgBH4iGCAMIBN+fCIEIBhUrSAEIAQgAyANfnwiBFatfCACIAx+fCAEIAQgESAVVK0gESAUVq18fCIEVq18IAMgDH4iAyACIA1+fCICIANUrUIghiACQiCIhHwgBCACQiCGfCICIARUrXwgAiACIBAgElatIA4gFlStIA4gEFatfHxCIIYgEkIgiIR8IgJWrXwgAiACIA8gFFStIA8gF1atfHwiAlatfCIEQoCAgICAgMAAg1BFBEAgBkEBaiEGDAELIAtCP4ghAyAEQgGGIAJCP4iEIQQgAkIBhiABQj+IhCECIAtCAYYhCyADIAFCAYaEIQELIAZB//8BTgRAIApCgICAgICAwP//AIQhCkIAIQEMAQsCfiAGQQBMBEBBASAGayIHQf8ATQRAIAVBMGogCyABIAZB/wBqIgYQZyAFQSBqIAIgBCAGEGcgBUEQaiALIAEgBxCOAiAFIAIgBCAHEI4CIAUpAzAgBSkDOIRCAFKtIAUpAyAgBSkDEISEIQsgBSkDKCAFKQMYhCEBIAUpAwAhAiAFKQMIDAILQgAhAQwCCyAEQv///////z+DIAatQjCGhAsgCoQhCiALUCABQgBZIAFCgICAgICAgICAf1EbRQRAIAogAkIBfCIBUK18IQoMAQsgCyABQoCAgICAgICAgH+FhFBFBEAgAiEBDAELIAogAiACQgGDfCIBIAJUrXwhCgsgACABNwMAIAAgCjcDCCAFQeAAaiQACyEAIAAgASACQoCAgIAwIAMgBEECENgBIQIgACABEA8gAgumAQEEfyAAQQA2AgQgAVAEQCAAQYCAgIB4NgIIIABBABBBGkEADwsCQCABQv////8PWARAIABBARBBDQEgACgCECABIAGnZyICrYY+AgAg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IAMQ2QEMAgtBACEEIAItAAUiBUEEcUUNACAFQQhxBEAgA0EATg0BIANB/////wdxIgMgAigCKCIFSSEEIAFFIAMgBU9yDQEgAUKAgICAMDcDGCABQoCAgIAwNwMQIAFBBzYCACABIAAgAq1CgICAgHCEIAMQsAE3AwgMAwsgACgCECgCRCACLwEGQRhsaigCFCIFRQ0AIAUoAgAiBUUNACAAIAEgAq1CgICAgHCEIAMgBREXACEECyAEDwtBfw8LQQELoQQBAn8CQAJAIAFCgICAgHBUIAJC/////w9Wcg0AIAKnIgQgAaciAygCKE8NAAJAAkACQAJAAkACQAJAAkACQAJAAkAgAy8BBkECaw4eAAsLCwsLAAsLCwsLCwsLCwsLCwIBAgMEBQYHCAkKCwsgAygCJCAEQQN0aikDACIBQiCIp0F1SQ0LIAGnIgAgACgCAEEBajYCACABDwsgAygCJCAEajAAAEL/////D4MPCyADKAIkIARqMQAADwsgAygCJCAEQQF0ajIBAEL/////D4MPCyADKAIkIARBAXRqMwEADwsgAygCJCAEQQJ0ajUCAA8LIAMoAiQgBEECdGooAgAiAEEATgRAIACtDwtCgICAgMB+IAC4vSIBQoCAgIDAgYD8/wB9IAFC////////////AINCgICAgICAgPj/AFYbDwsgACADKAIkIARBA3RqKQMAEIcCDwsgACADKAIkIARBA3RqKQMAEPsDDwtCgICAgMB+IAMoAiQgBEECdGoqAgC7vSIBQoCAgIDAgYD8/wB9IAFC////////////AINCgICAgICAgPj/AFYbDwtCgICAgMB+IAMoAiQgBEEDdGopAwAiAUKAgICAwIGA/P8AfSABQv///////////wCDQoCAgICAgID4/wBWGw8LIAAgAhAxIQMgACACEA8gA0UEQEKAgICA4AAPCyAAIAEgAyABQQAQFCEBIAAgAxATCyABCyoBAX8jAEEQayIEJAAgBCADNgIMIAAgASACIAMQywIhACAEQRBqJAAgAAuMAQECfyABKAJ8IgRBgIAETgRAIABBjTpBABBGQX8PC0F/IQMgACABQfQAakEQIAFB+ABqIARBAWoQeAR/QX8FIAEgASgCfCIDQQFqNgJ8IAEoAnQgA0EEdGoiA0IANwIAIANCADcCCCADIAAgAhAYNgIA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AwsNACAAIAEgARA/EJMCC20BAX8jAEGAAmsiBSQAIARBgMAEcSACIANMckUEQCAFIAFB/wFxIAIgA2siA0GAAiADQYACSSIBGxArGiABRQRAA0AgACAFQYACEFsgA0GAAmsiA0H/AUsNAAsLIAAgBSADEFsLIAVBgAJqJAALDAAgAEGAAmogARARC74BAgF+AX8CQAJAIAFCgICAgHCDQoCAgIAwUQRAIAAoAiggAkEDdGopAwAiA0IgiKdBdEsNAQwCCyAAIAFBOyABQQAQFCIDQoCAgIBwg0KAgICA4ABRBEAgAw8LIANC/////29WDQEgACADEA8gACABEIADIgRFBEBCgICAgOAADwsgBCgCKCACQQN0aikDACIDQiCIp0F1SQ0BCyADpyIEIAQoAgBBAWo2AgALIAAgAyACEEkhASAAIAMQDyABC3UBAX4gACABIAR+IAIgA358IANCIIgiAiABQiCIIgR+fCADQv////8PgyIDIAFC/////w+DIgF+IgVCIIggAyAEfnwiA0IgiHwgASACfiADQv////8Pg3wiAUIgiHw3AwggACAFQv////8PgyABQiCGhDcDAAtQAQF+AkAgA0HAAHEEQCABIANBQGqthiECQgAhAQwBCyADRQ0AIAIgA60iBIYgAUHAACADa62IhCECIAEgBIYhAQsgACABNwMAIAAgAjcDCAtVAQN/IAEgAkEFdSIESwRAIAAgBEECdGooAgAhAwsgAkEfcSICBH8gASAEQQFqIgRLBH8gACAEQQJ0aigCAAVBAAtBAXQgAkEfc3QgAyACdnIFIAMLC2QAAkACQCABQQBIDQAgACgCrAIgAUwNACAAKAKkAiABQRRsaiIAIAAoAgAgAmoiADYCACAAQQBIDQEgAA8LQYUpQa78AEHIqAFBlNUAEAAAC0GmjgFBrvwAQcuoAUGU1QAQAAALYAAgACABIAJCgICAgAh8Qv////8PWAR+IAJC/////w+DBUKAgICAwH4gArm9IgJCgICAgMCBgPz/AH0gAkL///////////8Ag0KAgICAgICA+P8AVhsLIANBh4ABEL0BCwwAIABBhvsAQQAQFQsLACAAIAFBARDBBQvSEAIMfwF+IwBBEGsiCiQAAkACQCABQv////9vWARAIAAQJAwBCyAGQYAwcSIORSAGIAZBCHYiEHEgEEF/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A6ciAiACKAIAQQFqNgIACyAAIAkgAyAGEMsFIQILIAZBggRxQYAERgRAIAogCSgCECIGQTBqNgIMQX8hByAAIAkgCkEMaiAGKAIwQRp2QT1xEJEDDQULIAIhBwwECyAMBEAgACAIKQMAEA8gA0IgiKdBdU8EQCADpyICIAIoAgBBAWo2AgALIAggAzcDAAsgBkGABHFFDQBBfyEHIAAgCSAKQQxqIAooAgwoAgBBGnZBPXEgBkECcXIQkQMNAwtBf0EBIAAgCSAKQQxqIBBBBXEiAEF/cyAKKAIMKAIAQRp2cSAAIAZxchCRAxshBwwCCyAAIAZB4ekAEG8hBwwBC0F/IQcLIApBEGokACAHC/8BAgJ/AXwjAEEQayIEJAACQCACQiCIpyIDQQJNBEAgASACp7c5AwBBACEADAELIANBB2tBbU0EQCABIAJCgICAgMCBgPz/AHw3AwBBACEADAELAn8gACACEI0BIgJCgICAgHCDQoCAgIDgAFEEQEQAAAAAAAD4fyEFQX8MAQsCfAJAAkBBByACQiCIpyIDIANBB2tBbkkbIgNBCmpBAk8EQCADQQdGDQIgAw0BIAKntwwDCyACp0EEaiAEQQhqELUFIAAgAhAPIAQrAwghBUEADAMLEAEACyACQoCAgIDAgYD8/wB8vwshBUEACyEAIAEgBTkDAAsgBEEQaiQAIAALXQECfyMAQRBrIgMkAAJAIAFBgIABcUUEQCABQYCAAnFFDQEgACgCECgCjAEiAUUNASABLQAoQQFxRQ0BCyADQQA2AgwgAEEEIAJBABCSBEF/IQQLIANBEGokACAEC8YJAgR/BX4jAEHwAGsiBiQAIARC////////////AIMhCQJAAkAgAVAiBSACQv///////////wCDIgpCgICAgICAwP//AH1CgICAgICAwICAf1QgClAbRQRAIANCAFIgCUKAgICAgIDA//8AfSILQoCAgICAgMCAgH9WIAtCgICAgICAwICAf1EbDQELIAUgCkKAgICAgIDA//8AVCAKQoCAgICAgMD//wBRG0UEQCACQoCAgICAgCCEIQQgASEDDAILIANQIAlCgICAgICAwP//AFQgCUKAgICAgIDA//8AURtFBEAgBEKAgICAgIAghCEEDAILIAEgCkKAgICAgIDA//8AhYRQBEBCgICAgICA4P//ACAC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IAAgAaciAkEAIAIoAgRB/////wdxEFEhAiAAKAIAIAEQDyACC7UCAQd/IwBBEGsiBSQAAkAgAEFAaygCACIBRQRADAELAkAgAQJ/IAEoAsgBIgQgASgCxAEiAkgEQCABKALMASEDIAQMAQsgBEEBaiIDIAJBA2xBAm0iAiACIANIGyIGQQN0IQIgACgCACEDAkAgASgCzAEiByABQdABakYEQCADQQAgAiAFQQxqEKgBIgNFDQMgAyABKALMASABKALIAUEDdBAfGgwBCyADIAcgAiAFQQxqEKgBIgNFDQILIAUoAgwhAiABIAM2AswBIAEgAkEDdiAGajYCxAEgASgCyAELQQFqNgLIASADIARBA3RqIgIgASgCvAE2AgAgAiABKALAATYCBCAAQbQBEBAgAEFAaygCACAEQf//A3EQFyABIAQ2ArwBDAELQX8hBAsgBUEQaiQAIAQLoQECA38BfiMAIQYCQCACQoCAgIBwVA0AIAKnIgUvAQZBMEcNACAFKAIgIQQLAn8gBiAAKAIQKAJ4SQRAIAAQ6QFBAAwBCyAELQARBEAgABC2AkEADAELQQAgACAEKQMIIgIgAyACQQAQFCIHQoCAgIBwgyICQoCAgIDgAFENABogAUKAgICAMCAHIAJCgICAgCBRGzcDACAECyEFIAYkACAFCxYAIAAgASACIAMgBCAFIAApAzAQ8QELKQEBfyMAQRBrIgIkACACIAA2AgwgAkEMaiABEJMEIQAgAkEQaiQAIAALngICA38BfiACIAEpAgQiB6dB/////wdxIANHckUEQCABIAEoAgBBAWo2AgAgAa1CgICAgJB/hA8LIAFBEGohBSAHQoCAgIAIg1AgAyACayIEQQBMckUEQCADIAIgAiADSBshBkEAIQMgAiEBA0AgASAGRkUEQCAFIAFBAXRqLwEAIANyIQMgAUEBaiEBDAELCyADQf//A3FBgAJPBEAgACAFIAJBAXRqIAQQ7gMPC0EAIQEgACAEQQAQ6gEiAEUEQEKAgICA4AAPCyAAQRBqIQMDQCABIARGRQRAIAEgA2ogBSABIAJqQQF0ai0AADoAACABQQFqIQEMAQsLIAMgBGpBADoAACAArUKAgICAkH+EDwsgACACIAVqIAQQhAMLugEBAn8CQAJAIAJC/////wdYBEAgACABIAKnQYCAgIB4chBx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IANBCGogAhDiA0UEQEEAIQQgASADKQMIIgJCgICAgICAgBBaBH4gAEGAIEEAEFBBfyEEQgAFIAILNwMACyADQRBqJAAgBAsRACAAIAEgASACIANBAhCKBAtTAQF/IAAoAhAiBEEQaiABIAIgBCgCCBEBACIBIAJFckUEQCAAEHwgAQ8LIAMEQCADIAEgACgCECgCDBEEACIAIAJrIgJBACAAIAJPGzYCAAsgAQvAAQAgAAJ/IAEoAggiAEH+////B04EQEEAIAJBAXENARpB/////wcgAEH+////B0cNARogASgCBEH/////B2oMAQtBACAAQQBMDQAaIABBH00EQEEAIAEoAhAgASgCDEECdGpBBGsoAgBBICAAa3YiAmsgAiABKAIEGwwBCyACQQFxRQRAQYCAgIB4Qf////8HIAEoAgQbDAELQQAgASgCECABKAIMIgIgAkEFdCAAaxBoIgJrIAIgASgCBBsLNgIACw0AIAAgASABED8QhQML+QECA34CfyMAQRBrIgUkAAJ+IAG9IgNC////////////AIMiAkKAgICAgICACH1C/////////+//AFgEQCACQjyGIQQgAkIEiEKAgICAgICAgDx8DAELIAJCgICAgICAgPj/AFoEQCADQjyGIQQgA0IEiEKAgICAgIDA//8AhAwBCyACUARAQgAMAQsgBSACQgAgA6dnQSBqIAJCIIinZyACQoCAgIAQVBsiBkExahBnIAUpAwAhBCAFKQMIQoCAgICAgMAAhUGM+AAgBmutQjCGhAshAiAAIAQ3AwAgACACIANCgICAgICAgICAf4OENwMIIAVBEGokAAu2AQEBfyMAQRBrIgMkAAJAAkAgAkEASARAIAEgAkH/////B3E2AgBBASECDAELIAAoAhAiACgCLCACTQ0BAn8CQCAAKAI4IAJBAnRqKAIAIgApAgRCgICAgICAgIBAg0KAgICAgICAgMAAUg0AIANBDGogABC9BUUNAEEBIAMoAgwiAEF/Rw0BGgtBACEAQQALIQIgASAANgIACyADQRBqJAAgAg8LQe/fAEGu/ABBvxhBryAQAAAL1QECAn8DfgJ/IAJFBEBCgICAgDAhBUEADAELIAAoAhAiAykDgAEhBSADQoCAgIAgNwOAAUF/CyEDAkAgACABQQYgAUEAEBQiB0KAgICAcIMiBkKA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BUEgahBGQX8MAQsCQCABKAIEIARODQAgASAENgIEIARB//8DSA0AIAUgAjYCBCAFIAM2AgAgAEGjkwEgBRBGQX8MAQsgASgCCCACQQF0aiIDLwEAIgZB//8DRwRAQQAgBCAGRg0BGiAFIAI2AhggBSAENgIUIAUgBjYCECAAQdSSASAFQRBqEEZBfwwBCyADIAQ7AQBBfyAAIAFBDGpBBCABQRRqIAEoAhBBAWoQeA0AGiABIAEoAhAiAEEBajYCECABKAIMIABBAnRqIAI2AgBBAAshAyAFQTBqJAAgAwsTACAAIAEgAiADIARBAEEAEPgBCzkAIABB/wBNBEAgAEEDdkH8////AXFBoIECaigCACAAdkEBcQ8LIABBfnFBjMAARiAAENIEQQBHcgtmAQF/An9BACAAKAIIIgIgAU8NABpBfyAAKAIMDQAaIAAoAhQgACgCACACQQNsQQF2IgIgASABIAJJGyIBIAAoAhARAQAiAkUEQCAAQQE2AgxBfw8LIAAgATYCCCAAIAI2AgBBAAsLrAECAX8BfiAAKQIEIgSnQf////8HcSEDAkACQCAEQoCAgIAIg1BFBEAgAiADIAIgA0obIQMgAEEQaiEAA0AgAiADRg0CIAAgAkEBdGovAQAgAUYNAyACQQFqIQIMAAsACyABQf8BSw0AIAIgAyACIANKGyEDIABBEGohACABQf8BcSEBA0AgAiADRg0BIAAgAmotAAAgAUYNAiACQQFqIQIMAAsAC0F/IQILIAILpgEBAX8jAEEQayIDJAAgAyACNwMIAkAgACABQYYBIAFBABAUIgJCgICAgHCDQoCAgIDgAFENACAAIAIQOARAIAAgAiABQQEgA0EIahAvIgJC/////29WIAJCgICAgLB/g0KAgICAIFFyDQEgACACEA8gAEGK0wBBABAVQoCAgIDgACECDAELIAAgAhAPIAAgASADIANBCGoQ8QQhAgsgA0EQaiQAIAILowECA38BfiAAQRBqIQIgASgCACIEQQFqIQMCQCAAKQIEIgVCgICAgAiDUEUEQCACIARBAXRqLwEAIgBBgPgDcUGAsANHIAMgBadB/////wdxTnINASACIANBAXRqLwEAIgJBgPgDcUGAuANHDQEgAEEKdEGA+D9xIAJB/wdxckGAgARqIQAgBEECaiEDDAELIAIgBGotAAAh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OCAaKAIkIRQgCCAVQQ9qQfD//wFxayIXJAAgBSEVIAYEQCAHIAQgByAEIAdIGyIIQQAgCEEAShsiCGsiFUEAIAcgFU8bIREDQAJAIAggCUYEQANAIAggEUYNAiAXIAhBA3RqQoCAgIAwNwMAIAhBAWohCAwACwALIAUgCUEDdCIVaikDACIBQiCIp0F1TwRAIAGnIgogCigCAEEBajYCAAsgFSAXaiABNwMAIBFBAWohESAJQQFqIQkMAQsLIA4gBzYCVCAXIRULIA4gFTYCQCAOIBcgBkEDdGoiETYCREEAIQgDQCAIIAtHBEAgESAIQQN0akKAgICAMDcDACAIQQFqIQgMAQsLIBMoAhQhCiAOIBYoAowBNgIwIBYgDkEwaiISNgKMASATKAIwIQYgESALQQN0aiIIIRwLQQAMAQtBAQshBwNAAkACQAJAAkAgB0UEQCAEQQN0IScgA0KAgICAcIMhMyARQQhqIR0gEUEQaiEeIBFBGGohHyAVQQhqISAgFUEQaiEhIBVBGGohIiASQRhqISggBkHIAWohGyAcQRhqISkgBkHAAWohGSACQiCIpyIkQX5xISogA0IgiKchKyAErSEyIAOnISUgDkEwaiEsIA5B6ABqISYgCCEHAkADQAJAIApBAWohDUIBIS5CgICAgDAhAQJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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ajYCAAsgCCABNwMIIAhBCGspAwAiAUIgiKdBdU8EQCABpyIHIAcoAgBBAWo2AgALIAggATcDECAIQRhqIQcM2wELIAggCEEIayIHKQMANwMAIAhBEGspAwAiAUIgiKdBdU8EQCABpyIKIAooAgBBAWo2AgALIAcgATcDACAIQQhqIQcM2gELIAggCEEIayIHKQMAIgE3AwAgByAIQRBrIgcpAwA3AwAgAUIgiKdBdU8EQCABpyIKIAooAgBBAWo2AgALIAcgATcDACAIQQhqIQcM2QELIAggCEEIayIHKQMAIgE3AwAgCEEQayIKKQMAIS0gCiAIQRhrIgopAwA3AwAgByAtNwMAIAFCIIinQXVPBEAgAaciByAHKAIAQQFqNgIACyAKIAE3AwAgCEEIaiEHDNgBCyAIIAhBCGsiBykDACIBNwMAIAhBEGsiCikDACEtIAogCEEYayIKKQMANwMAIAcgLTcDACAKIAhBIGsiBykDADcDACABQiCIp0F1TwRAIAGnIgogCigCAEEBajYCAAsgByABNwMAIAhBCGohBwzXAQsgCEEQayIHKQMAIQEgByAIQRhrIgcpAwA3AwAgByABNwMADNABCyAIQRhrIgcpAwAhASAHIAhBEGsiBykDADcDACAIQQhrIgopAwAhLSAKIAE3AwAgByAtNwMADM8BCyAIQSBrIgcpAwAhASAHIAhBGGsiBykDADcDACAIQRBrIgopAwAhLSAKIAhBCGsiCikDADcDACAHIC03AwAgCiABNwMADM4BCyAIQShrIgcpAwAhASAHIAhBIGsiBykDADcDACAIQRhrIgopAwAhLSAKIAhBEGsiCikDADcDACAHIC03AwAgCiAIQQhrIgcpAwA3AwAgByABNwMADM0BCyAIQQhrIgcpAwAhASAHIAhBEGsiBykDADcDACAIQRhrIgopAwAhLSAKIAE3AwAgByAtNwMADMwBCyAIQRBrIgcpAwAhASAHIAhBGGsiBykDADcDACAIQSBrIgopAwAhLSAKIAE3AwAgByAtNwMADMsBCyAIQRBrIgcpAwAhASAHIAhBGGsiBykDADcDACAIQSBrIgopAwAhLSAKIAhBKGsiCikDADcDACAHIC03AwAgCiABNwMADMoBCyAIQQhrIgcpAwAhASAHIAhBEGsiBykDADcDACAHIAE3AwAMyQEL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ayIHKQMAIgFC/////z9YBEAgAacMAQsgBiABECYLBH8gCQUgDSgAACAJakEEawshDSAGEHtFDXUMJwsgCkECaiEJAn8gCEEIayIHKQMAIgFC/////z9YBEAgAacMAQsgBiABECYLBH8gDSwAACAJakEBawUgCQshDSAGEHtFDXQMJgsgCkECaiEJAn8gCEEIayIHKQMAIgFC/////z9YBEAgAacMAQsgBiABECYLBH8gCQUgDSwAACAJakEBawshDSAGEHtFDXMMJQsgCCANIAooAAFqIBMoAhRrrUKAgICA0ACENwMAIApBBWohDSAIQQhqIQcMcgsgCigAASEHIAggCiATKAIUa0EFaq03AwAgByANaiENIAhBCGohBwxxCwJAIAhBCGsiBykDACIBQv////8PVg0AIAGnIgkgEygCGE8NACATKAIUIAlqIQ0McQsgBkH14QBBABBGDHQLIAhBCGsiDykDACItQiCIpyIHQQFqIglBBE1BAEEBIAl0QRlxG0UEQCAGIC0Q3AUhLQsCQCAGQRgQKSIJBEAgBkKAgICAIEEREEkiLkKAgICAcINCgICAgOAAUg0BIAYoAhAiB0EQaiAJIAcoAgQRAAALIC0hLgxlCyAJQQA2AhAgCSAtNwMAIAlBADYCCCAupyAJNgIgIAdBfnFBAkYNZSAtIgFCIIinIgdBdU8EQCAtpyILIAsoAgBBAWo2AgALA0AgBiABEIwCIgFCgICAgHCDIi9CgICAgCBSBEAgL0KAgICA4ABRDWYgBiAOQeAAaiAOQYABaiABp0EREI4BDWUgBiAOKAJgIA4oAoABIgsQWiALBEAgBiABEA8gB0F1SQ1lIC2nIgcgBygCAEEBajYCAAxlCyAGEHtFDQEMZQsLAkACQCAtpyIMLQAFQQhxRQ0AQQAhByAMKAIQIgsoAiAiEEEAIBBBAEobIRAgC0EwaiELA0AgByAQRg0CIAstAANBEHENASALQQhqIQsgB0EBaiEHDAALAAsgBiAOQeAAaiAOQYABaiAMQREQjgENZUEAIQcgDigCYCEKIA4oAoABIQkDQCAHIAlHBEAgBiAuIAogB0EDdGooAgRCgICAgCBBABDQARogB0EBaiEHDAELCyAGIAogCRBaDGYLIAlBATYCCCAJIAwoAig2AgwMZQtCgYCAgBAhLgJAIAhBCGspAwAi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/wB8v6G9IgFCgICAgMCBgPz/AH0gAUL///////////8Ag0KAgICAgICA+P8AVhs3AwAMSAsCfCAIQQhrIgcpAwAiLUIgiKciDCAIQRBrIgspAwAiLkIgiKciD3JFBEAgLcQgLsR+IgFCgICAgAh8QoCAgIAQWgRAIBItAChBBHFBACABQoCAgICAgIAQfUKBgICAgICAYFQbDQUgAbkMAgtEAAAAAAAAAIAgLSAuhEKAgICACINQIAFCAFJyRQ0BGiALIAFC/////w+DNwMADEkLIA9BB2tBbUsgDEEHa0FtS3INAyASLQAoQQRxDQMgLkKAgICAwIGA/P8AfL8gLUKAgICAwIGA/P8AfL+iCyE0IAtCgICAgMB+IDS9IgFCgICAgMCBgPz/AH0gAUL///////////8Ag0KAgICAgICA+P8AVhs3AwAMRwsgCEEIayIHKQMAIgEgCEEQayILKQMAIi2EQv////8PVg0BIBItAChBBHENASALAn4gLae3IAGnt6MiNL0iAQJ/IDSZRAAAAAAAAOBBYwRAIDSqDAELQYCAgIB4CyIIt71RBEAgCK0MAQtCgICAgMB+IAFCgICAgMCBgPz/AH0gAUL///////////8Ag0KAgICAgICA+P8AVhsLNwMADEYLIAhBCGsiBykDACIBIAhBEGsiCykDACIthEL/////D1YNACAtpyIMQQBIDQAgAaciD0EATA0AIAsgDCAPcK03AwAMRQsjAEEgayIHJAACfwJAAkACQAJAAn4CQAJAAkACQAJAAkACQEEHIAhBEGsiCykDACIBQiCIpyIMIAxBB2tBbkkbIgxBB0dBByAIQQhrIiMpAwAiLkIgiKciDyAPQQdrQW5JGyIPQQdHckUEQCAHIC5CgICAgMCBgPz/AHw3AwggByABQoCAgIDAgYD8/wB8NwMQDAELAkAgDEF/RiAPQX5xQQJHcUUgDEF+cUECRiAPQX9HcnENACAGIAdBGGogASAuIAlBAUEAEIUCIgxFDQAgBiABEA8gBiAuEA8gDEEASA0MIAsgBykDGDcDAAwJCyAGIAEQbCIBQoCAgIBwg0KAgICA4ABRDQogBiAuEGwiLkKAgICAcINCgICAgOAAUQRAIAYgARAPDAwLQQcgAUIgiKciDCAMQQdrQW5JGyIMQQcgLkIgiKciDyAPQQdrQW5JGyIPckUEQCAupyEMIAGnIQ8CQAJAAkACQAJAAkAgCUGaAWsOBgABAgkFAwQLIC7EIAHEfiEtAkAgBigCECIQKAKMASIYRQ0AIBgtAChBBHFFDQAgLUKAgICAgICAEH1CgYCAgICAgGBUDQgLQgAhASAtQgBSDQogDCAPckEATg0LIAtCgICAgMD+/wM3AwAMDgsgBigCECIQKAKMASIYBEAgGC0AKEEEcQ0HCyALQoCAgIDAfiAPtyAMt6O9IgFCgICAgMCBgPz/AH0gAUL///////////8Ag0KAgICAgICA+P8AVhs3AwAMDQsgDEEASiAPQQBOcUUEQCALAn4gD7cgDLcQjgMiNL0iAQJ/IDSZRAAAAAAAAOBBYwRAIDSqDAELQYCAgIB4CyIJt71RBEAgCa0MAQtCgICAgMB+IAFCgICAgMCBgPz/AH0gAUL///////////8Ag0KAgICAgICA+P8AVhsLNwMADA0LIA8gDHCtIS0MCAsgBigCECIQKAKMASIYBEAgGC0AKEEEcQ0FCyAPtyE0IAsCfgJ8IAy3IjW9QoCAgICAgID4/wCDQoCAgICAgID4/wBRBEBEAAAAAAAA+H8gNJlEAAAAAAAA8D9hDQEaCyA0IDUQjwMLIjS9IgECfyA0mUQAAAAAAADgQWMEQCA0qgwBC0GAgICAeAsiCbe9UQRAIAmtDAELQoCAgIDAfiABQoCAgIDAgYD8/wB9IAFC////////////AINCgICAgICAgPj/AFYbCzcDAAwLCyAJQbIBRg0FDAQLIAHEIC7EfSEtDAULIAxBdUcgD0F1R3FFBEAgBiAJIAsgASAuIAYoAhAoAtgCERoADQwMCQsgDEF3RyAPQXdHcUUEQCAGIAkgCyABIC4gBigCECgCvAIRGgBFDQkMDAsgDEF2RyAPQXZHcUUEQCAGKAIQIRAMAgsgBiAHQRBqIAEQbg0KIAYgB0EIaiAuEG4NCwsCQCAGKAIQIhAoAowBIgxFDQAgDC0AKEEEcUUNACAHKwMQEL0CRQ0AIAcrAwgQvQINAQsCQAJAAkACQAJAAkACQCAJQZoBaw4GAAECCAUEAwsgBysDECAHKwMIoiE0DAULIAcrAxAgBysDCKMhNAwECyAHKwMQIAcrAwgQjgMhNAwDCyAJQbIBRw0EIAcrAxAgBysDCJkiNRCOAyI0RAAAAAAAAAAAY0UNAiA1IDSgITQMAgsgBysDECE1IAcrAwgiNr1CgICAgICAgPj/AINCgICAgICAgPj/AFEEQEQAAAAAAAD4fyE0IDWZRAAAAAAAAPA/YQ0CCyA1IDYQjwMhNAwBCyAHKwMQIAcrAwihITQLIAtCgICAgMB+IDS9IgFCgICAgMCBgPz/AH0gAUL///////////8Ag0KAgICAgICA+P8AVhs3AwAMBwsgBiAJIAsgASAuIBAoAqACERoARQ0GDAkLEAEACyAMRQ0FIAHEIC7EIgGBIi1CAFkNACAMQQBIBEAgLSABfSEtDAELIAEgLXwhLQsgLUKAgICACHxC/////w9WDQEgLSEBCyABQv////8PgwwBC0KAgICAwH4gLbm9IgFCgICAgMCBgPz/AH0gAUL///////////8Ag0KAgICAgICA+P8AVhsLIQEgCyABNwMAC0EADAMLIAZBAhCEAgwBCyAGIC4QDwsgC0KAgICAMDcDACAjQoCAgIAwNwMAQX8LIQkgB0EgaiQAIAkNSCAIQQhrIQcMRAsgCEEEaygCACIHRSAHQQdrQW5Jcg09IAghByAGIAhBjQEQ5gFFDUMMRwsCQAJ8IAhBCGsiBykDACIBQiCIpyIJRQRARAAAAAAAAACAIAGnIgpFDQEaRAAAAAAAAOBBIApBgICAgHhGDQEaIAdCACABfUL/////D4M3AwAMPwsgCUEHa0FtSw0BIAFCgICAgMD+/wN9vwshNCAHQoCAgIDAfiA0vSIBQoCAgIDAgYD8/wB9IAFC////////////AINCgICAgICAgPj/AFYbNwMADD0LIAghByAGIAhBjAEQ5gFFDUIMRgsgCEEIayIHKQMAIgFC/////w9WIAFC/////w+DQv////8HUXJFBEAgByABQgF8Qv////8PgzcDAAw8CyAIIQcgBiAIQY8BEOYBRQ1BDEULIAhBCGsiBykDACIBQv////8PViABQv////8Pg0KAgICACFFyRQRAIAcgAUIBfUL/////D4M3AwAMOwsgCCEHIAYgCEGOARDmAUUNQAxECyAGIAhBCGsiBykDABBsIgFCgICAgHCDQoCAgIDgAFEEQCAHQoCAgIAwNwMADEQLIAcgATcDACABQiCIp0F1TwRAIAGnIgcgBygCAEEBajYCAAsgCCABNwMAIAYgCEEIaiIHIAlBAmsQ5gFFDT8MQwsgCkECaiENIBEgCi0AAUEDdGoiBykDACIBQv////8PViABQv////8Pg0L/////B1FyRQRAIAcgAUIBfEL/////D4M3AwAMOQsgAUIgiKdBdU8EQCABpyIJIAkoAgBBAWo2AgALIA4gATcDYCAGICZBjwEQ5gENQiAGIAcgDikDYBAgDDgLIApBAmohDSARIAotAAFBA3RqIgcpAwAiAUL/////D1YgAUL/////D4NCgICAgAhRckUEQCAHIAFCAX1C/////w+DNwMADDgLIAFCIIinQXVPBEAgAaciCSAJKAIAQQFqNgIACyAOIAE3A2AgBiAmQY4BEOYBDUEgBiAHIA4pA2AQIAw3CyAIQQhrIgcpAwAiAUL/////D1gEQCAHIAFC/////w+FNwMADDcLIAghByMAQRBrIgkkAAJ/AkACQAJAIAhBCGsiCykDACIBQoCAgIBwVA0AIAYgCUEIaiABQZUBEMIFIgxBAEgNASAMRQ0AIAYgARAPIAsgCSkDCDcDAAwCCwJAIAYgARBsIgFCgICAgHCDIi1CgICAgOAAUQ0AIAYoAhAiDCgCjAEiDwR/IA8tAChBBHFBAnYFQQALRSAtQoCAgIDgflJxRQRAIAYgC0GVASABIAwoApwCERsADQEMAwsgBiAJQQRqIAEQmAENACALIAk1AgRC/////w+FNwMADAILIAtCgICAgDA3AwALQX8MAQtBAAshCyAJQRBqJAAgC0UNPAxACwJAAkACQCAIQQhrIgcpAwAiASAIQRBrIgspAwAiLYRC/////w9WDQAgAachCSASLQAoQQRxRQ0BIAlBH0sNACAtIAGGQoCAgIAIfEKAgICAEFQNAgsgBiAIQaABEMMCRQ09DEELIAlBH3EhCQsgCyAtpyAJdK03AwAMOwsgCEEIayIHKQMAIgEgCEEQayIJKQMAIi2EQv////8PWARAIAkCfiAtpyABp3YiCEEATgRAIAitDAELQoCAgIDAfiAIuL0iAUKAgICAwIGA/P8AfSABQv///////////wCDQoCAgICAgID4/wBWGws3AwAMOwsjAEEQayIJJAAgCEEIayIMKQMAIS0CfwJAAkAgBiAIQRBrIgspAwAQbCIBQoCAgIBwgyIuQoCAgIDgAFEEQCAGIC0QDwwBCyAGIC0QbCItQoCAgIBw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gICAgOAAIQEgACACKQMAEOgBIgZCgICAgHCDQoCAgIDgAFEEQCAAIAUQDwwGCyAAIAYQDyAGpyAFp0YNBAsgACAFEA8gAEGE5ABBABAVC0KAgICA4AAhAQwDCyACKAIQKAIsIgBFBEBCgICAgCAhAQwDCyAAIAAoAgBBAWo2AgAgAK1CgICAgHCEIQEMAgsgACABEI0EIgFCIIinQXVJDQEgAaciACAAKAIAQQFqNgIADAELIAUhAQsgA0EQaiQAIAELCwAgAEGNIkEAEEYLGgAgACgCECABIAIQ7wQiAUUEQCAAEHwLIAELgAEBAn8CQAJAIAFFDQAgASgCACICQQBMDQEgASACQQFrIgI2AgAgAg0AIAEtAAVBAXEEQCAAIAEpAxgQIwsgASgCCCICIAEoAgwiAzYCBCADIAI2AgAgAUIANwIIIABBEGogASAAKAIEEQAACw8LQdaNAUGu/ABB9ChB6t0AEAAACxIAIAFB3gFOBEAgACABEOgFCwvbAQIBfwJ+QQEhBAJAIABCAFIgAUL///////////8AgyIFQoCAgICAgMD//wBWIAVCgICAgICAwP//AFEbDQAgAkIAUiADQv///////////wCDIgZCgICAgICAwP//AFYgBkKAgICAgIDA//8AURsNACAAIAKEIAUgBoSEUARAQQAPCyABIAODQgBZBEBBfyEEIAAgAlQgASADUyABIANRGw0BIAAgAoUgASADhYRCAFIPC0F/IQQgACACViABIANVIAEgA1EbDQAgACAChSABIAOFhEIAUiEECyAECy0BAX9BASEBAkACQAJAIABBDWsOBAIBAQIACyAAQTRGDQELIABBOEYhAQsgAQsfACAAIAEgACACEKoBIgIgAyAEEBkhBCAAIAIQEyAEC0QBAX9BfyEDIAAgACgCBCACahDGAQR/QX8FIAAoAgAgAWoiAyACaiADIAAoAgQgAWsQnAEgACAAKAIEIAJqNgIEQQALC44BAQF/IAAgBkEMEEkiBkKAgICAcINCgICAgOAAUgRAIAAgACgCAEEBajYCACAGpyIHIAU7ASogByAEOgApIAcgAzoAKCAHIAE2AiQgByAANgIgIAcgBy0ABUHvAXEgBEECa0EESUEEdHI6AAUgACAGIAAgAkHMngEgAhsQqgEiASADEJYDIAAgARATCyAGCykBAX9B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IAAgD0ElEEsiCEUNACAAIANB3QEgA0EAEBQiDkKAgICAcIMiDUKAgICA4ABRDQAgDUKAgICAMFEEQCAAIA8QD0EADAILIAAgDkElEEsiC0UNAAJAIAgoAgRFDQAgCygCBEUNACAAIA8QDyAAIA4QD0EADAILIAQQ9wMhBwJ/IAgoAgAiCiALKAIAIgxGBEAgCCAHQQJ0aigCCAwBCyAKIAxLBEAgCEHUAGogDCAHELgFDAELIAtB3ABqIAogBxC4BQsiCkUEQCAJIAdBAnRBwMABajYCACAAQZL6ACAJEBUMAQsCQCAIKAIEBEACfiAFBEAgACACELkCDAELIAAgAiAGEJACCyICQoCAgIBwg0KAgICA4ABSDQEMAgsgAkIgiKdBdUkNACACpyIIIAgoAgBBAWo2AgALAkAgCygCBARAAn4gBQRAIAAgAxC5AgwBCyAAIAMgBhCQAgsiA0KAgICAcINCgICAgOAAUg0BIAAgAhAPDAILIANCIIinQXVJDQAgA6ciBSAFKAIAQQFqNgIACyAKIAooAgBBAWo2AgAgCSACIAMgBEF+cUGkAUYgB0ENRnEiBRs3AxggCSADIAIgBRs3AxAgACAKrUKAgICAcIRCgICAgDBBAiAJQRBqEC8hDSAAIAIQDyAAIAMQDyANQoCAgIBwgyICQoCAgIDgAFENAAJ+IAdBDEYEQCAAIA0QJiAEQaoBRketQoCAgIAQhAwBCyANIAdBDUcNABpCgICAgBAgAkKAgICAMFENABogACANECYgBEF9cUGkAUZHrUKAgICAEIQLIQMgACAPEA8gACAOEA8gASADNwMAQQEMAQsgACAPEA8gACAOEA8gAUKAgICAMDcDAEF/CyEHIAlBIGokACAHC2MCAX8BfiMAQRBrIgIkACAAAn4gAUUEQEIADAELIAIgAa1CACABZyIBQdEAahBnIAIpAwhCgICAgICAwACFQZ6AASABa61CMIZ8IQMgAikDAAs3AwAgACADNwMIIAJBEGokAAvHAQIBfgF/AkAgACgCECgCjAEiA0UgAUL/////////D3xC/v///////x9Wcg0AIAMoAihBBHFFDQAgAUKAgICACHxC/////w9YBEAgAUL/////D4MPC0KAgICAwH4gAbm9IgFCgICAgMCBgPz/AH0gAUL///////////8Ag0KAgICAgICA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ACAAIAEQiANBH3YLvgEBB38gACgCDCIFIQMCQANAIAMiBEUNASAAKAIQIgkgBEEBayIDQQJ0aiIGKAIARQ0ACyAAIAAoAgggBCAFa0EFdGo2AgggBigCAGciBwRAQSAgB2shBUEAIQMDQCADIARGRQRAIAkgA0ECdGoiBiAIIAV2IAYoAgAiCCAHdHI2AgAgA0EBaiEDDAELCyAAIAAoAgggB2s2AggLIAAgASACIARBABCqAw8LIABBgICAgHg2AgggAEEAEEEaQQALTgIBfwF+An4jACICIAAoAhAoAnhJBEAgABDpAUKAgICA4AAMAQsgACABrSABKQMAQoCAgIAwIAEoAgggASgCIEEEENgBCyEDIAIkACADCwwAIABB+swAQQAQFQsLACAAQcMaQQAQFQvVAQEDfyMAQRBrIgUkAEF/IQMCQCAAKAIUDQACQAJAIAFBgICAgAROBEAgACgCAEHA2gBBABBGDAELIAEgACgCDEEDbEECbSIEIAEgBEobIQEgACgCECIEIAJBgAJIckUEQCAAIAEQ9QMhAwwDCyAAKAIAIAAoAgQgASAEdCAEa0ERaiAFQQxqEKgBIgINAQsgABCDAwwBCyAFKAIMIQMgACACNgIEIABB/////wMgAyAAKAIQdiABaiIAIABB/////wNOGzYCDEEAIQMLIAVBEGokACADCxEAIAAgASACIAMgBEEAELcFCyYBAX8gAUIgiKdBdU8EQCABpyICIAIoAgBBAWo2AgALIAAgARBsCycBAX8gAUIAUwRAIABCACABfRAwIQIgAEEBNgIEIAIPCyAAIAEQMAvsAQEBfwJAAkACQAJAAkACQAJAQQcgAkIgiKciAyADQQdrQW5JGyIDDggAAAAEBAQEAQMLIAAoAtgBIQAgAUIANwIMIAFCgICAgICAgICAfzcCBCABIAA2AgAgASACxBC6Ag0BDAQLIAAoAtgBIQAgAUIANwIMIAFCgICAgICAgICAfzcCBCABIAA2AgAgASACQoCAgIDAgYD8/wB8vxC6BUUNAwsgARAbQQAPCyADQQpqQQJJDQILIAAoAtgBIQAgAUIANwIMIAFCgICAgICAgICAfzcCBCABIAA2AgAgARA1CyABDwsgAqdBBGoL5AEBBH8jAEEQayICJAAgACACQQhqIAEQ5QEhAyAAIAEQDwJAIANFBEBC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IAMoAgAgAygCBHEMBAsgAygCACADKAIEcgwDCyADKAIAIAMoAgRzDAILEAEACyADKAIEIAMoAgB0C603AwAMAQsgAUKAgICAMDcDACAGQoCAgIAwNwMAQX8MAQtBAAshACADQRBqJAAgAAuGBQIHfwJ+AkAgAUKAgICAcINCgICAgJB/UgRAQoCAgIDgACEKIAAgARA3IgFCgICAgHCDQoCAgIDgAFENAQsCQCACQoCAgIBwg0KAgICAkH9RDQBCgICAgOAAIQogACACEDciAkKAgICAcINCgICAgOAAUg0AIAEhAgwBCwJAIAKnIgUpAgQiCkL/////B4NQDQAgAaciAykCBCELAkAgAygCAEEBRyAKIAuFQoCAgIAIg0IAUnINACADIAAoAhAoAgwRBAAgBSkCBCIKpyIEQf////8HcSIHIAMpAgQiC6ciBkH/////B3EiCGogBEEfdnQgBkEfdiIJQRFzakkNACAFQRBqIQYgA0EQaiEEIAkEQCAEIAhBAXRqIAYgB0EBdBAfGiADIAMpAgQiCiAFKQIEfEL/////B4MgCkKAgICAeIOENwIEDAILIAQgCGogBiAHEB8aIAMgAykCBCIKIAUpAgR8Qv////8HgyILIApCgICAgHiDhDcCBCAEIAunakEAOgAADAELAn4CQAJAIAunQf////8HcSAKp0H/////B3FqIgdBgICAgARPBEAgAEHA2gBBABBGDAELIAAgByAKIAuEpyIGQR92EOoBIggNAQtCgICAgOAADAELIAhBEGohBAJAIAZBAE4EQCAEIANBEGogAygCBEH/////B3EQHyIEIAMoAgRB/////wdxaiAFQRBqIAUoAgRB/////wdxEB8aIAQgB2pBADoAAAwBCyAEIAMgAygCBEH/////B3EQwwUgBCADKAIEQQF0aiAFIAUoAgRB/////wdxEMMFCyAIrUKAgICAkH+ECyEKIAAgARAPDAELIAEhCgsgACACEA8gCgtAACAAAn8CfyADBEAgASgCJCACQQN0akEEagwBC0EAIAEoAiAiA0UNARogAyABLwEoIAJqQQR0agsoAgALENkBCw0AIAAgASACQQIQzgILNQEBfyMAQdAAayICJAAgAiAAKAIQIAJBEGogARCQATYCACAAQef5ACACEMYCIAJB0ABqJAALowECAX8BfiMAQRBr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AiAAKAIQQf0ARw0ACyAAEPMBC0F/QQAgABASGyEBCyABC2gAIAAgASACEE8iAEEATgRAIAEoAnQgAEEEdGoiAiACKAIMQYd/cSADQQN0QfgAcXI2AgwgAiABKAK8ASIDNgIEIAIgASgCwAE2AgggASgCzAEgA0EDdGogADYCBCABIAA2AsABCyAAC20BAX8gACABQfwBakEQIAFB+AFqIAEoAvQBQQFqEHhFBEAgASABKAL0ASIDQQFqNgL0ASABKAL8ASADQQR0aiIDQX82AgAgAyADLQAEQfgBcToABCADIAEoArwBNgIIIAMgACACEBg2AgwLIAMLxgMBBH8gAEFAayIFKAIAQbACaiEDA0BBACECAkADQCADKAIAIgNFDQEgAygCHARAIAFFBEAgAEEGEBALIABBhAEQEEGDASECIAAgBSgCAC0AbEEDRgR/IABBDhAQIABBDhAQIABBwgAQECAAQQYQGiAAQREQECAAQbABEBAgAEHqAEF/EBwhASAAQSQQECAFKAIAQQAQFyAAQYEBEBAgAEGLARAQIABB6wBBfxAcIQQgACABEB4gAEEOEBAgACAEEB5BDgVBgwELEBBBfSECQQEhAQsgAygCECACaiECIAMoAhRBf0YNAAtBD0EOIAEbIQQDQCACBEAgACAEEBAgAkEBayECDAELCyABRQRAIABBBhAQCyAAQe0AIAMoAhQQHBpBASEBDAELCwJAIABBQGsoAgAiAigCYARAAkAgAUUEQEF/IQIMAQsgAEEqEBAgAEHpAEF/EBwhAiAAQQ4QEAsgAEG4ARAQIABBCBAaIABBQGsoAgBBABAXIAAgAhAeQSghAgwBCyACLQBsIgMEQCABRQRAIABBBhAQQS4hAgwCC0EuIQIgA0EDRw0BIABBiwEQEAwBC0EoQSkgARshAgsgACACEBALXQECfwJAAkAgACgCmAIiAUEASA0AIAAoAoACIAFqLQAAIgBBI2siAUENTUEAQQEgAXRB5fAAcRsNAQJAIABB6wBrDgQCAQECAAsgAEHsAWtBAkkNAQtBASECCyACCy8AIAAgASACIAMQ4wIiAEEATgRAIAEoAnQgAEEEdGoiASABKAIMQQNyNgIMCyAACy4AIABBDBApIgAEQCAAIAM2AgggACACNgIEIAAgASgCEDYCACABIAA2AhALIAALawEBfwJA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CyAAKAIQIgJBEGogAyACKAIEEQAAQQAhAgNAIAEoAvwBIQMgAiABKAL0AU5FBEAgACADIAJBBHRqKAIMEBMgAkEBaiECDAELCyAAKAIQIgJBEGogAyACKAIEEQAAQQAhAgNAIAEoAsgCIQMgAiABKALAAk5FBEAgACADIAJBA3RqKAIEEBMgAkEBaiECDAELCyAAKAIQIgJBEGogAyACKAIEEQAAIAEoAswBIgIgAUHQAWpHBEAgACgCECIDQRBqIAIgAygCBBEAAAsgACABKALsAhATIAFB9AJqEPYBIAAoAhAiAkEQaiABKAKMAyACKAIEEQAAIAEoAgQEQCABKAIYIgIgASgCHCIDNgIEIAMgAjYCACABQgA3AhgLIAAoAhAiAEEQaiABIAAoAgQRAAALggEBAn8gACABQRBqEM8FAkAgASgCICICBEAgASgCPCIDRQ0BA0AgAiADT0UEQCAAIAIpAwAQIyACQQhqIQIgASgCPCEDDAELCyAAQRBqIAEoAiAgACgCBBEAAAsgACABKQMYECMgACABKQMAECMPC0GEhAFBrvwAQYmUAUHC6wAQAAALaAEBfgJAAkAgABA0IgNCgICAgHCDQoCAgIDgAFEEQCABIQMMAQsgACADQcAAIAFBBxAZQQBIDQAgACADQekAIAJBAEetQoCAgIAQhEEHEBlBAE4NAQsgACADEA9CgICAgOAAIQMLIAMLjAEBAn8CQANAIAFCgICAgHBUDQECQAJAAkACQAJAAkAgAaciAi8BBiIDQQxrDgUFAQMHAQALIANBMEYNASADQTRrDgUABgYGAAYLIAIoAiAoAjAPCyACKAIgIgJFDQQgAi0AEUUNASAAELYCQQAPCyACKAIgIQILIAIpAwAhAQwBCwsgAigCICEACyAACyIAIAAgAkEBahApIgAEQCAAIAEgAhAfIAJqQQA6AAALIAALjQMCA34EfwJAIAEoAggiBkH+////B04EQEEBIQcgAkEBcQ0BQv///////////wAhAyAGQf7///8HRw0BIAE0AgRC////////////AHwhAwwBCyAGQQBMBEAMAQsgBkE/TQRAIAEoAhAiCSABKAIMIgJBAnRqQQRrKAIAIQhCACAGQSBNBH4gCEEgIAZrdq0FIAJBAk8EfiACQQJ0IAlqQQhrNQIABUIACyAIrUIghoRBwAAgBmutiAsiA30gAyABKAIEGyEDDAELIAJBAXFFBEAgASgCBEUEQEL///////////8AIQNBASEHDAILQoCAgICAgICAgH8hA0EBIQcgBkHAAEcNASABKAIQIAEoAgwiAUECdGoiAkEEazUCAEIghiEEIAFBAk8EfiACQQhrNQIABUIACyAEhEKAgICAgICAgIB/UiEHDAELQgAgASgCECIIIAEoAgwiAiACQQV0IAZrIgYQaK0gCCACIAZBIGoQaK1CIIaEIgN9IAMgASgCBBshAwsgACADNwMAIAcLMwEBfyAAKAIAKAIQIgFBEGogACgCBCABKAIEEQAAIABBADYCDCAAQgA3AgQgAEF/NgIUC0YAIAJBAEwEQCAAQS8QLQ8LIAAgAkEAEOoBIgBFBEBCgICAgOAADwsgAEEQaiABIAIQHyACakEAOgAAIACtQoCAgICQf4QLbwIBfwF+AkACQAJ/IAJFBEAgACgCECABQQAQswUMAQsgASwAAEE6a0F2Tw0BIAAoAhAgASACELMFCyIDDQELQQAhAyAAIAEgAhCTAiIEQoCAgIBwg0KAgICA4ABRDQAgACgCECAEpxD8AyEDCyADCxwAIAAgACgCECgCRCABQRhsaigCBEHL9gAQjwELSAECfwJAA0AgAUEKRg0BIAFBAnRB4oACai8BACAASg0BIAFBAXQhAiABQQFqIQEgAkEBdEHkgAJqLwEAIABMDQALQQEPC0EAC3QBBH9BAiECAkAgACgCCCIEQf////8HRg0AIAEoAggiBUH/////B0YNACAAKAIEIgMgASgCBEcEQCAEQYCAgIB4RgRAQQAhAiAFQYCAgIB4Rg0CC0EBIANBAXRrDwtBACAAIAEQ0wEiAGsgACADGyECCyACC4kBAQR+IAAQPiIEQoCAgIBwg0KAgICA4ABSBEAgAUEAIAFBAEobrSEGA0AgAyAGUQRAIAQPCyACIAOnQQN0aikDACIFQiCIp0F1TwRAIAWnIgEgASgCAEEBajYCAAsgACAEIAMgBUEAENIBIQEgA0IBfCEDIAFBAE4NAAsgACAEEA8LQoCAgIDgAAtPAQF/IAEgAjYCDCABIAA2AgAgAUEANgIUIAEgAzYCECABQQA2AgggASAAIAIgAxDqASIANgIEIAAEf0EABSABQX82AhQgAUEANgIMQX8LC7wBAQF/IwBBEGsiBSQAIAUgAzcDCAJAIAEEQCABIAEoAgBBAWo2AgAgACABrUKAgICAcIQgAkEBIAVBCGoQLyECIAAgBSkDCBAPQX8hASACQoCAgIBwg0KAgICA4ABRDQEgACACEA9BASEBDAELIAAgAxAPIARBgIABcUUEQEEAIQEgBEGAgAJxRQ0BIAAoAhAoAowBIgRFDQEgBC0AKEEBcUUNAQsgAEH/GkEAEBVBfyEBCyAFQRBqJAAgAQthAgF/AX4CQCABQQBIDQACQAJAAkAgACgCECgCOCABQQJ0aigCACkCBCIDQj6Ip0EBaw4DAwIAAQtBASECAkAgA0IgiKdB/////wNxDgIDAAELQQIPCxABAAtBASECCyACC6cFAgl/An4jAEEgayIDJAACQCABKQNAIgtCgICAgHCDQoCAgIAwUQRAQoCAgIDgACEMIABBCxB2IgtCgICAgHCDQoCAgIDgAFENASADQgA3AxggA0IANwMQIANCADcDCCAAIANBCGogAUEAEK8FIQQgACgCECICQRBqIAMoAgggAigCBBEAAAJAAkAgBARAIAMoAhQhBgwBCyALpyEHIAMoAhwiCEEAIAhBAEobIQkgAygCFCEGQQAhBAJAA0AgBCAJRwRAAkACQAJAIAYgBEEMbGoiAigCCCIFBEAgAyABNgIADAELAkAgACADIANBBGogASACKAIAEPQDIgUOBAAGBgIGCyADKAIEIQULIAUoAgxB/QBGBEAgAkECNgIEIAIgAygCACgCECAFKAIAQQN0aigCBDYCCAwCCyACQQE2AgQgBSgCBCIKBEAgAiAKNgIIDAILIAIgAygCACgCSCgCJCAFKAIAQQJ0aigCADYCCAwBCyACQQA2AgQLIARBAWohBAwBCwsgBiAIQQxBwQAgABC+AkEAIQQDQCAEIAlGDQMCQAJAAkAgBiAEQQxsaiICKAIEQQFrDgIAAQILIAIoAgghBSAAIAcgAigCAEEmEHoiAkUNBCAFIAUoAgBBAWo2AgAgAiAFNgIADAELIAAgCyACKAIAQQEgAigCCEEGEJUDQQBIDQMLIARBAWohBAwACwALIAAgBSABIAIoAgAQ8wMLIAAoAhAiAUEQaiAGIAEoAgQRAAAgACALEA8MAgsgACgCECIEQRBqIAYgBCgCBBEAACAAIAtB1wEgAEH+ABAtQQAQGRogByAHLQAFQf4BcToABSABIAs3A0ALIAtCIIinQXVPBEAgC6ciACAAKAIAQQFqNgIACyALIQwLIANBIGokACAMC4kEAgR+An8CQAJAIAG9IgRCAYYiA1ANACABvSECIAC9IgVCNIinQf8PcSIGQf8PRg0AIAJC////////////AINCgYCAgICAgPj/AFQNAQsgACABoiIAIACjDwsgAyAFQgGGIgJaBEAgAEQAAAAAAAAAAKIgACACIANRGw8LIARCNIinQf8PcSEHAn4gBkUEQEEAIQYgBUIMhiICQgBZBEADQCAGQQFrIQYgAkIBhiICQgBZDQALCyAFQQEgBmuthgwBCyAFQv////////8Hg0KAgICAgICACIQLIQICfiAHRQRAQQAhByAEQgyGIgNCAFkEQANAIAdBAWshByADQgGGIgNCAFkNAAsLIARBASAHa62GDAELIARC/////////weDQoCAgICAgIAIhAshBCAGIAdKBEADQAJAIAIgBH0iA0IAUw0AIAMiAkIAUg0AIABEAAAAAAAAAACiDwsgAkIBhiECIAZBAWsiBiAHSg0ACyAHIQYLAkAgAiAEfSIDQgBTDQAgAyICQgBSDQAgAEQAAAAAAAAAAKIPCwJAIAJC/////////wdWBEAgAiEDDAELA0AgBkEBayEGIAJCgICAgICAgARUIQcgAkIBhiIDIQIgBw0ACwsgBUKAgICAgICAgIB/gyADQoCAgICAgIAIfSAGrUI0hoQgA0EBIAZrrYggBkEAShuEvwvoDwMHfAh/An5EAAAAAAAA8D8hAwJAAkACQCABvSIRQiCIpyIPQf////8HcSIJIBGnIgxyRQ0AIAC9IhJCIIinIQogEqciEEUgCkGAgMD/A0ZxDQAgCkH/////B3EiC0GAgMD/B0sgC0GAgMD/B0YgEEEAR3FyIAlBgIDA/wdLckUgDEUgCUGAgMD/B0dycUUEQCAAIAGgDwsCQAJAAkACQAJAAn9BACASQgBZDQAaQQIgCUH///+ZBEsNABpBACAJQYCAwP8DSQ0AGiAJQRR2IQ0gCUGAgICKBEkNAUEAIAxBswggDWsiDnYiDSAOdCAMRw0AGkECIA1BAXFrCyEOIAwNAiAJQYCAwP8HRw0BIAtBgIDA/wNrIBByRQ0FIAtBgIDA/wNJDQMgAUQAAAAAAAAAACARQgBZGw8L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A38jAEFAaiIGJAACQCAEIANrIghBAUYEQAJAIANFBEAgAUIDEDAaDAELIAEgA60QMBogAUEBNgIECyACIANBAXRBAXKtEDAaIAIgAigCCEECajYCCCAAIAEQRBoMAQsgACgCACEHIAAgASACIAMgCEEBdiADaiIDQQEQoAQgBkIANwI4IAZCgICAgICAgICAfzcCMCAGIAc2AiwgBkIANwIkIAZCgICAgICAgICAfzcCHCAGIAc2AhggBkIANwIQIAZCgICAgICAgICAfzcCCCAGIAc2AgQgBkEsaiIHIAZBGGogBkEEaiIIIAMgBCAFEKAEIAAgACAIQf////8DQQEQQxogByAHIAFB/////wNBARBDGiAAIAAgB0H/////A0EBEMsBGiAFBEAgASABIAZBGGpB/////wNBARBDGgsgAiACIAZBBGoiAEH/////A0EBEEMaIAZBLGoQGyAGQRhqEBsgABAbCyAGQUBrJAALzgUCB38DfiMAQTBrIggkAAJ/AkACQAJAAkACQCADDgMAAQIDC0HcjAFB1PwAQbUaQZb8ABAAAAsgASACKAIQIAIoAgwiACAAQQV0IAIoAghrEGg2AgAMAgsgAigCECIDIAIoAgwiACAAQQV0IAIoAghrIgJBIGoQaK1CIIYgAyAAIAIQaK2EIQ8gBkGAlOvcA0YEQCABIA9CgJTr3AOAIhA+AgQgASAQQoDslKMMfiAPfD4CAAwCCyABIA8gBq0iEIAiET4CBCABIA8gECARfn0+AgAMAQsgAigCACEKIAhCADcCKCAIQoCAgICAgICAgH83AiAgCCAKNgIcIAhCADcCFCAIQoCAgICAgICAgH83AgwgCCAKNgIIIAMgBUEBdCAEQQFqIgt2QQFqQQF2IgprIQwgACAEQQF0QQFyQRRsaiENQQAhAyAAIARBKGxqIgQoAgxFBEAgBCAGIApB/////wNBARD8AiAIQQhqIglCARAwciANIAkgBCAKQQFqIAdsQQJqQQAQlQFyIQkLAkACQCAIQRxqIg4gAiANIAcgDGxBABBDIAlyIA5BARDRAXIgCEEIaiIJIA4gBEH/////A0EBEENyIAkgAiAJQf////8DQQEQ5AFyQSBxDQADQAJAIAgoAgxFDQAgCCgCFEUNACAIQQhqIgIgAiAEQf////8DQQEQywENAiADQQFrIQMM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3gQBCX8jAEEQayIGJAAgACAAKQOAARAjIABBEGohAyAAQaABaiEEIAAoAqQBIQEDQCABIARGRQRAIAEoAgQhBUEAIQIDQCACIAEoAhBORQRAIAAgASACQQN0aikDGBAjIAJBAWohAgwBCwsgAyABIAAoAgQRAAAgBSEBDAELCyAAIAQ2AqQBIAAgAEGgAWo2AqABIAAQogUgACgCVCAAQdAAakYEQEEAIQIDQAJAIAAoAkQhASACIAAoAkBODQAgASACQRhsaiIBKAIABEAgACABKAIEEOwBCyACQQFqIQIMAQsLIAMgASAAKAIEEQAAIAAoApACIgQEQEEAIQEDQEEAIQUgAUEFRkUEQANAQQAhAiAFQQJGRQRAA0AgAkEURwRAIAQgAUGgAWxqIAVB0ABsaiACQQJ0akGoDWoiBygCACIIBEAgBCgCACIJKAIAIAhBACAJKAIEEQEAGiAHQQA2AgALIAJBAWohAgwBCwsgBUEBaiEFDAELCyABQQFqIQEMAQsLIAAoAtgBIARBACAAKALcAREBABogAEEANgKQAgsgAEHgAWoQoQUgAEH4AWoQoQVBACECA0ACQCAAKAI4IQEgAiAAKAIsTg0AIAEgAkECdGooAgAiAUEBcUUEQCADIAEgACgCBBEAAAsgAkEBaiECDAELCyADIAEgACgCBBEAACADIAAoAjQgACgCBBEAACADIAAoAtQBIAAoAgQRAAAgBiADKQIINwMIIAYgAykCADcDACAGIAAgACgCBBEAACAGQRBqJAAPC0GNkQFBrvwAQb8PQaTlABAAAAtDAQJ/IAAoAogBIQJBfyEDAkADQCACQQBMDQEgACgCgAEgAkEBayICQQR0aigCACABRw0ACyACQYCAgIACciEDCyADC8YBAgR/AX4jAEEQayIDJAAgACABEC0iB0KAgICAcINCgICAgOAAUgRAAkAgACADQQxqIAcQ5QEiBkUEQAwBCwJAIAAgAhA/IgEgAygCDGpBAWoQKSIERQRAQQAhBAwBCyAEIAYgAygCDBAfIgUgAygCDGogAiABEB8aIAUgAygCDCABampBADoAACAAIAUgAygCDCABahCFAyEEIAAoAhAiAUEQaiAFIAEoAgQRAAALIAAgBhBUCyAAIAcQDwsgA0EQaiQAIAQLvwEBAX8gASADai0AAEE8RgRAIAAgBEH/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BEAgCygCJCIEIAJBA3RqIAQgAadBA3QQnAFBAAwBCyABpwshDUEAIQQgAkEAIAJBAEobIQIDQCACIARHBEAgAyAEQQN0aikDACIBQiCIp0F1TwRAIAGnIg4gDigCAEEBajYCAAsgCygCJCAEIA1qQQN0aiABNwMAIARBAWohBAwBCwsgCyAFPgIoIAsoAhQgBUL/////D4M3AwAgBUKAgICACHwhAQwBCyAAIAxBCGogBhA8DQEgDCkDCCIBIAKsIgh8IgVCgICAgICAgBBZBEAgAEHQ2gBBABAVDAILAkAgBEUgAkEATHJFBEBCACEHIAAgBiAIQgAgAUF/EPQCDQMMAQsgASEHCyACQQAgAkEAShutIQlCACEBA0AgASAJUgRAIAMgAadBA3RqKQMAIghCIIinQXVPBEAgCKciAiACKAIAQQFqNgIACyABIAd8IQogAUIBfCEBIAAgBiAKIAgQhgFBAE4NAQwDCwsgACAGQTAgBUKAgICACHwiAUL/////D1gEfiAFQv////8PgwVCgICAgMB+IAW5vSIHQoCAgIDAgYD8/wB9IAdC////////////AINCgICAgICAgPj/AFYbCxBFQQBIDQELIAAgBhAPIAVC/////w+DIAFC/////w9YDQEaQoCAgIDAfiAFub0iAUKAgICAwIGA/P8AfSABQv///////////wCDQoCAgICAgID4/wBWGwwBCyAAIAYQD0KAgICA4AALIQEgDEEQaiQAIAEL0gMCB38DfiMAQSBrIgQkACAEQQA2AgwgBEEANgIIAkACQCAEIAAoAhAoAnhJBEAgABDpAQwBCyAAIAEgAiABQQAQFCILQoCAgIBwg0KAgICA4ABRBEAgCyEBDAILAkACQCALQoCAgIBwVA0AIAAgCxDKASIKQQBIDQECQCAKBEAgACAEQQxqIAsQ1gFFDQEMAwsgACAEQQhqIARBDGogC6dBERCOASEJIAQoAgghBSAJQQBIDQILIAQoAgwhCANAIAcgCEYNAQJAIAoEQCAAIAcQqQUiBkUNBAwBCyAAIAUgB0EDdGooAgQQGCEGCwJ/AkAgACALIAYgAxD5BCINQoCAgIBwgyIMQoCAgIAwUgRAIAxCgICAgOAAUg0BIAAgBhATDAULIAAgCyAGQQAQ1QEMAQsgACALIAYgDUEHEBkLIQkgACAGEBMgB0EBaiEHIAlBAE4NAAsMAQsgACAFIAgQWkEAIQUgACACEFwiDEKAgICAcINCgICAgOAAUQ0AIAQgCzcDGCAEIAw3AxAgACADIAFBAiAEQRBqECEhASAAIAwQDyAAIAsQDwwCCyAAIAUgBCgCDBBaIAAgCxAPC0KAgICA4AAhAQsgBEEgaiQAIAELPwEBfyABQQAgAUEAShshAQNAAkAgASADRgRAQX8hAwwBCyAAIANBA3RqKAIEIAJGDQAgA0EBaiEDDAELCyADC/8EAgJ/BH4CQCACQv////9vWARAIAAQJAwBCwJAIAAgAkE9EHEEf0KAgICAMCEFQoCAgIAwIQZCgICAgDAhCCAAIAJBPSACQQAQFCIHQoCAgIBwg0KAgICA4ABRDQFBgQJBgAIgACAHECYbBUEACyEDIAAgAkE+EHEEQEKAgICAMCEFQoCAgIAwIQZCgICAgDAhCCAAIAJBPiACQQAQFCIHQoCAgIBwg0KAgICA4ABRDQFBggRBgAQgACAHECYbIANyIQMLIAAgAkE/EHEEQEKAgICAMCEFQoCAgIAwIQZCgICAgDAhCCAAIAJBPyACQQAQFCIHQoCAgIBwg0KAgICA4ABRDQFBhAhBgAggACAHECYbIANyIQMLQoCAgIAwIQYCQCAAIAJBwAAQcUUEQEKAgICAMCEIDAELQoCAgIAwIQUgACACQcAAIAJBABAUIghCgICAgHCDQoCAgIDgAFEEQAwCCyADQYDAAHIhAwsCQAJAIAAgAkHBABBxRQ0AQoCAgIAwIQUgA0GAEHIhAyAAIAJBwQAgAkEAEBQiBkKAgICAcIMiB0KAgICAMFENAEHDwgAhBCAHQoCAgIDgAFENASAAIAYQOEUNAQsCQCAAIAJBwgAQcUUEQEKAgICAMCEFDAELIANBgCByIQMgACACQcIAIAJBABAUIgVCgICAgHCDIgJCgICAgDBRDQBBtMIAIQQgAkKAgICA4ABRDQEgACAFEDhFDQELIANBgDBxBEBBsekAIQQgA0GAxABxDQELIAEgBTcDGCABIAY3AxAgASAINwMIIAEgAzYCAEEADwsgACAEQQAQFQsgACAIEA8gACAGEA8gACAFEA8LQX8LwgEBAn8gAigCBEUEQCACKAIYIgMgAigCHCIENgIEIAQgAzYCACACQgA3AhgCQCABKAIABEAgAhCfBQwBCyAAIAIpAyAQIwsgACACKQMoECMgAiACKAIAQQFrIgM2AgACQCADRQRAIAIoAhAiAyACKAIUIgQ2AgQgBCADNgIAIAJCADcCECAAQRBqIAIgACgCBBEAAAwBCyACQoCAgIAwNwMoIAJCgICAgDA3AyAgAkEBNgIECyABIAEoAgxBAWs2AgwLC5UBAQN+IAG9IgJC////////////AIMhAyAAvSIEQv///////////wCDQoGAgICAgID4/wBaBEAgA0KBgICAgICA+P8AVA8LAn9BfyADQoCAgICAgID4/wBWIAAgAWNyDQAaQQEgACABZA0AGkEAIABEAAAAAAAAAABiDQAaIARCAFMEQCACQj+Hp0F/cw8LIAJCP4inCwswACABQoCAgIAQhEKAgICAcINCgICAgDBRBEAgACABEDcPCyAAIAFBOEEAQQAQrQILKQEBfyACQiCIp0F1TwRAIAKnIgMgAygCAEEBajYCAAsgACABIAIQxQULUgIBfwF+QoCAgIDgACEEIAAgASACEJMBIgMEfiADKAIgIgMoAgwoAiAtAAQEQCACRQRAQgAPCyAAEGtCgICAgOAADwsgAzUCEAVCgICAgOAACws4ACAAIAEgAhCTASIARQRAQoCAgIDgAA8LIAAoAiAoAgwiACAAKAIAQQFqNgIAIACtQoCAgIBwhAtRAgF+AX8gACAAKQOQAUEDEEkiAkKAgICAcINCgICAgOAAUgRAIAFCIIinQXVPBEAgAaciAyADKAIAQQFqNgIACyAAIAJBNCABQQMQGRoLIAILlQEBA38jAEEQayIEJAAgBCACNwMIIAEoAgAiBSABKAIEIgY2AgQgBiAFNgIAIAFCADcCACAAIAAgAUEgaiADQQN0aikDAEKAgICAMEEBIARBCGoQIRAPIAAgASkDEBAPIAAgASkDGBAPIAAgASkDIBAPIAAgASkDKBAPIAAoAhAiAEEQaiABIAAoAgQRAAAgBEEQaiQAC40BAQN/IwBBEGsiBCQAIAQgATcDCCADQQF0IQZBACEDA0ACQAJAIANBAkYNACAAQcwAQQEgAyAGakEBIARBCGoQzwEiAUKAgICAcINCgICAgOAAUg0BQX8hBSADQQFHDQAgACACKQMAEA8LIARBEGokACAFDwsgAiADQQN0aiABNwMAIANBAWohAwwACwALyAYC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IARuDAILIARBACABQQJPGyADbAwBCyAAQX9zQR92IQQgAUECayEBIAQCfiACBEAgA60iBiABQQN0IgFB5KEEajUCAH5CIIggAUHgoQRqNQIAIAZ+fEIfiAwBCyABQQJ0QYCkBGo1AgAgA61+Qh2IC6dqCyIBayABIABBAEgbC0gBAn8jAEEQayICJABBfyEDAkAgACACQQxqIAEQugENACACKAIMIgNBJWtBXEsNACAAQdmJAUEAEFBBfyEDCyACQRBqJAAgAwt1AQF/AkAgAUKAgICAcINCgICAgOB+UQRADAELAkAgAUKAgICAcFQNACABpyICLwEGQSFHDQAgAikDICIBQoCAgIBwg0KAgICA4H5SDQAMAQsgAEGiLEEAEBVCgICAgOAADwsgAaciACAAKAIAQQFqNgIAIAELrgICAXwBfwJAA0ACQAJAAkACQAJAQQcgAkIgiKciBCAEQQdrQW5JG0EJag4RAgMDAwMDAwMDAAAAAAMDBAEDCyABIALENwMADAULIAJCgICAgMCBgPz/AHwiAkL///////////8Ag0KBgICAgICA+P8AWgRAIAFCADcDAAwFCyACvyIDRAAAAAAAAODDYwRAIAFCgICAgICAgICAfzcDAAwFCyADRAAAAAAAAOBDZARAIAFC////////////ADcDAAwFCyABAn4gA5lEAAAAAAAA4ENjBEAgA7AMAQtCgICAgICAgICAfws3AwAMBAsgASACp0EEakEAEIIDGiAAIAIQDwwDCyAAIAIQjQEiAkKAgICAcINCgICAgOAAUg0BCwsgAUIANwMAQX8PC0EAC7ECAQJ/IwBBIGsiBCQAAkACQAJAIAIoAgxFBEACQAJAAkACQCACKAIIQf7///8Haw4CAQACCyAAEDUMAgsgAigCBA0DCyAAIAIQRBoLQQAhAiABRQ0DIAFCABAwGgwDCyACKAIERQ0BCyAAEDVBASECIAFFDQEgAUIAEDAaDAELIAAgAiACKAIIQQFqQQJtQQEQkQYgAEEBENEBGiABIgNFBEAgACgCACEDIARCADcCGCAEQoCAgICAgICAgH83AhAgBCADNgIMIARBDGohAwsgAyAAIABB/////wNBARBDGiADIAMoAgRBAXM2AgQgAyADIAJB/////wNBARDLARpBICECIAMoAghB/////wdHBEAgAygC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AkEAEI0FIQVBECEEA0AgA0E0aiILIAJBACAEIAVqIglBAWoiB0HgDxD8AiALIAsgA0EgaiAHQeAPEENyIgdBIHENAyAHQRBxRQ0CIANBNGogAygCPEEBIAkQ4QMNAiAEQQJtIARqIQQMAAsACyADQTRqIANBIGoQRA0BDAMLIANBNGpBARDRAUEgcUUNAgsgA0E0ahAbDAQLIANByABqIANBNGogAiAFIAUQjAUMAQsgAygCTCEFIANByABqIANBNGogAiAIIAgQjAUgAygCTCIJIAVBAWoiAiACIAlJG0EBayEIIAMoAkghByAFIQQDQAJAIAkgBCICQQFqIgRNBEAgCCECDAELIAIgB2otAABBMEcNACAEIAdqLQAAQS5HDQELCyACIAVNDQAgBSAHaiACIAdqIAkgAmsQnAEgAyAFIAJrIAlqNgJMCyADQTRqEBsLIANByABqQQAQESADKAJUDQAgAygCSAwBC0EAIAMoAkgiAkUNABogCigCACACQQAgCigCBBEBABpBAAshBCAGIAw2AgQgACAGIANBDGoQXiAERQRAIAAQfAwBCyAAIAQQYiENIAAoAtgBIgAoAgAgBEEAIAAoAgQRAQAaCyADQeAAaiQAIA0Lw3UCEn8BfiMAQaAGayIDJAAgASgCyAEiBEEAIARBAEobIQYDQCACIAZGRQRAIAEoAswBIAJBA3RqQX82AgQgAkEBaiECDAELCyABKAI8BEAgASgCzAFBfjYCDAtBACECIAEoAnwiBkEAIAZBAEobIQYCfgJAAkADQCACIAZGBEACQEECIQJBAiAEIARBAkwbIQgDQAJAIAIgCEYEQEEAIQIDQCACIAZGDQICQCABKAJ0IAJBBHRqIgQoAghBAE4NACAEKAIEIghBAkgNACAEIAEoAswBIgQgBCAIQQN0aigCAEEDdGooAgQ2AggLIAJBAWohAgwACwALIAEoAswBIgcgAkEDdGoiBCgCBEEASARAIAQgByAEKAIAQQN0aigCBDYCBAsgAkEBaiECDAELCwJAIAEoAkRFDQACQCABKAIgDQAgAS0AbkEBcQ0AIAEgACABQdIAEE82ApABIAEoAjxFDQAgASAAIAFB0wAQTzYClAELAkAgASgCTCIIRQ0AIAEoAqgBQQBIBEAgASAAIAEQygM2AqgBCyABKAKsAUEASARAIAEgACAB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KAIAEB0gAkHAABARIAIgACAJKAIMEBgQHSACIBEQEQsgACAJKAIMEBMgBEEBaiEEDAALAAtBhSlBrvwAQYzyAUH7ORAAAAtBmoIBQa78AEHY6wFB3/QAEAAAC0GuhAFBrvwAQZvrAUHf9AAQAAALA0AgAiAOTkUEQCADQYAGaiACIA1qIgQgBC0AAEECdEGAuAFqLQAAIgQQciACIARqIQIMAQsLIAwQ9gEgDCADKQOQBjcCECAMIAMpA4gGNwIIIAwgAykDgAY3AgAMDAsgDBD2ASAMIAMpA5AGNwIQIAwgAykDiAY3AgggDCADKQOABjcCAAJAIAEoAowCDQAgASgCpAIhDSADIAEoAvACNgKYBiADIAEoAoACIgk2AtwFIAMgASgChAIiCzYC4AUgACgCECECIANCADcDiAYgA0IANwOABiADIAI2ApQGIANBOzYCkAYgASgC0AIiAgRAIAEgASgCACACQQR0EF8iAjYCzAIgAkUNDQsCQCABKALcAiICRQ0AIAEtAG5BAnENACABIAEoAgAgAkEDdBBfIgI2AtgCIAJFDQ0gAUEANgLoAiABIAEoAvACNgLkAgsgASgCtAFBAE4EQCADQYAGaiICQQwQESACQQQQESACQdkAIAEoArQBEF0LIAEoArABQQBOBEAgA0GABmoiAkEMEBEgAkECEBEgAkHZACABKAKwARBdCyABKAKsAUEATgRAIANBgAZqIgJBDBARIAJBAxARIAJB2QAgASgCrAEQXQsCQCABKAKoAUEASA0AIAEoAmAEQCADQYAGaiICQeEAEBEgAiABLwGoARAqDAELIANBgAZqIgJBCBARIAJB2QAgASgCqAEQXQsgASgCmAFBAE4EQEEAIQIgAS0AbkEBcUUEQCABKAI4QQBHIQILIANBgAZqIgRBDBARIAQgAhARIAEoApwBIgJBAE4EQCADQYAGakHaACACEF0LIANBgAZqQdkAIAEoApgBEF0LIAEoAqABQQBOBEAgA0GABmoiAkEMEBEgAkECEBEgAkHZACABKAKgARBdCyABKAKQAUEATgRAIANBgAZqIgJBDBARIAJBBRARIAJB2QAgASgCkAEQXQsgASgClAFBAE4EQCADQYAGaiICQQwQESACQQUQESACQdkAIAEoApQBEF0LQQAhAgJAA0ACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAiALTgRAQQAhAiABKAKsAiIEQQAgBEEAShshBANAIAIgBEYNAiACQRRsIQYgAkEBaiECIAYgDWooAhBFDQALQdWDAUGu/ABB/foBQZQ4EAAACyACIAIgCWoiBi0AACIFQQJ0QYC4AWotAAAiB2ohBAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgBUHYAGsOIBASGhESGhESGhoaGhoaGhoaBAQBAwIaGgwMBQUFBQUFAAsCQCAFQQFrDhUJCgoLGg0HGggIGhoaBhoaDxoaGg4ACyAFQSJrIghBH0sNGEEBIAh0IgpBwOEBcQ0SIApBBXFFBEAgCEEfRw0ZIAYoAAFBMEcNGiABIAMoAoQGIAMoApgGEDMgA0GABmpB6QEQESAEIQIMIwsgBi8AASECIANCqICAgHA3A1AgA0HcBWogBCADQdAAahAnBEACQCADKALoBSIEQQBIBEAgAygCmAYhBAwBCyADIAQ2ApgGCyABIAMoAoQGIAQQMyADQYAGaiAFQQFqIAIQXSABIAkgCyADKALkBSADQZgGahCkAiECDCMLIAEgAygChAYgAygCmAYQMyADQYAGaiAFIAIQXSAEIQIMIgsgBigAASEFIAQhBgwWCyAGKAABIQdB7QAhBQwUCyAGKAABIQdB7AAhBQwTCyABIAYoAAEgA0GcBmpBABDHAyEHIAMoAtwFIAMoAuAFIAQgBxDGAwRAIAEgB0F/EGkaIANBgAZqQQ4QESAEIQIMHwsgA0LrgICAcDcDYCADQdwFaiAEIANB4ABqECdFDRIgAygC6AUhCCADKALcBSADKALgBSADKALkBSIGIAcQxgNFDRIgCEEATgRAIAMgCDYCmAYLIAEgB0F/EGkaIAVBA3MhBSADKAL0BSEHDBwLIAYtAAkhCCAGKAABIQcgASAGKAAFIANBnAZqQQAQxwMiAkEASA0PIAIgASgCrAJODQ8gASADKAKEBiADKAKYBhAzIAEgASgC1AIiBkEBajYC1AIgASgCzAIgBkEEdGoiBkEENgIEIAYgBTYCACADKAKEBiEKIAYgAjYCDCAGIApBBWo2AgggA0GABmoiBiAFEBEgBiAHEB0gBiANIAJBFGxqIgIoAgwgAygChAZrEB0gAigCDEF/RgRAIAAgAiADKAKEBkEEa0EEEOgCRQ0dCyADQYAGaiAIEBEgBCECDB0LIANCqYCAgHA3A3AgA0HcBWogBCADQfAAahAnRQ0TIAQhAiADKALoBSIEQQBIDRwgAyAENgKYBgwcCyADQquBgIBwNwOgASADQdwFaiAEIANBoAFqECcEQAJAIAMoAugFIgJBAEgEQCADKAKYBiECDAELIAMgAjYCmAYLIAEgAygChAYgAhAzIANBgAZqQfMBEBEMGAsgA0F/NgKYASADQqyBgICQzRo3A5ABIANB3AVqIAQgA0GQAWoQJ0UNAAJAIAMoAugFIgVBAEgEQCADKAKYBiEFDAELIAMgBTYCmAYLIAEgAygChAYgBRAzIANBgAZqQfMBEBEgAygC7AVBA3MhBQwYCyADQunUgYBwNwOAASADQdwFaiAEIANBgAFqECdFDREgBUEKRiEKDA0LAkAgBigAASIGQYCAgIB4ckGAgICAeEYNACADQoyBgIBwNwPgASADQdwFaiAEIANB4AFqECdFDQAgAygC6AUiAkEATgRAIAMgAjYCmAYLIANCjoCAgHA3A9ABIANB3AVqIAMoAuQFIANB0AFqECcEQCADKALoBSICQQBIDRcgAyACNgKYBgwXCyABIAMoAoQGIAMoApgGEDMgA0GABmpBACAGaxDFAwwWCyADQo6AgIBwNwPAASADQdwFaiAEIANBwAFqECcEQCADKALoBSICQQBIDRYgAyACNgKYBgwWCyADQunUgYBwNwOwASADQdwFaiAEIANBsAFqECcEQCAGQQBHIQoMDQsgASADKAKEBiADKAKYBhAzIANBgAZqIAYQxQMgBCECDBkLIAYoAAEiAkH/AUoNDyABIAMoAoQGIAMoApgGEDMgA0GABmoiBiAFQcMAa0H/AXEQESAGIAJB/wFxEBEgBCECDBgLIAYoAAEhAiADQo6AgIBwNwPwASADQdwFaiAEIANB8AFqECcEQCAAIAIQEyADKALoBSICQQBIDRQgAyACNgKYBgwUCyACQS9HDQ4gASADKAKEBiADKAKYBhAzIANBgAZqQcEBEBEgBCECDBcLIANCyYCAgHA3A6gCIANC2Lb5gnA3A6ACIANB3AVqIAQiAiADQaACahAnDRYgA0F/NgKYAiADQoGEkICQCTcDkAIgA0HcBWogAiADQZACahAnDRYgA0F/NgKIAiADQoaO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DQMgAyAGKAABNgKYBiAEIQIMDAsgBigAASICQQBIDQMgAiABKAKsAk4NAyANIAJBFGxqIggoAgxBf0cNBCAIIAMoAoQGNgIMIAgoAhAhBwNAIAciAgRAIAgoAgwgAigCBCIFayEGIAIoAgAhBwJAAkACQAJAIAIoAghBAWsOBAIBAwADCyADKAKABiAFaiAGNgAADAILIAZBgIACakGAgARPDQkgAygCgAYgBWogBjsAAAwBCyAGQYABakGAAk8NCSADKAKABiAFaiAGOgAACyAAKAIQIgZBEGogAiAGKAIEEQAADAELCyAIQQA2AhAgBCECDAsLIANCjoCAgHA3A6gFIANC2bj9gnA3A6AFIANB3AVqIAQgA0GgBWoQJwRAIAMoAugFIgJBAE4EQCADIAI2ApgGCyADIAMoAvAFIgY2ApQFIANBfzYCmAUgAyADKALsBSIEQQFrNgKQBSADQdwFaiADKALkBSICIANBkAVqECcEQCADKALoBSICQQBOBEAgAyACNgKYBgsgBEEBaiEEIAMoAuQFIQILIAEgAygChAYgAygCmAYQMyADQYAGaiIHIAVBAmtB/wFxEBEgByAEIAYQXQwLCyADQo6AgIBwNwOIBSADQpiAgICw6A43A4AFIANB3AVqIAQgA0GABWoQJwRAAkAgAygC6AUiAkEASARAIAMoApgGIQIMAQsgAyACNgKYBgsgASADKAKEBiACEDMgA0GABmoiAiAFQQJrQf8BcRARIAIgAy0A7AUQESACIAMoAvwFEB0MBwsgA0KOgICAcDcD+AQgA0KZgICAkAk3A/AEIANB3AVqIAQgA0HwBGoQJ0UNAQJAIAMoAugFIgJBAEgEQCADKAKYBiECDAELIAMgAjYCmAYLIAEgAygChAYgAhAzIANBgAZqIgIgBUECa0H/AXEQESACQckAEBEMBgsgA0F/NgLIBSADQoSAgICwlevUqn83A8AFIANB3AVqIAQgA0HABWoQJ0UNACADKALoBSIIQQBOBEAgAyAINgKYBgsgAygC7AUhCCADKAL8BSIFQcUARgR/QfQBBSAFQRtHDQFB9QELIQogCEF9cUGpAUYEQCABIAMoAoQGIAMoApgGEDMgA0GABmogChARIAAgAygC/AUQEwwGCyADQumAgIBwNwOwBSADQdwFaiADKALkBSADQbAFahAnRQ0A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DAELIAEgAzYCACACIAY2AgBBACEECyAHQRBqJAAgBAvCAwEJfyABKAIIIgZBACAGQQBKGyEFAkACQANAIAQgBUYNASAEQQJ0IQcgBEEBaiEEIAcgASgCAGooAgAgAkcNAAtBACEFDAELQX8hBSAAIAFBBCABQQRqIAZBAWoQeA0AIAEgASgCCCIEQQFqNgIIIAEoAgAgBEECdGogAjYCACABQRBqIQkgAUEMaiEHQQAhBQNAAkAgAigCICAFTARAQQAhBUEAIQQDQCAEIAIoAixODQQgBEECdCEDIARBAWohBCAAIAEgAigCECADIAIoAihqKAIAQQN0aigCBEEBEK8FRQ0ACwwBCwJAIANBACACKAIcIAVBFGxqIgYoAhAiCkEWRhsNAEEAIQQgASgCFCIIQQAgCEEAShshCwJAAkADQCAEIAtGDQEgCiAHKAIAIARBDGxqIgwoAgBHBEAgBEEBaiEEDAELCyAEQQBODQELIAAgB0EMIAkgCEEBahB4DQIgASABKAIUIgRBAWo2AhQgASgCDCAEQQxsaiIEIAYoAhA2AgACQCADRQRAIAYoAghFDQELIARBADYCCAwCCyAEIAY2AggMAQsgDEEANgIICyAFQQFqIQUMAQsLQX8PCyAFC2gCAn8BfiAAQRBqIQIgACkCBCIEp0H/////B3EhAwJAIARCgICAgAiDUEUEQEEAIQADQCAAIANGDQIgAiAAQQF0ai8BACABQYcCbGohASAAQQFqIQAMAAsACyACIAMgARCyBSEBCyABCxIAIAAgASACIANBgIABENABGgssAQF/A0AgASADRkUEQCAAIANqLQAAIAJBhwJsaiECIANBAWohAwwBCwsgAgvOAQIDfwF+IAEgAkEBELIFIgNB/////wNxIQUgACgCNCAAKAIkQQFrIANxQQJ0aiEDA0AgAygCACIERQRAQQAPCwJAIAAoAjggBEECdGooAgAiAykCBCIGQiCIp0H/////A3EgBUcgBkKAgICAgICAgECDQoCAgICAgICAwABSciAGp0H/////B3EgAkcgBkKAgICACINCAFJycg0AIANBEGogASACEGENACAEQd4BTgRAIAMgAygCAEEBajYCAAsgBA8LIANBDGohAwwACwALfwEEfyABLQAAQdsARgRAIAFBAWoiAxA/QQFrIQIgACgCECgCOCEEQdABIQEDQCABQd4BRwRAAkAgBCABQQJ0aigCACIFKAIEQf////8HcSACRw0AIAVBEGogAyACEGENACAAIAEQGA8LIAFBAWohAQwBCwsQAQALIAAgARCqAQusAgMCfwJ+AXwjAEEgayICJABEAAAAAAAA+H8hBiAAKAIIQf////8HRwRAIAAoAgAhAyACQgA3AhggAkKAgICAgICAgIB/NwIQIAIgAzYCDCACQQxqIAAQRBoCfiACKAIUIgBB/f///wdMBEAgAkEMakE1QcgEEM4BGiACKAIUIQALQoCAgICAgID4/wAgAEH+////B0YNABogAEGAgICAeEYEQEIADAELIAIoAhwhAwJ+IAIoAhhBAkYEQCADKQIADAELIAM1AgBCIIYLIQQgAEGCeEwEQCAEQY54IABrrYghBEIADAELIARCC4hC/////////weDIQQgAEH+B2qtQjSGCyEFIAQgBYQgAjUCEEI/hoS/IQYgAkEMahAbCyABIAY5AwAgAkEgaiQACw4AIABCgICAgPB+EIAGC+4PAwt/A34BfCMAQUBqIhAkAEHfAEGAAiAEQSBxGyEJIARBgANxIQsCQAJAAkACfwJAAkACQAJAAkACQAJAAkACQCABLQAAIgZBK2sOAwEDAAMLQQEhDiABQQFqIQEMAQsgAUEBaiEBCyAEQYAIcUUNASABLQAAIQYLIAZB/wFxQTBHDQACQAJAAkAgAS0AASIHQfgARwRAIAdB7wBGDQIgB0HYAEcNAQsgA0FvcQ0FIAFBAmohB0EQIQMMCQsgAyAHQc8AR3INAQwFCyADRQ0EDAMLAkACQCAHQeIARwRAIANFIAdBwgBGcQ0BIAMgB0Ewa0H/AXFBCUtyDQQgBEEQcQ0CDAcLIAMNBAsgBEEEcUUNBUECIQMgAUECaiEHDAcLIAFBAWohB0EBIQYDQCABIAZqIQMgBkEBaiEGIAMtAAAiCEH4AXFBMEYNAAtBCCEDQYACIQlBASEKIAhB/gFxQThGDQQMBgsgBEEBcSALQYACckGAAkdyDQAgAUEIaiEHQfUcIQYgASEIA0AgBkH9HEcEQCAILQAAIAYtAABHDQIgBkEBaiEGIAhBAWohCAwBCwsgC0GAAkYEQCAAELYFIhFCgICAgHCDQoCAgIDgAFEEQEKAgICA4AAhEQwJCyARp0EEaiAOEIwBDAgLRAAAAAAAAPD/RAAAAAAAAPB/IA4bIhS9IhECfyAUmUQAAAAAAADgQWMEQCAUqgwBC0GAgICAeAsiBre9UQRAIAatIREMCAtCgICAgMB+IBFCgICAgMCBgPz/AH0gEUL///////////8Ag0KAgICAgICA+P8AVhshEQwHCyABIgcgA0UNAxoMBQsgASEHDAQLIARBBHFFDQAgAUECaiEHQQghAwwCCyABCyEHQQohAwwBC0KAgICAwH4hESAHLQAAEJYBIANPDQELQQAhBiADQQpHIQwgByEBA0ACQCAGIAdqIg0tAAAiCMAhDyAIEJYBIANOBEAgCSAPRw0BAkAgDCAGQQFHcg0AIA1BAWstAABBMEcNAEEBIQYMAgsgDS0AARCWASADTg0BCyAHIAZBAWoiBmohAQwBCwtBACEMAkACQCAEQQFxDQACQCAIQS5HDQAgDS0AASEIIAZFBEAgCBCWASADTg0BCyANQQFqIQFCgICAgMB+IREgCSAIwEYNAgNAAkAgCEH/AXEQlgEgA0gEQCABLQABIQgMAQtBASEMIAkgCMBHDQIgAS0AASIIEJYBIANODQILIAFBAWohAQwACwALIAEgB00NAAJAIAEtAAAiBkHlAEcEQCADQQpGIAZBxQBGcQ0BIAZBIHJB8ABHIANBEEtyDQJBASADdEGEggRxDQEMAgsgA0EKRw0BC0EBIQwgAUEBaiEGAkACQAJAIAEtAAFBK2sOAwACAQILIAFBAmohBgwBCyABQQJqIQYLIAYtAABBOmtBdkkNACAGIQEDQCABIgZBAWohASAGLQABIgjAIQ0gCEE6a0F1Sw0AIAkgDUcNASAGLQACQTprQXVLDQALCyABIAdGBEBCgICAgMB+IREMAQsgECEJAkAgASAHayINQQJqIg9BwQBPBEAgACgCECIGQRBqIA8gBigCABEDACIJRQ0BC0EAIQZBACEIIA4EQCAJQS06AABBASEICyANQQAgDUEAShshDgNAIAYgDkZFBEAgBiAHai0AACINQd8ARwRAIAggCWogDToAACAIQQFqIQgLIAZBAWohBgwBCwsgCCAJakEAOgAAAn4CQAJAIARBwABxBEACQAJAAkACQCABLQAAQewAaw4DAQIAAwsgAUEBaiEBQYABIQsMBQsgAUEBaiEBQYACIQsMBAsgAUEBaiEBQYADIQsM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IAFBEGohAgJ/IAdCgICAgAiDUCIFRQRAIAIvAQAMAQsgAi0AAAsiAUEwayIDQQlLDQACfwJAIAFBMEcEQEEBIQEDQCABIARGDQICfyAFRQRAIAIgAUEBdGovAQAMAQsgASACai0AAAtBMGsiBkEJSw0EIAFBAWohASAGrSADrUIKfnwiB6chAyAHQoCAgIAQVA0ACwwDC0EAIgMgBEEBRw0BGgsgACADNgIAQQELDwtBAAupAgIDfwF+AkAgACACEDhFDQAgAqciBC8BBkEORgRAIAAgASAEKAIgKQMAENAFDwsgAUKAgICAcFQNAAJAIAAgAkE7IAJBABAUIgJC/////29YBEBBfyEDIAJCgICAgHCDQoCAgIDgAFENASAAQcYwQQAQFQwBCyABpyEEIAKnIQUCQANAAkAgBCgCECgCLCIDRQRAQQAhAyAELwEGQTBHDQQgBCAEKAIAQQFqNgIAIAStQoCAgIBwhCEBA0AgACABEIwCIgFCgICAgHCDIgZCgICAgCBRDQRBfyEDIAZCgICAgOAAUQ0FIAGnIAVGBEAgACABEA8MAwsgABB7RQ0ACyAAIAEQDwwECyADIgQgBUcNAQsLQQEhAwwBC0EAIQMLIAAgAhAPCyADC9IDAgJ+An8jAEEgayIEJAACQCABQv///////////wCDIgNCgICAgICAwIA8fSADQoCAgICAgMD/wwB9VARAIAFCBIYgAEI8iIQhAyAAQv//////////D4MiAEKBgICAgICAgAhaBEAgA0KBgICAgICAgMAAfCECDAILIANCgICAgICAgIBAfSECIABCgICAgICAgIAIUg0BIAIgA0IBg3whAgwBCyAAUCADQoCAgICAgMD//wBUIANCgICAgICAwP//AFEbRQRAIAFCBIYgAEI8iIRC/////////wODQoCAgICAgID8/wCEIQIMAQtCgICAgICAgPj/ACECIANC////////v//DAFYNAEIAIQIgA0IwiKciBUGR9wBJDQAgBEEQaiAAIAFC////////P4NCgICAgICAwACEIgIgBUGB9wBrEGcgBCAAIAJBgfgAIAVrEI4CIAQpAwhCBIYgBCkDACIAQjyIhCECIAQpAxAgBCkDGIRCAFKtIABC//////////8Pg4QiAEKBgICAgICAgAhaBEAgAkIBfCECDAELIABCgICA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cINCgICAgJB/UXFFBEAgAEGN9wBBABAVDAELIAAgAUESEGUiAUKAgICAcINCgICAgOAAUQ0AIAGnIgQgAz4CJCAEIAI+AiAgACABQdUAQgBBAhAZGiABDwsgACADEA8gACACEA9CgICAgOAACw0AIAAgAUHOlQEQ/wMLZwEBfwJAIAFBAE4EQCAAKAIQIgIoAiwgAU0NASACKAI4IAFBAnRqKAIAIgEgASgCAEEBajYCACAAIAFBBBCABA8LQfKRAUGu/ABBzhdBmdIAEAAAC0HZ3wBBrvwAQc8XQZnSABAAAAtEAQF/IABB+AFqIQIgAEH0AWohAAN/IAAgAigCACICRgRAQQAPCyABIAJBBGsoAgBGBH8gAkEIawUgAkEEaiECDAELCwtSAgJ/AX4CQCAAKAIQKAKMASIBRQ0AIAEpAwgiA0KAgICAcFQNACADpyIBLwEGEO4BRQ0AIAEoAiAiAS0AEkEEcUUNACAAIAEoAkAQGCECCyACC6oPAgV/D34jAEHQAmsiBSQAIARC////////P4MhCyACQv///////z+DIQogAiAEhUKAgICAgICAgIB/gyENIARCMIinQf//AXEhCAJAAkAgAkIwiKdB//8BcSIJQf//AWtBgoB+TwRAIAhB//8Ba0GBgH5LDQELIAFQIAJC////////////AIMiDEKAgICAgIDA//8AVCAMQoCAgICAgMD//wBRG0UEQCACQoCAgICAgCCEIQ0MAgsgA1AgBEL///////////8AgyICQoCAgICAgMD//wBUIAJCgICAgICAwP//AFEbRQRAIARCgICAgICAIIQhDSADIQEMAgsgASAMQoCAgICAgMD//wCFhFAEQCADIAJCgICAgICAwP//AIWEUARAQgAhAUKAgICAgIDg//8AIQ0MAwsgDUKAgICAgIDA//8AhCENQgAhAQwCCyADIAJCgICAgICAwP//AIWEUARAQgAhAQwCCyABIAyEUARAQoCAgICAgOD//wAgDSACIAOEUBshDUIAIQEMAgsgAiADhFAEQCANQoCAgICAgMD//wCEIQ1CACEBDAILIAxC////////P1gEQCAFQcACaiABIAogASAKIApQIgYbeSAGQQZ0rXynIgZBD2sQZ0EQIAZrIQYgBSkDyAIhCiAFKQPAAiEBCyACQv///////z9WDQAgBUGw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AgQLIBIgFHwhEgwDCyADRSEFIABBAEgNAQsgAikDcEIAUw0AIAIgAigCBEEBazYCBAsgBUUNAEGg1ARBHDYCACACEJoEQgAhE0IADAELIAEoApAGIgBFBEAgASAGt0QAAAAAAAAAAKIQqwEgASkDACETIAEpAwgMAQsgEiATUiATQglVckUEQCABQTBqIAYQeSABQSBqIAAQhgIgAUEQaiABKQMwIAEpAzggASkDICABKQMoEC4gASkDECETIAEpAxgMAQsgEkKaBFkEQEGg1ARBxAA2AgAgAUHgAGogBhB5IAFB0ABqIAEpA2AgASkDaEJ/Qv///////7///wAQLiABQUBrIAEpA1AgASkDWEJ/Qv///////7///wAQLiABKQNAIRMgASkDSAwBCyASQut1VwRAQaDUBEHEADYCACABQZABaiAGEHkgAUGAAWogASkDkAEgASkDmAFCAEKAgICAgIDAABAuIAFB8ABqIAEpA4ABIAEpA4gBQgBCgICAgICAwAAQLiABKQNwIRMgASkDeAwBCyAKBEAgCkEITARAIAFBkAZqIAdBAnRqIgAoAgAhCQNAIAlBCmwhCSAKQQFqIgpBCUcNAAsgACAJNgIACyAHQQFqIQcLAkAgCyASpyIISiALQQhKciAIQRFKcg0AIAhBCUYEQCABQcABaiAGEHkgAUGwAWogASgCkAYQhgIgAUGgAWogASkDwAEgASkDyAEgASkDsAEgASkDuAEQLiABKQOgASETIAEpA6gBDAILIAhBCEwEQCABQZACaiAGEHkgAUGAAmogASgCkAYQhgIgAUHwAWogASkDkAIgASkDmAIgASkDgAIgASkDiAIQLiABQeABakEAIAhrQQJ0QeDBBGooAgAQeSABQdABaiABKQPwASABKQP4ASABKQPgASABKQPoARDjBSABKQPQASETIAEpA9gBDAILIAhBEU5BACABKAKQBiIAIAhBfWxB0ABqdhsNACABQeACaiAGEHkgAUHQAmogABCGAiABQcACaiABKQPgAiABKQPoAiABKQPQAiABKQPYAhAuIAFBsAJqIAhBAnRBmMEEaigCABB5IAFBoAJqIAEpA8ACIAEpA8gCIAEpA7ACIAEpA7gCEC4gASkDoAIhEyABKQOoAgwBCwNAIAFBkAZqIAciAEEBayIHQQJ0aigCAEUNAAsCQCAI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AAEiAjoAASAAQQFqIQAgAUEBaiEBIAINAAsLC/UBAgF/AX4jAEHQAGsiAyQAAkACfiABQQBIBEAgAyABQf////8HcTYCACADQRBqIgFBwABB3CIgAxBOGiAAIAEQYgwBCyAAKAIQIgAoAiwgAU0NAQJAAkAgACgCOCIAIAFBAnRqKAIAIgEpAgQiBEKAgICAgICAgECDQoCAgICAgICAwABRDQAgAkUNASAEp0GAgICAeEcNACAAKAK8ASEBCyABIAEoAgBBAWo2AgAgAa1CgICAgJB/hAwBCyABIAEoAgBBAWo2AgAgAa1CgICAgIB/hAshBCADQdAAaiQAIAQPC0Hv3wBBrvwAQZgYQYfiABAAAAvrAgECfyAAIAEoAgQQEwNAIAEoAhAhAyACIAEoAhRORQRAIAAgAyACQQN0aigCABATIAJBAWohAgwBCwsgACgCECICQRBqIAMgAigCBBEAAEEAIQIDQAJAIAEoAhwhAyACIAEoAiBODQAgAyACQRRsaiIDKAIIRQRAIAAoAhAgAygCBBDrAQsgACADKAIQEBMgACADKAIMEBMgAkEBaiECDAELCyAAKAIQIgJBEGogAyACKAIEEQAAIAAoAhAiAkEQaiABKAIoIAIoAgQRAABBACECA0AgASgCNCEDIAIgASgCOE5FBEAgACADIAJBDGxqKAIEEBMgAkEBaiECDAELCyAAKAIQIgJBEGogAyACKAIEEQAAIAAgASkDQBAPIAAgASkDSBAPIAAgASkDYBAPIAAgASkDaBAPIAEoAggiAiABKAIMIgM2AgQgAyACNgIAIAFCADcCCCAAKAIQIgBBEGogASAAKAIEEQAACzABAX8gACgCOCABQQJ0aigCACIBIAEoAgAiAkEBazYCACACQQFMBEAgACABEKIDCwvAAQIBfwJ+QX8hAwJAIABCAFIgAUL///////////8AgyIEQoCAgICAgMD//wBWIARCgICAgICAwP//AFEbDQAgAkL///////////8AgyIFQoCAgICAgMD//wBWIAVCgICAgICAwP//AFJxDQAgACAEIAWEhFAEQEEADwsgASACg0IAWQRAIAEgAlIgASACU3ENASAAIAEgAoWEQgBSDwsgAEIAUiABIAJVIAEgAlEbDQAgACABIAKFhEIAUiEDCyADCwoAIABBfHEQpAMLZQEEfwNA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sgEhAyAAIAIQDyAAIAAgA0HdwAAQsgEiAiADQQEgARAhIQQgACACEA8gACADEA8gBAsMACAAIAEpAwAQswELygYCBH8DfiMAQYABayIFJAACQAJAAkAgAyAEQgBCABDtAUUNAAJ/IARC////////P4MhCgJ/IARCMIinQf//AXEiBkH//wFHBEBBBCAGDQEaQQJBAyADIAqEUBsMAgsgAyAKhFALCyEGIAJCMIinIghB//8BcSIHQf//AUYNACAGDQELIAVBEGogASACIAMgBBAuIAUgBSkDECICIAUpAxgiASACIAEQ4wUgBSkDCCECIAUpAwAhBAwBCyABIAJC////////////AIMiCiADIARC////////////AIMiCRDtAUEATARAIAEgCiADIAkQ7QEEQCABIQQMAgsgBUHwAGogASACQgBCABAuIAUpA3ghAiAFKQNwIQQMAQsgBEIwiKdB//8BcSEGIAcEfiABBSAFQeAAaiABIApCAEKAgICAgIDAu8AAEC4gBSkDaCIKQjCIp0H4AGshByAFKQNgCyEEIAZFBEAgBUHQAGogAyAJQgBCgICAgICAwLvAABAuIAUpA1giCUIwiKdB+ABrIQYgBSkDUCEDCyAJQv///////z+DQoCAgICAgMAAhCELIApC////////P4NCgICAgICAwACEIQogBiAHSARAA0ACfiAKIAt9IAMgBFatfSIJQgBZBEAgCSAEIAN9IgSEUARAIAVBIGogASACQgBCABAuIAUpAyghAiAFKQMgIQQMBQsgCUIBhiAEQj+IhAwBCyAKQgGGIARCP4iECyEKIARCAYYhBCAHQQFrIgcgBkoNAAsgBiEHCwJAIAogC30gAyAEVq19IglCAFMEQCAKIQkMAQsgCSAEIAN9IgSEQgBSDQAgBUEwaiABIAJCAEIAEC4gBSkDOCECIAUpAzAhBAwBCyAJQv///////z9YBEADQCAEQj+IIQEgB0EBayEHIARCAYYhBCABIAlCAYaEIglCgICAgICAwABUDQALCyAIQYCAAnEhBiAHQQBMBEAgBUFAayAEIAlC////////P4MgB0H4AGogBnKtQjCGhEIAQoCAgICAgMDDPxAuIAUpA0ghAiAFKQNAIQQMAQsgCUL///////8/gyAGIAdyrUIwhoQhAgsgACAENwMAIAAgAjcDCCAF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QCABQQlrDhIACgsMCgsCAwQFDAsMDAoLBwgJCyACIAIoAgAiAUEEajYCACAAIAEoAgA2AgAPCwALIAIgAigCACIBQQRqNgIAIAAgATIBADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATMBADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATAAADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATEAADcDAA8LAAsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKwMAOQMADwsgACACIAMRAAALDwsgAiACKAIAIgFBBGo2AgAgACABNAIANwMADwsgAiACKAIAIgFBBGo2AgAgACABNQIANwMADwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKQMANwMAC14BBH8gACgCACECA0AgAiwAACIDENECBEBBfyEEIAAgAkEBaiICNgIAIAFBzJmz5gBNBH9BfyADQTBrIgMgAUEKbCIEaiADIARB/////wdzShsFQX8LIQEMAQsLIAEL3BICEn8BfiMAQdAAayIIJAAgCCABNgJMIAhBN2ohFyAIQThqIRICQAJAAkACQANAIAEhDCAHIA5B/////wdzSg0BIAcgDmohDgJAAkACQCAMIgctAAAiCQRAA0ACQAJAIAlB/wFxIgFFBEAgByEBDAELIAFBJUcNASAHIQkDQCAJLQABQSVHBEAgCSEBDAILIAdBAWohByAJLQACIQogCUECaiIBIQkgCkElRg0ACwsgByAMayIHIA5B/////wdzIhhKDQcgAARAIAAgDCAHEFsLIAcNBiAIIAE2AkwgAUEBaiEHQX8hDwJAIAEsAAEiChDRAkUNACABLQACQSRHDQAgAUEDaiEHIApBMGshD0EBIRMLIAggBzYCTEEAIQ0CQCAHLAAAIglBIGsiAUEfSwRAIAchCgwBCyAHIQpBASABdCIBQYnRBHFFDQADQCAIIAdBAWoiCjYCTCABIA1yIQ0gBywAASIJQSBrIgFBIE8NASAKIQdBASABdCIBQYnRBHENAAsLAkAgCUEqRgRAAn8CQCAKLAABIgEQ0QJFDQAgCi0AAkEkRw0AIAFBAnQgBGpBwAFrQQo2AgAgCkEDaiEJQQEhEyAKLAABQQN0IANqQYADaygCAAwBCyATDQYgCkEBaiEJIABFBEAgCCAJNgJMQQAhE0EAIRAM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IAgoAgRBAWsiBzYCBCAEIAlqQRBqIQQgBw0JIAAgACgCMEEBazYCMAwJCyAHCyEFIARBAWohBAwACwALIANBACAEQQFGGw0EQQAhCSADDQAgBEECRg0DCyAAIAU2AjAMAAsACyAJDwsgASAIQRBqIAAoAgxBA3QQHxoLIAgoAgghBSAIKAIMIQQgAiAIIAAoAgxBA3RqQRBqIAgtAAEiA0ECdBAfGiAAIAAoAjBBAWs2AjAMAAsAC4sCAQd/IAFBAnRBwP4DaigCACICIAFBAXRBkIAEai8BAGohCEEAIQECQANAIAIgCE8NASACQQFqIQYCQAJAIAItAAAiBEE/TQRAIAMgBEEDdmpBAWohAiABBEAgACADIAIQfg0DCyABQQFzIQEgBEEHcSACakEBaiEFDAELAn8gAyAEakH/AGsgBMBBAEgNABogBi0AACEFIARB3wBNBEAgAkECaiEGIAMgBEEIdGogBWpB//8AawwBCyACQQNqIQYgAi0AAiADIARBEHRqIAVBCHRqakH///8CawshBSADIQILIAEEQCAAIAIgBRB+DQELIAFBAXMhASAGIQIgBSEDDAELC0F/IQcLIAcLOABBsNQCIAEQrwQiAUEASARAQX4PCyAAIAFBHU0Ef0IBIAGthqcFIAFBAnRB2NgCaigCAAsQoQYLNQEBfyMAQRBrIgMkACADIAE2AgggAyACQQFqNgIMIAAgA0EIakECELEEIQAgA0EQaiQAIAALlwIBA38gASgCACICQf7/B08EQCAAQYY7QQAQOkF/DwsCQCACQQFNBEAgAEECQX8QuAEaDAELIAEoAgggAkECdGoiBEEEaygCACIDQX9GBEAgBEEIaygCACEDCyACQQF2IQIgA0H//wNNBEAgAEEVIAIQsgRBACECA0AgAiABKAIATg0CIAAgAkECdCIDIAEoAghqLwEAECogAEF/IAEoAgggA0EEcmooAgBBAWsiAyADQX5GG0H//wNxECogAkECaiECDAALAAsgAEEWIAIQsgRBACECA0AgAiABKAIATg0BIAAgAkECdCIDIAEoAghqKAIAEB0gACABKAIIIANBBHJqKAIAQQFrEB0gAkECaiECDAALAAtBAAsmAQF/IAAoAjgiAUEASARAIAAgACAAQTxqQQAQqwYiATYCOAsgAQvgAgEFfyMAQZABayIEJAAg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IgMgAkohBEKAgICAECEBIAMhAiAERQ0BDAILIAYoAgwgBWsiAyECC0KAgICAECEBIANBAEggAiADSHINAANAIAkgByADQQAgBRCzA0UEQEKBgICAECEBDAILIAIgA0chBCADQQFqIQMgBA0ACwsgACAKEA8gACALEA8LIAZBEGokACABC7ADAwd/AXwBfiMAQRBrIgUkAAJAIAAgARBZIgFCgICAgHCDQoCAgIDgAFENAAJAAkAgACADKQMAECgiDUKAgICAcINCgICAgOAAUQ0AIA2nIgkoAgRB/////wdxIQYgAaciCigCBEH/////B3EhBwJAIAQEQCAFIAcgBmsiCzYCDEF/IQhBACEEIAJBAkgNASAAIAUgAykDCBBCDQIgBSsDACIMvUL///////////8Ag0KAgICAgICA+P8AVg0BIAxEAAAAAAAAAABlBEAgBUEANgIMDAILIAwgC7djRQ0BIAUCfyAMmUQAAAAAAADgQWMEQCAMqgwBC0GAgICAeAs2AgwMAQsgBUEANgIMIAJBAk4EQCAAIAVBDGogAykDCCAHQQAQVw0CCyAHIAZrIQRBASEIC0F/IQIgBiAHSw0BIAQgBSgCDCIDayAIbEEASA0BA0AgCiAJIANBACAGELMDRQRAIAMhAgwDCyADIARGDQIgAyAIaiEDDAALAAsgACABEA8gACANEA9CgICAgOAAIQEMAQsgACABEA8gACANEA8gAq0hAQsgBUEQaiQAIAELkwECAX4BfyMAQRBrIgIkAEKAgICA4AAhBAJAIAAgARBZIgFCgICAgHCDQoCAgIDgAFEEQCABIQQMAQsCQCAAIAJBDGogAykDABC6AQ0AQoCAgIAwIQQgAigCDCIDQQBIDQAgAyABpyIFKAIEQf////8HcU8NACAFIAJBDGoQyQGtIQQLIAAgARAPCyACQRBqJAAgBAtpAgJ/AX4gACABEFkhAQNAIAIgBEwgAUKAgICAcINCgICAgOAAUXJFBEAgAyAEQQN0aikDACIGQiCIp0F1TwRAIAanIgUgBSgCAEEBajYCAAsgBEEBaiEEIAAgASAGEMQCIQEMAQsLIAELyAECAX4BfyMAQRBrIgIkAEKAgICA4AAhBAJAIAAgARBZIgFCgICAgHCDQoCAgIDgAFEEQCABIQQMAQsCQCAAIAJBDGogAykDABC6AQ0AAkAgAigCDCIDQQBOBEAgAyABpyIFKQIEIgSnQf////8HcUkNAQsgAEEvEC0hBAwBCyAFQRBqIQUgAAJ/IARCgICAgAiDUEUEQCAFIANBAXRqLwEADAELIAMgBWotAAALQf//A3EQnwMhBAsgACABEA8LIAJBEGokACAEC7gBAgJ+AX8jAEEQayICJABCgICAgOAAIQQCQCAAIAEQWSIBQoCAgIBwg0KAgICA4ABRBEAgASEEDAELAkAgACACQQxqIAMpAwAQugENAEKAgICAwH4hBCACKAIMIgNBAEgNACADIAGnIgYpAgQiBadB/////wdxTw0AIAZBEGohBiAFQoCAgIAIg1BFBEAgBiADQQF0ajMBACEEDAELIAMgBmoxAAAhBAsgACABEA8LIAJBEGokACAEC+MBAgF+An8jAEEQayICJAACQCAAIAFBLRBLIgNFBEAgBEEANgIAQoCAgIDgACEBDAELQoCAgIAwIQECQCADKQMAIgZCgICAgHCDQoCAgIAwUgRAIAIgAygCDCIFNgIMIAUgBqciBygCBEH/////B3FJDQEgACAGEA8gA0KAgICAMDcDAAsgBEEBNgIADAELIAcgAkEMahDJASEIIAMgAigCDDYCDCAEQQA2AgAgCEH//wNNBEAgACAIQf//A3EQnwMhAQwBCyAAIAcgBUEBdGpBEGpBAhDuAyEBCyACQRBqJAAgAQs3ACMAQRBrIgIkACAAIAJBDGogAykDABB3IQAgAigCDCEDIAJBEGokAEKAgICA4AAgA2etIAAbC04AIwBBEGsiAiQAQoCAgIDgACEBAkAgACACQQxqIAMpAwAQdw0AIAAgAkEIaiADKQMIEHcNACACKAIIIAIoAgxsrSEBCyACQRBqJAAgAQsGACAAtrsLfwAgACAAKQPQASIBQgyIIAGFIgFCGYYgAYUiAUIbiCABhSIBNwPQAUKAgICAwH4gAUKdurP7lJL9oiV+QgyIQoCAgICAgID4P4S/RAAAAAAAAPC/oL0iAUKAgICAwIGA/P8AfSABQv///////////wCDQoCAgICAgID4/wBWGwujBAMDfAV/A34jAEEQayIIJAAgCEIANwMIAkACQCACQQBMDQBCgICAgOAAIQEgACAIQQhqIAMpAwAQQg0BQQEhCSAIKwMIIQQgAkEBRwRAA0AgAiAJRg0CIAAgCCADIAlBA3RqKQMAEEINAyAJQQFqIQkgCCsDACEFIwBBIGsiByQAIAS9Qv///////////wCDIg0gBb1C////////////AIMiDCAMIA1WGyIOvyEEAkAgDkI0iKciCkH/D0YNACANIAwgDCANVBsiDL8hBQJAIA5QDQAgDEI0iKciC0H/D0YNACALIAprQcEATgRAIAUgBKAhBAwCCwJ8IAtB/gtPBEAgBEQAAAAAAAAwFKIhBCAFRAAAAAAAADAUoiEFRAAAAAAAALBrDAELRAAAAAAAAPA/IApBvARLDQAaIAREAAAAAAAAsGuiIQQgBUQAAAAAAACwa6IhBUQAAAAAAAAwFAshBiAHQRhqIAdBEGogBRCKBiAHQQhqIAcgBBCKBiAGIAcrAwAgBysDEKAgBysDCKAgBysDGKCfoiEEDAELIAUhBAsgB0EgaiQADAALAAsgBJkhBAsgBL0iAQJ/IASZRAAAAAAAAOBBYwRAIASqDAELQYCAgIB4CyIAt71RBEAgAK0hAQwBC0KAgICAwH4gAUKAgICAwIGA/P8AfSABQv///////////wCDQoCAgICAgID4/wBWGyEBCyAIQRBqJAAgAQtOACAAIABEAAAAAAAA8L9EAAAAAAAA8D8gAEQAAAAAAAAAAGMbIAC9Qv///////////wCDQoCAgICAgID4/wBWGyAARAAAAAAAAAAAYRsLQwACfCABvUKAgICAgICA+P8Ag0KAgICAgICA+P8AUQRARAAAAAAAAPh/IACZRAAAAAAAAPA/YQ0BGgsgACABEI8DCwuDAQICfgF/IAC9IgFCNIinQf8PcSIDQf4HTQRAIAFCgICAgICAgICAf4MhAiADQf4HRyABQoCAgICAgIDwv39RckUEQCACQoCAgICAgID4P4S/DwsgAr8PCyADQbIITQR8IAFCP4cgAXxCAUGzCCADa62GIgFCAYh8QgAgAX2DvwUgAAsLggUDAnwFfwF+IwBBEGsiCSQAAn5CgICAgMD+//v/AEKAgICAwP7/eyAEGyACRQ0AGgJ8IAMpAwAiAUL/////D1gEQEEBIAIgAkEBTBshCiABpyEIQQEhBwNAIAcgCkcEQCAItyADIAdBA3RqKQMAIgFCgICAgBBaDQMaIAggAaciCyAIIAtKGyAIIAsgCCALSBsgBBshCCAHQQFqIQcMAQsLIAitDAILQoCAgIDgACAAIAlBCGogARBCDQEaQQEhByAJKwMICyEFIAcgAiACIAdIGyECA0AgAiAHRwRAQoCAgIDgACAAIAkgAyAHQQN0aikDABBCDQIaAkAgBb0iDEL///////////8Ag0KAgICAgICA+P8AVg0AIAkrAwAiBr0iAUL///////////8Ag0KAgICAgICA+P8AVgRAIAYhBQwBCyAFRAAAAAAAAAAAYSAGRAAAAAAAAAAAYXEhCiAEBEAgCgRAIAEgDIO/IQUMAgsgBSAFIAalIAa9Qv///////////wCDQoCAgICAgID4/wBWGyAGIAW9Qv///////////wCDQoCAgICAgID4/wBYGyEFDAELIAoEQCABIAyEvyEFDAELIAUgBSAGpCAGvUL///////////8Ag0KAgICAgICA+P8AVhsgBiAFvUL///////////8Ag0KAgICAgICA+P8AWBshBQsgB0EBaiEHDAELCyAFvSIBAn8gBZlEAAAAAAAA4EFjBEAgBaoMAQtBgICAgHgLIgC3vVEEQCAArQwBC0KAgICAwH4gAUKAgICAwIGA/P8AfSABQv///////////wCDQoCAgICAgID4/wBWGwshASAJQRBqJAAgAQstAEKAgICA4AAgACADKQMAIAMpAwhBABCLAiIAQQBHrUKAgICAEIQgAEEASBsLoAEBA34gAykDACIFIQQgAkEETgRAIAMpAxghBAsgBUL/////b1gEQCAAECRCgICAgOAADwsgAykDECEBQoCAgIDgACEGAkAgACADKQMIEDEiAkUNACABQiCIp0F1TwRAIAGnIgMgAygCAEEBajYCAAsgACAFIAIgASAEQQAQhgQhAyAAIAIQEyADQQBIDQAgA0EAR61CgICAgBCEIQYLIAYLjwEAAkACQCADKQMAIgFC/////29YBEAgBARAIAAQJAwDCyABQiCIp0F1SQ0BIAGnIgAgACgCAEEBajYCACABDwsgACABELYDIgJBAEgNASAEBEAgAkEAR61CgICAgBCEDwsgAkUEQCAAQfjiAEEAEBUMAgsgAaciACAAKAIAQQFqNgIACyABDwtCgICAgOAACyoAIAMpAwAiAUL/////b1gEQCAAECRCgICAgOAADwsgACABQQNBABCqAgtPAAJAAkAgAykDACIBQv////9vWARAIARFBEBCgICAgBAPCyAAECQMAQsgACABEJkBIgBBAE4NAQtCgICAgOAADwsgAEEAR61CgICAgBCEC2MBAX4gAykDACIEQv////9vWARAIAAQJEKAgICA4AAPC0KAgICA4AAhAQJAIAAgAykDCBAxIgJFDQAgACAEIAIQcSEDIAAgAhATIANBAEgNACADQQBHrUKAgICAEIQhAQsgAQs2ACADKQMAIgFCIIinIgJBf0YgBEUgAkF+cUECR3FyRQRAIAAQJEKAgICA4AAPCyAAIAEQ6AELYwECfgJAAkAgAykDACIBQv////9vWARAIAAQJAwBCyADKQMIIQUgASEEIAJBA04EQCADKQMQIQQLIAAgBRAxIgINAQtCgICAgOAADwsgACABIAIgBEEAEBQhASAAIAIQEyABC2YBAX4gAykDACIEQv////9vWARAIAAQJEKAgICA4AAPC0KAgICA4AAhAQJAIAAgAykDCBAxIgJFDQAgACAEIAJBABDVASEDIAAgAhATIANBAEgNACADQQBHrUKAgICAEIQhAQsgAQuLAQECfiADKQMAIgFC/////29YBEAgABAkQoCAgIDgAA8LIAMpAxAhBkKAgICA4AAhBQJAIAAgAykDCBAxIgJFDQAgACABIAIgBiAERUEOdBDHBCEDIAAgAhATIANBAEgNACAEBEAgA0EAR61CgICAgBCEDwsgAaciACAAKAIAQQFqNgIAIAEhBQsgBQuaAQIBfwJ+IwBBEGsiBCQAIAMpAwghBSADKQMAIgYhAQJAAkACQAJAIAJBA0gNACADKQMQIgFCgICAgHBaBEAgAactAAVBEHENAQsgAEGiPkEAEBUMAQsgACAEQQxqIAUQiQQiAg0BC0KAgICA4AAhAQwBCyAAIAYgASAEKAIMIgMgAhCQAyEBIAAgAiADEJsDCyAEQRBqJAAgAQsVACAAIAMpAwAgAyADQQhqQQIQnQMLVgIBfgF/IAAgARC0AyIBQoCAgIBwg0KAgICA4ABRBEAgAQ8LQoCAgIAwIQIgAaciAygCBEGAgICAeEcEQCAAIAAoAhAgAxDBAhAtIQILIAAgARAPIAILCQAgACABELQDC1sBAX4jAEEQayICJAAgAiAAIAEQtAMiATcDCAJAIAFCgICAgHCDQoCAgIDgAFEEQCABIQQMAQsgAEKAgICAMEEBIAJBCGoQlwYhBCAAIAEQDwsgAkEQaiQAIAQLfgEBfiADKQMAIgFCgICAgHCDQoCAgICAf1IEQCAAQfbSAEEAEBVCgICAgOAADwtCgICAgDAhBCABpyIAKQIEQoCAgICAgICAQINCgICAgICAgICAf1EEfiAAIAAoAgBBAWo2AgAgAUL/////D4NCgICAgJB/hAVCgICAgDALCzwBAX5CgICAgOAAIQEgACADKQMAECgiBEKAgICAcINCgICAgOAAUgR+IAAgBKdBAhCABAVCgICAgOAACwuBBAIBfgF/AkACQAJAAkACQCABQoCAgIBwWgRAIAGnIgIvAQZBL0YNAQsgBEEBNgIADAELIAIoAiAhAiAEQQE2AgAgAg0BCyAAQbY/QQAQFQwBCwJAAkACQAJAAkACQAJAAkAgAigCACIHQQFrDgQCAgcBAAsgBUUNAiAAKAIQIAIQtQMLQoCAgIAwIQEgBUEBaw4CAwQHCyADKQMAIgFCIIinQXVPBEAgAaciAyADKAIAQQFqNgIACwJAIAVBAkcNAEEBIQMgB0EBRw0AIAAgARCKAQwCCyACKAJEIgMgBa03AwAgA0EIayABNwMAIAIgA0EIajYCRAtBACEDCyACQQM2AgAgAiADNgIUIAAgAkEIahC0AiEBIAJBATYCACABQoCAgIBwg0KAgICA4ABRBEAgACgCECACELUDIAEPCyACKAJEQQhrIgMpAwAhBiADQoCAgIAwNwMAIAFC/////w9YBEAgAUICUQRAIAJBAjYCACAEQQI2AgAgBg8LIARBADYCACAGDwsgACABEA8gACgCECACELUDIAYPCyADKQMAIgFCIIinQXVJDQMgAaciACAAKAIAQQFqNgIAIAEPCyADKQMAIgFCIIinQXVPBEAgAaciAiACKAIAQQFqNgIACyAAIAEQigEMAQsgAEGUP0EAEBULQoCAgIDgACEBCyABC+8BAQN+IwBBEGsiAiQAQoCAgIDgACEEAkAgACAAIAEQJSIBQQEQkAIiBUKAgICAcINCgICAgOAAUQ0AIAVCIIinIgNBACADQQtqQRJJG0UEQCAAIAJBCGogBRBCQQBIDQFCgICAgCAhBCACKQMIQoCAgICAgID4/wCDQoCAgICAgID4/wBRDQELQoCAgIDgACEEIAAgAUG/3AAQsgEiBkKAgICAcINCgICAgOAAUQ0AIAAgBhA4RQRAIABB7PEAQQAQFSAAIAYQDwwBCyAAIAYgAUEAQQAQLyEECyAAIAEQDyAAIAUQDyACQRBqJAAgBAuNAgIBfAF+IwBBEGsiAiQAQoCAgIDgACEFAkAgACACQQhqIAEQmwINACAAIAJBCGogAykDABBCDQAgAgJ+IAIrAwgiBL0iBUKAgICAgICA+P8Ag0KAgICAgICA+P8AUgRAIASdIgREAAAAAACwnUCgIAQgBEQAAAAAAABZQGMbIAQgBEQAAAAAAAAAAGYbIgS9IQULAn8gBJlEAAAAAAAA4EFjBEAgBKoMAQtBgICAgHgLIgO3vSAFUQRAIAOtDAELQoCAgIDAfiAFQoCAgIDAgYD8/wB9IAVC////////////AINCgICAgICAgPj/AFYbCzcDACAAIAFBASACQREQyAQhBQsgAkEQaiQAIAULiQECAX4BfCMAQRBrIgIkAEKAgICA4AAhBAJAIAAgAkEIaiABEJsCDQAgACACQQhqIAMpAwAQQg0AIAAgASACKwMIIgWdRAAAAAAAAAAAoEQAAAAAAAD4fyAFRAAA3MIIsj5DZRtEAAAAAAAA+H8gBUQAANzCCLI+w2YbEMkEIQQLIAJBEGokACAEC9cBAQF8IwBB0ABrIgIkAAJ+QoCAgIDgACAAIAEgAiAEQQ9xQQAQtwMiAEEASA0AGkKAgICAwH4gAEUNABogBEGAAnEEQCACIAIrAwBEAAAAAACwncCgOQMACyACIARBBHZBD3FBA3RqKwMAIgW9IgECfyAFmUQAAAAAAADgQWMEQCAFqgwBC0GAgICAeAsiBLe9UQRAIAStDAELQoCAgIDAfiABQoCAgIDAgYD8/wB9IAFC////////////AINCgICAgICAgPj/AFYbCyEBIAJB0ABqJAAgAQuFAQEBfCMAQRBrIgIkAAJ+QoCAgIDgACAAIAJBCGogARCbAg0AGkKAgICAwH4gAisDCCIEvUL///////////8Ag0KAgICAgICA+P8AVg0AGgJ+IASdIgSZRAAAAAAAAOBDYwRAIASwDAELQoCAgICAgICAgH8LELgDrQshASACQRBqJAAgAQuGAQEBfgJAIAFC/////29YBEAgABAkDAELAkAgAykDACIEQoCAgIBwg0KAgICAkH9SDQAgACAEEDEiAkUNASAAIAIQE0ERIQMCQAJAAkAgAkHGAGsOBgIDAQMDAgALIAJBFkcNAgtBECEDCyAAIAEgAxCQAg8LIABBtitBABAVC0KAgICA4AALlgEBAXwjAEEQayICJAACfkKAgICA4AAgACACQQhqIAEQmwINABogAisDCCIEvSIBAn8gBJlEAAAAAAAA4EFjBEAgBKoMAQtBgICAgHgLIgC3vVEEQCAArQwBC0KAgICAwH4gAUKAgICAwIGA/P8AfSABQv///////////wCDQoCAgICAgID4/wBWGwshASACQRBqJAAgAQvsAgIDfwF8IwBB0ABrIgQkACAEQRBqQQBBOBArGiAEQoCAgICAgID4PzcDIEKAgICAwH4hAQJAIAJFDQBBByACIAJBB04bIgJBACACQQBKGyECA0AgAiAFRwRAIAAgBEEIaiADIAVBA3QiBmopAwAQQgRAQoCAgIDgACEBDAMLIAQrAwgiB71CgICAgICAgPj/AINCgICAgICAgPj/AFENAiAEQRBqIAZqIAedOQMAAkAgBQ0AIAQrAxAiB0QAAAAAAAAAAGZFIAdEAAAAAAAAWUBjRXINACAEIAdEAAAAAACwnUCgOQMQCyAFQQFqIQUMAQsLIARBEGpBABDgAiIHvSIBAn8gB5lEAAAAAAAA4EFjBEAgB6oMAQtBgICAgHgLIgW3vVEEQCAFrSEBDAELQoCAgIDAfiABQoCAgIDAgYD8/wB9IAFC////////////AINCgICAgICAgPj/AFYbIQELIARB0ABqJAAgAQtWABDQBCIBQoCAgIAIfEL/////D1gEQCABQv////8Pgw8LQoCAgIDAfiABub0iAUKAgICAwIGA/P8AfSABQv///////////wCDQoCAgICAgID4/wBWGwsIAEKAgICAMAuqHQIGfwR+IwBB0ABrIgYkAAJAAkAgAEEQaiIDQYgCIAAoAgARAwAiAUUNACABQQVqQQBBgwIQKxogAUEFOgAEIAFBATYCACAAKAJQIgQgAUEIaiIFNgIEIAEgAEHQAGo2AgwgASAENgIIIAAgBTYCUCABIAMgACgCQEEDdCAAKAIAEQMAIgQ2AiggBEUEQCADIAEgACgCBBEAAAwBCyABIAA2AhAgACgCSCIDIAFBFGoiBTYCBCABIABByABqNgIYIAEgAzYCFCAAIAU2AkggAULxgICAgDk3AtwB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aiAAIAFB1QAgAUEAEBQQowENACAAIAVB1QACfiACKQMIIgFCgICAgAh8Qv////8PWARAIAFC/////w+DDAELQoCAgIDAfiABub0iAUKAgICAwIGA/P8AfSABQv///////////wCDQoCAgICAgID4/wBWGwsQRUEASA0AQoCAgIDgACEIIABBLhB2IgFCgICAgHCDQoCAgIDgAFENACAAQSAQKSIDRQRAIAEhCAwBCyADIAk3AwggAyAFNwMAIAMgBKciCkHnAEEAEMcBQX9zQR92NgIQIApB9QBBABDHASEKIANBADYCGCADIApBf3NBH3Y2AhQgAUKAgICAcFoEQCABpyADNgIgCyAAIAYQDyAAIAQQDyABIQcMAQsgACAJEA8gACAGEA8gACAEEA8gACAFEA8gACAIEA8LIAJBIGokACAHC74EAgd+An8jAEEQayICJAACQCABQv////9vWARAIAAQJEKAgICA4AAhBgwBC0KAgICA4AAhBkKAgICAMCEFAkAgAAJ+AkAgACADKQMAECgiB0KAgICAcINCgICAgOAAUQ0AIAAgACABQe4AIAFBABAUECYiA0EASA0AIANFBEAgACABIAcQyAEhBgwDCyAAIAAgAUHvACABQQAQFBAmIgtBAEgNACAAIAFB1QBCABBFQQBIDQBCgICAgOAAIAAQPiIIQoCAgIBwg0KAgICA4ABRDQEaIAenIQwCQANAIAAgBRAPIAAgASAHEMgBIgVCgICAgHCDIgRCgICAgCBRDQECQCAEQoCAgIDgAFENAAJ/IAAgACAFQgAQTRA3IgRCgICAgHCDIgpCgICAgJB/UgRAQQAgCkKAgICA4ABSDQEaDAILIASnKAIEQf////8HcUULIQMgACAIIAkgBBCGAUEASA0AIAlCAXwhCSADRQ0BIAAgAkEIaiAAIAFB1QAgAUEAEBQQowFBAEgNACAAIAFB1QACfiAMIAIpAwggCxDxAiIEQoCAgIAIfEL/////D1gEQCAEQv////8PgwwBC0KAgICAwH4gBLm9IgRCgICAgMCBgPz/AH0gBEL///////////8Ag0KAgICAgICA+P8AVhsLEEVBAE4NAQsLIAgMAgsgCacEQCAIIQYMAwsgACAIEA9CgICAgCAhBgwCC0KAgICAMAsQDwsgACAFEA8gACAHEA8LIAJBEGokACAG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/////w+DEGpBAEgNDSADRQRAIAkgCSgCAEEBajYCAAsgACABIAZBAWqtIBQQakEASA0NIA5CgICAgDBSBEAgEUIgiKdBdU8EQCARpyICIAIoAgBBAWo2AgALIAAgASAGQQJqrSAREGpBAEgNDgsgBCABNwNYIARCgICAgDA3A1AgACATEA8gACAAIBkgBCAEQdAAakEAEJ0DEDchEwwBC0KAgICAMCEVIA5CgICAgDBSBEAgACARECUiFUKAgICAcINCgICAgOAAUQ0NCyAEIBc3A3ggBCAVNwNwIAQgATcDaCAEIBQ3A1ggBCAPNwNQIAQgEkL/////D4M3A2AgACATEA8gACAEQdAAahDtBCETIAAgFRAPCyATQoCAgIBwg0KAgICA4ABRDQsgB6wgElcEQCAEQThqIgIgCSAHIBKnEFEaIAIgExCHARogD6cpAgRC/////weDIBJ8pyEHCyAFQQFqIQUMAQsLIARBOGoiAiAJIAcgCSgCBEH/////B3EQURogAhA2IRAMCgsgACAPEA9CgICAgDAhEwJAAn8CQCAAIAAgEkIAEE0QNyIPQoCAgIBwgyIOQoCAgICQf1IEQCAOQoCAgIDgAFINASAOIRAMAwsgD6coAgRB/////wdxDQAgACAEQdAAaiAAIAFB1QAgAUEAEBQQowFBAEgNAiAAIAFB1QACfiAJIAQpA1AgDRDxAiIOQoCAgIAIfEL/////D1gEQCAOQv////8PgwwBC0KAgICAwH4gDrm9Ig5CgICAgMCBgPz/AH0gDkL///////////8Ag0KAgICAgICA+P8AVhsLEEUiAkEATg0AIAJBHnZBAnEMAQtBAAtFDQELCwwCCwwGC0KAgICAMCETC0KAgICAMCEBDAQLIARB0ABqIAsgCCALKAIEQf////8HcRBRDQAgACASEA8gACgCECICQRBqIAMgAigCBBEAACAEQdAAahA2IRAMAQsgACASEA8gACgCECICQRBqIAMgAigCBBEAACAEKAJQKAIQIgJBEGogBCgCVCACKAIEEQAAC0KAgICAMCERC0KAgICAMCETQoCAgIAwIQFCgICAgDAhDwsgBCgCOCgCECICQRBqIAQoAjwgAigCBBEAAAsgBBDuBCAAIBcQDyAAIA8QDyAAIAEQDyAAIBMQDyAAIBEQDyAAIBQQDwsgBEGQAWokACAQC6IBACMAQSBrIgIkAAJ+AkAgAUL/////b1gEQCAAECQMAQsgACACQQhqIgNBABA9GiADQS8QOxoCQCADIAAgAUHsACABQQAQFBB/DQAgAkEIaiIDQS8QOxogAyAAIAFB7QAgAUEAEBQQfw0AIAJBCGoQNgwCCyACKAIIKAIQIgBBEGogAigCDCAAKAIEEQAAC0KAgICA4AALIQEgAkEgaiQAIAELTgECfkKAgICA4AAhBCAAIAEgAykDABDIASIBQoCAgIBwgyIFQoCAgIDgAFIEfiAAIAEQDyAFQoCAgIAgUq1CgICAgBCEBUKAgICA4AALC/gCAgN+AX8CQAJAIAAgARDwAiICRQ0AIAMpAwghBgJAAkACQCADKQMAIgRCgICAgHBUDQAgBKciAy8BBkESRw0AIAZCgICAgHCDQoCAgIAwUgRAIABBnvkAQQAQFUKAgICA4AAPCyADKAIgIgcgBygCAEEBajYCACADKAIkIgMgAygCAEEBajYCACAHrUKAgICAkH+EIQQgA61CgICAgJB/hCEFDAELQoCAgIAwIQUCfiAEQoCAgIBwg0KAgICAMFEEQCAAQS8QLQwBCyAAIAQQKAsiBEKAgICAcINCgICAgOAAUQ0BIAAgBCAGEJgEIgVCgICAgHCDQoCAgIDgAFENAQsgACACNQIAQoCAgICQf4QQDyAAIAI1AgRCgICAgJB/hBAPIAIgBT4CBCACIAQ+AgAgACABQdUAQgAQRUEASA0BIAFCIIinQXVJDQIgAaciACAAKAIAQQFqNgIADAILIAAgBBAPIAAgBRAPC0KAgICA4AAPCyABC2oBAX8gAUL/////b1gEQCAAECRCgICAgOAADwsCfiABpyIDLwEGQRJHBEBCgICAgDAgACABIAAoAigpA5ABEFINARogAEESEIYDQoCAgIDgAA8LIAMoAiQtABAgAnFBAEetQoCAgIAQhAsLvQQBCX8jAEEgayIHJAACQAJAAkACQAJAIAFC/////29YBEAgABAkDAELIAAgASAAKAIoKQOQARBSDQIgACABEPACIgINAQtCgICAgOAAIQEMAwsgAigCACIIKAIEIgJB/////wdxIgMNAQsgAEH+kwEQYiEBDAELIAAgB0EIaiADIAJBH3YQigMaIAhBEGohBiAIKAIEQf////8HcSEJQQAhAANAAkACQCAAIAlIBEAgAEEBaiECQX8hBQJAAn8CQAJAAkACQAJAAkACQAJ/IAgpAgRCgICAgAiDIgFQIgpFBEAgBiAAQQF0ai8BAAwBCyAAIAZqLQAACyIDQdsAaw4DAwECAAsgAiEAAkAgA0EKaw4EBAsLBQALIANBL0cNByAERQ0FQQEhBEEvIQMMBwtB3AAhAyACIAlODQYgAEECaiEAIApFBEAgBiACQQF0ai8BACEFDAoLIAIgBmotAAAhBQwJC0EAIQRB3QAhAwwFC0HbACEDIAQgAiAJTnINBiAAQQJqIQAgAVAEQEHdAEF/IAIgBmotAABB3QBGIgQbIQUgACACIAQbIQBBASEEDAgLQQEhBEHdAEF/IAYgAkEBdGovAQBB3QBGIgobIQUgACACIAobIQAMBwtB7gAMAgtB8gAMAQtBACEEQS8LIQVB3AAhAwsgAiEADAILIAdBCGoQNiEBDAMLIAIhAEEBIQQLIAdBCGogAxCLARogBUEASA0AIAdBCGogBRCLARoMAAsACyAHQSBqJAAgAQvWAgIDfwF+IwBBEGsiBCQAAkAgAUL/////b1gEQCAAECRCgICAgOAAIQUMAQtCgICAgOAAIQUgACAAIAFB7gAgAUEAEBQQJiICQQBIDQAgAgR/IARB5wA6AAggBEEJagUgBEEIagshAiAAIAAgAUHr4wAQsgEQJiIDQQBIDQAgAwRAIAJB6QA6AAAgAkEBaiECCyAAIAAgAUGL5QAQsgEQJiIDQQBIDQAgAwRAIAJB7QA6AAAgAkEBaiECCyAAIAAgAUH01AAQsgEQJiIDQQBIDQAgAwRAIAJB8wA6AAAgAkEBaiECCyAAIAAgAUHvACABQQAQFBAmIgNBAEgNACADBEAgAkH1ADoAACACQQFqIQILIAAgACABQfsdELIBECYiA0EASA0AIAAgBEEIaiIAIAMEfyACQfkAOgAAIAJBAWoFIAILIABrEJMCIQULIARBEGokACAFC6UDAQR+IwBBEGsiAyQAIAQCfwJAAkACQAJAIAAgAUEuEEsiAkUEQEKAgICAMCEBDAELIAIoAhgEQEKAgICAMCEBQQEMBQsgACACKQMAIgggAikDCCIGEMgBIgFCgICAgHCDIgdCgICAgOAAUg0BC0KAgICAMCEHDAELIAdCgICAgCBRBEAgAkEBNgIYQoCAgIAwIQFBAQwDCyACKAIQBEAgACAAIAFCABBNEDciB0KAgICAcIMiCUKAgICA4ABRDQECQCAJQoCAgICQf1INACAHpygCBEH/////B3ENACAAIANBCGogACAIQdUAIAhBABAUEKMBQQBIDQIgACAIQdUAAn4gBqcgAykDCCACKAIUEPECIgZCgICAgAh8Qv////8PWARAIAZC/////w+DDAELQoCAgIDAfiAGub0iBkKAgICAwIGA/P8AfSAGQv///////////wCDQoCAgICAgID4/wBWGwsQRUEASA0CCyAAIAcQDwwCCyACQQE2AhgMAQsgACABEA8gACAHEA9CgICAgOAAIQELQQALNgIAIANBEGokACABCw4AIAAQtQJCgICAgOAACwkAQoCAgIDAfgsWACAAIAMpAwAgAykDCCADKQMQEJQEC9EBAgN+An8jAEEQayIHJAACQCAAIAdBDGogAykDABDlASIIRQRAQoCAgIDgACEEDAELIAAgCCAHKAIMQdKIARD1BSEBIAAgCBBUAkAgAkECSCABQoCAgIBwg0KAgICA4ABRcg0AIAAgAykDCCIGEDhFDQBCgICAgOAAIQQCQCAAEDQiBUKAgICAcINCgICAgOAAUQRAIAEhBQwBCyAAIAVBLyABQQcQGUEASA0AIAAgBUEvIAYQ+QQhBAsgACAFEA8MAQsgASEECyAHQRBqJAAgBAsNACAAIAEgAkEwEP0FCwsAIAAgAUEwEP4FC7QDAgN/An4jAEHQAGsiBiQAQX8hBwJAIAAgBkHIAGogAUHCABCBASIIRQ0AIAYpA0giAUKAgICAcINCgICAgDBRBEAgCCkDACEBIANCIIinQXVPBEAgA6ciByAHKAIAQQFqNgIACyAAIAEgAiADIAQgBRCGBCEHDAELIAAgAhBcIglCgICAgHCDQoCAgIDgAFEEQCAAIAEQDwwBCyAIKQMAIQogBiAENwM4IAYgAzcDMCAGIAk3AyggBiAKNwMgIAAgASAIKQMIQQQgBkEgahAvIQEgACAJEA8gAUKAgICAcINCgICAgOAAUQ0AAkACQCAAIAEQJiIHBEAgACAGIAgoAgAgAhBMIgJBAEgNASACRQ0DAkAgBigCACICQRNxRQRAIAAgBikDCCADEFJFDQEMBAsgAkERcUEQRw0DIAY1AhxCIIZCgICAgDBSDQMLIAAgBhBI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gICAwH4gALi9IgFCgICAgMCBgPz/AH0gAUL///////////8Ag0KAgICAgICA+P8AVhsLOQEBfkKAgICAwH4gASkDACICQoCAgIDAgYD8/wB9IAJC////////////AINCgICAgICAgPj/AFYbCzsBAX5CgICAgMB+IAEqAgC7vSICQoCAgIDAgYD8/wB9IAJC////////////AINCgICAgICAgPj/AFYbCwwAIAAgASkDABD7AwsMACAAIAEpAwAQhwILSQEBfiABKAIAIgBBAE4EQCAArQ8LQoCAgIDAfiAAuL0iAkKAgICAwIGA/P8AfSACQv///////////wCDQoCAgICAgID4/wBWGwsHACABNQIACwcAIAEzAQALDgAgATIBAEL/////D4MLCQAgABC1AkF/Cw4AIAEwAABC/////w+DCwcAIAExAAALDwAgACsDACABKwMAEP0ECxEAIAAqAgC7IAEqAgC7EP0ECxkBAn4gASkDACIDIAApAwAiBFQgAyAEVmsLGQECfiABKQMAIgMgACkDACIEUyADIARVawsXACABKAIAIgEgACgCACIASSAAIAFJawsXACABKAIAIgEgACgCACIASCAAIAFIawsNACAALwEAIAEvAQBrCw0AIAAuAQAgAS4BAGsLDQAgACwAACABLAAAawsNACAALQAAIAEtAABrC8wNBAd/AXwBfgF9IwBBIGsiBiQAQoCAgIDgACENAkAgACABEJIBIgpBAEgNAEF/IQUCQAJAAkAgCkUNAEEBIQgCQAJAIARBAUYEQEF/IQggBiAKQQFrIgU2AhwgAkECSA0BIAAgBkEIaiADKQMIEEINBiAGKwMIIgy9Qv///////////wCDQoGAgICAgID4/wBaBEAgBkEANgIcDAILIAxEAAAAAAAAAABmBEAgDCAFt2NFDQIgBgJ/IAyZRAAAAAAAAOBBYwRAIAyqDAELQYCAgIB4CzYCHAwCC0F/IQUgDCAKt6AiDEQAAAAAAAAAAGMNBCAGAn8gDJlEAAAAAAAA4EFjBEAgDKoMAQtBgICAgHgLNgIcDAELIAZBADYCHCACQQJIBEAgCiECDAILIAAgBkEcaiADKQMIIAoiAiACEFcNBQwBC0F/IQILIAGnIgkoAiAoAgwoAiAtAAQEQEF/IQUgBEF/Rw0CQX9BACADNQIEQiCGQoCA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IA1CgICAgDBBBCAFQRBqECEhCiAAIAsQDyAAIA8QDyAFQoCAgIAwNwM4IApCgICAgHCDQoCAgIDgAFENASAAIAkQDyAKIQkLIAhCAXwhCAwBCwsgBSAJNwMwIAUpAzghCwsgACAFKQMwEA8gACALEA9CgICAgOAAIQkLIAAgARAPIAVBQGskACAJC6wIAgN/CX4jAEEwayIFJABCgICAgDAhCSAFQoCAgIAwNwMoAkACQAJAAkAgBEEIcSIHBEAgAUIgiKdBdU8EQCABpyIGIAYoAgBBAWo2AgALIAUgACABEJIBIgasNwMIIAZBAE4NAQwCCyAAIAVBCGogACABECUiARA8DQELIAMpAwAhD0KAgICAMCEOIAJBAk4EQCADKQMIIQ4LIAAgDxBgDQACQAJAAkACQAJAAkACQCAEDg0FAAYBAgYGBgUABgMEBgtCgICAgBAhCQwFCyAAIAECfiAFKQMIIghCgICAgAh8Qv////8PWARAIAhC/////w+DDAELQoCAgIDAfiAIub0iCEKAgICAwIGA/P8AfSAIQv///////////wCDQoCAgICAgID4/wBWGwsQqwIiCUKAgICAcINCgICAgOAAUg0EDAULIAAgAUIAEKsCIglCgICAgHCDQoCAgIDgAFINAwwECyAFIAE3AxAgBSAFNQIINwMYIABBAiAFQRBqEPYCIglCgICAgHCDQoCAgIDgAFINAgwDCyAAED4iCUKAgICAcINCgICAgOAAUg0BQoCAgIDgACEJDAILQoGAgIAQIQkLQgAhCCAFKQMIIgpCACAKQgBVGyEQA0AgCCAQUgRAAkACQCAHBEAgBSAAIAEgCBBzIgo3AyggCkKAgICAcINCgICAgOAAUg0BDAULIAAgASAIIAVBKGoQhQEiAkEASA0EIAJFDQELIAghCiAIQoCAgIAIWgRAQoCAgIDAfiAIub0iCkKAgICAwIGA/P8AfSAKQv///////////wCDQoCAgICAgID4/wBWGyEKCyAKQoCAgIBwg0KAgICA4ABRDQMgBSABNwMgIAUgCjcDGCAFIAUpAygiDTcDECAAIA8gDkEDIAVBEGoQISELIAAgChAPIAtCgICAgHCDQoCAgIDgAFENAwJAAkACQAJAAkACQAJAIAQODQABBQIEBQUFAAEFAwQFCyAAIAsQJg0FQoCAgIAQIQgM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AUL///////////8Ag0KAgICAgICA+P8AVhshBQwCCxABAAsgAjAAAEL/////D4MhBQsgB0EQaiQAIAULUgIBfwF+QoCAgIDgACEEIAAgASACEJMBIgMEfiADKAIgIgMoAgwoAiAtAAQEQCACRQRAQgAPCyAAEGtCgICAgOAADwsgAzUCFAVCgICAgOAACwvXAQEDfwJAIAFCgICAgHBUDQAgAaciAy8BBkE5Rw0AIAMoAiAiBEUNACAEQcwAaiEDIARByABqIQUDQCAFIAMoAgAiA0cEQCADKQMQIgFCgICAgGBaBEAgACABpyACEQAACyADKQMYIgFCgICAgGBaBEAgACABpyACEQAACyADKQMgIgFCgICAgGBaBEAgACABpyACEQAACyADKQMoIgFCgICAgGBaBEAgACABpyACEQAACyADQQRqIQMMAQsLIAQoAgRBfnFBBEYNACAAIARBCGogAhDvAwsLBgBB4MYECzABAX8CQCABQoCAgIBwVA0AIAGnIgIvAQZBOUcNACACKAIgIgJFDQAgACACEIcFCwsNACAAIAEgAkE3EP0FCwsAIAAgAUE3EP4FCxYBAX8gAacoAiAiAgRAIAAgAhCIBQsLMQEBfyABpygCICICBEAgACACKAIIEKMFIAAgAikDABAjIABBEGogAiAAKAIEEQAACwvcAQEEfwJAIAFCgICAgHBUDQAgAaciBC8BBkExRw0AIAQoAiAiBkUNAEEAIQQDQCAEQQJGRQRAIAYgBEEDdGoiBUEIaiEDIAVBBGohBQNAIAUgAygCACIDRwRAIAMpAwgiAUKAgICAYFoEQCAAIAGnIAIRAAALIAMpAxAiAUKAgICAYFoEQCAAIAGnIAIRAAALIAMpAxgiAUKAgICAYFoEQCAAIAGnIAIRAAALIANBBGohAwwBCwsgBEEBaiEEDAELCyAGKQMYIgFCgICAgGBUDQAgACABpyACEQAACwuMAQEFfwJAIAFCgICAgHBUDQAgAaciAi8BBkExRw0AIAIoAiAiBEUNAANAIANBAkZFBEAgBCADQQN0aiICQQRqIQUgAigCCCECA0AgAiAFRkUEQCACKAIEIQYgACACEK4CIAYhAgwBCwsgA0EBaiEDDAELCyAAIAQpAxgQIyAAQRBqIAQgACgCBBEAAAsLJQAgBSkDACIBQiCIp0F1TwRAIAGn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IAMpAwAQpgENACAAEJcBIgVCgICAgHCDQoCAgIDgAFENACAAIAJBFGogAykDCBC7ASIGRQRAIAAgBRAPDAELIAAoAtgBIQMgAkIANwIMIAJCgICAgICAgICAfzcCBCACIAM2AgAgAkIBEDAaIAIgAikDKCIBpyIHQf////8DQQEQzAEaIAIgAkJ/Qf////8DQQEQdRogBadBBGoiAyAGIAIQkwUaAkAgBEUgAVByDQAgAkIBEDAaIAIgB0EBa0H/////A0EBEMwBGiADIAIQ0wFBAEgNACACQgEQMBogAiAHQf////8DQQEQzAEaIAMgAyACQf////8DQQEQ5AEaCyACEBsgACAGIAJBFGoQXiAAIAUQzQEhAQsgAkEwaiQAIAEL6hMCAn4BfyMAQdABayIEJAAgACAEEJgFIAEgARA0IgNBqi0CfiAEKQMIIgJCgICAgAh8Qv////8PWARAIAJC/////w+DDAELQoCAgIDAfiACub0iAkKAgICAwIGA/P8AfSACQv///////////wCDQoCAgICAgID4/wBWGwsQQCABIANB3+AAAn4gBCkDECICQoCAgIAIfEL/////D1gEQCACQv////8PgwwBC0KAgICAwH4gArm9IgJCgICAgMCBgPz/AH0gAkL///////////8Ag0KAgICAgICA+P8AVhsLEEAgASADQboqAn4gBCkDGCICQoCAgIAIfEL/////D1gEQCACQv////8PgwwBC0KAgICAwH4gArm9IgJCgICAgMCBgPz/AH0gAkL///////////8Ag0KAgICAgICA+P8AVhsLEEAgASADQagqAn4gBCkDICICQoCAgIAIfEL/////D1gEQCACQv////8PgwwBC0KAgICAwH4gArm9IgJCgICAgMCBgPz/AH0gAkL///////////8Ag0KAgICAgICA+P8AVhsLEEAgASADQfooAn4gBCkDKCICQoCAgIAIfEL/////D1gEQCACQv////8PgwwBC0KAgICAwH4gArm9IgJCgICAgMCBgPz/AH0gAkL///////////8Ag0KAgICAgICA+P8AVhsLEEAgASADQfrfAAJ+IAQpAzAiAkKAgICACHxC/////w9YBEAgAkL/////D4MMAQtCgICAgMB+IAK5vSICQoCAgIDAgYD8/wB9IAJC////////////AINCgICAgICAgPj/AFYbCxBAIAEgA0HYKAJ+IAQpAzgiAkKAgICACHxC/////w9YBEAgAkL/////D4MMAQtCgICAgMB+IAK5vSICQoCAgIDAgYD8/wB9IAJC////////////AINCgICAgICAgPj/AFYbCxBAIAEgA0G23wACfiAEKQNAIgJCgICAgAh8Qv////8PWARAIAJC/////w+DDAELQoCAgIDAfiACub0iAkKAgICAwIGA/P8AfSACQv///////////wCDQoCAgICAgID4/wBWGwsQQCABIANBzSkCfiAEKQNIIgJCgICAgAh8Qv////8PWARAIAJC/////w+DDAELQoCAgIDAfiACub0iAkKAgICAwIGA/P8AfSACQv///////////wCDQoCAgICAgID4/wBWGwsQQCABIANBl+AAAn4gBCkDUCICQoCAgIAIfEL/////D1gEQCACQv////8PgwwBC0KAgICAwH4gArm9IgJCgICAgMCBgPz/AH0gAkL///////////8Ag0KAgICAgICA+P8AVhsLEEAgASADQeIoAn4gBCkDWCICQoCAgIAIfEL/////D1gEQCACQv////8PgwwBC0KAgICAwH4gArm9IgJCgICAgMCBgPz/AH0gAkL///////////8Ag0KAgICAgICA+P8AVhsLEEAgASADQc/fAAJ+IAQpA2AiAkKAgICACHxC/////w9YBEAgAkL/////D4MMAQtCgICAgMB+IAK5vSICQoCAgIDAgYD8/wB9IAJC////////////AINCgICAgICAgPj/AFYbCxBAIAEgA0GGKgJ+IAQpA2giAkKAgICACHxC/////w9YBEAgAkL/////D4MMAQtCgICAgMB+IAK5vSICQoCAgIDAgYD8/wB9IAJC////////////AINCgICAgICAgPj/AFYbCxBAIAEgA0Gt4AACfiAEKQNwIgJCgICAgAh8Qv////8PWARAIAJC/////w+DDAELQoCAgIDAfiACub0iAkKAgICAwIGA/P8AfSACQv///////////wCDQoCAgICAgID4/wBWGwsQQCABIANBxyoCfiAEKQN4IgJCgICAgAh8Qv////8PWARAIAJC/////w+DDAELQoCAgIDAfiACub0iAkKAgICAwIGA/P8AfSACQv///////////wCDQoCAgICAgID4/wBWGwsQQCABIANB8OAAAn4gBCkDgAEiAkKAgICACHxC/////w9YBEAgAkL/////D4MMAQtCgICAgMB+IAK5vSICQoCAgIDAgYD8/wB9IAJC////////////AINCgICAgICAgPj/AFYbCxBAIAEgA0HN4AACfiAEKQOIASICQoCAgIAIfEL/////D1gEQCACQv////8PgwwBC0KAgICAwH4gArm9IgJCgICAgMCBgPz/AH0gAkL///////////8Ag0KAgICAgICA+P8AVhsLEEAgASADQZIqAn4gBCkDkAEiAkKAgICACHxC/////w9YBEAgAkL/////D4MMAQtCgICAgMB+IAK5vSICQoCAgIDAgYD8/wB9IAJC////////////AINCgICAgICAgPj/AFYbCxBAIAEgA0G44AACfiAEKQOYASICQoCAgIAIfEL/////D1gEQCACQv////8PgwwBC0KAgICAwH4gArm9IgJCgICAgMCBgPz/AH0gAkL///////////8Ag0KAgICAgICA+P8AVhsLEEAgASADQdUqAn4gBCkDoAEiAkKAgICACHxC/////w9YBEAgAkL/////D4MMAQtCgICAgMB+IAK5vSICQoCAgIDAgYD8/wB9IAJC////////////AINCgICAgICAgPj/AFYbCxBAIAEgA0HvJwJ+IAQpA6gBIgJCgICAgAh8Qv////8PWARAIAJC/////w+DDAELQoCAgIDAfiACub0iAkKAgICAwIGA/P8AfSACQv///////////wCDQoCAgICAgID4/wBWGwsQQCABIANB6icCfiAEKQOwASICQoCAgIAIfEL/////D1gEQCACQv////8PgwwBC0KAgICAwH4gArm9IgJCgICAgMCBgPz/AH0gAkL///////////8Ag0KAgICAgICA+P8AVhsLEEAgASADQeszAn4gBCkDuAEiAkKAgICACHxC/////w9YBEAgAkL/////D4MMAQtCgICAgMB+IAK5vSICQoCAgIDAgYD8/wB9IAJC////////////AINCgICAgICAgPj/AFYbCxBAIAEgA0H7JwJ+IAQpA8ABIgJCgICAgAh8Qv////8PWARAIAJC/////w+DDAELQoCAgIDAfiACub0iAkKAgICAwIGA/P8AfSACQv///////////wCDQoCAgICAgID4/wBWGwsQQCABIANBo98AAn4gBCkDyAEiAkKAgICACHxC/////w9YBEAgAkL/////D4MMAQtCgICAgMB+IAK5vSICQoCAgIDAgYD8/wB9IAJC////////////AINCgICAgICAgPj/AFYbCxBAIAMQUyEAIARB0AFqJAAgAAufAgEDfiABQv////9vWARAIAAQJEKAgICA4AAPC0KAgICA4AAhBQJ+IAAgAUE2IAFBABAUIgRCgICAgHCDQoCAgIAwUQRAIABBlAEQLQwBCyAAIAQQNwsiBEKAgICAcIMiBkKAgICA4ABSBH4CfiAAIAFBMyABQQAQFCIBQoCAgIBwg0KAgICAMFEEQCAAQS8QLQwBCyAAIAEQNwsiAUKAgICAcIMiBUKAgICA4ABRBEAgACAEEA9CgICAgOAADwsCQCAGQoCAgICQf1EEQCAEpygCBEH/////B3FFDQELIAVCgICAgJB/UQRAIAGnKAIEQf////8HcUUNAQsgAEHMngEgBEH4mQEQvgEhBAsgACAEIAEQxAIFQoCAgIDgAAsLXwEBfwJAIAFFBEAgAkUNASAAIAIQ2QMPCyACRQRAIAAgACgCAEEBazYCACAAIAAoAgRBCGs2AgQgARCbAQwBCyAAKAIIIAAoAgQgAmpPBH8gASACEPMFBUEACw8LQQALJgAgAQRAIAAgACgCAEEBazYCACAAIAAoAgRBCGs2AgQgARCbAQsLCQAgACABNgIYCygBAX8CQCABpygCICIDRQ0AIAMoAgBBBEYNACAAIANBCGogAhDvAwsLPwEBfwJAIAFCgICAgHBUDQAgAaciAi8BBkEvRw0AIAIoAiAiAkUNACAAIAIQ7AMgAEEQaiACIAAoAgQRAAALC0cBAX8CQCABpygCICIDRQ0AIAMpAwAiAUKAgICAYFoEQCAAIAGnIAIRAAALIAMpAwgiAUKAgICAYFQNACAAIAGnIAIRAAALCzABAX8gAacoAiAiAgRAIAAgAikDABAjIAAgAikDCBAjIABBEGogAiAAKAIEEQAACwsnAQF/IAGnKAIgIgIEQCAAIAIpAwAQIyAAQRBqIAIgACgCBBEAAAsLWgECfyABpygCICICBEACQCACKQMAIgFCgICAgHBUDQAgAactAAVBAnENACACKAIMIgNFDQAgACADEOoDIAIpAwAhAQsgACABECMgAEEQaiACIAAoAgQRAAALC3gBA38CQCABpygCICIERQ0AIARBCGohAyAEQQRqIQUDQCADKAIAIgMgBUYNAQJAIAQoAgANACADKQMQIgFCgICAgGBUDQAgACABpyACEQAACyADKQMYIgFCgICAgGBaBEAgACABpyACEQAACyADQQRqIQMMAAsACwuaAQEGfyABpygCICIDBEAgAEEQaiEEIANBBGohBiADKAIIIQIDQCACIAZHBEAgAigCBCEHIAJBEGshBSACQQxrKAIARQRAAkAgAygCAARAIAUQnwUMAQsgACACKQMQECMLIAAgAikDGBAjCyAEIAUgACgCBBEAACAHIQIMAQsLIAQgAygCECAAKAIEEQAAIAQgAyAAKAIEEQAACwuUAgEFfwJAIAFCgICAgHBUDQAgAaciAy8BBkElRw0AIAMoAiAiBUUNAEEAIQMDQAJAIANBE0YEQEEAIQQMAQsgBSADQQJ0aigCCCIEBEAgACAEIAIRAAALIANBAWohAwwBCwsDQCAFKAJUIARMBEBBACEEA0AgBCAFKAJcTg0DIAUoAmAhBkEAIQMDQCADQQ5HBEAgBiAEQTxsaiADQQJ0aigCBCIHBEAgACAHIAIRAAALIANBAWohAwwBCwsgBEEBaiEEDAALAAUgBSgCWCEGQQAhAwNAIANBDkcEQCAGIARBPGxqIANBAnRqKAIEIgcEQCAAIAcgAhEAAAsgA0EBaiEDDAELCyAEQQFqIQQMAQsACwALC80CAQZ/AkAgAUKAgICAcFQNACABpyICLwEGQSVHDQAgAigCICIERQ0AQQAhAgNAIAJBE0YEQEEAIQMDQCAEKAJYIQVBACECIAQoAlQgA0wEQCAAQRBqIgYgBSAAKAIEEQAAQQAhAwNAIAQoAmAhBUEAIQIgBCgCXCADTARAIAYgBSAAKAIEEQAAIAYgBCAAKAIEEQAADAYFA0AgAkEORwRAIAUgA0E8bGogAkECdGooAgQiBwRAIAAgB61CgICAgHCEECMLIAJBAWohAgwBCwsgA0EBaiEDDAELAAsABQNAIAJBDkcEQCAFIANBPGxqIAJBAnRqKAIEIgYEQCAAIAatQoCAgIBwhBAjCyACQQFqIQIMAQsLIANBAWohAwwBCwALAAsgBCACQQJ0aigCCCIDBEAgACADrUKAgICAcIQQIwsgAkEBaiECDAALAAsLNQECfwJAIAFCgICAgHBUDQAgAaciAy8BBkEjRw0AIAMoAiAhAgsgAEEQaiACIAAoAgQRAAALGwEBfyABpygCICIDBEAgACADKAIMIAIRAAALC2ABA38gAacoAiAiAgRAIAIoAgwiA61CgICAgHCEIQEgAy0ABUECcUUEQCACKAIAIgMgAigCBCIENgIEIAQgAzYCACACQgA3AgALIAAgARAjIABBEGogAiAAKAIEEQAACwtkAQJ/IAGnKAIgIgIEQAJAAkAgAi0ABUUNACAAKAK8ASIDRQ0AIAAoAsQBIAIoAgggAxEAAAwBCyACKAIYIgNFDQAgACACKAIUIAIoAgggAxEGAAsgAEEQaiACIAAoAgQRAAALCykBAX8gACABpyICNQIkQoCAgICQf4QQIyAAIAI1AiBCgICAgJB/hBAjCyEAIAGnKAIgKQMAIgFCgICAgGBaBEAgACABpyACEQAACwsiAQF/IAAgAacoAiAiAikDABAjIABBEGogAiAAKAIEEQAACwoAIABBAxB2EFMLZQECfwJAIAFCgICAgHBUDQAgAaciAy8BBkEPRw0AIAMoAiAiBEUNAEEAIQMDQCADIAQtAAVPDQEgBCADQQN0aikDCCIBQoCAgIBgWgRAIAAgAacgAhEAAAsgA0EBaiEDDAALAAsLYwECfwJAIAFCgICAgHBUDQAgAaciAi8BBkEPRw0AIAIoAiAiA0UNAEEAIQIDQCACIAMtAAVPRQRAIAAgAyACQQN0aikDCBAjIAJBAWohAgwBCwsgAEEQaiADIAAoAgQRAAALC3gBAn8gAacoAiAiBCkDACIBQoCAgIBgWgRAIAAgAacgAhEAAAsgBCkDCCIBQoCAgIBgWgRAIAAgAacgAhEAAAsDQCAEKAIQIANKBEAgBCADQQN0aikDGCIBQoCAgIBgWgRAIAAgAacgAhEAAAsgA0EBaiEDDAELCwtSAQJ/IAAgAacoAiAiAikDABAjIAAgAikDCBAjA0AgAyACKAIQTkUEQCAAIAIgA0EDdGopAxgQIyADQQFqIQMMAQsLIABBEGogAiAAKAIEEQAAC4ABAQR/IAGnIgMoAiAhBCADKAIkIQUgAygCKCIDBEAgACADIAIRAAALIAQEQAJAIAVFDQBBACEDA0AgAyAEKAI8Tg0BAkAgBSADQQJ0aigCACIGRQ0AIAYtAAVBAXFFDQAgACAGIAIRAAALIANBAWohAwwACwALIAAgBCACEQAACwt8AQN/IAGnIgIoAigiAwRAIAAgA61CgICAgHCEECMLIAIoAiAiAwRAIAIoAiQiBARAQQAhAgNAIAIgAygCPE5FBEAgACAEIAJBAnRqKAIAEOsBIAJBAWohAgwBCwsgAEEQaiAEIAAoAgQRAAALIAAgA61CgICAgGCEECMLCxIAIAGnKAIgIgAEQCAAEKQDCwseACABpykDICIBQoCAgIBgWgRAIAAgAacgAhEAAAsLGQAgACABpyIAKQMgECMgAEKAgICAMDcDIAtEAQJ/IAGnIQQDQCAEKAIoIANLBEAgBCgCJCADQQN0aikDACIBQoCAgIBgWgRAIAAgAacgAhEAAAsgA0EBaiEDDAELCwtGAQN/IAGnIQMDQCADKAIkIQQgAiADKAIoT0UEQCAAIAQgAkEDdGopAwAQIyACQQFqIQIMAQsLIABBEGogBCAAKAIEEQAAC2kBAn8jAEEQayIHJAACfwJAIAGnIggtAAVBCHFFDQAgACAHQQxqIAIQrAFFDQAgBygCDCAIKAIoTw0AQX8gACAIEJIDDQEaCyAAIAEgAiADIAQgBSAGQYCACHIQbQshACAHQRBqJAAgAAuBAgIDfwF+AkACQCACQQBODQAgAacpAyAiCkKAgICAcINCgICAgJB/Ug0AIAJB/////wdxIgggCqciBykCBCIKp0H/////B3FPDQACQEEEIAYQkwNFDQBBASECIAZBgMAAcUUNAiADQoCAgIBwg0KAgICAkH9SDQAgA6ciCSkCBCIBQv////8Hg0IBUg0AIAdBEGohBwJ/IApCgICAgAiDUEUEQCAHIAhBAXRqLwEADAELIAcgCGotAAALAn8gAUKAgICACINQRQRAIAkvARAMAQsgCS0AEAtGDQILIAAgBkHh6QAQbw8LIAAgASACIAMgBCAFIAZBgIAIchBtIQILIAILRgACfwJAIAJBAE4NACABpykDICIBQoCAgIBwg0KAgICAkH9SDQBBACACQf////8HcSABpygCBEH/////B3FJDQEaC0EBCwuzAQECfwJAIANBAE4NACACpykDICICQoCAgIBwg0KAgICAkH9SDQAgA0H/////B3EiAyACpyIEKQIEIgKnQf////8HcU8NAEEBIQUgAUUNACAEQRBqIQQCfyACQoCAgIAIg1BFBEAgBCADQQF0ai8BAAwBCyADIARqLQAACyEDIAFBBDYCACAAIANB//8DcRCfAyECIAFCgICAgDA3AxggAUKAgICAMDcDECABIAI3AwgLIAULWwECfyABpygCECIAQTBqIQMgACAAKAIYIAJxQX9zQQJ0aigCACEAA0ACQCAARQ0AIAMgAEEBa0EDdGoiBCgCBCACRg0AIAQoAgBB////H3EhAAwBCwsgAEEARws1AQF+IAEpAwAiAkIgiKdBdU8EQCACpyIBIAEoAgBBAWo2AgALIAAgAhCKAUKAgICA4AAQUwuOAQECfyABKAIAIgJBAEoEQCABIAJBAWsiAjYCAAJAIAINACABLQAEQfABcUEQRw0AIAEoAggiAiABKAIMIgM2AgQgAyACNgIAIAFBADYCCCAAKAJgIgIgAUEIaiIDNgIEIAEgAEHgAGo2AgwgASACNgIIIAAgAzYCYAsPC0HFjQFBrvwAQbAsQc/0ABAAAAtvAQJ/IAEgASgCACICQQFqNgIAIAJFBEAgASgCCCICIAEoAgwiAzYCBCADIAI2AgAgAUEANgIIIAAoAlAiAiABQQhqIgM2AgQgASAAQdAAajYCDCABIAI2AgggACADNgJQIAEgAS0ABEEPcToABAsLDwAgASABKAIAQQFqNgIAC4gBAgF+AX9BACECQoCAgIAwIQEDQAJAIAJBAkcEfiAFIAJBA3QiBGoiBzUCBEIghkKAgICAMFENASAAQawuQQAQFUKAgICA4AAFQoCAgIAwCw8LIAMgBGopAwAiBkIgiKdBdU8EQCAGpyIEIAQoAgBBAWo2AgALIAcgBjcDACACQQFqIQIMAAsAC1wBAn4gAiAAKAIAEC0hA0EAIQAgA0KAgICAcINCgICAgOAAUSACIAEoAgAQLSIEQoCAgIBwg0KAgICA4ABRckUEQCADpyAEpxCDAiEACyACIAMQDyACIAQQDyAAC2sBAX4CQAJAAkACQAJAIAMtAAUiAQ4EAwICAAELIAAgAygCCBDKBA8LIAFBCEYNAgsQAQALIAAgAygCDCADKAIAIAMtAAggAy0ACSADLgEGEIIBDwsgACAAEDQiBCADKAIIIAMoAgwQIiAECwkAIAAgAxCNAwtTAQF+IAAQNCIEQoCAgIBwg0KAgICA4ABSBEAgASABKAIAQQFqNgIAIAAgBEE8IAGtQoCAgIBwhEEDEBlBAE4EQCAEDwsgACAEEA8LQoCAgIDgAAsDAAELagEBfyMAQRBrIgMkACABKAIEIQEgAiADQQxqIAAoAgQQrAFBACACIANBCGogARCsARtFBEBB0MUAQa78AEGDOkH8yQAQAAALIAMoAgghACADKAIMIQEgA0EQaiQAQX8gACABRyAAIAFLGwvaAwICfgF/IwBBIGsiBSQAAkACQCAAIAFBLBBLIgJFDQBCgICAgDAhAQJAIAIpAwAiBkKAgICAcINCgICAgDBSBEACfwJAIAanIgMvAQZBFWtB//8DcUEKTQRAIAMoAiAoAgwoAiAtAARFDQEgABBrDAULIAAgBUEcaiAGENYBDQQgBUEcagwBCyADQShqCyEIIAIoAgwiAyAIKAIASQ0BIAAgAikDABAPIAJCgICAgDA3AwALIARBATYCAAwCCyACIANBAWo2AgwgBEEANgIAIAIoAghFBEAgA0EATgRAIAOtIQEMAwtCgICAgMB+IAO4vSIBQoCAgIDAgYD8/wB9IAFC////////////AINCgICAgICAgPj/AFYbIQEMAgtCgICAgOAAIQEgACACKQMAIAMQsAEiBkKAgICAcINCgICAgOAAUQ0BIAIoAghBAUYEQCAGIQEMAgsgBSAGNwMIIAUgA0EATgR+IAOtBUKAgICAwH4gA7i9IgFCgICAgMCBgPz/AH0gAUL///////////8Ag0KAgICAgICA+P8AVhsLIgc3AwAgAEECIAUQiQMhASAAIAYQDyAAIAcQDwwBCyAEQQA2AgBCgICAgOAAIQELIAVBIGokACABCxAAIwAgAGtBcHEiACQAIAALBgAgACQACwQAIwAL7gICBH8CfiMAQRBrIgMkAAJAAkAgAikDECIHQoCAgIBwg0KAgICAkH9SBEAgAEGDlAFBABAVDAELIAIpAxghCCAAIAcQswEiBEUEQEEAIQQMAQsgACAIELMBIgZFDQACQCAAIAQgBhDJBSIBRQ0AIAAgARD+A0EASARAIABBARCPBAwBCyABIAEoAgBBAWo2AgAgACABrUKAgICAUIQgACkDwAFBAEEAEMgFIgdCgICAgHCDQoCAgIDgAFENACAAIAcQDyABIQULIAAgBhBUIAVFDQAgAyAAIAUQjQMiBzcD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ACEEIANCADcCaCADQoCAgICAgICAgH83AmAgAyAENgJcIANB3ABqIgUgARBEGiADQgA3AlQgA0KAgICAgICAgIB/NwJMIAMgBDYCSCADKAJkIQYgA0EANgJkIANByABqIgFCqtWq1QoQMBogA0EANgJQIAUgARCyAgRAIAMgAygCZEEBajYCZCAGQQFrIQYLIANByABqEBsgAkEBakEBdhCVBiEFIANCADcCVCADQoCAgICAgICAgH83AkwgAyAENgJIIANCADcCQCADQoCAgICAgICAgH83AjggAyAENgI0IANB3ABqIgEgAUJ/Qf////8DQQAQdRogBUEAIAVBAEobIQkgAiAFaiACIAVBAXRuQQFqIgpBAXRqQSBqIQJBACEBA0AgASAJRkUEQCADQcgAaiIHIANB3ABqIghCASACQQAQdRogA0E0aiILIAcgAkEGEJEGIAcgC0IBIAJBABB1GiAIIAggByACQQAQlQEaIAFBAWohAQwBCwsgA0IANwIsIANCgICAgICAgICAfzcCJCADIAQ2AiAgA0IANwIYIANCgICAgICAgICAfzcCECADIAQ2AgwgA0EgaiIBIANB3ABqIgRCAiACQQAQdRogASAEIAEgAkEAEJUBGiADQQxqIAEgASACQQAQQxogAEIAEDAaIAqsIQwDQCAMQgBXRQRAIANByABqIgFCARAwGiADQTRqIgQgDKdBAXRBAXKsEDAaIAEgASAEIAJBABCVARogACAAIAEgAkEAEMsBGiAAIAAgA0EMaiACQQAQQxogDEIBfSEMDAELCyAAIABCASACQQAQdRogACAAIANBIGoiASACQQAQQxogARAbIANBDGoQGyADQTRqEBsgA0HIAGoQGyAAIAVBAWpB/////wNBARDMARogA0HcAGoiASACQQYQ0wIgASABIAasIAJBABDUAiAAIAAgASACQQAQywEaIAEQGyADQfAAaiQAQRAPC0HY/QBB1PwAQdciQajWABAAAAsRACAAIAEgAiADIARBABCWBgsRACAAIAEgAiADIARBARCWBgvYAwEHfyACKAIEIAEoAgRzIQcCQAJAAkACQAJAAkACQCABKAIIIgZB/f///wdMBEAgAigCCCIFQf3///8HSg0BIAZBgICAgHhHDQYgBUGAgICAeEYNBAwHCyAGQf////8HRg0BIAIoAggh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gICAMEEBENQFDQIgACABEA8LIAJBAWohAgwACwALIAAgBBAPIAAgARAPQoCAgIDgAAsYACAAIAMpAwAgAykDCBBSrUKAgICAEIQL4gICA34DfyMAQSBrIgIkAEKAgICA4AAhBCAAIAMpAwAQJSIFQoCAgIBwg0KAgICA4ABSBEBCgICAgDAhAQJAAkAgACACQRxqIAJBGGogBadBAxCOAQ0AQoCAgIDgACEBIAAQNCIEQoCAgIBwg0KAgICA4ABRDQAgAigCHCEHIAIoAhghCEEAIQMDQCADIAhHBEACQAJAIAAgByADQQN0aiIJKAIEEFwiAUKAgICAcINCgICAgOAAUQ0AIAIgATcDCCACIAU3AwAgACAEIAAgAkEAEMYEIQYgACABEA8gBkKAgICAcIMiAUKAgICAMFENASABQoCAgIDgAFENACAAIAQgCSgCBCAGQYeAARAZQQBODQELIAQhAQwDCyADQQFqIQMMAQsLIAAgByAIEFogBSEBDAELIAAgAigCHCACKAIYEFogACAFEA9CgICAgOAAIQQLIAAgARAPCyACQSBqJAAgBAsQACAAIAMpAwBBESAEEKoCCxAAIAAgAykDAEECQQAQqgILEAAgACADKQMAQQFBABCqAgtHAQF+QoCAgIDgACEEIAAgAykDACIBIAMpAwgQrgYEfkKAgICA4AAFIAFCIIinQXVPBEAgAaciACAAKAIAQQFqNgIACyABCwtBACAAIAMpAwAiASADKQMIQQEQiwJBAEgEQEKAgICA4AAPCyABQiCIp0F1TwRAIAGnIgAgACgCAEEBajYCAAsgAQuJAQEBfiADKQMAIgFC/////29WIAFCgICAgHCDQoCAgIAgUXJFBEAgAEG35ABBABAVQoCAgIDgAA8LAkAgACABEEciAUKAgICAcINCgICAgOAAUgRAIAMpAwgiBEKAgICAcINCgICAgDBRDQEgACABIAQQrgZFDQEgACABEA8LQoCAgIDgAA8LIAELpQQCBX8CfiMAQSBrIgUkACAAIAVBCGoiBkEAED0aIAZBKBA7GiAEQX5xQQJGBEAgBUEIakHxmQEQiAEaCyAFQQhqQbrMABCIARogBEF9cUEBRgRAIAVBCGpBKhA7GgsgBUEIakGvlAEQiAEaQQAhBiACQQFrIgdBACAHQQBKGyEIAkACQAJAA0AgBiAIRwRAIAYEQCAFQQhqQSwQOxoLIAZBA3QhCSAGQQFqIQYgBUEIaiADIAlqKQMAEIcBRQ0BDAILCyAFQQhqQYaaARCIARogAkEASgRAIAVBCGogAyAHQQN0aikDABCHAQ0BCyAFQQhqIgJBiZEBEIgBGkKAgICAMCELIAIQNiIKQoCAgIBwg0KAgICA4ABRDQEgACAAKQPAASAKQQNBfxCcAyELIAAgChAPIAtCgICAgHCDQoCAgIDgAFENASABQoCAgIBwg0KAgICAMFENAiAAIAFBOyABQQAQFCIKQoCAgIBwg0KAgICA4ABRDQECQCAKQv////9vVg0AIAAgChAPIAAgARCAAyICRQ0CIAIoAiggBEEBdEGuwAFqLwEAQQN0aikDACIKQiCIp0F1SQ0AIAqnIgIgAigCAEEBajYCAAsgACALIApBARCLAiECIAAgChAPIAJBAE4NAgwBCyAFKAIIKAIQIgJBEGogBSgCDCACKAIEEQAAQoCAgIAwIQsLIAAgCxAPQoCAgIDgACELCyAFQSBqJAAgCwuAAgICfgF/IwBBIGsiByQAQoCAgIDgACEFAkACQCAAIAEQJSIBQoCAgIBwg0KAgICA4ABRDQAgACADKQMAEDEiA0UNAANAIAAgByABpyADEEwiAkEASA0CIAIEQEKAgICAMCEFAkAgBy0AAEEQcUUNACAHQRhBECAEG2opAwAiBUIgiKdBdUkNACAFpyICIAIoAgBBAWo2AgALIAAgBxBIDAMLIAAgARCMAiIBQoCAgIBwgyIGQoCAgIAgUgRAIAZCgICAgOAAUQRAIAYhBQwECyAAEHtFDQEMAwsLQoCAgIAwIQUMAQtBACEDCyAAIAMQEyAAIAEQDyAHQSBqJAAgBQuxAQEDfiADKQMIIQUgAykDACEGQoCAgIDgACEHAkAgACABECUiAUKAgICAcINCgICAgOAAUgR+IAAgBRBgDQEgACAGEDEiAkUNASAAIAEgAkKAgICAMEKAgICAMCAFIAQbIAVCgICAgDAgBBtBhaoBQYWaASAEGxBtIQMgACABEA8gACACEBNCgICAgOAAQoCAgIAwIANBAEgbBUKAgICA4AALDwsgACABEA9CgICAgOAAC3IBAX5CgICAgDAhAyABQoCAgIAQhEKAgICAcINCgICAgDBRBEAgABAkQoCAgIDgAA8LIAJCgICAgHCDQoCAgIAgUiACQv////9vWHEEfkKAgICAMAVCgICAgOAAQoCAgIAwIAAgASACQQEQiwJBAEgbCwsyAQF+IAAgARAlIgFCgICAgHCDQoCAgIDgAFEEQCABDwsgACABEOgBIQIgACABEA8gAgugAQIBfgF/IwBBIGsiAiQAQoCAgIDgACEEAkACQCAAIAEQJSIBQoCAgIBwg0KAgICA4ABRDQAgACADKQMAEDEiA0UNACAAIAIgAacgAxBMIgVBAEgNASAFRQRAQoCAgIAQIQQMAgsgAjUCACEEIAAgAhBIIARCAohCAYNCgICAgBCEIQQMAQtBACEDCyAAIAMQEyAAIAEQDyACQSBqJAAgBAvBAQECfgJAAn5CgICAgBAgAykDACIEQoCAgIBwVA0AGkKAgICA4AAgACABECUiAUKAgICAcINCgICAgOAAUQ0AGiAEpyICIAIoAgBBAWo2AgAgAachAgNAIAAgBBCMAiIEQoCAgIBwgyIFQoCAgIDgAFIEQCACIASnRiAFQoCAgIAgUXINAyAAEHtFDQELCyAAIAQQDyAAIAEQD0KAgICA4AALDwsgACAEEA8gACABEA8gBUKAgICAIFKtQoCAgIAQhAt6AQF+IAAgAykDABAxIgJFBEBCgICAgOAADwtCgICAgOAAIQQgACABECUiAUKAgICAcINCgICAgOAAUQRAIAAgAhATIAEPCyAAQQAgAacgAhBMIQMgACACEBMgACABEA9CgICAgOAAIANBAEetQoCAgIAQhCADQQBIGwsIACAAIAEQJQsPACAAIAFBN0EAQQAQrAILLQEBfkKAgICAMCECAkAgARCjAyIARQ0AIAAtABJBBHFFDQAgADUCRCECCyACCzMCAX4Bf0KAgICAMCECAkAgARCjAyIDRQ0AIAMtABJBBHFFDQAgACADKAJAEC0hAgsgAgsoAEKAgICA4AAgACADKQMAIAEQvgUiAEEAR61CgICAgBCEIABBAEgbC7cBAgF+An9CgICAgOAAIQQgACABEGAEfkKAgICA4AAFQcqZASECAkAgAaciAy8BBhDuAUUNAAJAIAMoAiAiAy8AESIFQYAIcUUNACADKAJUIgZFDQAgACAGIAMoAkgQkwIPCyAFQQR2QQNxQQFrIgNBAksNACADQQJ0QfT/AWooAgAhAgsgACACIAAgAUE2IAFBABAUIgFCgICAgHCDQoCAgIAwUQR+IABBLxAtBSABC0G+GRC+AQsL6QUDA34GfwN8AkACfkKAgICA4AAgACABEGANABpCgICAgOAAIAAgACkDMEEOEEkiBUKAgICAcINCgICAgOAAUQ0AGiAFpyIKIAFCgICAgHBaBH8gAactAAVBEHEFQQALIAotAAVB7wFxcjoABSAAQQEgAiACQQFMGyILQQFrIghBA3RBGGoQKSIHRQ0BIAFCIIinQXVPBEAgAaciAiACKAIAQQFqNgIACyAHIAE3AwAgAykDACIEQiCIp0F1TwRAIASnIgIgAigCAEEBajYCAAsgByAINgIQIAcgBDcDCEEAIQIDQCACIAhHBEAgAyACQQFqIglBA3RqKQMAIgRCIIinQXVPBEAgBKciDCAMKAIAQQFqNgIACyAHIAJBA3RqIAQ3AxggCSECDAELCyAKIAc2AiAgAUL/////b1gEQCAAECQMAgsgAEEAIAGnQTAQTCICQQBIDQFCACEEAkAgAkUNACAAIAFBMCABQQAQFCIGQoCAgIBwg0KAgICA4ABRDQIgBkL/////D1gEQCAGpyICIAhrQQAgAiALThutIQQMAQsgBkIgiKdBB2tBbU0EQAJAIAZCgICAgMCBgPz/AHwiBEL///////////8Ag0KAgICAgICA+P8AVg0AIAS/nSIOIAi3Ig9lDQAgDiAPoSENCyANvSIEAn8gDZlEAAAAAAAA4EFjBEAgDaoMAQtBgICAgHgLIgK3vVEEQCACrSEEDAILQoCAgIDAfiAEQoCAgIDAgYD8/wB9IARC////////////AINCgICAgICAgPj/AFYbIQQMAQsgACAGEA8LIAAgBUEwIARBARAZGiAAQdSZASAAIAFBNiABQQAQFCIEQoCAgIBwgyIBQoCAgICQf1IEfiABQoCAgIDgAFENAiAAIAQQDyAAQS8QLQUgBAtBzJ4BEL4BIgFCgICAgHCDQoCAgIDgAFENASAAIAVBNiABQQEQGRogBQsPCyAAIAUQD0KAgICA4AALMAAgAkEATARAIAAgAUKAgICAMEEAQQAQIQ8LIAAgASADKQMAIAJBAWsgA0EIahAhC6MCAgF/BH4jAEEQayIFJABCgICAgDAhBgJAAkAgACAFQQhqIAAgARAlIgkQPA0AIAVBATYCBAJAIAQEQCAD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gDBSBEAgB0KAgICA4ABRDQcgACABECYMAQsgACAFEMoBCyICQQBIDQUgAkUNACAAIAkgBRA8DQUgCSkDACIHIAR8Qv////////8PVQ0EQgAhASAHQgAgB0IAVRshBwNAIAEgB1ENAiAAIAUgASAJQQhqEIUBIgJBAEgNBiACBEAgACAGIAQgCSkDCBBqQQBIDQcLIARCAXwhBCABQgF8IQEMAAsACyAEQv7///////8PVQ0DIAVCIIinQXVPBEAgBaciAiACKAIAQQFqNgIACyAAIAYgBCAFEGpBAEgNBCAEQgF8IQQLIApBAWohCgwBCwsgACAGQTAgBEKAgICACHxC/////w9YBH4gBEL/////D4MFQoCAgIDAfiAEub0iAUKAgICAwIGA/P8AfSABQv///////////wCDQoCAgICAgID4/wBWGwsQRUEASA0BDAILIABB0NoAQQAQFQsgACAGEA9CgICAgOAAIQYLIAAgCBAPIAlBEGokACAGC7ECAgR+An8jAEEQayIIJABCgICAgOAAIQUCQAJ+AkAgAUKAgICAcFQNACABpy0ABUEQcUUNACAIIAKtNwMIIAAgAUEBIAhBCGoQpwEMAQsgABA+CyIEQoCAgIBwg0KAgICA4ABRDQAgAkEAIAJBAEobrSEHQgAhAQJAA0AgASAHUgRAIAMgAadBA3RqKQMAIgZCIIinQXVPBEAgBqciCSAJKAIAQQFqNgIACyAAIAQgASAGQYCAARDSASEJIAFCAXwhASAJQQBODQEMAgsLIAAgBEEwIAJBAE4EfiACrQVCgICAgMB+IAK4vSIBQoCAgIDAgYD8/wB9IAFC////////////AINCgICAgICAgPj/AFYbCxBFQQBIDQAgBCEFDAELIAAgBBAPCyAIQRBqJAAgBQu6CQICfwh+IwBBMGsiBCQAIAMpAwAhBiAEQoCAgIAwNwMYQQEhBQJAAkACfiACQQJIBEBCgICAgDAhDEKAgICAMAwBC0KAgICAMCADKQMIIgxCgICAgHCDQoCAgIAwUQ0AGkKAgICAMCEKQoCAgIAwIQlCgICAgDAhCEKAgICAMCELIAAgDBBgDQFBACEFQoCAgIAwIAJBA0kNABogAykDEAshDQJAAkACQAJAIAAgBkHRASAGQQAQFCIHQoCAgIBwgyIIQoCAgIAwUgRAAkACQCAIQoCAgIDgAFEEQEKAgICAMCEKQoCAgIAwIQlCgICAgDAhCAwBCyAAIAcQDwJ+AkAgAUKAgICAcFQNACABpy0ABUEQcUUNACAAIAFBAEEAEKcBDAELIAAQPgsiCEKAgICAcINCgICAgOAAUQRAQoCAgIAwIQpCgICAgDAhCQwBCyAGQiCIp0F1TwRAIAanIgIgAigCAEEBajYCAAsgBCAGNwMQIAAgBEEQakEIckEAEJkDIQIgBCkDGCEKIAQpAxAhCSACRQ0BC0KAgICAMCELDAYLQgAhBwNAIAAgCSAKIARBCGoQrgEiBkKAgICAcINCgICAgOAAUQ0CIAQoAggEQEKAgICAMCELDAYLAkAgBQRAIAYhAQwBCyAEIAY3AyAgBCAHQv////8PgzcDKCAAIAwgDUECIARBIGoQISEBIAAgBhAPIAFCgICAgHCDQoCAgIDgAFENAwsgACAIIAcgARBqQQBIDQIgB0IBfCEHDAALAAsgACAGECUiC0KAgICAcINCgICAgOAAUQ0CIAAgBEEIaiALEDxBAEgNAiAEAn4gBCkDCCIGQoCAgIAIfEL/////D1gEQCAGQv////8PgwwBC0KAgICAwH4gBrm9IgdCgICAgMCBgPz/AH0gB0L///////////8Ag0KAgICAgICA+P8AVhsLIgc3AyACfgJAIAFCgICAgHBUDQAgAactAAVBEHFFDQAgACABQQEgBEEgahCnAQwBCyAAQoCAgIAwQQEgBEEgahCuAwshCCAAIAcQDyAIQoCAgIBwg0KAgICA4ABRBEBCgICAgDAhCgwCC0IAIQcgBkIAIAZCAFUbIQkDQCAHIAlRBEBCgICAgDAhCkKAgICAMCEJDAULQoCAgIAwIQogACALIAcQcyIGQoCAgIBwg0KAgICA4ABRDQICQCAFBEAgBiEBDAELIAQgBjcDICAEIAdC/////w+DNwMoIAAgDCANQQIgBEEgahAhIQEgACAGEA8gAUKAgICAcINCgICAgOAAUQ0DCyAAIAggByABEGpBAEgNAiAHQgF8IQcMAAsAC0KAgICAMCELIAlCgICAgHCDQoCAgIAwUQ0DIAAgCUEBEK0BGgwDC0KAgICAMCEJDAILQoCAgIAwIQpCgICAgDAhCUKAgICAMCEIDAELIAAgCEEwIAenIgJBAE4EfiAHQv////8PgwVCgICAgMB+IAK4vSIBQoCAgIDAgYD8/wB9IAFC////////////AINCgICAgICAgPj/AFYbCxBFQQBODQELIAAgCBAPQoCAgIDgACEICyAAIAsQDyAAIAkQDyAAIAoQDyAEQTBqJAAgCAsmAEKAgICA4AAgACADKQMAEMoBIgBBAEetQoCAgIAQhCAAQQBIGwuAAQAjAEEQayIAJAAgABCjBAJ+IAA0AgggACkDAELAhD1+fCIBQoCAgIAIfEL/////D1gEQCABQv////8PgwwBC0KAgICAwH4gAbm9IgFCgICAgMCBgPz/AH0gAUL///////////8Ag0KAgICAgICA+P8AVhsLIQEgAEEQaiQAIAELxwIBBX8jAEEgayIEJAAgACADKQMAECgiAUKAgICAcINCgICAgOAAUgRAIAAgBEEIakEAED0aIAGnIgVBEGohBiAFKAIEQf////8HcSEHQQAhAwNAIAMgB05FBEACQAJ/IAUpAgRCgICAgAiDUCIIRQRAIAYgA0EBdGovAQAMAQsgAyAGai0AAAsiAkElRw0AAkAgA0EGaiAHSg0AIANBAWohAgJ/IAhFBEAgBiACQQF0ai8BAAwBCyACIAZqLQAAC0H1AEcNACAFIANBAmpBBBC4BCICQQBIDQAgA0EFaiEDDAELQSUhAiADQQNqIAdKDQAgBSADQQFqQQIQuAQiAkElIAJBAE4iCBshAiADQQJqIAMgCBshAwsgBEEIaiACEIsBGiADQQFqIQMMAQsLIAAgARAPIARBCGoQNiEBCyAEQSBqJAAgAQvkAQEEfyMAQSBrIgIkACAAIAMpAwAQKCIBQoCAgIBwg0KAgICA4ABSBEAgACACQQhqIAGnIgUoAgRB/////wdxED0aIAVBEGohBiAFKAIEQf////8HcSEHQQAhAwNAIAMgB0ZFBEACQAJAAkAgBS0AB0GAAXFFBEAgAyAGai0AACEEDAELIAYgA0EBdGovAQAiBEH/AUsNAQtBkOEBIARBxQAQ+wFFDQAgAkEIaiAEEIsBGgwBCyACQQhqIAQQmgILIANBAWohAwwBCwsgACABEA8gAkEIahA2IQELIAJBIGokACABC84EAgZ/AX4jAEEgayIGJAACQCAAIAMpAwAQKCIBQoCAgIBwg0KAgICA4ABRDQAgACAGQQhqIAGnIgkoAgRB/////wdxED0aIAlBEGohCEEAIQICQANAIAkpAgQiC6dB/////wdxIgogAkoEQCACQQFqIQUCQAJAIAtCgICAgAiDIgtQBEAgAiAIai0AACEDDAELIAggAkEBdGovAQAiA0H/AUsNAQsCQCADQTBrQQpJIANB3/8DcUHBAGtBGklyDQBBpZQBIANBCRD7AQ0AIAQNASADELIGRQ0BCyAGQQhqIAMQiwEaIAUhAgwCCwJ/An8CQCADQYD4A3EiB0GAsANHBEAgB0GAuANHDQFBv8MAIQcMBgtB5MAAIQcgBSAKTg0FAn8gC1BFBEAgCCAFQQF0ai8BAAwBCyAFIAhqLQAACyIFQYDAA2tBgHhJDQUgBkEIaiAFQf8HcSADQQp0QYD4P3FyQYCABGoiA0ESdkHwAXIQmgIgA0EMdkE/cUGAAXIhByACQQJqDAELIANB/wBNBEAgBkEIaiADEJoCIAUhAgwECyADQf8PTQRAIAUhAiADQQZ2QcABcgwCCyADQQx2QeABciEHIAULIQIgBkEIaiAHEJoCIANBBnZBP3FBgAFyCyEHIAZBCGoiBSAHEJoCIAUgA0E/cUGAAXIQmgIMAQsLIAAgARAPIAZBCGoQNiEBDAELIAAgBxC5BCAAIAEQDyAGKAIIKAIQIgBBEGogBigCDCAAKAIEEQAAQoCAgIDgACEBCyAGQSBqJAAgAQuVBAIGfwF+IwBBIGsiBSQAAkAgACADKQMAECgiAUKAgICAcINCgICAgOAAUQ0AIAAgBUEIakEAED0aIAGnIghBEGohCUEAIQIDQAJAAkACQCAIKQIEIgunQf////8HcSACSgRAAn8gC0KAgICACINQRQRAIAkgAkEBdGovAQAMAQsgAiAJai0AAAsiA0ElRgRAIAAgCCACELMGIgNBAEgNAyACQQNqIQYgA0H/AE0EQCAEBEAgBiECDAYLQSUgAyADELIGIgcbIQMgAkEBaiAGIAcbIQIMBQsCfyADQWBxQcABRgRAIANBH3EhA0GAASEHQQEMAQsgA0FwcUHgAUYEQCADQQ9xIQNBgBAhB0ECDAELIANBeHFB8AFHBEBBASEHQQAhA0EADAELIANBB3EhA0GAgAQhB0EDCyECA0AgAkEATA0DIAAgCCAGELMGIgpBAEgNBCAGQQNqIQYgCkHAAXFBgAFHBEBBACEDDAQFIAJBAWshAiAKQT9xIANBBnRyIQMMAQsACwALIAJBAWohAgwDCyAAIAEQDyAFQQhqEDYhAQwECyAGIQIgAyAHSCADQf//wwBKckUgA0GAcHFBgLADR3ENASAAQcmJARC5BAsgACABEA8gBSgCCCgCECIAQRBqIAUoAgwgACgCBBEAAEKAgICA4AAhAQwCCyAFQQhqIAMQuQEaDAALAAsgBUEgaiQAIAELNwAgACADKQMAELMBIgJFBEBCgICAgOAADwsgACACEIECIAJqQQBBCkEAELgCIQEgACACEFQgAQuHAQEBfyMAQRBrIgIkAAJAIAAgAykDABCzASIERQRAQoCAgIDgACEBDAELAn5CgICAgOAAIAAgAkEMaiADKQMIEHcNABogAigCDCIDBEBCgICAgMB+IANBJWtBXUkNARoLIAAgBBCBAiAEakEAIANBgQgQuAILIQEgACAEEFQLIAJBEGokACABCwkAIAAgARDdAgujAQIBfgF/IwBBEGsiAiQAAn4gACABEN0CIgVCgICAgHCDQoCAgIDgAFEEQCAFDAELQQohBgJAAkAgBA0AIAMpAwAiAUKAgICAcINCgICAgDBRDQAgACABEI4FIgZBAEgNAQtCgICAgOAAIAAgAkEIaiAFEG4NARogACACKwMIIAZBAEEAEI8CDAELIAAgBRAPQoCAgIDgAAshASACQRBqJAAgAQuMAgIBfgF8IwBBEGsiAiQAQoCAgIDgACEEAkAgACABEN0CIgFCgICAgHCDQoCAgIDgAFEEQCABIQQMAQsgACACIAEQbg0AAkACQCADKQMAIgFCgICAgHCDQoCAgIAwUQRAIAIpAwAhAQwBCyAAIAJBDGogARC6AQ0CIAIrAwAiBb0iAUKAgICAgICA+P8Ag0KAgICAgICA+P8AUg0BCyAAQoCAgIDAfiABQoCAgIDAgYD8/wB9IAFC////////////AINCgICAgICAgPj/AFYbEDchBAwBCyACKAIMIgNB5QBrQZt/TQRAIABBijRBABBQDAELIAAgBUEKIANBARCPAiEECyACQRBqJAAgBAvYAQIBfgF8IwBBEGsiAiQAQoCAgIDgACEEAkAgACABEN0CIgFCgICAgHCDQoCAgIDgAFEEQCABIQQMAQsgACACIAEQbg0AIAAgAkEMaiADKQMAELoBDQAgAigCDCIDQeUATwRAIABBijRB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LUiv7z8IIKpBvMOOPCdaYe4buu8/Muupw5QrhDyXums3K8XvP+6F0TGpZIo8QEVuW3bQ7z/t4zvkujeOvBS+nK392+8/nc2RTTuJdzzYkJ6BwefvP4nMYEHBBVM88XGPK8Lz7z8AAAAAAADwPwAAAAAAAPg/AAAAAAAAAAAG0M9D6/1MPgBBmxkL54UBQAO44j8oKXt9ACgpe3N1cGVyKC4uLmFyZ3VtZW50cyk7fQAoKSB7CiAgICBbbmF0aXZlIGNvZGVdCn0AY2Fubm90IG1peCA/PyB3aXRoICYmIG9yIHx8AGN0egBwcm94eTogcHJvcGVydHkgbm90IHByZXNlbnQgaW4gdGFyZ2V0IHdlcmUgcmV0dXJuZWQgYnkgbm9uIGV4dGVuc2libGUgcHJveHkAcmV2b2tlZCBwcm94eQBQcm94eQBhZGRfcHJvcGVydHkAcHJveHk6IGNhbm5vdCBzZXQgcHJvcGVydHkAbm8gc2V0dGVyIGZvciBwcm9wZXJ0eQB2YWx1ZSBoYXMgbm8gcHJvcGVydHkAY291bGQgbm90IGRlbGV0ZSBwcm9wZXJ0eQBwcm94eTogZHVwbGljYXRlIHByb3BlcnR5AEpTX0RlZmluZUF1dG9Jbml0UHJvcGVydHkAaGFzT3duUHJvcGVydHkAcHJveHk6IGluY29uc2lzdGVudCBkZWxldGVQcm9wZXJ0eQBwcm94eTogaW5jb25zaXN0ZW50IGRlZmluZVByb3BlcnR5AEpTX0RlZmluZVByb3BlcnR5ACFtci0+ZW1wdHkAaW5maW5pdHkASW5maW5pdHkAb3V0IG9mIG1lbW9yeQB1bmtub3duIHVuaWNvZGUgZ2VuZXJhbCBjYXRlZ29yeQBHZW5lcmFsX0NhdGVnb3J5AGV2ZXJ5AGFueQBhcHBseQAnJXMnIGlzIHJlYWQtb25seQBleHBlY3RpbmcgY2F0Y2ggb3IgZmluYWxseQBzdGlja3kAYmlnaW50IGFyZSBmb3JiaWRkZW4gaW4gSlNPTi5zdHJpbmdpZnkAc3ViYXJyYXkAZW1wdHkgYXJyYXkAbm9uIGludGVnZXIgaW5kZXggaW4gdHlwZWQgYXJyYXkAbmVnYXRpdmUgaW5kZXggaW4gdHlwZWQgYXJyYXkAb3V0LW9mLWJvdW5kIGluZGV4IGluIHR5cGVkIGFycmF5AGNhbm5vdCBjcmVhdGUgbnVtZXJpYyBpbmRleCBpbiB0eXBlZCBhcnJheQBpc0FycmF5AFR5cGVkQXJyYXkAZ2V0RGF5AGdldFVUQ0RheQBqc19nZXRfYXRvbV9pbmRleABpbnZhbGlkIGFycmF5IGluZGV4AG91dC1vZi1ib3VuZCBudW1lcmljIGluZGV4AEpTX0F0b21Jc0FycmF5SW5kZXgAZmluZEluZGV4AGludmFsaWQgZXhwb3J0IHN5bnRheABpbnZhbGlkIGFzc2lnbm1lbnQgc3ludGF4AG1heABcdSUwNHgAaW52YWxpZCBvcGNvZGU6IHBjPSV1IG9wY29kZT0weCUwMngALSsgICAwWDB4AC0wWCswWCAwWC0weCsweCAweABsaW5lIHRlcm1pbmF0b3Igbm90IGFsbG93ZWQgYWZ0ZXIgdGhyb3cAYmZfcG93AG5vdwBpbnRlZ2VyIG92ZXJmbG93AHN0YWNrIG92ZXJmbG93AG11c3QgYmUgY2FsbGVkIHdpdGggbmV3AGlzVmlldwBEYXRhVmlldwByYXcAdGRpdgBmZGl2AGVkaXYAY2RpdgAldQBjbGFzcyBkZWNsYXJhdGlvbnMgY2FuJ3QgYXBwZWFyIGluIHNpbmdsZS1zdGF0ZW1lbnQgY29udGV4dABmdW5jdGlvbiBkZWNsYXJhdGlvbnMgY2FuJ3QgYXBwZWFyIGluIHNpbmdsZS1zdGF0ZW1lbnQgY29udGV4dABsZXhpY2FsIGRlY2xhcmF0aW9ucyBjYW4ndCBhcHBlYXIgaW4gc2luZ2xlLXN0YXRlbWVudCBjb250ZXh0AGR1cGxpY2F0ZSBhcmd1bWVudCBuYW1lcyBub3QgYWxsb3dlZCBpbiB0aGlzIGNvbnRleHQAZHVwbGljYXRlIHBhcmFtZXRlciBuYW1lcyBub3QgYWxsb3dlZCBpbiB0aGlzIGNvbnRleHQAaW1wb3J0Lm1ldGEgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGNvbnRleHQASlNfRnJlZUNvbnRleHQASlNDb250ZXh0AGpzX21hcF9pdGVyYXRvcl9uZXh0AGpzX2FzeW5jX2dlbmVyYXRvcl9yZXN1bWVfbmV4dAB1bmV4cGVjdGVkIGVuZCBvZiBpbnB1dAB0dABleHBvcnRlZCB2YXJpYWJsZSAnJXMnIGRvZXMgbm90IGV4aXN0AHByaXZhdGUgY2xhc3MgZmllbGQgJyVzJyBkb2VzIG5vdCBleGlzdAB0ZXN0AGFzc2lnbm1lbnQgcmVzdCBwcm9wZXJ0eSBtdXN0IGJlIGxhc3QAYmZfc3FydABzb3J0AGNicnQAdHJpbVN0YXJ0AHBhZFN0YXJ0AHVua25vd24gdW5pY29kZSBzY3JpcHQAU2NyaXB0AGh5cG90AGZyZWVfemVyb19yZWZjb3VudABmYXN0X2FycmF5X2NvdW50AGJpbmFyeV9vYmplY3RfY291bnQAc3RyX2luZGV4ID09IG51bV9rZXlzX2NvdW50ICsgc3RyX2tleXNfY291bnQAbnVtX2luZGV4ID09IG51bV9rZXlzX2NvdW50AHN0cl9jb3VudABwcm9wX2NvdW50AHN5bV9pbmRleCA9PSBhdG9tX2NvdW50AGxhYmVsID49IDAgJiYgbGFiZWwgPCBzLT5sYWJlbF9jb3VudABsYWIxID49IDAgJiYgbGFiMSA8IHMtPmxhYmVsX2NvdW50AG9ial9jb3VudAB2YWwgPCBzLT5jYXB0dXJlX2NvdW50AHZhbDIgPCBzLT5jYXB0dXJlX2NvdW50AHNoYXBlX2NvdW50AGpzX2Z1bmNfcGMybGluZV9jb3VudABtZW1vcnlfdXNlZF9jb3VudABtYWxsb2NfY291bnQAanNfZnVuY19jb3VudABjX2Z1bmNfY291bnQAaW52YWxpZCByZXBlYXQgY291bnQAaW52YWxpZCByZXBldGl0aW9uIGNvdW50AGZvbnQAaW52YWxpZCBjb2RlIHBvaW50AGZyb21Db2RlUG9pbnQAaW52YWxpZCBoaW50AGNhbm5vdCBjb252ZXJ0IE5hTiBvciBJbmZpbml0eSB0byBiaWdpbnQAY2Fubm90IGNvbnZlcnQgdG8gYmlnaW50AGJvdGggb3BlcmFuZHMgbXVzdCBiZSBiaWdpbnQAbm90IGEgYmlnaW50AGVuY29kZVVSSUNvbXBvbmVudABkZWNvZGVVUklDb21wb25lbnQAdW5leHBlY3RlZCBlbmQgb2YgY29tbWVudABpbnZhbGlkIHN3aXRjaCBzdGF0ZW1lbnQAQmlnSW50AHBhcnNlSW50AGR1cGxpY2F0ZSBkZWZhdWx0AG1hbGxvY19saW1pdABzcGxpdABleHBlY3RpbmcgaGV4IGRpZ2l0AHRyaW1SaWdodAByZWR1Y2VSaWdodAB1bnNoaWZ0AHRyaW1MZWZ0AGludmFsaWQgb2Zmc2V0AGludmFsaWQgYnl0ZU9mZnNldABnZXRUaW1lem9uZU9mZnNldAByZXNvbHZpbmcgZnVuY3Rpb24gYWxyZWFkeSBzZXQAcHJveHk6IGluY29uc2lzdGVudCBzZXQAZmluZF9qdW1wX3RhcmdldABleHBlY3RpbmcgdGFyZ2V0AGludmFsaWQgZGVzdHJ1Y3R1cmluZyB0YXJnZXQAcHJveHk6IGluY29uc2lzdGVudCBnZXQAV2Vha1NldABjb25zdHJ1Y3QASlNfRnJlZUF0b21TdHJ1Y3QAdXNlIHN0cmljdABSZWZsZWN0AHJlamVjdABub3QgYW4gQXN5bmNHZW5lcmF0b3Igb2JqZWN0AGNhbm5vdCBjb252ZXJ0IHRvIG9iamVjdABpbnZhbGlkIGJyYW5kIG9uIG9iamVjdABvcGVyYW5kICdwcm90b3R5cGUnIHByb3BlcnR5IGlzIG5vdCBhbiBvYmplY3QAcmVjZWl2ZXIgaXMgbm90IGFuIG9iamVjdABpdGVyYXRvciBtdXN0IHJldHVybiBhbiBvYmplY3QAbm90IGEgRGF0ZSBvYmplY3QAbm90IGEgb2JqZWN0AEpTT2JqZWN0AGJpZ2Zsb2F0AHBhcnNlRmxvYXQAZmxhdABub3RoaW5nIHRvIHJlcGVhdABjb25jYXQAY29kZVBvaW50QXQAY2hhckF0AGNoYXJDb2RlQXQAa2V5cwBwcm94eTogdGFyZ2V0IHByb3BlcnR5IG11c3QgYmUgcHJlc2VudCBpbiBwcm94eSBvd25LZXlzACAgZmFzdCBhcnJheXMAZXhwb3J0ICclcycgaW4gbW9kdWxlICclcycgaXMgYW1iaWd1b3VzAHByaXZhdGUgY2xhc3MgZmllbGQgJyVzJyBhbHJlYWR5IGV4aXN0cwB0b28gbWFueSBhcmd1bWVudHMAVG9vIG1hbnkgY2FsbCBhcmd1bWVudHMAZmFzdF9hcnJheV9lbGVtZW50cwAgIGVsZW1lbnRzAGludmFsaWQgbnVtYmVyIG9mIGRpZ2l0cwBiaW5hcnkgb2JqZWN0cwBpbnZhbGlkIHByb3BlcnR5IGFjY2VzcwBqc19vcF9kZWZpbmVfY2xhc3MAZmQtPmJ5dGVfY29kZS5idWZbZGVmaW5lX2NsYXNzX3Bvc10gPT0gT1BfZGVmaW5lX2NsYXNzAF9fZ2V0Q2xhc3MAc2V0SG91cnMAZ2V0SG91cnMAc2V0VVRDSG91cnMAZ2V0VVRDSG91cnMAZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycwB0b28gbWFueSBpbWJyaWNhdGVkIHF1YW50aWZpZXJzAHVuaWNvZGVfcHJvcF9vcHMAYWNvcwBmb3IgYXdhaXQgaXMgb25seSB2YWxpZCBpbiBhc3luY2hyb25vdXMgZnVuY3Rpb25zAG5ldy50YXJnZXQgb25seSBhbGxvd2VkIHdpdGhpbiBmdW5jdGlvbnMAYnl0ZWNvZGUgZnVuY3Rpb25zAEMgZnVuY3Rpb25zAHByb3h5OiBpbmNvbnNpc3RlbnQgcHJldmVudEV4dGVuc2lvbnMAU2NyaXB0X0V4dGVuc2lvbnMAYXRvbXMAcHJveHk6IHByb3BlcnRpZXMgbXVzdCBiZSBzdHJpbmdzIG9yIHN5bWJvbHMAZ2V0T3duUHJvcGVydHlTeW1ib2xzAHJlc29sdmVfbGFiZWxzAEpTX0V2YWxUaGlzAHN0cmluZ3MAaW52YWxpZCBkZXNjcmlwdG9yIGZsYWdzAGludmFsaWQgcmVndWxhciBleHByZXNzaW9uIGZsYWdzAHZhbHVlcwBzZXRNaW51dGVzAGdldE1pbnV0ZXMAc2V0VVRDTWludXRlcwBnZXRVVENNaW51dGVzAHRvbyBtYW55IGNhcHR1cmVzACAgc2hhcGVzAGdldE93blByb3BlcnR5TmFtZXMAZ2NfZnJlZV9jeWNsZXMAYWRkX2V2YWxfdmFyaWFibGVzAHJlc29sdmVfdmFyaWFibGVzAHRvbyBtYW55IGxvY2FsIHZhcmlhYmxlcwB0b28gbWFueSBjbG9zdXJlIHZhcmlhYmxlcwBjb21wYWN0X3Byb3BlcnRpZXMAICBwcm9wZXJ0aWVzAGRlZmluZVByb3BlcnRpZXMAZW50cmllcwBmcm9tRW50cmllcwB0b28gbWFueSByYW5nZXMAaW5jbHVkZXMAc2V0TWlsbGlzZWNvbmRzAGdldE1pbGxpc2Vjb25kcwBzZXRVVENNaWxsaXNlY29uZHMAZ2V0VVRDTWlsbGlzZWNvbmRzAHNldFNlY29uZHMAZ2V0U2Vjb25kcwBzZXRVVENTZWNvbmRzAGdldFVUQ1NlY29uZHMAaXRhbGljcwBhYnMAcHJveHk6IGluY29uc2lzdGVudCBoYXMAJS4qcwAgKCVzAHNldCAlcwBnZXQgJXMAICAgIGF0ICVzAG5vIG92ZXJsb2FkZWQgb3BlcmF0b3IgJXMAbm90IGEgJXMAdW5zdXBwb3J0ZWQga2V5d29yZDogJXMAc3Vic3RyAHByb3h5OiBpbmNvbnNpc3RlbnQgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yAHN1cGVyKCkgaXMgb25seSB2YWxpZCBpbiBhIGRlcml2ZWQgY2xhc3MgY29uc3RydWN0b3IAcGFyZW50IGNsYXNzIG11c3QgYmUgY29uc3RydWN0b3IAbm90IGEgY29uc3RydWN0b3IAQXJyYXkgSXRlcmF0b3IAU2V0IEl0ZXJhdG9yAE1hcCBJdGVyYXRvcgBSZWdFeHAgU3RyaW5nIEl0ZXJhdG9yAG5vdCBhbiBBc3luYy1mcm9tLVN5bmMgSXRlcmF0b3IAY2Fubm90IGludm9rZSBhIHJ1bm5pbmcgZ2VuZXJhdG9yAG5vdCBhIGdlbmVyYXRvcgBBc3luY0dlbmVyYXRvcgBzeW50YXggZXJyb3IAU3ludGF4RXJyb3IARXZhbEVycm9yAEludGVybmFsRXJyb3IAQWdncmVnYXRlRXJyb3IAVHlwZUVycm9yAFJhbmdlRXJyb3IAUmVmZXJlbmNlRXJyb3IAVVJJRXJyb3IAZmxvb3IAZm9udGNvbG9yAGFuY2hvcgBmb3IAa2V5Rm9yAGV4cGVjdGluZyBzdXJyb2dhdGUgcGFpcgBhIGRlY2xhcmF0aW9uIGluIHRoZSBoZWFkIG9mIGEgZm9yLSVzIGxvb3AgY2FuJ3QgaGF2ZSBhbiBpbml0aWFsaXplcgAnYXJndW1lbnRzJyBpZGVudGlmaWVyIGlzIG5vdCBhbGxvd2VkIGluIGNsYXNzIGZpZWxkIGluaXRpYWxpemVyAGludmFsaWQgbnVtYmVyIG9mIGFyZ3VtZW50cyBmb3IgZ2V0dGVyIG9yIHNldHRlcgBpbnZhbGlkIHNldHRlcgBpbnZhbGlkIGdldHRlcgBmaWx0ZXIAbWlzc2luZyBmb3JtYWwgcGFyYW1ldGVyACJ1c2Ugc3RyaWN0IiBub3QgYWxsb3dlZCBpbiBmdW5jdGlvbiB3aXRoIGRlZmF1bHQgb3IgZGVzdHJ1Y3R1cmluZyBwYXJhbWV0ZXIAaW52YWxpZCBjaGFyYWN0ZXIAdW5leHBlY3RlZCBjaGFyYWN0ZXIAcHJpdmF0ZSBjbGFzcyBmaWVsZCBmb3JiaWRkZW4gYWZ0ZXIgc3VwZXIAaW52YWxpZCByZWRlZmluaXRpb24gb2YgbGV4aWNhbCBpZGVudGlmaWVyACdsZXQnIGlzIG5vdCBhIHZhbGlkIGxleGljYWwgaWRlbnRpZmllcgBpbnZhbGlkIHJlZGVmaW5pdGlvbiBvZiBnbG9iYWwgaWRlbnRpZmllcgB5aWVsZCBpcyBhIHJlc2VydmVkIGlkZW50aWZpZXIAJyVzJyBpcyBhIHJlc2VydmVkIGlkZW50aWZpZXIAb3RoZXIAYXRvbTFfaXNfaW50ZWdlciAmJiBhdG9tMl9pc19pbnRlZ2VyAGNhbm5vdCBjb252ZXJ0IHRvIGJpZ2ludDogbm90IGFuIGludGVnZXIAaXNJbnRlZ2VyAGlzU2FmZUludGVnZXIAYnVmZmVyAFNoYXJlZEFycmF5QnVmZmVyAGNhbm5vdCB1c2UgaWRlbnRpY2FsIEFycmF5QnVmZmVyAGNhbm5vdCBjb252ZXJ0IGJpZ2ludCB0byBudW1iZXIAY2Fubm90IGNvbnZlcnQgYmlnZmxvYXQgdG8gbnVtYmVyAGNhbm5vdCBjb252ZXJ0IHN5bWJvbCB0byBudW1iZXIAY2Fubm90IGNvbnZlcnQgYmlnZGVjaW1hbCB0byBudW1iZXIAbm90IGEgbnVtYmVyAGxpbmVOdW1iZXIAbWFsZm9ybWVkIHVuaWNvZGUgY2hhcgBjbGVhcgBzZXRZZWFyAGdldFllYXIAc2V0RnVsbFllYXIAZ2V0RnVsbFllYXIAc2V0VVRDRnVsbFllYXIAZ2V0VVRDRnVsbFllYXIAcSAhPSByAHVuZXhwZWN0ZWQgbGluZSB0ZXJtaW5hdG9yIGluIHJlZ2V4cAB1bmV4cGVjdGVkIGVuZCBvZiByZWdleHAAUmVnRXhwAHN1cABpbnZhbGlkIGdyb3VwAHBvcABjb250aW51ZSBtdXN0IGJlIGluc2lkZSBsb29wAGJmX2xvZ2ljX29wAG51bV9rZXlzX2NtcAB1c2Ugc3RyaXAAbWFwAGZsYXRNYXAAV2Vha01hcABleHBlY3RpbmcgJ3snIGFmdGVyIFxwAGxvZzFwAGRpdmlzaW9uIGJ5IHplcm8AdW5rbm93bgBpdGVyYXRvcl9jbG9zZV9yZXR1cm4AcHJvbWlzZSBzZWxmIHJlc29sdXRpb24Ab3V0IG9mIG1lbW9yeSBpbiByZWdleHAgZXhlY3V0aW9uAGRlc2NyaXB0aW9uAHByb3h5OiBkZWZpbmVQcm9wZXJ0eSBleGNlcHRpb24AanNfYXN5bmNfZ2VuZXJhdG9yX3Jlc29sdmVfZnVuY3Rpb24AanNfY3JlYXRlX2Z1bmN0aW9uAHNldC9hZGQgaXMgbm90IGEgZnVuY3Rpb24AcmV0dXJuIG5vdCBpbiBhIGZ1bmN0aW9uAEFzeW5jR2VuZXJhdG9yRnVuY3Rpb24AQXN5bmNGdW5jdGlvbgBpbnZhbGlkIG9wZXJhdGlvbgB1bnN1cHBvcnRlZCBvcGVyYXRpb24AYXdhaXQgaW4gZGVmYXVsdCBleHByZXNzaW9uAHlpZWxkIGluIGRlZmF1bHQgZXhwcmVzc2lvbgBpbnZhbGlkIGRlY2ltYWwgZXNjYXBlIGluIHJlZ3VsYXIgZXhwcmVzc2lvbgBiYWNrIHJlZmVyZW5jZSBvdXQgb2YgcmFuZ2UgaW4gcmVndWxhciBleHByZXNzaW9uAGludmFsaWQgZXNjYXBlIHNlcXVlbmNlIGluIHJlZ3VsYXIgZXhwcmVzc2lvbgBleHBlY3RlZCAnb2YnIG9yICdpbicgaW4gZm9yIGNvbnRyb2wgZXhwcmVzc2lvbgB0b28gY29tcGxpY2F0ZWQgZGVzdHJ1Y3R1cmluZyBleHByZXNzaW9uAGV4cGVjdGVkICd9JyBhZnRlciB0ZW1wbGF0ZSBleHByZXNzaW9uAHRvUHJlY2lzaW9uAGFzaW4Aam9pbgBtaW4AY29weVdpdGhpbgB0ZW1wbGF0ZSBsaXRlcmFsIGNhbm5vdCBhcHBlYXIgaW4gYW4gb3B0aW9uYWwgY2hhaW4AY2lyY3VsYXIgcHJvdG90eXBlIGNoYWluAGFzc2lnbgAheS0+c2lnbgBpc0Zyb3plbgBtYXJrX2NoaWxkcmVuAChwb3MgKyBsZW4pIDw9IGJjX2J1Zl9sZW4AdW5leHBlY3RlZCBlbGxpcHNpcyB0b2tlbgB0aGVuAHNldHRlciBpcyBmb3JiaWRkZW4AbnVsbCBvciB1bmRlZmluZWQgYXJlIGZvcmJpZGRlbgBhdGFuAG5hbgBub3QgYSBib29sZWFuAEJvb2xlYW4AZ2Nfc2NhbgBiYWQgbm9ybWFsaXphdGlvbiBmb3JtAEpTX05ld1N5bWJvbEZyb21BdG9tAGZyb20AcmFuZG9tAHRyaW0AdGRpdnJlbQBmZGl2cmVtAGVkaXZyZW0AY2RpdnJlbQBiZl9kaXZyZW0Ac3FydHJlbQBpbXVsAG5vdCBhIHN5bWJvbABTeW1ib2wAUmVnRXhwIGV4ZWMgbWV0aG9kIG11c3QgcmV0dXJuIGFuIG9iamVjdCBvciBudWxsAHBhcmVudCBwcm90b3R5cGUgbXVzdCBiZSBhbiBvYmplY3Qgb3IgbnVsbABjYW5ub3Qgc2V0IHByb3BlcnR5ICclcycgb2YgbnVsbABjYW5ub3QgcmVhZCBwcm9wZXJ0eSAnJXMnIG9mIG51bGwATnVsbABmaWxsAG5ldyBBcnJheUJ1ZmZlciBpcyB0b28gc21hbGwAVHlwZWRBcnJheSBsZW5ndGggaXMgdG9vIHNtYWxsAGNhbGwAZG90QWxsAG1hdGNoQWxsAHJlcGxhY2VBbGwAY2VpbAB1cGRhdGVfbGFiZWwAYmNfYnVmW3Bvc10gPT0gT1BfbGFiZWwAZXZhbABpbnZhbGlkIGJpZ2ludCBsaXRlcmFsAGludmFsaWQgbnVtYmVyIGxpdGVyYWwAbWFsZm9ybWVkIGVzY2FwZSBzZXF1ZW5jZSBpbiBzdHJpbmcgbGl0ZXJhbABiZl9leHBfaW50ZXJuYWwAYmZfbG9nX2ludGVybmFsAEpTX1NldFByb3BlcnR5SW50ZXJuYWwASlNfR2V0T3duUHJvcGVydHlOYW1lc0ludGVybmFsAF9fSlNfRXZhbEludGVybmFsAGJpZ2RlY2ltYWwAbnR0X2ZmdF9wYXJ0aWFsAHRvRXhwb25lbnRpYWwAc2VhbABnbG9iYWwAYmxpbmsAX19kYXRlX2Nsb2NrAHN0YWNrAGxyZV9leGVjX2JhY2t0cmFjawBzLT5pc193ZWFrAGJmX3Bvd191aQBzZXRNb250aABnZXRNb250aABzZXRVVENNb250aABnZXRVVENNb250aABpbnZhbGlkIGtleXdvcmQ6IHdpdGgAc3RhcnRzV2l0aABlbmRzV2l0aABwcm9wID09IEpTX0FUT01fbGVuZ3RoAGludmFsaWQgYXJyYXkgbGVuZ3RoAGludmFsaWQgYXJyYXkgYnVmZmVyIGxlbmd0aABpbnZhbGlkIGxlbmd0aABpbnZhbGlkIGJ5dGVMZW5ndGgAdXNlIG1hdGgATWF0aABwdXNoAGFjb3NoAEpTX1Jlc2l6ZUF0b21IYXNoAGFzaW5oAGF0YW5oAGJyZWFrIG11c3QgYmUgaW5zaWRlIGxvb3Agb3Igc3dpdGNoAG1hdGNoAGNhdGNoAHNlYXJjaABmb3JFYWNoAGJmX2xvZwBBcnJheSB0b28gbG9uZwBzdHJpbmcgdG9vIGxvbmcAQXJyYXkgbG9vIGxvbmcAc3Vic3RyaW5nAGNhbm5vdCBjb252ZXJ0IHN5bWJvbCB0byBzdHJpbmcAdW5leHBlY3RlZCBlbmQgb2Ygc3RyaW5nAG5vdCBhIHN0cmluZwBpbnZhbGlkIGNoYXJhY3RlciBpbiBhIEpTT04gc3RyaW5nAHRvU3RyaW5nAHRvRGF0ZVN0cmluZwB0b0xvY2FsZURhdGVTdHJpbmcAdG9UaW1lU3RyaW5nAHRvTG9jYWxlVGltZVN0cmluZwB0b0xvY2FsZVN0cmluZwB0b0dNVFN0cmluZwBKU1N0cmluZwB0b0lTT1N0cmluZwB0b1VUQ1N0cmluZwBkdXBsaWNhdGUgaW1wb3J0IGJpbmRpbmcAaW52YWxpZCBpbXBvcnQgYmluZGluZwBiaWcAcmVnZXhwIG11c3QgaGF2ZSB0aGUgJ2cnIGZsYWcAb2YAaW5mAGRpZmYgPT0gKGludDhfdClkaWZmAGRpZmYgPT0gKGludDE2X3QpZGlmZgBocmVmAGdjX2RlY3JlZgBmcmVlX3Zhcl9yZWYAb3B0aW1pemVfc2NvcGVfbWFrZV9nbG9iYWxfcmVmAHJlc2V0X3dlYWtfcmVmAGRlbGV0ZV93ZWFrX3JlZgBvcHRpbWl6ZV9zY29wZV9tYWtlX3JlZgBpbmRleE9mAGxhc3RJbmRleE9mAHZhbHVlT2YAc2V0UHJvdG90eXBlT2YAZ2V0UHJvdG90eXBlT2YAaXNQcm90b3R5cGVPZgAlLipmAGZvbnRzaXplAGJpbmFyeV9vYmplY3Rfc2l6ZQBzdHJfc2l6ZQBuZXdfc2l6ZSA8PSBzaC0+cHJvcF9zaXplAGRlc2NyIDwgcnQtPmF0b21fc2l6ZQBhdG9tIDwgcnQtPmF0b21fc2l6ZQBjb21wdXRlX3N0YWNrX3NpemUAb2JqX3NpemUAbiA8IGJ1Zl9zaXplAHNoYXBlX3NpemUAanNfZnVuY19wYzJsaW5lX3NpemUAanNfZnVuY19jb2RlX3NpemUAbWVtb3J5X3VzZWRfc2l6ZQBqc19mdW5jX3NpemUAbm9ybWFsaXplAGZyZWV6ZQByZXNvbHZlAHRvUHJpbWl0aXZlAHB1dF9sdmFsdWUAdW5rbm93biB1bmljb2RlIHByb3BlcnR5IHZhbHVlAHJlc3QgZWxlbWVudCBjYW5ub3QgaGF2ZSBhIGRlZmF1bHQgdmFsdWUAaW52YWxpZCByZXQgdmFsdWUAX19KU19BdG9tVG9WYWx1ZQBfX3F1b3RlAGlzRmluaXRlAGRlbGV0ZQBjcmVhdGUAc2V0RGF0ZQBnZXREYXRlAHNldFVUQ0RhdGUAZ2V0VVRDRGF0ZQBJbnZhbGlkIERhdGUAcmV2ZXJzZQBwYXJzZQBwcm94eSBwcmV2ZW50RXh0ZW5zaW9ucyBoYW5kbGVyIHJldHVybmVkIGZhbHNlAFByb21pc2UAdG9Mb3dlckNhc2UAdG9Mb2NhbGVMb3dlckNhc2UAdG9VcHBlckNhc2UAdG9Mb2NhbGVVcHBlckNhc2UAaWdub3JlQ2FzZQBsb2NhbGVDb21wYXJlAHByb3h5OiBpbmNvbnNpc3RlbnQgcHJvdG90eXBlAHByb3h5OiBiYWQgcHJvdG90eXBlAG5vdCBhIHByb3RvdHlwZQBpbnZhbGlkIG9iamVjdCB0eXBlAHVuZXNjYXBlAG5vbmUAcmVzdCBlbGVtZW50IG11c3QgYmUgdGhlIGxhc3Qgb25lAG11bHRpbGluZQAgIHBjMmxpbmUAc29tZQBKU19GcmVlUnVudGltZQBKU1J1bnRpbWUAc2V0VGltZQBnZXRUaW1lAHNldF9vYmplY3RfbmFtZQBleHBlY3RpbmcgcHJvcGVydHkgbmFtZQB1bmtub3duIHVuaWNvZGUgcHJvcGVydHkgbmFtZQBpbnZhbGlkIHByb3BlcnR5IG5hbWUAZHVwbGljYXRlIF9fcHJvdG9fXyBwcm9wZXJ0eSBuYW1lAGludmFsaWQgcmVkZWZpbml0aW9uIG9mIHBhcmFtZXRlciBuYW1lAGV4cGVjdGluZyBncm91cCBuYW1lAGR1cGxpY2F0ZSBncm91cCBuYW1lAGludmFsaWQgZ3JvdXAgbmFtZQBkdXBsaWNhdGUgbGFiZWwgbmFtZQBpbnZhbGlkIGZpcnN0IGNoYXJhY3RlciBvZiBwcml2YXRlIG5hbWUAaW52YWxpZCBsZXhpY2FsIHZhcmlhYmxlIG5hbWUAaW52YWxpZCBtZXRob2QgbmFtZQBleHBlY3RpbmcgZmllbGQgbmFtZQBpbnZhbGlkIGZpZWxkIG5hbWUAY2xhc3Mgc3RhdGVtZW50IHJlcXVpcmVzIGEgbmFtZQBmaWxlTmFtZQBjb21waWxlAG9iamVjdCBpcyBub3QgZXh0ZW5zaWJsZQBwcm94eTogaW5jb25zaXN0ZW50IGlzRXh0ZW5zaWJsZQBjYW5ub3QgaGF2ZSBzZXR0ZXIvZ2V0dGVyIGFuZCB2YWx1ZSBvciB3cml0YWJsZQBwcm9wZXJ0eSBpcyBub3QgY29uZmlndXJhYmxlAHZhbHVlIGlzIG5vdCBpdGVyYWJsZQBwcm9wZXJ0eUlzRW51bWVyYWJsZQBtaXNzaW5nIGluaXRpYWxpemVyIGZvciBjb25zdCB2YXJpYWJsZQBsZXhpY2FsIHZhcmlhYmxlAGludmFsaWQgcmVkZWZpbml0aW9uIG9mIGEgdmFyaWFibGUAcmV2b2NhYmxlAHN0cmlrZQBtcF9kaXZub3JtX2xhcmdlAGludmFsaWQgY2xhc3MgcmFuZ2UAbWVzc2FnZQBhc3luY19mdW5jX2ZyZWUAaW52YWxpZCBsdmFsdWUgaW4gc3RyaWN0IG1vZGUAaW52YWxpZCB2YXJpYWJsZSBuYW1lIGluIHN0cmljdCBtb2RlAGNhbm5vdCBkZWxldGUgYSBkaXJlY3QgcmVmZXJlbmNlIGluIHN0cmljdCBtb2RlAG9jdGFsIGVzY2FwZSBzZXF1ZW5jZXMgYXJlIG5vdCBhbGxvd2VkIGluIHN0cmljdCBtb2RlAG9jdGFsIGxpdGVyYWxzIGFyZSBkZXByZWNhdGVkIGluIHN0cmljdCBtb2RlAHVuaWNvZGUAICBieXRlY29kZQBKU0Z1bmN0aW9uQnl0ZWNvZGUAc2tpcF9kZWFkX2NvZGUAaW52YWxpZCBhcmd1bWVudCBuYW1lIGluIHN0cmljdCBjb2RlAGludmFsaWQgZnVuY3Rpb24gbmFtZSBpbiBzdHJpY3QgY29kZQBpbnZhbGlkIHJlZGVmaW5pdGlvbiBvZiBnbG9iYWwgaWRlbnRpZmllciBpbiBtb2R1bGUgY29kZQBpbXBvcnQubWV0YSBvbmx5IHZhbGlkIGluIG1vZHVsZSBjb2RlAGZyb21DaGFyQ29kZQBpbnZhbGlkIGZvciBpbi9vZiBsZWZ0IGhhbmQtc2lkZQBpbnZhbGlkIGFzc2lnbm1lbnQgbGVmdC1oYW5kIHNpZGUAcmVkdWNlAHNvdXJjZQAndGhpcycgY2FuIGJlIGluaXRpYWxpemVkIG9ubHkgb25jZQBwcm9wZXJ0eSBjb25zdHJ1Y3RvciBhcHBlYXJzIG1vcmUgdGhhbiBvbmNlAGludmFsaWQgVVRGLTggc2VxdWVuY2UAY2lyY3VsYXIgcmVmZXJlbmNlAHNsaWNlAHNwbGljZQByYWNlAHJlcGxhY2UAJSsuKmUAdW5leHBlY3RlZCAnYXdhaXQnIGtleXdvcmQAdW5leHBlY3RlZCAneWllbGQnIGtleXdvcmQAbWFwX2RlY3JlZl9yZWNvcmQAaXRlcmF0b3IgZG9lcyBub3QgaGF2ZSBhIHRocm93IG1ldGhvZABvYmplY3QgbmVlZHMgdG9JU09TdHJpbmcgbWV0aG9kACdzdXBlcicgaXMgb25seSB2YWxpZCBpbiBhIG1ldGhvZABmcm91bmQAX19iZl9yb3VuZABicmVhay9jb250aW51ZSBsYWJlbCBub3QgZm91bmQAb3V0IG9mIGJvdW5kAGZpbmQAYmluZABpbnZhbGlkIGluZGV4IGZvciBhcHBlbmQAZXh0cmFuZW91cyBjaGFyYWN0ZXJzIGF0IHRoZSBlbmQAdW5leHBlY3RlZCBkYXRhIGF0IHRoZSBlbmQAdW5leHBlY3RlZCBlbmQAaW52YWxpZCBpbmNyZW1lbnQvZGVjcmVtZW50IG9wZXJhbmQAaW52YWxpZCAnaW5zdGFuY2VvZicgcmlnaHQgb3BlcmFuZABpbnZhbGlkICdpbicgb3BlcmFuZAB0cmltRW5kAHBhZEVuZABib2xkACVsbGQAZ2NfZGVjcmVmX2NoaWxkAHJlc29sdmVfc2NvcGVfcHJpdmF0ZV9maWVsZABjYW5ub3QgZGVsZXRlIGEgcHJpdmF0ZSBjbGFzcyBmaWVsZABleHBlY3RpbmcgPGJyYW5kPiBwcml2YXRlIGZpZWxkACVzIGlzIG5vdCBpbml0aWFsaXplZABmaXhlZAB0b0ZpeGVkAHNldF9vYmplY3RfbmFtZV9jb21wdXRlZAByZWdleCBub3Qgc3VwcG9ydGVkAGV2YWwgaXMgbm90IHN1cHBvcnRlZABSZWdFeHAgYXJlIG5vdCBzdXBwb3J0ZWQAaW50ZXJydXB0ZWQAJXMgb2JqZWN0IGV4cGVjdGVkAGlkZW50aWZpZXIgZXhwZWN0ZWQAYnl0ZWNvZGUgZnVuY3Rpb24gZXhwZWN0ZWQAc3RyaW5nIGV4cGVjdGVkAGZyb20gY2xhdXNlIGV4cGVjdGVkAGZ1bmN0aW9uIG5hbWUgZXhwZWN0ZWQAdmFyaWFibGUgbmFtZSBleHBlY3RlZABtZXRhIGV4cGVjdGVkAHJlamVjdGVkAG1lbW9yeSBhbGxvY2F0ZWQAbWVtb3J5IHVzZWQAZGVyaXZlZCBjbGFzcyBjb25zdHJ1Y3RvciBtdXN0IHJldHVybiBhbiBvYmplY3Qgb3IgdW5kZWZpbmVkAGNhbm5vdCBzZXQgcHJvcGVydHkgJyVzJyBvZiB1bmRlZmluZWQAY2Fubm90IHJlYWQgcHJvcGVydHkgJyVzJyBvZiB1bmRlZmluZWQAZmxhZ3MgbXVzdCBiZSB1bmRlZmluZWQAVW5kZWZpbmVkAHByaXZhdGUgY2xhc3MgZmllbGQgaXMgYWxyZWFkeSBkZWZpbmVkACclcycgaXMgbm90IGRlZmluZWQAZ3JvdXAgbmFtZSBub3QgZGVmaW5lZABvcGVyYXRvciAlczogbm8gZnVuY3Rpb24gZGVmaW5lZABhbGxTZXR0bGVkAGZ1bGZpbGxlZABjYW5ub3QgYmUgY2FsbGVkAGlzU2VhbGVkACFzaC0+aXNfaGFzaGVkAHZhcl9yZWYtPmlzX2RldGFjaGVkAEFycmF5QnVmZmVyIGlzIGRldGFjaGVkAGFkZAAlKzA3ZAAlMDRkACUwMmQlMDJkACUwMmQvJTAyZC8lMCpkACUuM3MgJS4zcyAlMDJkICUwKmQAOiVkAGludmFsaWQgdGhyb3cgdmFyIHR5cGUgJWQAc2MAanNfZGVmX21hbGxvYwB0cnVuYwBnYwBleGVjAGJmX2ludGVnZXJfdG9fcmFkaXhfcmVjAHF1aWNranMvcXVpY2tqcy5jAHF1aWNranMvbGlicmVnZXhwLmMAcXVpY2tqcy9saWJiZi5jAHF1aWNranMvbGlidW5pY29kZS5jAHN1YgBwcm9taXNlX3JlYWN0aW9uX2pvYgBqc19wcm9taXNlX3Jlc29sdmVfdGhlbmFibGVfam9iAHIgIT0gYSAmJiByICE9IGIAcSAhPSBhICYmIHEgIT0gYgByd2EAciAhPSBhAF9fbG9va3VwU2V0dGVyX18AX19kZWZpbmVTZXR0ZXJfXwBfX2xvb2t1cEdldHRlcl9fAF9fZGVmaW5lR2V0dGVyX18AX19wcm90b19fAFtTeW1ib2wuc3BsaXRdAFtTeW1ib2wuc3BlY2llc10AW1N5bWJvbC5pdGVyYXRvcl0AW1N5bWJvbC5hc3luY0l0ZXJhdG9yXQBbU3ltYm9sLm1hdGNoQWxsXQBbU3ltYm9sLm1hdGNoXQBbU3ltYm9sLnNlYXJjaF0AW1N5bWJvbC50b1N0cmluZ1RhZ10AW1N5bWJvbC50b1ByaW1pdGl2ZV0AW3Vuc3VwcG9ydGVkIHR5cGVdAFtmdW5jdGlvbiBieXRlY29kZV0AW1N5bWJvbC5oYXNJbnN0YW5jZV0AW1N5bWJvbC5yZXBsYWNlXQBbACUwMmQ6JTAyZDolMDJkLiUwM2RaAFBPU0lUSVZFX0lORklOSVRZAE5FR0FUSVZFX0lORklOSVRZAHAtPmNsYXNzX2lkID09IEpTX0NMQVNTX0FSUkFZAHN0YWNrX2xlbiA8IFBPUF9TVEFDS19MRU5fTUFYAC0lMDJkLSUwMmRUAEpTX0F0b21HZXRTdHJSVABvcGNvZGUgPCBSRU9QX0NPVU5UAEJZVEVTX1BFUl9FTEVNRU5UACUwMmQ6JTAyZDolMDJkIEdNVABKU19WQUxVRV9HRVRfVEFHKHNmLT5jdXJfZnVuYykgPT0gSlNfVEFHX09CSkVDVAB2YXJfa2luZCA9PSBKU19WQVJfUFJJVkFURV9TRVRURVIATUFYX1NBRkVfSU5URUdFUgBNSU5fU0FGRV9JTlRFR0VSAGFzVWludE4AYXNJbnROAGlzTmFOAERhdGUgdmFsdWUgaXMgTmFOAHRvSlNPTgBFUFNJTE9OAE5BTgAlMDJkOiUwMmQ6JTAyZCAlY00Acy0+bGFiZWxfc2xvdHNbbGFiZWxdLmZpcnN0X3JlbG9jID09IE5VTEwAbGFiZWxfc2xvdHNbaV0uZmlyc3RfcmVsb2MgPT0gTlVMTABwcnMgIT0gTlVMTABzZi0+Y3VyX3NwICE9IE5VTEwAc2YgIT0gTlVMTABtcjEgIT0gTlVMTAB2YXJfa2luZCAhPSBKU19WQVJfTk9STUFMAGItPmZ1bmNfa2luZCA9PSBKU19GVU5DX05PUk1BTABlbmNvZGVVUkkAZGVjb2RlVVJJAFBJAHNwZWNpYWwgPT0gUFVUX0xWQUxVRV9OT0tFRVAgfHwgc3BlY2lhbCA9PSBQVVRfTFZBTFVFX05PS0VFUF9ERVBUSABzLT5zdGF0ZSA9PSBKU19BU1lOQ19HRU5FUkFUT1JfU1RBVEVfRVhFQ1VUSU5HAHByZWMxICE9IEJGX1BSRUNfSU5GADAxMjM0NTY3ODlBQkNERUYAU0laRQBNQVhfVkFMVUUATUlOX1ZBTFVFAE5BTUUAZXZhbF90eXBlID09IEpTX0VWQUxfVFlQRV9HTE9CQUwgfHwgZXZhbF90eXBlID09IEpTX0VWQUxfVFlQRV9NT0RVTEUAcC0+Z2Nfb2JqX3R5cGUgPT0gSlNfR0NfT0JKX1RZUEVfSlNfT0JKRUNUIHx8IHAtPmdjX29ial90eXBlID09IEpTX0dDX09CSl9UWVBFX0ZVTkNUSU9OX0JZVEVDT0RFAExPRzJFAExPRzEwRQBzLT5zdGF0ZSA9PSBKU19BU1lOQ19HRU5FUkFUT1JfU1RBVEVfQVdBSVRJTkdfUkVUVVJOIHx8IHMtPnN0YXRlID09IEpTX0FTWU5DX0dFTkVSQVRPUl9TVEFURV9DT01QTEVURUQAVVRDADxpbnB1dD4APHNldD4APGFub255bW91cz4APGR1bXA+ADxudWxsPgBiaWdpbnQgb3BlcmFuZHMgYXJlIGZvcmJpZGRlbiBmb3IgPj4+ACZxdW90OwBzZXRVaW50OABnZXRVaW50OABzZXRJbnQ4AGdldEludDgAbWFsZm9ybWVkIFVURi04AHJhZGl4IG11c3QgYmUgYmV0d2VlbiAyIGFuZCAzNgBzZXRVaW50MTYAZ2V0VWludDE2AHNldEludDE2AGdldEludDE2AGFyZ2MgPT0gNQBzZXRCaWdVaW50NjQAZ2V0QmlnVWludDY0AHNldEJpZ0ludDY0AGdldEJpZ0ludDY0AHNldEZsb2F0NjQAZ2V0RmxvYXQ2NABhcmdjID09IDMAYXRhbjIAbG9nMgBmbG9vckxvZzIAU1FSVDFfMgBTUVJUMgBMTjIAY2x6MzIAc2V0VWludDMyAGdldFVpbnQzMgBzZXRJbnQzMgBnZXRJbnQzMgBzZXRGbG9hdDMyAGdldEZsb2F0MzIAc3RhY2tfbGVuID49IDIASlNfQXRvbUlzTnVtZXJpY0luZGV4MQBqc19mY3Z0MQBKU19Db21wYWN0QmlnSW50MQBleHBtMQByICE9IGExICYmIHIgIT0gYjEAbHMtPmFkZHIgPT0gLTEAbnEgPj0gMQBzdGFja19sZW4gPj0gMQBwLT5oZWFkZXIucmVmX2NvdW50ID09IDEAcC0+c2hhcGUtPmhlYWRlci5yZWZfY291bnQgPT0gMQBzdGFja19sZW4gPT0gMQBqc19mcmVlX3NoYXBlMABsb2cxMABMTjEwAHAtPnJlZl9jb3VudCA+IDAAdmFyX3JlZi0+aGVhZGVyLnJlZl9jb3VudCA+IDAAc3RhY2tfc2l6ZSA+IDAAY3Bvb2xfaWR4ID49IDAAcnQtPmF0b21fY291bnQgPj0gMABscy0+cmVmX2NvdW50ID49IDAAcy0+aXNfZXZhbCB8fCBzLT5jbG9zdXJlX3Zhcl9jb3VudCA9PSAwAHAtPnJlZl9jb3VudCA9PSAwAGN0eC0+aGVhZGVyLnJlZl9jb3VudCA9PSAwAHNoLT5oZWFkZXIucmVmX2NvdW50ID09IDAAcC0+bWFyayA9PSAwAChuMiAlIHN0cmlwX2xlbikgPT0gMAAocHItPnUuaW5pdC5yZWFsbV9hbmRfaWQgJiAzKSA9PSAwAChuZXdfaGFzaF9zaXplICYgKG5ld19oYXNoX3NpemUgLSAxKSkgPT0gMABpICE9IDAAc2l6ZSAhPSAwAF4kXC4qKz8oKVtde318LwA8LwAwLgBtaXNzaW5nIGJpbmRpbmcgcGF0dGVybi4uLgBiaWdpbnQgYXJndW1lbnQgd2l0aCB1bmFyeSArAGFzeW5jIGZ1bmN0aW9uICoACn0pAGxpc3RfZW1wdHkoJnJ0LT5nY19vYmpfbGlzdCkAaiA9PSAoc2gtPnByb3BfY291bnQgLSBzaC0+ZGVsZXRlZF9wcm9wX2NvdW50KQBKU19Jc1VuZGVmaW5lZChmdW5jX3JldCkAIV9fSlNfQXRvbUlzVGFnZ2VkSW50KGRlc2NyKQAhYXRvbV9pc19mcmVlKHApAChudWxsKQAgKG5hdGl2ZSkAanNfY2xhc3NfaGFzX2J5dGVjb2RlKHAtPmNsYXNzX2lkKQB1bmNvbnNpc3RlbnQgc3RhY2sgc2l6ZTogJWQgJWQgKHBjPSVkKQBieXRlY29kZSBidWZmZXIgb3ZlcmZsb3cgKG9wPSVkLCBwYz0lZCkAc3RhY2sgb3ZlcmZsb3cgKG9wPSVkLCBwYz0lZCkAc3RhY2sgdW5kZXJmbG93IChvcD0lZCwgcGM9JWQpAGludmFsaWQgb3Bjb2RlIChvcD0lZCwgcGM9JWQpACg/OikAbm8gZnVuY3Rpb24gZmlsZW5hbWUgZm9yIGltcG9ydCgpAC1fLiF+KicoKQAgYW5vbnltb3VzKABTeW1ib2woAGV4cGVjdGluZyAnfScAY2xhc3MgY29uc3RydWN0b3JzIG11c3QgYmUgaW52b2tlZCB3aXRoICduZXcnAGV4cGVjdGluZyAnYXMnAHVuZXhwZWN0ZWQgdG9rZW4gaW4gZXhwcmVzc2lvbjogJyUuKnMnAHVuZXhwZWN0ZWQgdG9rZW46ICclLipzJwByZWRlY2xhcmF0aW9uIG9mICclcycAZHVwbGljYXRlIGV4cG9ydGVkIG5hbWUgJyVzJwBjaXJjdWxhciByZWZlcmVuY2Ugd2hlbiBsb29raW5nIGZvciBleHBvcnQgJyVzJyBpbiBtb2R1bGUgJyVzJwBDb3VsZCBub3QgZmluZCBleHBvcnQg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AJYAAADBAAAAlwAAAJgAAADCAAAAlwAAAJgAAADDAAAAawAAAGwAAADEAAAAmQAAAJoAAADFAAAAmQAAAJoAAAAvAAAAmwAAAJwAAADGAAAAawAAAGwAAADHAAAAnQAAAJ4AAAAAAAAA7h8AAB8gAAAqIAAA4h8AABUgAAA5IAAA+B8AAAYgAABjb3B5V2l0aGluAGVudHJpZXMAZmlsbABmaW5kAGZpbmRJbmRleABmbGF0AGZsYXRNYXAAaW5jbHVkZXMAa2V5cwB2YWx1ZXMAAAAAAAEBAgIDAwIDAEGQpwEL3xBudWxsAGZhbHNlAHRydWUAaWYAZWxzZQByZXR1cm4AdmFyAHRoaXMAZGVsZXRlAHZvaWQAdHlwZW9mAG5ldwBpbgBpbnN0YW5jZW9mAGRvAHdoaWxlAGZvcgBicmVhawBjb250aW51ZQBzd2l0Y2gAY2FzZQBkZWZhdWx0AHRocm93AHRyeQBjYXRjaABmaW5hbGx5AGZ1bmN0aW9uAGRlYnVnZ2VyAHdpdGgAY2xhc3MAY29uc3QAZW51bQBleHBvcnQAZXh0ZW5kcwBpbXBvcnQAc3VwZXIAaW1wbGVtZW50cwBpbnRlcmZhY2UAbGV0AHBhY2thZ2UAcHJpdmF0ZQBwcm90ZWN0ZWQAcHVibGljAHN0YXRpYwB5aWVsZABhd2FpdAAAbGVuZ3RoAGZpbGVOYW1lAGxpbmVOdW1iZXIAbWVzc2FnZQBlcnJvcnMAc3RhY2sAbmFtZQB0b1N0cmluZwB0b0xvY2FsZVN0cmluZwB2YWx1ZU9mAGV2YWwAcHJvdG90eXBlAGNvbnN0cnVjdG9yAGNvbmZpZ3VyYWJsZQB3cml0YWJsZQBlbnVtZXJhYmxlAHZhbHVlAGdldABzZXQAb2YAX19wcm90b19fAHVuZGVmaW5lZABudW1iZXIAYm9vbGVhbgBzdHJpbmcAb2JqZWN0AHN5bWJvbABpbnRlZ2VyAHVua25vd24AYXJndW1lbnRzAGNhbGxlZQBjYWxsZXIAPGV2YWw+ADxyZXQ+ADx2YXI+ADxhcmdfdmFyPgA8d2l0aD4AbGFzdEluZGV4AHRhcmdldABpbmRleABpbnB1dABkZWZpbmVQcm9wZXJ0aWVzAGFwcGx5AGpvaW4AY29uY2F0AHNwbGl0AGNvbnN0cnVjdABnZXRQcm90b3R5cGVPZgBzZXRQcm90b3R5cGVPZgBpc0V4dGVuc2libGUAcHJldmVudEV4dGVuc2lvbnMAaGFzAGRlbGV0ZVByb3BlcnR5AGRlZmluZVByb3BlcnR5AGdldE93blByb3BlcnR5RGVzY3JpcHRvcgBvd25LZXlzAGFkZABkb25lAG5leHQAdmFsdWVzAHNvdXJjZQBmbGFncwBnbG9iYWwAdW5pY29kZQByYXcAbmV3LnRhcmdldAB0aGlzLmFjdGl2ZV9mdW5jADxob21lX29iamVjdD4APGNvbXB1dGVkX2ZpZWxkPgA8c3RhdGljX2NvbXB1dGVkX2ZpZWxkPgA8Y2xhc3NfZmllbGRzX2luaXQ+ADxicmFuZD4AI2NvbnN0cnVjdG9yAGFzAGZyb20AbWV0YQAqZGVmYXVsdCoAKgBNb2R1bGUAdGhlbgByZXNvbHZlAHJlamVjdABwcm9taXNlAHByb3h5AHJldm9rZQBhc3luYwBleGVjAGdyb3VwcwBzdGF0dXMAcmVhc29uAGdsb2JhbFRoaXMAYmlnaW50AGJpZ2Zsb2F0AGJpZ2RlY2ltYWwAcm91bmRpbmdNb2RlAG1heGltdW1TaWduaWZpY2FudERpZ2l0cwBtYXhpbXVtRnJhY3Rpb25EaWdpdHMAdG9KU09OAE9iamVjdABBcnJheQBFcnJvcgBOdW1iZXIAU3RyaW5nAEJvb2xlYW4AU3ltYm9sAEFyZ3VtZW50cwBNYXRoAEpTT04ARGF0ZQBGdW5jdGlvbgBHZW5lcmF0b3JGdW5jdGlvbgBGb3JJbkl0ZXJhdG9yAFJlZ0V4cABBcnJheUJ1ZmZlcgBTaGFyZWRBcnJheUJ1ZmZlcgBVaW50OENsYW1wZWRBcnJheQBJbnQ4QXJyYXkAVWludDhBcnJheQBJbnQxNkFycmF5AFVpbnQxNkFycmF5AEludDMyQXJyYXkAVWludDMyQXJyYXkAQmlnSW50NjRBcnJheQBCaWdVaW50NjRBcnJheQBGbG9hdDMyQXJyYXkARmxvYXQ2NEFycmF5AERhdGFWaWV3AEJpZ0ludABCaWdGbG9hdABCaWdGbG9hdEVudgBCaWdEZWNpbWFsAE9wZXJhdG9yU2V0AE9wZXJhdG9ycwBNYXAAU2V0AFdlYWtNYXAAV2Vha1NldABNYXAgSXRlcmF0b3IAU2V0IEl0ZXJhdG9yAEFycmF5IEl0ZXJhdG9yAFN0cmluZyBJdGVyYXRvcgBSZWdFeHAgU3RyaW5nIEl0ZXJhdG9yAEdlbmVyYXRvcgBQcm94eQBQcm9taXNlAFByb21pc2VSZXNvbHZlRnVuY3Rpb24AUHJvbWlzZVJlamVjdEZ1bmN0aW9uAEFzeW5jRnVuY3Rpb24AQXN5bmNGdW5jdGlvblJlc29sdmUAQXN5bmNGdW5jdGlvblJlamVjdABBc3luY0dlbmVyYXRvckZ1bmN0aW9uAEFzeW5jR2VuZXJhdG9yAEV2YWxFcnJvcgBSYW5nZUVycm9yAFJlZmVyZW5jZUVycm9yAFN5bnRheEVycm9yAFR5cGVFcnJvcgBVUklFcnJvcgBJbnRlcm5hbEVycm9yADxicmFuZD4AU3ltYm9sLnRvUHJpbWl0aXZlAFN5bWJvbC5pdGVyYXRvcgBTeW1ib2wubWF0Y2gAU3ltYm9sLm1hdGNoQWxsAFN5bWJvbC5yZXBsYWNlAFN5bWJvbC5zZWFyY2gAU3ltYm9sLnNwbGl0AFN5bWJvbC50b1N0cmluZ1RhZwBTeW1ib2wuaXNDb25jYXRTcHJlYWRhYmxlAFN5bWJvbC5oYXNJbnN0YW5jZQBTeW1ib2wuc3BlY2llcwBTeW1ib2wudW5zY29wYWJsZXMAU3ltYm9sLmFzeW5jSXRlcmF0b3IAU3ltYm9sLm9wZXJhdG9yU2V0AEGAuAELtQgBAAAABQABFAUAARUFAAEVBQABFwUAARcBAAEAAQABAAEAAQABAAEAAQABAAEAAQACAAEFAwABCgEBAAABAgEAAQMCAAEBAgABAgMAAQIEAAEDBgABAgMAAQMEAAEEBQABAwMAAQQEAAEFBQABAgIAAQQEAAEDAwABAwMAAQQEAAEFBQADAgENAwEBDQMBAA0DAgENAwIADQMAAQ0DAwEKAQEAAAEAAAABAQIAAQAAAAECAgABAgAAAQEAAAEBAAAGAAAYBQEBDwMCAQoBAgEAAQEBAAEBAQAFAAEXBQABFwUAARcFAQAXBQEAFwUCABcBAgMAAQMAAAYAABgGAAAYBgEAGAUBARcFAQIXBQIAFwECAQABAwAAAQMBAAECAQABAgIAAQMAAAEDAQABBAAABQIBFwUBARcBAgIAAQIB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AAABADAAOgBB0IECCxEEADAAOgBBAFsAXwBgAGEAewBB8IECC8QLAQMFAQEBAQUFBQECAgMFBQEBAQICAwMFBQEFAREAAAAwmiAAAJowAHOBWgAwF2AAMAdsALOBbwAAF3AAAAd8AACBfwBAMIAAwwGYAJCBmABABpkAQJCcALSBpABALqUAMAG8AECGvABwgb8AAAHAADCBwABABMEAMAHDAECCwwAwgsQAQILFADABxwAwgccAMAHIAECCyAAwgckAMAHKAACBygAwAcsAMIHLAEACzAAAAc0AMAHOADCBzgAAAc8AMIHPAEAG0AAwAdMAQILTADCB1ABAAtYAMAHXAECC1wAwgtgAQITZADCB2wBAAtwAQALeAACB3wBQA+IAUIPjAFAD5QBAkOYAAIHuAEAS7wC0AfgAUIP4AEAC+gAwAfsAMIH7AEAo/AAwARABQBIRATEBHQFAgh0BMIEeATEBHwEBgh8BQIIgATCBIQEwASIBMIEiAUAKIwEBASgBAYEoAQEBKQEAgSkBAAEqAQACKwEAgSwBAIEtAQEBLgEAATABAYEwAQCBMQEBgTIBAQEzAQABNAEAgTQBAQE1AQGBNQEBATYBAIE3AQGBOAEAATkBAIE6AQGBPgEAAUABAQFBAQCBQQEBgUMBAAFEAQCBRAEAAkUBAAFGAQABSQEBgU4BAQFPAXOBogFABLgBQAK7AQCDvQEwgb8BMAHDATADxAEwAcYBMALHAdAByAEwkcgBMInRAQAB1gEAg9YB0wHYAQCR2AFzAeEBAInhAQAB5gEAguYBMIHnAXMB6AFzgegBc4HqAXMB6wEAgesBQBjsAXMB+AFzgfgBAAH5AQCB+QGgAfoBc4H6AUCC+wEwgfwBQAL9ATCD/gEwEAACMCAIAgAgGAIAECgCQCIwAkA2RQIwAWACQI5gAgCBZwJAYGgCMKaYAgCmsAK1gcMCMSZQCDGBYwgxgWYIACtoCACDfggRUNAJEAb4CSAG/Al0AUAOdIFADnQBQQ50gUEOdAFCDnSBQg50AUMOgIFDDoABRA4wK0gOMINeDgGBvA4Bgb4OAQHHDkB+AA9AGD8PtQFLD7aBSw+2AUwPtoFMD7cBTQ+AgU0PMAFPD0BgUA8ACIAPMAiEDwAGiA8wBowPAAiQDzAIlA8ACJgPMAicDwAGoA8wBqQPsAGoDwCBqA/T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iaCCsQARDAiAqCSBQOs4CYlgTyOAQuCPj48Rl4JAv4mkgEK8gEDhgECUhEEkiUVWEAyDpxOAQKSBQjwfiUFwgUCYikCugrSOnomOg6yKtIkqo42AiSGrgIuCr407gIvRiyhAn4uEiSu2CDEJgoiAiQkyhEC/kYiJGNCTi4lA1DGImoHRkI6J0IyHidKOg4lA8Y5ApInFKAkYAIGLifYxMoCbiacwH4CIiq2PQZQ4h4+Jt5WAjfkqAAgwB4mvIAgniUFIg2BLaIlAhYS6hpiJQ/QAtjPQgIqBYEyqgVTFIi85hp2DQJOCRYixQf+2g7E4jYCVII5FTzCQDgEEQQSGiIlBoY1F1YbsNIlSlYlsBQVA7wBBoKcCC6MS+gYAhAkA8AoAcAwA9A0AShAgGhggdBsg3SAADKgAWqogGv8ArQ4BOBIhwRUh5Rkhqh0hjNFBSuEh8AEOAAAAAEFkbGFtLEFkbG0AQWhvbSxBaG9tAEFuYXRvbGlhbl9IaWVyb2dseXBocyxIbHV3AEFyYWJpYyxBcmFiAEFybWVuaWFuLEFybW4AQXZlc3RhbixBdnN0AEJhbGluZXNlLEJhbGkAQmFtdW0sQmFtdQBCYXNzYV9WYWgsQmFzcwBCYXRhayxCYXRrAEJlbmdhbGksQmVuZwBCaGFpa3N1a2ksQmhrcwBCb3BvbW9mbyxCb3BvAEJyYWhtaSxCcmFoAEJyYWlsbGUsQnJhaQBCdWdpbmVzZSxCdWdpAEJ1aGlkLEJ1aGQAQ2FuYWRpYW5fQWJvcmlnaW5hbCxDYW5zAENhcmlhbixDYXJpAENhdWNhc2lhbl9BbGJhbmlhbixBZ2hiAENoYWttYSxDYWttAENoYW0sQ2hhbQBDaGVyb2tlZSxDaGVyAENob3Jhc21pYW4sQ2hycwBDb21tb24sWnl5eQBDb3B0aWMsQ29wdCxRYWFjAEN1bmVpZm9ybSxYc3V4AEN5cHJpb3QsQ3BydABDeXJpbGxpYyxDeXJsAERlc2VyZXQsRHNydABEZXZhbmFnYXJpLERldmEARGl2ZXNfQWt1cnUsRGlhawBEb2dyYSxEb2dyAER1cGxveWFuLER1cGwARWd5cHRpYW5fSGllcm9nbHlwaHMsRWd5cABFbGJhc2FuLEVsYmEARWx5bWFpYyxFbHltAEV0aGlvcGljLEV0aGkAR2VvcmdpYW4sR2VvcgBHbGFnb2xpdGljLEdsYWcAR290aGljLEdvdGgAR3JhbnRoYSxHcmFuAEdyZWVrLEdyZWsAR3VqYXJhdGksR3VqcgBHdW5qYWxhX0dvbmRpLEdvbmcAR3VybXVraGksR3VydQBIYW4sSGFuaQBIYW5ndWwsSGFuZwBIYW5pZmlfUm9oaW5neWEsUm9oZwBIYW51bm9vLEhhbm8ASGF0cmFuLEhhdHIASGVicmV3LEhlYnIASGlyYWdhbmEsSGlyYQBJbXBlcmlhbF9BcmFtYWljLEFybWkASW5oZXJpdGVkLFppbmgsUWFhaQBJbnNjcmlwdGlvbmFsX1BhaGxhdmksUGhsaQBJbnNjcmlwdGlvbmFsX1BhcnRoaWFuLFBydGkASmF2YW5lc2UsSmF2YQBLYWl0aGksS3RoaQBLYW5uYWRhLEtuZGEAS2F0YWthbmEsS2FuYQBLYXlhaF9MaSxLYWxpAEtoYXJvc2h0aGksS2hhcgBLaG1lcixLaG1yAEtob2praSxLaG9qAEtoaXRhbl9TbWFsbF9TY3JpcHQsS2l0cwBLaHVkYXdhZGksU2luZABMYW8sTGFvbwBMYXRpbixMYXRuAExlcGNoYSxMZXBjAExpbWJ1LExpbWIATGluZWFyX0EsTGluYQBMaW5lYXJfQixMaW5iAExpc3UsTGlzdQBMeWNpYW4sTHljaQBMeWRpYW4sTHlkaQBNYWthc2FyLE1ha2EATWFoYWphbmksTWFoagBNYWxheWFsYW0sTWx5bQBNYW5kYWljLE1hbmQATWFuaWNoYWVhbixNYW5pAE1hcmNoZW4sTWFyYwBNYXNhcmFtX0dvbmRpLEdvbm0ATWVkZWZhaWRyaW4sTWVkZgBNZWV0ZWlfTWF5ZWssTXRlaQBNZW5kZV9LaWtha3VpLE1lbmQATWVyb2l0aWNfQ3Vyc2l2ZSxNZXJjAE1lcm9pdGljX0hpZXJvZ2x5cGhzLE1lcm8ATWlhbyxQbHJkAE1vZGksTW9kaQBNb25nb2xpYW4sTW9uZwBNcm8sTXJvbwBNdWx0YW5pLE11bHQATXlhbm1hcixNeW1yAE5hYmF0YWVhbixOYmF0AE5hbmRpbmFnYXJpLE5hbmQATmV3X1RhaV9MdWUsVGFsdQBOZXdhLE5ld2EATmtvLE5rb28ATnVzaHUsTnNodQBOeWlha2VuZ19QdWFjaHVlX0htb25nLEhtbnAAT2doYW0sT2dhbQBPbF9DaGlraSxPbGNrAE9sZF9IdW5nYXJpYW4sSHVuZwBPbGRfSXRhbGljLEl0YWwAT2xkX05vcnRoX0FyYWJpYW4sTmFyYgBPbGRfUGVybWljLFBlcm0AT2xkX1BlcnNpYW4sWHBlbwBPbGRfU29nZGlhbixTb2dvAE9sZF9Tb3V0aF9BcmFiaWFuLFNhcmIAT2xkX1R1cmtpYyxPcmtoAE9yaXlhLE9yeWEAT3NhZ2UsT3NnZQBPc21hbnlhLE9zbWEAUGFoYXdoX0htb25nLEhtbmcAUGFsbXlyZW5lLFBhbG0AUGF1X0Npbl9IYXUsUGF1YwBQaGFnc19QYSxQaGFnAFBob2VuaWNpYW4sUGhueABQc2FsdGVyX1BhaGxhdmksUGhscABSZWphbmcsUmpuZwBSdW5pYyxSdW5yAFNhbWFyaXRhbixTYW1yAFNhdXJhc2h0cmEsU2F1cgBTaGFyYWRhLFNocmQAU2hhdmlhbixTaGF3AFNpZGRoYW0sU2lkZABTaWduV3JpdGluZyxTZ253AFNpbmhhbGEsU2luaABTb2dkaWFuLFNvZ2QAU29yYV9Tb21wZW5nLFNvcmEAU295b21ibyxTb3lvAFN1bmRhbmVzZSxTdW5kAFN5bG90aV9OYWdyaSxTeWxvAFN5cmlhYyxTeXJjAFRhZ2Fsb2csVGdsZwBUYWdiYW53YSxUYWdiAFRhaV9MZSxUYWxlAFRhaV9UaGFtLExhbmEAVGFpX1ZpZXQsVGF2dABUYWtyaSxUYWtyAFRhbWlsLFRhbWwAVGFuZ3V0LFRhbmcAVGVsdWd1LFRlbHUAVGhhYW5hLFRoYWEAVGhhaSxUaGFpAFRpYmV0YW4sVGlidABUaWZpbmFnaCxUZm5nAFRpcmh1dGEsVGlyaABVZ2FyaXRpYyxVZ2FyAFZhaSxWYWlpAFdhbmNobyxXY2hvAFdhcmFuZ19DaXRpLFdhcmEAWWV6aWRpLFllemkAWWksWWlpaQBaYW5hYmF6YXJfU3F1YXJlLFphbmIAQdC5AguxFMAZmUWFGZlFrhmARY4ZgEWEGZZFgBmeRYAZ4WBFphmERYQZgQ2TGeAPN4MrgBmCKwGDK4AZgCsDgCuAGYArgBmCKwCAKwCT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ayxNb2RpZmllcl9TeW1ib2wAU28sT3RoZXJfU3ltYm9sAFBjLENvbm5lY3Rvcl9QdW5jdHVhdGlvbgBQZCxEYXNoX1B1bmN0dWF0aW9uAFBzLE9wZW5fUHVuY3R1YXRpb24AUGUsQ2xvc2VfUHVuY3R1YXRpb24AUGksSW5pdGlhbF9QdW5jdHVhdGlvbgBQZixGaW5hbF9QdW5jdHVhdGlvbgBQbyxPdGhlcl9QdW5jdHVhdGlvbgBacyxTcGFjZV9TZXBhcmF0b3IAWmwsTGluZV9TZXBhcmF0b3IAWnAsUGFyYWdyYXBoX1NlcGFyYXRvcgBDYyxDb250cm9sLGNudHJsAENmLEZvcm1hdABDcyxTdXJyb2dhdGUAQ28sUHJpdmF0ZV9Vc2UATEMsQ2FzZWRfTGV0dGVyAEwsTGV0dGVyAE0sTWFyayxDb21iaW5pbmdfTWFyawBOLE51bWJlcgBTLFN5bWJvbABQLFB1bmN0dWF0aW9uLHB1bmN0AFosU2VwYXJhdG9yAEMsT3RoZXIAQdDZAguwCA4AAAA+AAAAwAEAAAAOAAAA8AAAAAB/AAAAgAMBAAA8QVNDSUlfSGV4X0RpZ2l0LEFIZXgAQmlkaV9Db250cm9sLEJpZGlfQwBEYXNoAERlcHJlY2F0ZWQsRGVwAERpYWNyaXRpYyxEaWEARXh0ZW5kZXIsRXh0AEhleF9EaWdpdCxIZXgASURTX0JpbmFyeV9PcGVyYXRvcixJRFNCAElEU19UcmluYXJ5X09wZXJhdG9yLElEU1QASWRlb2dyYXBoaWMsSWRlbwBKb2luX0NvbnRyb2wsSm9pbl9DAExvZ2ljYWxfT3JkZXJfRXhjZXB0aW9uLExPRQBOb25jaGFyYWN0ZXJfQ29kZV9Qb2ludCxOQ2hhcgBQYXR0ZXJuX1N5bnRheCxQYXRfU3luAFBhdHRlcm5fV2hpdGVfU3BhY2UsUGF0X1dTAFF1b3RhdGlvbl9NYXJrLFFNYXJrAFJhZGljYWwAUmVnaW9uYWxfSW5kaWNhdG9yLFJJAFNlbnRlbmNlX1Rlcm1pbmFsLFNUZXJtAFNvZnRfRG90dGVkLFNEAFRlcm1pbmFsX1B1bmN0dWF0aW9uLFRlcm0AVW5pZmllZF9JZGVvZ3JhcGgsVUlkZW8AVmFyaWF0aW9uX1NlbGVjdG9yLFZTAFdoaXRlX1NwYWNlLHNwYWNlAEJpZGlfTWlycm9yZWQsQmlkaV9NAEVtb2ppAEVtb2ppX0NvbXBvbmVudCxFQ29tcABFbW9qaV9Nb2RpZmllcixFTW9kAEVtb2ppX01vZGlmaWVyX0Jhc2UsRUJhc2UARW1vamlfUHJlc2VudGF0aW9uLEVQcmVzAEV4dGVuZGVkX1BpY3RvZ3JhcGhpYyxFeHRQaWN0AERlZmF1bHRfSWdub3JhYmxlX0NvZGVfUG9pbnQsREkASURfU3RhcnQsSURTAENhc2VfSWdub3JhYmxlLENJAEFTQ0lJAEFscGhhYmV0aWMsQWxwaGEAQW55AEFzc2lnbmVkAENhc2VkAENoYW5nZXNfV2hlbl9DYXNlZm9sZGVkLENXQ0YAQ2hhbmdlc19XaGVuX0Nhc2VtYXBwZWQsQ1dDTQBDaGFuZ2VzX1doZW5fTG93ZXJjYXNlZCxDV0wAQ2hhbmdlc19XaGVuX05GS0NfQ2FzZWZvbGRlZCxDV0tDRgBDaGFuZ2VzX1doZW5fVGl0bGVjYXNlZCxDV1QAQ2hhbmdlc19XaGVuX1VwcGVyY2FzZWQsQ1dVAEdyYXBoZW1lX0Jhc2UsR3JfQmFzZQBHcmFwaGVtZV9FeHRlbmQsR3JfRXh0AElEX0NvbnRpbnVlLElEQwBMb3dlcmNhc2UsTG93ZXIATWF0aABVcHBlcmNhc2UsVXBwZXIAWElEX0NvbnRpbnVlLFhJREMAWElEX1N0YXJ0LFhJRFMAQZDiAgu0IIEAKACXACoAgYAqAJfAKwAVgSwAlwAtAIFALQCXAC4AFUEuAJkBLwAWIDAAQghAAEKKRABCBEoAlgBMABeBTABCAk0AQkNOAC/BTwBCw1AAv0BSAEIDUwBCCVUAQghaAJYAXgBCQ14AgcBfAEIBaABCwWsAhQFxABfDcQBESHMARIN3AEKDeQC+AnsAl0F8AEIBfQBEBH4AQg6AAEKBhwBEh4kAgwSsABcDtgCDArgAFALQAJYA0QCAAN0Al4DeAICA3wCXAOEAPkHhAIDA4QC+BOIAroPqAK6C8gCtAfQALsH0AANB9QADA/wAgUD+AD4CAAG+wAEBvgEDAb5ABgG+QA4BPgIUAb7AFQG+ARcBRIEdAURBMAFEAjQBRIE1AUSDNgFEgzgBRIY6AUQBPgGFwGEB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SHpUSHq8AxMhbQATIWQAEyFrABMhZgBtbgBtvANtbQBtYwBtawBtYwAKCk8ACk9tALIAYwAICk8KClAAClBtALMAawBtALMAbQAVInMAbQAVInMAsgBQYWtQYU1QYUdQYXJhZHJhZNFzcgBhAGQAFSJzALIAcABzbgBzvANzbQBzcABWbgBWvANWbQBWawBWTQBWcABXbgBXvANXbQBXawBXTQBXawCpA00AqQNhLm0uQnFjY2NkQ9FrZ0NvLmRCR3loYUhQaW5LS0tNa3RsbWxubG9nbHhtYm1pbG1vbFBIcC5tLlBQTVBSc3JTdldiVtFtQdFtMQDlZTEAMADlZTIAMADlZTMAMADlZWdhbEoETAQmAVMBJ6c3q2sCUqtIjPRmyo7IjNFuMk7lU5yfnJ9RWdGRh1VIWfZhaXaFfz+Guof4iI+QAmobbdlw3nM9hGqR8ZmCTnVTBGsbci2GHp5QXetvzYVkicli2IEfiMpeF2dqbfxyzpCGT7dR3lLEZNNqEHLndgGABoZchu+NMpdvm/qdjHh/eaB9yYMEk3+e1orfWARfYHx+gGJyynjCjPeW2FhiXBNq2m0Pby99N35LltJSi4DcUcxRHHq+ffGDdZaAi89iAmr+ijlO51sSYIdzcHUXU/t4v0+pXw1OzGx4ZSJ9w1NeWAF3SYSqirprsI+IbP5i5YKgY2V1rk5pUclRgWjnfG+C0orPkfVSQlRzWexexWX+byp5rZVqmpeezp6bUsZmd2tij3RekGEAYppkI29JcYl0ynn0fW+AJo/uhCOQSpMXUqNSvVTIcMKIqorJXvVfe2Ouaz58dXPkTvlW51u6XRxgsnNpdJp/RoA0kvaWSJcYmItPrnm0kbiW4WCGTtpQ7ls/XJllAmrOcUJ2/IR8kI2fiGYulolSe2fzZ0FtnG4JdFl1a3gQfV6YbVEuYniWK1AZXeptKo+LX0RhF2iHc4aWKVIPVGVcE2ZOZ6ho5WwGdOJ1eX/PiOGIzJHilj9Tum4dVNBxmHT6haOWV5yfnpdny23ogct6IHuSfMBymXBYi8BONoM6UgdSpl7TYtZ8hVsebbRmO49MiE2Wi4nTXkBRwFUAAAAAWlgAAHRmAAAAAN5RKnPKdjx5XnlleY95Vpe+fL1/AAAShgAA+IoAAAAAOJD9kO+Y/JgombSd3pC3lq5P51BNUclS5FJR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";
		        if (!R.startsWith(Q)) {
		            var fa = R;
		            R = a.locateFile ? a.locateFile(fa, x) : x + fa;
		        }
		        function ha(b) { try {
		            if (b == R && E)
		                return new Uint8Array(E);
		            var c = C(b);
		            if (c)
		                return c;
		            if (A)
		                return A(b);
		            throw "both async and sync fetching of the wasm failed";
		        }
		        catch (d) {
		            F(d);
		        } }
		        function ia(b) { if (!E && (u || v)) {
		            if ("function" == typeof fetch && !b.startsWith("file://"))
		                return fetch(b, { credentials: "same-origin" }).then(function (c) { if (!c.ok)
		                    throw "failed to load wasm binary file at '" + b + "'"; return c.arrayBuffer(); }).catch(function () { return ha(b); });
		            if (z)
		                return new Promise(function (c, d) { z(b, function (e) { c(new Uint8Array(e)); }, d); });
		        } return Promise.resolve().then(function () { return ha(b); }); }
		        function ja(b, c, d) { return ia(b).then(function (e) { return WebAssembly.instantiate(e, c); }).then(function (e) { return e; }).then(d, function (e) { D("failed to asynchronously prepare wasm: " + e); F(e); }); }
		        function ka(b, c) { var d = R; return E || "function" != typeof WebAssembly.instantiateStreaming || d.startsWith(Q) || d.startsWith("file://") || w || "function" != typeof fetch ? ja(d, b, c) : fetch(d, { credentials: "same-origin" }).then(function (e) { return WebAssembly.instantiateStreaming(e, b).then(c, function (f) { D("wasm streaming compile failed: " + f); D("falling back to ArrayBuffer instantiation"); return ja(d, b, c); }); }); }
		        function S(b) { for (; 0 < b.length;)
		            b.shift()(a); }
		        var la = "undefined" != typeof TextDecoder ? new TextDecoder("utf8") : void 0;
		        function na(b, c, d) { var e = c + d; for (d = c; b[d] && !(d >= e);)
		            ++d; if (16 < d - c && b.buffer && la)
		            return la.decode(b.subarray(c, d)); for (e = ""; c < d;) {
		            var f = b[c++];
		            if (f & 128) {
		                var g = b[c++] & 63;
		                if (192 == (f & 224))
		                    e += String.fromCharCode((f & 31) << 6 | g);
		                else {
		                    var h = b[c++] & 63;
		                    f = 224 == (f & 240) ? (f & 15) << 12 | g << 6 | h : (f & 7) << 18 | g << 12 | h << 6 | b[c++] & 63;
		                    65536 > f ? e += String.fromCharCode(f) : (f -= 65536, e += String.fromCharCode(55296 | f >> 10, 56320 | f & 1023));
		                }
		            }
		            else
		                e += String.fromCharCode(f);
		        } return e; }
		        function T(b, c) { return b ? na(J, b, c) : ""; }
		        var oa = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335], pa = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
		        function U(b) { for (var c = 0, d = 0; d < b.length; ++d) {
		            var e = b.charCodeAt(d);
		            127 >= e ? c++ : 2047 >= e ? c += 2 : 55296 <= e && 57343 >= e ? (c += 4, ++d) : c += 3;
		        } return c; }
		        function V(b, c, d) { var e = J; if (!(0 < d))
		            return 0; var f = c; d = c + d - 1; for (var g = 0; g < b.length; ++g) {
		            var h = b.charCodeAt(g);
		            if (55296 <= h && 57343 >= h) {
		                var k = b.charCodeAt(++g);
		                h = 65536 + ((h & 1023) << 10) | k & 1023;
		            }
		            if (127 >= h) {
		                if (c >= d)
		                    break;
		                e[c++] = h;
		            }
		            else {
		                if (2047 >= h) {
		                    if (c + 1 >= d)
		                        break;
		                    e[c++] = 192 | h >> 6;
		                }
		                else {
		                    if (65535 >= h) {
		                        if (c + 2 >= d)
		                            break;
		                        e[c++] = 224 | h >> 12;
		                    }
		                    else {
		                        if (c + 3 >= d)
		                            break;
		                        e[c++] = 240 | h >> 18;
		                        e[c++] = 128 | h >> 12 & 63;
		                    }
		                    e[c++] = 128 | h >> 6 & 63;
		                }
		                e[c++] = 128 | h & 63;
		            }
		        } e[c] = 0; return c - f; }
		        function qa(b) { var c = U(b) + 1, d = ra(c); d && V(b, d, c); return d; }
		        var W = {};
		        function sa() { if (!X) {
		            var b = { USER: "web_user", LOGNAME: "web_user", PATH: "/", PWD: "/", HOME: "/home/web_user", LANG: ("object" == typeof navigator && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8", _: t || "./this.program" }, c;
		            for (c in W)
		                void 0 === W[c] ? delete b[c] : b[c] = W[c];
		            var d = [];
		            for (c in b)
		                d.push(c + "=" + b[c]);
		            X = d;
		        } return X; }
		        var X, ta = [null, [], []];
		        function ua(b, c, d, e) { var f = { string: l => { var q = 0; if (null !== l && void 0 !== l && 0 !== l) {
		                q = U(l) + 1;
		                var ma = Y(q);
		                V(l, ma, q);
		                q = ma;
		            } return q; }, array: l => { var q = Y(l.length); I.set(l, q); return q; } }; b = a["_" + b]; var g = [], h = 0; if (e)
		            for (var k = 0; k < e.length; k++) {
		                var r = f[d[k]];
		                r ? (0 === h && (h = va()), g[k] = r(e[k])) : g[k] = e[k];
		            } d = b.apply(null, g); return d = function (l) { 0 !== h && wa(h); return "string" === c ? T(l) : "boolean" === c ? !!l : l; }(d); }
		        var xa = "function" == typeof atob ? atob : function (b) {
		            var c = "", d = 0;
		            b = b.replace(/[^A-Za-z0-9\+\/=]/g, "");
		            do {
		                var e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(b.charAt(d++));
		                var f = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(b.charAt(d++));
		                var g = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(b.charAt(d++));
		                var h = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(b.charAt(d++));
		                e = e << 2 | f >> 4;
		                f = (f & 15) << 4 | g >> 2;
		                var k = (g & 3) << 6 | h;
		                c += String.fromCharCode(e);
		                64 !== g && (c += String.fromCharCode(f));
		                64 !== h && (c += String.fromCharCode(k));
		            } while (d < b.length);
		            return c;
		        };
		        function C(b) { if (b.startsWith(Q)) {
		            b = b.slice(Q.length);
		            if ("boolean" == typeof w && w) {
		                var c = Buffer.from(b, "base64");
		                c = new Uint8Array(c.buffer, c.byteOffset, c.byteLength);
		            }
		            else
		                try {
		                    var d = xa(b), e = new Uint8Array(d.length);
		                    for (b = 0; b < d.length; ++b)
		                        e[b] = d.charCodeAt(b);
		                    c = e;
		                }
		                catch (f) {
		                    throw Error("Converting base64 string to bytes failed.");
		                }
		            return c;
		        } }
		        var ya = { a: function (b, c, d, e) { F("Assertion failed: " + T(b) + ", at: " + [c ? T(c) : "unknown filename", d, e ? T(e) : "unknown function"]); }, l: function (b, c) {
		                b = new Date(1E3 * (L[b >> 2] + 4294967296 * K[b + 4 >> 2]));
		                K[c >> 2] = b.getSeconds();
		                K[c + 4 >> 2] = b.getMinutes();
		                K[c + 8 >> 2] = b.getHours();
		                K[c + 12 >> 2] = b.getDate();
		                K[c + 16 >> 2] = b.getMonth();
		                K[c + 20 >> 2] = b.getFullYear() - 1900;
		                K[c + 24 >> 2] = b.getDay();
		                var d = b.getFullYear();
		                K[c + 28 >> 2] = (0 !== d % 4 || 0 === d % 100 && 0 !== d % 400 ? pa : oa)[b.getMonth()] + b.getDate() - 1 | 0;
		                K[c + 36 >> 2] = -(60 * b.getTimezoneOffset());
		                d = (new Date(b.getFullYear(), 6, 1)).getTimezoneOffset();
		                var e = (new Date(b.getFullYear(), 0, 1)).getTimezoneOffset();
		                K[c + 32 >> 2] = (d != e && b.getTimezoneOffset() == Math.min(e, d)) | 0;
		            }, k: function (b, c, d) { function e(r) { return (r = r.toTimeString().match(/\(([A-Za-z ]+)\)$/)) ? r[1] : "GMT"; } var f = (new Date).getFullYear(), g = new Date(f, 0, 1), h = new Date(f, 6, 1); f = g.getTimezoneOffset(); var k = h.getTimezoneOffset(); L[b >> 2] = 60 * Math.max(f, k); K[c >> 2] = Number(f != k); b = e(g); c = e(h); b = qa(b); c = qa(c); k < f ? (L[d >> 2] = b, L[d + 4 >> 2] = c) : (L[d >> 2] = c, L[d + 4 >> 2] = b); }, b: function () { F(""); },
		            m: function () { return Date.now(); }, j: function (b) { var c = J.length; b >>>= 0; if (2147483648 < b)
		                return false; for (var d = 1; 4 >= d; d *= 2) {
		                var e = c * (1 + .2 / d);
		                e = Math.min(e, b + 100663296);
		                var f = Math, g = f.min;
		                e = Math.max(b, e);
		                e += (65536 - e % 65536) % 65536;
		                a: {
		                    var h = G.buffer;
		                    try {
		                        G.grow(g.call(f, 2147483648, e) - h.byteLength + 65535 >>> 16);
		                        M();
		                        var k = 1;
		                        break a;
		                    }
		                    catch (r) { }
		                    k = void 0;
		                }
		                if (k)
		                    return true;
		            } return false; }, e: function (b, c) {
		                var d = 0;
		                sa().forEach(function (e, f) {
		                    var g = c + d;
		                    f = L[b + 4 * f >> 2] = g;
		                    for (g = 0; g < e.length; ++g)
		                        I[f++ >> 0] = e.charCodeAt(g);
		                    I[f >> 0] = 0;
		                    d += e.length +
		                        1;
		                });
		                return 0;
		            }, f: function (b, c) { var d = sa(); L[b >> 2] = d.length; var e = 0; d.forEach(function (f) { e += f.length + 1; }); L[c >> 2] = e; return 0; }, d: function () { return 52; }, i: function () { return 70; }, c: function (b, c, d, e) { for (var f = 0, g = 0; g < d; g++) {
		                var h = L[c >> 2], k = L[c + 4 >> 2];
		                c += 8;
		                for (var r = 0; r < k; r++) {
		                    var l = J[h + r], q = ta[b];
		                    0 === l || 10 === l ? ((1 === b ? aa : D)(na(q, 0)), q.length = 0) : q.push(l);
		                }
		                f += k;
		            } L[e >> 2] = f; return 0; }, o: function (b, c, d, e, f) { return a.callbacks.callFunction(void 0, b, c, d, e, f); }, n: function (b) {
		                return a.callbacks.shouldInterrupt(void 0, b);
		            }, h: function (b, c, d) { d = T(d); return a.callbacks.loadModuleSource(void 0, b, c, d); }, g: function (b, c, d, e) { d = T(d); e = T(e); return a.callbacks.normalizeModule(void 0, b, c, d, e); } };
		        (function () { function b(d) { d = d.exports; a.asm = d; G = a.asm.p; M(); ca.unshift(a.asm.q); N--; a.monitorRunDependencies && a.monitorRunDependencies(N); if (0 == N && (P)) {
		            var e = P;
		            P = null;
		            e();
		        } return d; } var c = { a: ya }; N++; a.monitorRunDependencies && a.monitorRunDependencies(N); if (a.instantiateWasm)
		            try {
		                return a.instantiateWasm(c, b);
		            }
		            catch (d) {
		                D("Module.instantiateWasm callback failed with error: " + d), n(d);
		            } ka(c, function (d) { b(d.instance); }).catch(n); return {}; })();
		        var ra = a._malloc = function () { return (ra = a._malloc = a.asm.r).apply(null, arguments); };
		        a._QTS_Throw = function () { return (a._QTS_Throw = a.asm.s).apply(null, arguments); };
		        a._QTS_NewError = function () { return (a._QTS_NewError = a.asm.t).apply(null, arguments); };
		        a._QTS_RuntimeSetMemoryLimit = function () { return (a._QTS_RuntimeSetMemoryLimit = a.asm.u).apply(null, arguments); };
		        a._QTS_RuntimeComputeMemoryUsage = function () { return (a._QTS_RuntimeComputeMemoryUsage = a.asm.v).apply(null, arguments); };
		        a._QTS_RuntimeDumpMemoryUsage = function () { return (a._QTS_RuntimeDumpMemoryUsage = a.asm.w).apply(null, arguments); };
		        a._QTS_RecoverableLeakCheck = function () { return (a._QTS_RecoverableLeakCheck = a.asm.x).apply(null, arguments); };
		        a._QTS_BuildIsSanitizeLeak = function () { return (a._QTS_BuildIsSanitizeLeak = a.asm.y).apply(null, arguments); };
		        a._QTS_RuntimeSetMaxStackSize = function () { return (a._QTS_RuntimeSetMaxStackSize = a.asm.z).apply(null, arguments); };
		        a._QTS_GetUndefined = function () { return (a._QTS_GetUndefined = a.asm.A).apply(null, arguments); };
		        a._QTS_GetNull = function () { return (a._QTS_GetNull = a.asm.B).apply(null, arguments); };
		        a._QTS_GetFalse = function () { return (a._QTS_GetFalse = a.asm.C).apply(null, arguments); };
		        a._QTS_GetTrue = function () { return (a._QTS_GetTrue = a.asm.D).apply(null, arguments); };
		        a._QTS_NewRuntime = function () { return (a._QTS_NewRuntime = a.asm.E).apply(null, arguments); };
		        a._QTS_FreeRuntime = function () { return (a._QTS_FreeRuntime = a.asm.F).apply(null, arguments); };
		        a._QTS_NewContext = function () { return (a._QTS_NewContext = a.asm.G).apply(null, arguments); };
		        a._QTS_FreeContext = function () { return (a._QTS_FreeContext = a.asm.H).apply(null, arguments); };
		        a._QTS_FreeValuePointer = function () { return (a._QTS_FreeValuePointer = a.asm.I).apply(null, arguments); };
		        a._free = function () { return (a._free = a.asm.J).apply(null, arguments); };
		        a._QTS_FreeValuePointerRuntime = function () { return (a._QTS_FreeValuePointerRuntime = a.asm.K).apply(null, arguments); };
		        a._QTS_FreeVoidPointer = function () { return (a._QTS_FreeVoidPointer = a.asm.L).apply(null, arguments); };
		        a._QTS_FreeCString = function () { return (a._QTS_FreeCString = a.asm.M).apply(null, arguments); };
		        a._QTS_DupValuePointer = function () { return (a._QTS_DupValuePointer = a.asm.N).apply(null, arguments); };
		        a._QTS_NewObject = function () { return (a._QTS_NewObject = a.asm.O).apply(null, arguments); };
		        a._QTS_NewObjectProto = function () { return (a._QTS_NewObjectProto = a.asm.P).apply(null, arguments); };
		        a._QTS_NewArray = function () { return (a._QTS_NewArray = a.asm.Q).apply(null, arguments); };
		        a._QTS_NewFloat64 = function () { return (a._QTS_NewFloat64 = a.asm.R).apply(null, arguments); };
		        a._QTS_GetFloat64 = function () { return (a._QTS_GetFloat64 = a.asm.S).apply(null, arguments); };
		        a._QTS_NewString = function () { return (a._QTS_NewString = a.asm.T).apply(null, arguments); };
		        a._QTS_GetString = function () { return (a._QTS_GetString = a.asm.U).apply(null, arguments); };
		        a._QTS_NewSymbol = function () { return (a._QTS_NewSymbol = a.asm.V).apply(null, arguments); };
		        a._QTS_GetSymbolDescriptionOrKey = function () { return (a._QTS_GetSymbolDescriptionOrKey = a.asm.W).apply(null, arguments); };
		        a._QTS_IsGlobalSymbol = function () { return (a._QTS_IsGlobalSymbol = a.asm.X).apply(null, arguments); };
		        a._QTS_IsJobPending = function () { return (a._QTS_IsJobPending = a.asm.Y).apply(null, arguments); };
		        a._QTS_ExecutePendingJob = function () { return (a._QTS_ExecutePendingJob = a.asm.Z).apply(null, arguments); };
		        a._QTS_GetProp = function () { return (a._QTS_GetProp = a.asm._).apply(null, arguments); };
		        a._QTS_SetProp = function () { return (a._QTS_SetProp = a.asm.$).apply(null, arguments); };
		        a._QTS_DefineProp = function () { return (a._QTS_DefineProp = a.asm.aa).apply(null, arguments); };
		        a._QTS_Call = function () { return (a._QTS_Call = a.asm.ba).apply(null, arguments); };
		        a._QTS_ResolveException = function () { return (a._QTS_ResolveException = a.asm.ca).apply(null, arguments); };
		        a._QTS_Dump = function () { return (a._QTS_Dump = a.asm.da).apply(null, arguments); };
		        a._QTS_Eval = function () { return (a._QTS_Eval = a.asm.ea).apply(null, arguments); };
		        a._QTS_Typeof = function () { return (a._QTS_Typeof = a.asm.fa).apply(null, arguments); };
		        a._QTS_GetGlobalObject = function () { return (a._QTS_GetGlobalObject = a.asm.ga).apply(null, arguments); };
		        a._QTS_NewPromiseCapability = function () { return (a._QTS_NewPromiseCapability = a.asm.ha).apply(null, arguments); };
		        a._QTS_TestStringArg = function () { return (a._QTS_TestStringArg = a.asm.ia).apply(null, arguments); };
		        a._QTS_BuildIsDebug = function () { return (a._QTS_BuildIsDebug = a.asm.ja).apply(null, arguments); };
		        a._QTS_BuildIsAsyncify = function () { return (a._QTS_BuildIsAsyncify = a.asm.ka).apply(null, arguments); };
		        a._QTS_NewFunction = function () { return (a._QTS_NewFunction = a.asm.la).apply(null, arguments); };
		        a._QTS_ArgvGetJSValueConstPointer = function () { return (a._QTS_ArgvGetJSValueConstPointer = a.asm.ma).apply(null, arguments); };
		        a._QTS_RuntimeEnableInterruptHandler = function () { return (a._QTS_RuntimeEnableInterruptHandler = a.asm.na).apply(null, arguments); };
		        a._QTS_RuntimeDisableInterruptHandler = function () { return (a._QTS_RuntimeDisableInterruptHandler = a.asm.oa).apply(null, arguments); };
		        a._QTS_RuntimeEnableModuleLoader = function () { return (a._QTS_RuntimeEnableModuleLoader = a.asm.pa).apply(null, arguments); };
		        a._QTS_RuntimeDisableModuleLoader = function () { return (a._QTS_RuntimeDisableModuleLoader = a.asm.qa).apply(null, arguments); };
		        function va() { return (va = a.asm.sa).apply(null, arguments); }
		        function wa() { return (wa = a.asm.ta).apply(null, arguments); }
		        function Y() { return (Y = a.asm.ua).apply(null, arguments); }
		        a.___start_em_js = 74916;
		        a.___stop_em_js = 75818;
		        a.cwrap = function (b, c, d, e) { var f = !d || d.every(g => "number" === g || "boolean" === g); return "string" !== c && f && !e ? a["_" + b] : function () { return ua(b, c, d, arguments); }; };
		        a.UTF8ToString = T;
		        a.stringToUTF8 = function (b, c, d) { return V(b, c, d); };
		        a.lengthBytesUTF8 = U;
		        var Z;
		        P = function za() { Z || Aa(); Z || (P = za); };
		        function Aa() { function b() { if (!Z && (Z = true, a.calledRun = true, !H)) {
		            S(ca);
		            m(a);
		            if (a.onRuntimeInitialized)
		                a.onRuntimeInitialized();
		            if (a.postRun)
		                for ("function" == typeof a.postRun && (a.postRun = [a.postRun]); a.postRun.length;) {
		                    var c = a.postRun.shift();
		                    da.unshift(c);
		                }
		            S(da);
		        } } if (!(0 < N)) {
		            if (a.preRun)
		                for ("function" == typeof a.preRun && (a.preRun = [a.preRun]); a.preRun.length;)
		                    ea();
		            S(ba);
		            0 < N || (a.setStatus ? (a.setStatus("Running..."), setTimeout(function () { setTimeout(function () { a.setStatus(""); }, 1); b(); }, 1)) : b());
		        } }
		        if (a.preInit)
		            for ("function" == typeof a.preInit && (a.preInit = [a.preInit]); 0 < a.preInit.length;)
		                a.preInit.pop()();
		        Aa();
		        return QuickJSRaw.ready;
		    });
		})();
		module.exports = QuickJSRaw; 
	} (emscriptenModule_WASM_RELEASE_SYNC));
	return emscriptenModule_WASM_RELEASE_SYNC.exports;
}

var hasRequiredVariants;

function requireVariants () {
	if (hasRequiredVariants) return variants;
	hasRequiredVariants = 1;
	(function (exports) {
		var __createBinding = (variants && variants.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __setModuleDefault = (variants && variants.__setModuleDefault) || (Object.create ? (function(o, v) {
		    Object.defineProperty(o, "default", { enumerable: true, value: v });
		}) : function(o, v) {
		    o["default"] = v;
		});
		var __importStar = (variants && variants.__importStar) || function (mod) {
		    if (mod && mod.__esModule) return mod;
		    var result = {};
		    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
		    __setModuleDefault(result, mod);
		    return result;
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.RELEASE_ASYNC = exports.DEBUG_ASYNC = exports.RELEASE_SYNC = exports.DEBUG_SYNC = exports.memoizePromiseFactory = exports.newQuickJSAsyncWASMModule = exports.newQuickJSWASMModule = void 0;
		const esmHelpers_1 = /*@__PURE__*/ requireEsmHelpers();
		async function newQuickJSWASMModule(
		variant = exports.RELEASE_SYNC) {
		    const [wasmModuleLoader, QuickJSFFI, { QuickJSWASMModule }] = await Promise.all([
		        variant.importModuleLoader(),
		        variant.importFFI(),
		        Promise.resolve().then(() => __importStar(/*@__PURE__*/ requireModule())).then(esmHelpers_1.unwrapTypescript),
		    ]);
		    const wasmModule = await wasmModuleLoader();
		    wasmModule.type = "sync";
		    const ffi = new QuickJSFFI(wasmModule);
		    return new QuickJSWASMModule(wasmModule, ffi);
		}
		exports.newQuickJSWASMModule = newQuickJSWASMModule;
		async function newQuickJSAsyncWASMModule(
		variant = exports.RELEASE_ASYNC) {
		    const [wasmModuleLoader, QuickJSAsyncFFI, { QuickJSAsyncWASMModule }] = await Promise.all([
		        variant.importModuleLoader(),
		        variant.importFFI(),
		        Promise.resolve().then(() => __importStar(/*@__PURE__*/ requireModuleAsyncify())).then(esmHelpers_1.unwrapTypescript),
		    ]);
		    const wasmModule = await wasmModuleLoader();
		    wasmModule.type = "async";
		    const ffi = new QuickJSAsyncFFI(wasmModule);
		    return new QuickJSAsyncWASMModule(wasmModule, ffi);
		}
		exports.newQuickJSAsyncWASMModule = newQuickJSAsyncWASMModule;
		function memoizePromiseFactory(fn) {
		    let promise;
		    return () => {
		        return (promise ?? (promise = fn()));
		    };
		}
		exports.memoizePromiseFactory = memoizePromiseFactory;
		exports.DEBUG_SYNC = {
		    type: "sync",
		    async importFFI() {
		        throw new Error("not implemented");
		    },
		    async importModuleLoader() {
		        throw new Error("not implemented");
		    },
		};
		exports.RELEASE_SYNC = {
		    type: "sync",
		    async importFFI() {
		        const mod = await Promise.resolve().then(() => __importStar(/*@__PURE__*/ requireFfi_WASM_RELEASE_SYNC()));
		        return (0, esmHelpers_1.unwrapTypescript)(mod).QuickJSFFI;
		    },
		    async importModuleLoader() {
		        const mod = await Promise.resolve().then(() => __importStar(/*@__PURE__*/ requireEmscriptenModule_WASM_RELEASE_SYNC()));
		        return (0, esmHelpers_1.unwrapJavascript)(mod);
		    },
		};
		exports.DEBUG_ASYNC = {
		    type: "async",
		    async importFFI() {
		        throw new Error("not implemented");
		    },
		    async importModuleLoader() {
		        throw new Error("not implemented");
		    },
		};
		exports.RELEASE_ASYNC = {
		    type: "async",
		    async importFFI() {
		        throw new Error("not implemented");
		    },
		    async importModuleLoader() {
		        throw new Error("not implemented");
		    },
		}; 
	} (variants));
	return variants;
}

var vmInterface = {};

var hasRequiredVmInterface;

function requireVmInterface () {
	if (hasRequiredVmInterface) return vmInterface;
	hasRequiredVmInterface = 1;
	Object.defineProperty(vmInterface, "__esModule", { value: true });
	vmInterface.isFail = vmInterface.isSuccess = void 0;
	function isSuccess(successOrFail) {
	    return "error" in successOrFail === false;
	}
	vmInterface.isSuccess = isSuccess;
	function isFail(successOrFail) {
	    return "error" in successOrFail === true;
	}
	vmInterface.isFail = isFail;
	return vmInterface;
}

var moduleTest = {};

var hasRequiredModuleTest;

function requireModuleTest () {
	if (hasRequiredModuleTest) return moduleTest;
	hasRequiredModuleTest = 1;
	Object.defineProperty(moduleTest, "__esModule", { value: true });
	moduleTest.TestQuickJSWASMModule = void 0;
	const errors_1 = /*@__PURE__*/ requireErrors();
	const lifetime_1 = /*@__PURE__*/ requireLifetime();
	class TestQuickJSWASMModule {
	    constructor(parent) {
	        this.parent = parent;
	        this.contexts = new Set();
	        this.runtimes = new Set();
	    }
	    newRuntime(options) {
	        const runtime = this.parent.newRuntime({
	            ...options,
	            ownedLifetimes: [
	                new lifetime_1.Lifetime(undefined, undefined, () => this.runtimes.delete(runtime)),
	                ...(options?.ownedLifetimes ?? []),
	            ],
	        });
	        this.runtimes.add(runtime);
	        return runtime;
	    }
	    newContext(options) {
	        const context = this.parent.newContext({
	            ...options,
	            ownedLifetimes: [
	                new lifetime_1.Lifetime(undefined, undefined, () => this.contexts.delete(context)),
	                ...(options?.ownedLifetimes ?? []),
	            ],
	        });
	        this.contexts.add(context);
	        return context;
	    }
	    evalCode(code, options) {
	        return this.parent.evalCode(code, options);
	    }
	    disposeAll() {
	        const allDisposables = [...this.contexts, ...this.runtimes];
	        this.runtimes.clear();
	        this.contexts.clear();
	        allDisposables.forEach((d) => {
	            if (d.alive) {
	                d.dispose();
	            }
	        });
	    }
	    assertNoMemoryAllocated() {
	        const leaksDetected = this.getFFI().QTS_RecoverableLeakCheck();
	        if (leaksDetected) {
	            throw new errors_1.QuickJSMemoryLeakDetected("Leak sanitizer detected un-freed memory");
	        }
	        if (this.contexts.size > 0) {
	            throw new errors_1.QuickJSMemoryLeakDetected(`${this.contexts.size} contexts leaked`);
	        }
	        if (this.runtimes.size > 0) {
	            throw new errors_1.QuickJSMemoryLeakDetected(`${this.runtimes.size} runtimes leaked`);
	        }
	    }
	    getFFI() {
	        return this.parent.getFFI();
	    }
	}
	moduleTest.TestQuickJSWASMModule = TestQuickJSWASMModule;
	return moduleTest;
}

var hasRequiredDist$2;

function requireDist$2 () {
	if (hasRequiredDist$2) return dist;
	hasRequiredDist$2 = 1;
	(function (exports) {
		var __createBinding = (dist && dist.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __setModuleDefault = (dist && dist.__setModuleDefault) || (Object.create ? (function(o, v) {
		    Object.defineProperty(o, "default", { enumerable: true, value: v });
		}) : function(o, v) {
		    o["default"] = v;
		});
		var __exportStar = (dist && dist.__exportStar) || function(m, exports) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
		};
		var __importStar = (dist && dist.__importStar) || function (mod) {
		    if (mod && mod.__esModule) return mod;
		    var result = {};
		    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
		    __setModuleDefault(result, mod);
		    return result;
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.shouldInterruptAfterDeadline = exports.newAsyncContext = exports.newAsyncRuntime = exports.getQuickJSSync = exports.getQuickJS = exports.errors = exports.RELEASE_SYNC = exports.RELEASE_ASYNC = exports.DEBUG_SYNC = exports.DEBUG_ASYNC = exports.newQuickJSAsyncWASMModule = exports.newQuickJSWASMModule = void 0;
		const variants_1 = /*@__PURE__*/ requireVariants();
		Object.defineProperty(exports, "newQuickJSWASMModule", { enumerable: true, get: function () { return variants_1.newQuickJSWASMModule; } });
		Object.defineProperty(exports, "newQuickJSAsyncWASMModule", { enumerable: true, get: function () { return variants_1.newQuickJSAsyncWASMModule; } });
		Object.defineProperty(exports, "DEBUG_ASYNC", { enumerable: true, get: function () { return variants_1.DEBUG_ASYNC; } });
		Object.defineProperty(exports, "DEBUG_SYNC", { enumerable: true, get: function () { return variants_1.DEBUG_SYNC; } });
		Object.defineProperty(exports, "RELEASE_ASYNC", { enumerable: true, get: function () { return variants_1.RELEASE_ASYNC; } });
		Object.defineProperty(exports, "RELEASE_SYNC", { enumerable: true, get: function () { return variants_1.RELEASE_SYNC; } });
		__exportStar(/*@__PURE__*/ requireVmInterface(), exports);
		__exportStar(/*@__PURE__*/ requireLifetime(), exports);
		exports.errors = __importStar(/*@__PURE__*/ requireErrors());
		__exportStar(/*@__PURE__*/ requireDeferredPromise(), exports);
		__exportStar(/*@__PURE__*/ requireModuleTest(), exports);
		let singleton = undefined;
		let singletonPromise = undefined;
		async function getQuickJS() {
		    singletonPromise ?? (singletonPromise = (0, variants_1.newQuickJSWASMModule)().then((instance) => {
		        singleton = instance;
		        return instance;
		    }));
		    return await singletonPromise;
		}
		exports.getQuickJS = getQuickJS;
		function getQuickJSSync() {
		    if (!singleton) {
		        throw new Error("QuickJS not initialized. Await getQuickJS() at least once.");
		    }
		    return singleton;
		}
		exports.getQuickJSSync = getQuickJSSync;
		async function newAsyncRuntime(options) {
		    const module = await (0, variants_1.newQuickJSAsyncWASMModule)();
		    return module.newRuntime(options);
		}
		exports.newAsyncRuntime = newAsyncRuntime;
		async function newAsyncContext(options) {
		    const module = await (0, variants_1.newQuickJSAsyncWASMModule)();
		    return module.newContext(options);
		}
		exports.newAsyncContext = newAsyncContext;
		function shouldInterruptAfterDeadline(deadline) {
		    const deadlineAsNumber = typeof deadline === "number" ? deadline : deadline.getTime();
		    return function () {
		        return Date.now() > deadlineAsNumber;
		    };
		}
		exports.shouldInterruptAfterDeadline = shouldInterruptAfterDeadline; 
	} (dist));
	return dist;
}

var hasRequiredDist$1;

function requireDist$1 () {
	if (hasRequiredDist$1) return dist$6;
	hasRequiredDist$1 = 1;
	var __createBinding = (dist$6 && dist$6.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (dist$6 && dist$6.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (dist$6 && dist$6.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	var __importDefault = (dist$6 && dist$6.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(dist$6, "__esModule", { value: true });
	dist$6.PacProxyAgent = void 0;
	const net = __importStar(require$$0$4);
	const tls = __importStar(require$$1$2);
	const crypto = __importStar(require$$2$1);
	const events_1 = require$$0$5;
	const debug_1 = __importDefault(requireSrc());
	const url_1 = require$$5;
	const agent_base_1 = requireDist$b();
	const get_uri_1 = requireDist$5();
	const pac_resolver_1 = requireDist$3();
	const quickjs_emscripten_1 = /*@__PURE__*/ requireDist$2();
	const debug = (0, debug_1.default)('pac-proxy-agent');
	const setServernameFromNonIpHost = (options) => {
	    if (options.servername === undefined &&
	        options.host &&
	        !net.isIP(options.host)) {
	        return {
	            ...options,
	            servername: options.host,
	        };
	    }
	    return options;
	};
	class PacProxyAgent extends agent_base_1.Agent {
	    constructor(uri, opts) {
	        super(opts);
	        this.clearResolverPromise = () => {
	            this.resolverPromise = undefined;
	        };
	        const uriStr = typeof uri === 'string' ? uri : uri.href;
	        this.uri = new url_1.URL(uriStr.replace(/^pac\+/i, ''));
	        debug('Creating PacProxyAgent with URI %o', this.uri.href);
	        this.opts = { ...opts };
	        this.cache = undefined;
	        this.resolver = undefined;
	        this.resolverHash = '';
	        this.resolverPromise = undefined;
	        if (!this.opts.filename) {
	            this.opts.filename = this.uri.href;
	        }
	    }
	    getResolver() {
	        if (!this.resolverPromise) {
	            this.resolverPromise = this.loadResolver();
	            this.resolverPromise.then(this.clearResolverPromise, this.clearResolverPromise);
	        }
	        return this.resolverPromise;
	    }
	    async loadResolver() {
	        try {
	            const [qjs, code] = await Promise.all([
	                (0, quickjs_emscripten_1.getQuickJS)(),
	                this.loadPacFile(),
	            ]);
	            const hash = crypto.createHash('sha1').update(code).digest('hex');
	            if (this.resolver && this.resolverHash === hash) {
	                debug('Same sha1 hash for code - contents have not changed, reusing previous proxy resolver');
	                return this.resolver;
	            }
	            debug('Creating new proxy resolver instance');
	            this.resolver = (0, pac_resolver_1.createPacResolver)(qjs, code, this.opts);
	            this.resolverHash = hash;
	            return this.resolver;
	        }
	        catch (err) {
	            if (this.resolver &&
	                err.code === 'ENOTMODIFIED') {
	                debug('Got ENOTMODIFIED response, reusing previous proxy resolver');
	                return this.resolver;
	            }
	            throw err;
	        }
	    }
	    async loadPacFile() {
	        debug('Loading PAC file: %o', this.uri);
	        const rs = await (0, get_uri_1.getUri)(this.uri, { ...this.opts, cache: this.cache });
	        debug('Got `Readable` instance for URI');
	        this.cache = rs;
	        const buf = await (0, agent_base_1.toBuffer)(rs);
	        debug('Read %o byte PAC file from URI', buf.length);
	        return buf.toString('utf8');
	    }
	    async connect(req, opts) {
	        const { secureEndpoint } = opts;
	        const isWebSocket = req.getHeader('upgrade') === 'websocket';
	        const resolver = await this.getResolver();
	        const protocol = secureEndpoint ? 'https:' : 'http:';
	        const host = opts.host && net.isIPv6(opts.host) ? `[${opts.host}]` : opts.host;
	        const url = Object.assign(new url_1.URL(req.path, `${protocol}//${host}`), undefined );
	        debug('url: %s', url);
	        let result = await resolver(url);
	        if (!result) {
	            result = 'DIRECT';
	        }
	        const proxies = String(result)
	            .trim()
	            .split(/\s*;\s*/g)
	            .filter(Boolean);
	        if (this.opts.fallbackToDirect && !proxies.includes('DIRECT')) {
	            proxies.push('DIRECT');
	        }
	        for (const proxy of proxies) {
	            let agent = null;
	            let socket = null;
	            const [type, target] = proxy.split(/\s+/);
	            debug('Attempting to use proxy: %o', proxy);
	            if (type === 'DIRECT') {
	                if (secureEndpoint) {
	                    socket = tls.connect(setServernameFromNonIpHost(opts));
	                }
	                else {
	                    socket = net.connect(opts);
	                }
	            }
	            else if (type === 'SOCKS' || type === 'SOCKS5') {
	                const { SocksProxyAgent } = await Promise.resolve().then(() => __importStar(requireDist$8()));
	                agent = new SocksProxyAgent(`socks://${target}`, this.opts);
	            }
	            else if (type === 'SOCKS4') {
	                const { SocksProxyAgent } = await Promise.resolve().then(() => __importStar(requireDist$8()));
	                agent = new SocksProxyAgent(`socks4a://${target}`, this.opts);
	            }
	            else if (type === 'PROXY' ||
	                type === 'HTTP' ||
	                type === 'HTTPS') {
	                const proxyURL = `${type === 'HTTPS' ? 'https' : 'http'}://${target}`;
	                if (secureEndpoint || isWebSocket) {
	                    const { HttpsProxyAgent } = await Promise.resolve().then(() => __importStar(requireDist$9()));
	                    agent = new HttpsProxyAgent(proxyURL, this.opts);
	                }
	                else {
	                    const { HttpProxyAgent } = await Promise.resolve().then(() => __importStar(requireDist$a()));
	                    agent = new HttpProxyAgent(proxyURL, this.opts);
	                }
	            }
	            try {
	                if (socket) {
	                    await (0, events_1.once)(socket, 'connect');
	                    req.emit('proxy', { proxy, socket });
	                    return socket;
	                }
	                if (agent) {
	                    const s = await agent.connect(req, opts);
	                    if (!(s instanceof net.Socket)) {
	                        throw new Error('Expected a `net.Socket` to be returned from agent');
	                    }
	                    req.emit('proxy', { proxy, socket: s });
	                    return s;
	                }
	                throw new Error(`Could not determine proxy type for: ${proxy}`);
	            }
	            catch (err) {
	                debug('Got error for proxy %o: %o', proxy, err);
	                req.emit('proxy', { proxy, error: err });
	            }
	        }
	        throw new Error(`Failed to establish a socket connection to proxies: ${JSON.stringify(proxies)}`);
	    }
	}
	PacProxyAgent.protocols = [
	    'pac+data',
	    'pac+file',
	    'pac+ftp',
	    'pac+http',
	    'pac+https',
	];
	dist$6.PacProxyAgent = PacProxyAgent;
	return dist$6;
}

var hasRequiredDist;

function requireDist () {
	if (hasRequiredDist) return dist$b;
	hasRequiredDist = 1;
	(function (exports) {
		var __createBinding = (dist$b && dist$b.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __setModuleDefault = (dist$b && dist$b.__setModuleDefault) || (Object.create ? (function(o, v) {
		    Object.defineProperty(o, "default", { enumerable: true, value: v });
		}) : function(o, v) {
		    o["default"] = v;
		});
		var __importStar = (dist$b && dist$b.__importStar) || function (mod) {
		    if (mod && mod.__esModule) return mod;
		    var result = {};
		    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
		    __setModuleDefault(result, mod);
		    return result;
		};
		var __importDefault = (dist$b && dist$b.__importDefault) || function (mod) {
		    return (mod && mod.__esModule) ? mod : { "default": mod };
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.ProxyAgent = exports.proxies = void 0;
		const http = __importStar(require$$0$3);
		const https = __importStar(require$$1$1);
		const url_1 = require$$5;
		const lru_cache_1 = __importDefault(/*@__PURE__*/ requireLruCache());
		const agent_base_1 = requireDist$b();
		const debug_1 = __importDefault(requireSrc());
		const proxy_from_env_1 = requireProxyFromEnv();
		const debug = (0, debug_1.default)('proxy-agent');
		const wellKnownAgents = {
		    http: async () => (await Promise.resolve().then(() => __importStar(requireDist$a()))).HttpProxyAgent,
		    https: async () => (await Promise.resolve().then(() => __importStar(requireDist$9()))).HttpsProxyAgent,
		    socks: async () => (await Promise.resolve().then(() => __importStar(requireDist$8()))).SocksProxyAgent,
		    pac: async () => (await Promise.resolve().then(() => __importStar(requireDist$1()))).PacProxyAgent,
		};
		exports.proxies = {
		    http: [wellKnownAgents.http, wellKnownAgents.https],
		    https: [wellKnownAgents.http, wellKnownAgents.https],
		    socks: [wellKnownAgents.socks, wellKnownAgents.socks],
		    socks4: [wellKnownAgents.socks, wellKnownAgents.socks],
		    socks4a: [wellKnownAgents.socks, wellKnownAgents.socks],
		    socks5: [wellKnownAgents.socks, wellKnownAgents.socks],
		    socks5h: [wellKnownAgents.socks, wellKnownAgents.socks],
		    'pac+data': [wellKnownAgents.pac, wellKnownAgents.pac],
		    'pac+file': [wellKnownAgents.pac, wellKnownAgents.pac],
		    'pac+ftp': [wellKnownAgents.pac, wellKnownAgents.pac],
		    'pac+http': [wellKnownAgents.pac, wellKnownAgents.pac],
		    'pac+https': [wellKnownAgents.pac, wellKnownAgents.pac],
		};
		function isValidProtocol(v) {
		    return Object.keys(exports.proxies).includes(v);
		}
		class ProxyAgent extends agent_base_1.Agent {
		    constructor(opts) {
		        super(opts);
		        this.cache = new lru_cache_1.default({
		            max: 20,
		            dispose: (agent) => agent.destroy(),
		        });
		        debug('Creating new ProxyAgent instance: %o', opts);
		        this.connectOpts = opts;
		        this.httpAgent = opts?.httpAgent || new http.Agent(opts);
		        this.httpsAgent =
		            opts?.httpsAgent || new https.Agent(opts);
		        this.getProxyForUrl = opts?.getProxyForUrl || proxy_from_env_1.getProxyForUrl;
		    }
		    async connect(req, opts) {
		        const { secureEndpoint } = opts;
		        const isWebSocket = req.getHeader('upgrade') === 'websocket';
		        const protocol = secureEndpoint
		            ? isWebSocket
		                ? 'wss:'
		                : 'https:'
		            : isWebSocket
		                ? 'ws:'
		                : 'http:';
		        const host = req.getHeader('host');
		        const url = new url_1.URL(req.path, `${protocol}//${host}`).href;
		        const proxy = await this.getProxyForUrl(url, req);
		        if (!proxy) {
		            debug('Proxy not enabled for URL: %o', url);
		            return secureEndpoint ? this.httpsAgent : this.httpAgent;
		        }
		        debug('Request URL: %o', url);
		        debug('Proxy URL: %o', proxy);
		        const cacheKey = `${protocol}+${proxy}`;
		        let agent = this.cache.get(cacheKey);
		        if (!agent) {
		            const proxyUrl = new url_1.URL(proxy);
		            const proxyProto = proxyUrl.protocol.replace(':', '');
		            if (!isValidProtocol(proxyProto)) {
		                throw new Error(`Unsupported protocol for proxy URL: ${proxy}`);
		            }
		            const ctor = await exports.proxies[proxyProto][secureEndpoint || isWebSocket ? 1 : 0]();
		            agent = new ctor(proxy, this.connectOpts);
		            this.cache.set(cacheKey, agent);
		        }
		        else {
		            debug('Cache hit for proxy URL: %o', proxy);
		        }
		        return agent;
		    }
		    destroy() {
		        for (const agent of this.cache.values()) {
		            agent.destroy();
		        }
		        super.destroy();
		    }
		}
		exports.ProxyAgent = ProxyAgent; 
	} (dist$b));
	return dist$b;
}

var distExports = requireDist();

/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
function httpRequest(url, method, response, keepAlive = true) {
    const options = {
        protocol: url.protocol,
        hostname: url.hostname,
        port: url.port,
        path: url.pathname + url.search,
        method,
        headers: keepAlive ? { Connection: 'keep-alive' } : undefined,
        auth: urlToHttpOptions(url).auth,
        agent: new distExports.ProxyAgent(),
    };
    const requestCallback = (res) => {
        if (res.statusCode &&
            res.statusCode >= 300 &&
            res.statusCode < 400 &&
            res.headers.location) {
            httpRequest(new URL$1(res.headers.location), method, response);
            res.resume();
        }
        else {
            response(res);
        }
    };
    const request = options.protocol === 'https:'
        ? https$1.request(options, requestCallback)
        : http$1.request(options, requestCallback);
    request.end();
    return request;
}
async function getJSON(url) {
    const text = await getText(url);
    try {
        return JSON.parse(text);
    }
    catch {
        throw new Error('Could not parse JSON from ' + url.toString());
    }
}
function getText(url) {
    return new Promise((resolve, reject) => {
        const request = httpRequest(url, 'GET', response => {
            let data = '';
            if (response.statusCode && response.statusCode >= 400) {
                return reject(new Error(`Got status code ${response.statusCode}`));
            }
            response.on('data', chunk => {
                data += chunk;
            });
            response.on('end', () => {
                try {
                    return resolve(String(data));
                }
                catch {
                    return reject(new Error('Chrome version not found'));
                }
            });
        }, false);
        request.on('error', err => {
            reject(err);
        });
    });
}

/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
function folder$3(platform) {
    switch (platform) {
        case BrowserPlatform.LINUX_ARM:
        case BrowserPlatform.LINUX:
            return 'linux64';
        case BrowserPlatform.MAC_ARM:
            return 'mac-arm64';
        case BrowserPlatform.MAC:
            return 'mac-x64';
        case BrowserPlatform.WIN32:
            return 'win32';
        case BrowserPlatform.WIN64:
            return 'win64';
    }
}
function resolveDownloadUrl$4(platform, buildId, baseUrl = 'https://storage.googleapis.com/chrome-for-testing-public') {
    return `${baseUrl}/${resolveDownloadPath$4(platform, buildId).join('/')}`;
}
function resolveDownloadPath$4(platform, buildId) {
    return [buildId, folder$3(platform), `chrome-${folder$3(platform)}.zip`];
}
function relativeExecutablePath$4(platform, _buildId) {
    switch (platform) {
        case BrowserPlatform.MAC:
        case BrowserPlatform.MAC_ARM:
            return path$1.join('chrome-' + folder$3(platform), 'Google Chrome for Testing.app', 'Contents', 'MacOS', 'Google Chrome for Testing');
        case BrowserPlatform.LINUX_ARM:
        case BrowserPlatform.LINUX:
            return path$1.join('chrome-linux64', 'chrome');
        case BrowserPlatform.WIN32:
        case BrowserPlatform.WIN64:
            return path$1.join('chrome-' + folder$3(platform), 'chrome.exe');
    }
}
async function getLastKnownGoodReleaseForChannel(channel) {
    const data = (await getJSON(new URL('https://googlechromelabs.github.io/chrome-for-testing/last-known-good-versions.json')));
    for (const channel of Object.keys(data.channels)) {
        data.channels[channel.toLowerCase()] = data.channels[channel];
        delete data.channels[channel];
    }
    return data.channels[channel];
}
async function getLastKnownGoodReleaseForMilestone(milestone) {
    const data = (await getJSON(new URL('https://googlechromelabs.github.io/chrome-for-testing/latest-versions-per-milestone.json')));
    return data.milestones[milestone];
}
async function getLastKnownGoodReleaseForBuild(
buildPrefix) {
    const data = (await getJSON(new URL('https://googlechromelabs.github.io/chrome-for-testing/latest-patch-versions-per-build.json')));
    return data.builds[buildPrefix];
}
async function resolveBuildId$3(channel) {
    if (Object.values(ChromeReleaseChannel).includes(channel)) {
        return (await getLastKnownGoodReleaseForChannel(channel)).version;
    }
    if (channel.match(/^\d+$/)) {
        return (await getLastKnownGoodReleaseForMilestone(channel))?.version;
    }
    if (channel.match(/^\d+\.\d+\.\d+$/)) {
        return (await getLastKnownGoodReleaseForBuild(channel))?.version;
    }
    return;
}
const WINDOWS_ENV_PARAM_NAMES = [
    'PROGRAMFILES',
    'ProgramW6432',
    'ProgramFiles(x86)',
    'LOCALAPPDATA',
];
function getChromeWindowsLocation(channel, locationsPrefixes) {
    if (locationsPrefixes.size === 0) {
        throw new Error('Non of the common Windows Env variables were set');
    }
    let suffix;
    switch (channel) {
        case ChromeReleaseChannel.STABLE:
            suffix = 'Google\\Chrome\\Application\\chrome.exe';
            break;
        case ChromeReleaseChannel.BETA:
            suffix = 'Google\\Chrome Beta\\Application\\chrome.exe';
            break;
        case ChromeReleaseChannel.CANARY:
            suffix = 'Google\\Chrome SxS\\Application\\chrome.exe';
            break;
        case ChromeReleaseChannel.DEV:
            suffix = 'Google\\Chrome Dev\\Application\\chrome.exe';
            break;
    }
    return [...locationsPrefixes.values()].map(l => {
        return path$1.win32.join(l, suffix);
    });
}
function getWslLocation(channel) {
    const wslVersion = execSync('wslinfo --version', {
        stdio: ['ignore', 'pipe', 'ignore'],
        encoding: 'utf-8',
    }).trim();
    if (!wslVersion) {
        throw new Error('Not in WSL or unsupported version of WSL.');
    }
    const wslPrefixes = new Set();
    for (const name of WINDOWS_ENV_PARAM_NAMES) {
        try {
            const wslPrefix = execSync(`cmd.exe /c echo %${name.toLocaleUpperCase()}%`, {
                stdio: ['ignore', 'pipe', 'ignore'],
                encoding: 'utf-8',
            }).trim();
            if (wslPrefix) {
                wslPrefixes.add(wslPrefix);
            }
        }
        catch { }
    }
    const windowsPath = getChromeWindowsLocation(channel, wslPrefixes);
    return windowsPath.map(path => {
        return execSync(`wslpath "${path}"`).toString().trim();
    });
}
function getChromeLinuxOrWslLocation(channel) {
    const locations = [];
    try {
        const wslPath = getWslLocation(channel);
        if (wslPath) {
            locations.push(...wslPath);
        }
    }
    catch {
    }
    switch (channel) {
        case ChromeReleaseChannel.STABLE:
            locations.push('/opt/google/chrome/chrome');
            break;
        case ChromeReleaseChannel.BETA:
            locations.push('/opt/google/chrome-beta/chrome');
            break;
        case ChromeReleaseChannel.CANARY:
            locations.push('/opt/google/chrome-canary/chrome');
            break;
        case ChromeReleaseChannel.DEV:
            locations.push('/opt/google/chrome-unstable/chrome');
            break;
    }
    return locations;
}
function resolveSystemExecutablePaths$1(platform, channel) {
    switch (platform) {
        case BrowserPlatform.WIN64:
        case BrowserPlatform.WIN32:
            const prefixLocation = new Set(WINDOWS_ENV_PARAM_NAMES.map(name => {
                return process.env[name];
            }).filter((l) => {
                return !!l;
            }));
            prefixLocation.add('C:\\Program Files');
            prefixLocation.add('C:\\Program Files (x86)');
            prefixLocation.add('D:\\Program Files');
            prefixLocation.add('D:\\Program Files (x86)');
            return getChromeWindowsLocation(channel, prefixLocation);
        case BrowserPlatform.MAC_ARM:
        case BrowserPlatform.MAC:
            switch (channel) {
                case ChromeReleaseChannel.STABLE:
                    return [
                        '/Applications/Google Chrome.app/Contents/MacOS/Google Chrome',
                    ];
                case ChromeReleaseChannel.BETA:
                    return [
                        '/Applications/Google Chrome Beta.app/Contents/MacOS/Google Chrome Beta',
                    ];
                case ChromeReleaseChannel.CANARY:
                    return [
                        '/Applications/Google Chrome Canary.app/Contents/MacOS/Google Chrome Canary',
                    ];
                case ChromeReleaseChannel.DEV:
                    return [
                        '/Applications/Google Chrome Dev.app/Contents/MacOS/Google Chrome Dev',
                    ];
            }
        case BrowserPlatform.LINUX_ARM:
        case BrowserPlatform.LINUX:
            return getChromeLinuxOrWslLocation(channel);
    }
}
function compareVersions$2(a, b) {
    if (!semver.valid(a)) {
        throw new Error(`Version ${a} is not a valid semver version`);
    }
    if (!semver.valid(b)) {
        throw new Error(`Version ${b} is not a valid semver version`);
    }
    if (semver.gt(a, b)) {
        return 1;
    }
    else if (semver.lt(a, b)) {
        return -1;
    }
    else {
        return 0;
    }
}

/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
function folder$2(platform) {
    switch (platform) {
        case BrowserPlatform.LINUX_ARM:
        case BrowserPlatform.LINUX:
            return 'linux64';
        case BrowserPlatform.MAC_ARM:
            return 'mac-arm64';
        case BrowserPlatform.MAC:
            return 'mac-x64';
        case BrowserPlatform.WIN32:
            return 'win32';
        case BrowserPlatform.WIN64:
            return 'win64';
    }
}
function resolveDownloadUrl$3(platform, buildId, baseUrl = 'https://storage.googleapis.com/chrome-for-testing-public') {
    return `${baseUrl}/${resolveDownloadPath$3(platform, buildId).join('/')}`;
}
function resolveDownloadPath$3(platform, buildId) {
    return [
        buildId,
        folder$2(platform),
        `chrome-headless-shell-${folder$2(platform)}.zip`,
    ];
}
function relativeExecutablePath$3(platform, _buildId) {
    switch (platform) {
        case BrowserPlatform.MAC:
        case BrowserPlatform.MAC_ARM:
            return path$1.join('chrome-headless-shell-' + folder$2(platform), 'chrome-headless-shell');
        case BrowserPlatform.LINUX_ARM:
        case BrowserPlatform.LINUX:
            return path$1.join('chrome-headless-shell-linux64', 'chrome-headless-shell');
        case BrowserPlatform.WIN32:
        case BrowserPlatform.WIN64:
            return path$1.join('chrome-headless-shell-' + folder$2(platform), 'chrome-headless-shell.exe');
    }
}

/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
function folder$1(platform) {
    switch (platform) {
        case BrowserPlatform.LINUX_ARM:
        case BrowserPlatform.LINUX:
            return 'linux64';
        case BrowserPlatform.MAC_ARM:
            return 'mac-arm64';
        case BrowserPlatform.MAC:
            return 'mac-x64';
        case BrowserPlatform.WIN32:
            return 'win32';
        case BrowserPlatform.WIN64:
            return 'win64';
    }
}
function resolveDownloadUrl$2(platform, buildId, baseUrl = 'https://storage.googleapis.com/chrome-for-testing-public') {
    return `${baseUrl}/${resolveDownloadPath$2(platform, buildId).join('/')}`;
}
function resolveDownloadPath$2(platform, buildId) {
    return [buildId, folder$1(platform), `chromedriver-${folder$1(platform)}.zip`];
}
function relativeExecutablePath$2(platform, _buildId) {
    switch (platform) {
        case BrowserPlatform.MAC:
        case BrowserPlatform.MAC_ARM:
            return path$1.join('chromedriver-' + folder$1(platform), 'chromedriver');
        case BrowserPlatform.LINUX_ARM:
        case BrowserPlatform.LINUX:
            return path$1.join('chromedriver-linux64', 'chromedriver');
        case BrowserPlatform.WIN32:
        case BrowserPlatform.WIN64:
            return path$1.join('chromedriver-' + folder$1(platform), 'chromedriver.exe');
    }
}

/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
function archive$1(platform, buildId) {
    switch (platform) {
        case BrowserPlatform.LINUX_ARM:
        case BrowserPlatform.LINUX:
            return 'chrome-linux';
        case BrowserPlatform.MAC_ARM:
        case BrowserPlatform.MAC:
            return 'chrome-mac';
        case BrowserPlatform.WIN32:
        case BrowserPlatform.WIN64:
            return parseInt(buildId, 10) > 591479 ? 'chrome-win' : 'chrome-win32';
    }
}
function folder(platform) {
    switch (platform) {
        case BrowserPlatform.LINUX_ARM:
        case BrowserPlatform.LINUX:
            return 'Linux_x64';
        case BrowserPlatform.MAC_ARM:
            return 'Mac_Arm';
        case BrowserPlatform.MAC:
            return 'Mac';
        case BrowserPlatform.WIN32:
            return 'Win';
        case BrowserPlatform.WIN64:
            return 'Win_x64';
    }
}
function resolveDownloadUrl$1(platform, buildId, baseUrl = 'https://storage.googleapis.com/chromium-browser-snapshots') {
    return `${baseUrl}/${resolveDownloadPath$1(platform, buildId).join('/')}`;
}
function resolveDownloadPath$1(platform, buildId) {
    return [folder(platform), buildId, `${archive$1(platform, buildId)}.zip`];
}
function relativeExecutablePath$1(platform, _buildId) {
    switch (platform) {
        case BrowserPlatform.MAC:
        case BrowserPlatform.MAC_ARM:
            return path$1.join('chrome-mac', 'Chromium.app', 'Contents', 'MacOS', 'Chromium');
        case BrowserPlatform.LINUX_ARM:
        case BrowserPlatform.LINUX:
            return path$1.join('chrome-linux', 'chrome');
        case BrowserPlatform.WIN32:
        case BrowserPlatform.WIN64:
            return path$1.join('chrome-win', 'chrome.exe');
    }
}
async function resolveBuildId$2(platform) {
    return await getText(new URL(`https://storage.googleapis.com/chromium-browser-snapshots/${folder(platform)}/LAST_CHANGE`));
}
function compareVersions$1(a, b) {
    return Number(a) - Number(b);
}

/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
function getFormat(buildId) {
    const majorVersion = Number(buildId.split('.').shift());
    return majorVersion >= 135 ? 'xz' : 'bz2';
}
function archiveNightly(platform, buildId) {
    switch (platform) {
        case BrowserPlatform.LINUX:
            return `firefox-${buildId}.en-US.linux-x86_64.tar.${getFormat(buildId)}`;
        case BrowserPlatform.LINUX_ARM:
            return `firefox-${buildId}.en-US.linux-aarch64.tar.${getFormat(buildId)}`;
        case BrowserPlatform.MAC_ARM:
        case BrowserPlatform.MAC:
            return `firefox-${buildId}.en-US.mac.dmg`;
        case BrowserPlatform.WIN32:
        case BrowserPlatform.WIN64:
            return `firefox-${buildId}.en-US.${platform}.zip`;
    }
}
function archive(platform, buildId) {
    switch (platform) {
        case BrowserPlatform.LINUX_ARM:
        case BrowserPlatform.LINUX:
            return `firefox-${buildId}.tar.${getFormat(buildId)}`;
        case BrowserPlatform.MAC_ARM:
        case BrowserPlatform.MAC:
            return `Firefox ${buildId}.dmg`;
        case BrowserPlatform.WIN32:
        case BrowserPlatform.WIN64:
            return `Firefox Setup ${buildId}.exe`;
    }
}
function platformName(platform) {
    switch (platform) {
        case BrowserPlatform.LINUX:
            return `linux-x86_64`;
        case BrowserPlatform.LINUX_ARM:
            return `linux-aarch64`;
        case BrowserPlatform.MAC_ARM:
        case BrowserPlatform.MAC:
            return `mac`;
        case BrowserPlatform.WIN32:
        case BrowserPlatform.WIN64:
            return platform;
    }
}
function parseBuildId(buildId) {
    for (const value of Object.values(FirefoxChannel)) {
        if (buildId.startsWith(value + '_')) {
            buildId = buildId.substring(value.length + 1);
            return [value, buildId];
        }
    }
    return [FirefoxChannel.NIGHTLY, buildId];
}
function resolveDownloadUrl(platform, buildId, baseUrl) {
    const [channel] = parseBuildId(buildId);
    switch (channel) {
        case FirefoxChannel.NIGHTLY:
            baseUrl ??=
                'https://archive.mozilla.org/pub/firefox/nightly/latest-mozilla-central';
            break;
        case FirefoxChannel.DEVEDITION:
            baseUrl ??= 'https://archive.mozilla.org/pub/devedition/releases';
            break;
        case FirefoxChannel.BETA:
        case FirefoxChannel.STABLE:
        case FirefoxChannel.ESR:
            baseUrl ??= 'https://archive.mozilla.org/pub/firefox/releases';
            break;
    }
    return `${baseUrl}/${resolveDownloadPath(platform, buildId).join('/')}`;
}
function resolveDownloadPath(platform, buildId) {
    const [channel, resolvedBuildId] = parseBuildId(buildId);
    switch (channel) {
        case FirefoxChannel.NIGHTLY:
            return [archiveNightly(platform, resolvedBuildId)];
        case FirefoxChannel.DEVEDITION:
        case FirefoxChannel.BETA:
        case FirefoxChannel.STABLE:
        case FirefoxChannel.ESR:
            return [
                resolvedBuildId,
                platformName(platform),
                'en-US',
                archive(platform, resolvedBuildId),
            ];
    }
}
function relativeExecutablePath(platform, buildId) {
    const [channel] = parseBuildId(buildId);
    switch (channel) {
        case FirefoxChannel.NIGHTLY:
            switch (platform) {
                case BrowserPlatform.MAC_ARM:
                case BrowserPlatform.MAC:
                    return path$1.join('Firefox Nightly.app', 'Contents', 'MacOS', 'firefox');
                case BrowserPlatform.LINUX_ARM:
                case BrowserPlatform.LINUX:
                    return path$1.join('firefox', 'firefox');
                case BrowserPlatform.WIN32:
                case BrowserPlatform.WIN64:
                    return path$1.join('firefox', 'firefox.exe');
            }
        case FirefoxChannel.BETA:
        case FirefoxChannel.DEVEDITION:
        case FirefoxChannel.ESR:
        case FirefoxChannel.STABLE:
            switch (platform) {
                case BrowserPlatform.MAC_ARM:
                case BrowserPlatform.MAC:
                    return path$1.join('Firefox.app', 'Contents', 'MacOS', 'firefox');
                case BrowserPlatform.LINUX_ARM:
                case BrowserPlatform.LINUX:
                    return path$1.join('firefox', 'firefox');
                case BrowserPlatform.WIN32:
                case BrowserPlatform.WIN64:
                    return path$1.join('core', 'firefox.exe');
            }
    }
}
var FirefoxChannel;
(function (FirefoxChannel) {
    FirefoxChannel["STABLE"] = "stable";
    FirefoxChannel["ESR"] = "esr";
    FirefoxChannel["DEVEDITION"] = "devedition";
    FirefoxChannel["BETA"] = "beta";
    FirefoxChannel["NIGHTLY"] = "nightly";
})(FirefoxChannel || (FirefoxChannel = {}));
async function resolveBuildId$1(channel = FirefoxChannel.NIGHTLY) {
    const channelToVersionKey = {
        [FirefoxChannel.ESR]: 'FIREFOX_ESR',
        [FirefoxChannel.STABLE]: 'LATEST_FIREFOX_VERSION',
        [FirefoxChannel.DEVEDITION]: 'FIREFOX_DEVEDITION',
        [FirefoxChannel.BETA]: 'FIREFOX_DEVEDITION',
        [FirefoxChannel.NIGHTLY]: 'FIREFOX_NIGHTLY',
    };
    const versions = (await getJSON(new URL('https://product-details.mozilla.org/1.0/firefox_versions.json')));
    const version = versions[channelToVersionKey[channel]];
    if (!version) {
        throw new Error(`Channel ${channel} is not found.`);
    }
    return channel + '_' + version;
}
async function createProfile$1(options) {
    if (!fs.existsSync(options.path)) {
        await fs.promises.mkdir(options.path, {
            recursive: true,
        });
    }
    await syncPreferences({
        preferences: {
            ...defaultProfilePreferences(options.preferences),
            ...options.preferences,
        },
        path: options.path,
    });
}
function defaultProfilePreferences(extraPrefs) {
    const server = 'dummy.test';
    const defaultPrefs = {
        'app.normandy.api_url': '',
        'app.update.checkInstallTime': false,
        'app.update.disabledForTesting': true,
        'apz.content_response_timeout': 60000,
        'browser.backup.enabled': false,
        'browser.contentblocking.features.standard': '-tp,tpPrivate,cookieBehavior0,-cryptoTP,-fp',
        'browser.dom.window.dump.enabled': true,
        'browser.newtabpage.activity-stream.feeds.system.topstories': false,
        'browser.newtabpage.enabled': false,
        'browser.pagethumbnails.capturing_disabled': true,
        'browser.safebrowsing.blockedURIs.enabled': false,
        'browser.safebrowsing.downloads.enabled': false,
        'browser.safebrowsing.malware.enabled': false,
        'browser.safebrowsing.phishing.enabled': false,
        'browser.search.update': false,
        'browser.sessionstore.resume_from_crash': false,
        'browser.shell.checkDefaultBrowser': false,
        'browser.startup.homepage': 'about:blank',
        'browser.startup.homepage_override.mstone': 'ignore',
        'browser.startup.page': 0,
        'browser.tabs.disableBackgroundZombification': false,
        'browser.tabs.warnOnCloseOtherTabs': false,
        'browser.tabs.warnOnOpen': false,
        'browser.translations.automaticallyPopup': false,
        'browser.uitour.enabled': false,
        'browser.urlbar.suggest.searches': false,
        'browser.usedOnWindows10.introURL': '',
        'browser.warnOnQuit': false,
        'datareporting.healthreport.documentServerURI': `http://${server}/dummy/healthreport/`,
        'datareporting.healthreport.logging.consoleEnabled': false,
        'datareporting.healthreport.service.enabled': false,
        'datareporting.healthreport.service.firstRun': false,
        'datareporting.healthreport.uploadEnabled': false,
        'datareporting.policy.dataSubmissionEnabled': false,
        'datareporting.policy.dataSubmissionPolicyBypassNotification': true,
        'devtools.jsonview.enabled': false,
        'dom.disable_open_during_load': false,
        'dom.file.createInChild': true,
        'dom.ipc.reportProcessHangs': false,
        'dom.max_chrome_script_run_time': 0,
        'dom.max_script_run_time': 0,
        'extensions.autoDisableScopes': 0,
        'extensions.enabledScopes': 5,
        'extensions.getAddons.cache.enabled': false,
        'extensions.installDistroAddons': false,
        'extensions.update.enabled': false,
        'extensions.update.notifyUser': false,
        'extensions.webservice.discoverURL': `http://${server}/dummy/discoveryURL`,
        'focusmanager.testmode': true,
        'general.useragent.updates.enabled': false,
        'geo.provider.testing': true,
        'geo.wifi.scan': false,
        'hangmonitor.timeout': 0,
        'javascript.options.showInConsole': true,
        'media.gmp-manager.updateEnabled': false,
        'media.sanity-test.disabled': true,
        'network.cookie.sameSite.laxByDefault': false,
        'network.http.prompt-temp-redirect': false,
        'network.http.speculative-parallel-limit': 0,
        'network.manage-offline-status': false,
        'network.sntp.pools': server,
        'plugin.state.flash': 0,
        'privacy.trackingprotection.enabled': false,
        'remote.enabled': true,
        'screenshots.browser.component.enabled': false,
        'security.certerrors.mitm.priming.enabled': false,
        'security.fileuri.strict_origin_policy': false,
        'security.notification_enable_delay': 0,
        'services.settings.server': `http://${server}/dummy/blocklist/`,
        'signon.autofillForms': false,
        'signon.rememberSignons': false,
        'startup.homepage_welcome_url': 'about:blank',
        'startup.homepage_welcome_url.additional': '',
        'toolkit.cosmeticAnimations.enabled': false,
        'toolkit.startup.max_resumed_crashes': -1,
    };
    return Object.assign(defaultPrefs, extraPrefs);
}
async function backupFile(input) {
    if (!fs.existsSync(input)) {
        return;
    }
    await fs.promises.copyFile(input, input + '.puppeteer');
}
async function syncPreferences(options) {
    const prefsPath = path$1.join(options.path, 'prefs.js');
    const userPath = path$1.join(options.path, 'user.js');
    const lines = Object.entries(options.preferences).map(([key, value]) => {
        return `user_pref(${JSON.stringify(key)}, ${JSON.stringify(value)});`;
    });
    const result = await Promise.allSettled([
        backupFile(userPath).then(async () => {
            await fs.promises.writeFile(userPath, lines.join('\n'));
        }),
        backupFile(prefsPath),
    ]);
    for (const command of result) {
        if (command.status === 'rejected') {
            throw command.reason;
        }
    }
}
function compareVersions(a, b) {
    return parseInt(a.replace('.', ''), 16) - parseInt(b.replace('.', ''), 16);
}

/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
({
    [Browser.CHROMEDRIVER]: resolveDownloadUrl$2,
    [Browser.CHROMEHEADLESSSHELL]: resolveDownloadUrl$3,
    [Browser.CHROME]: resolveDownloadUrl$4,
    [Browser.CHROMIUM]: resolveDownloadUrl$1,
    [Browser.FIREFOX]: resolveDownloadUrl,
});
({
    [Browser.CHROMEDRIVER]: resolveDownloadPath$2,
    [Browser.CHROMEHEADLESSSHELL]: resolveDownloadPath$3,
    [Browser.CHROME]: resolveDownloadPath$4,
    [Browser.CHROMIUM]: resolveDownloadPath$1,
    [Browser.FIREFOX]: resolveDownloadPath,
});
const executablePathByBrowser = {
    [Browser.CHROMEDRIVER]: relativeExecutablePath$2,
    [Browser.CHROMEHEADLESSSHELL]: relativeExecutablePath$3,
    [Browser.CHROME]: relativeExecutablePath$4,
    [Browser.CHROMIUM]: relativeExecutablePath$1,
    [Browser.FIREFOX]: relativeExecutablePath,
};
const versionComparators = {
    [Browser.CHROMEDRIVER]: compareVersions$2,
    [Browser.CHROMEHEADLESSSHELL]: compareVersions$2,
    [Browser.CHROME]: compareVersions$2,
    [Browser.CHROMIUM]: compareVersions$1,
    [Browser.FIREFOX]: compareVersions,
};
async function resolveBuildIdForBrowserTag(browser, platform, tag) {
    switch (browser) {
        case Browser.FIREFOX:
            switch (tag) {
                case BrowserTag.LATEST:
                    return await resolveBuildId$1(FirefoxChannel.NIGHTLY);
                case BrowserTag.BETA:
                    return await resolveBuildId$1(FirefoxChannel.BETA);
                case BrowserTag.NIGHTLY:
                    return await resolveBuildId$1(FirefoxChannel.NIGHTLY);
                case BrowserTag.DEVEDITION:
                    return await resolveBuildId$1(FirefoxChannel.DEVEDITION);
                case BrowserTag.STABLE:
                    return await resolveBuildId$1(FirefoxChannel.STABLE);
                case BrowserTag.ESR:
                    return await resolveBuildId$1(FirefoxChannel.ESR);
                case BrowserTag.CANARY:
                case BrowserTag.DEV:
                    throw new Error(`${tag.toUpperCase()} is not available for Firefox`);
            }
        case Browser.CHROME: {
            switch (tag) {
                case BrowserTag.LATEST:
                    return await resolveBuildId$3(ChromeReleaseChannel.CANARY);
                case BrowserTag.BETA:
                    return await resolveBuildId$3(ChromeReleaseChannel.BETA);
                case BrowserTag.CANARY:
                    return await resolveBuildId$3(ChromeReleaseChannel.CANARY);
                case BrowserTag.DEV:
                    return await resolveBuildId$3(ChromeReleaseChannel.DEV);
                case BrowserTag.STABLE:
                    return await resolveBuildId$3(ChromeReleaseChannel.STABLE);
                case BrowserTag.NIGHTLY:
                case BrowserTag.DEVEDITION:
                case BrowserTag.ESR:
                    throw new Error(`${tag.toUpperCase()} is not available for Chrome`);
            }
        }
        case Browser.CHROMEDRIVER: {
            switch (tag) {
                case BrowserTag.LATEST:
                case BrowserTag.CANARY:
                    return await resolveBuildId$3(ChromeReleaseChannel.CANARY);
                case BrowserTag.BETA:
                    return await resolveBuildId$3(ChromeReleaseChannel.BETA);
                case BrowserTag.DEV:
                    return await resolveBuildId$3(ChromeReleaseChannel.DEV);
                case BrowserTag.STABLE:
                    return await resolveBuildId$3(ChromeReleaseChannel.STABLE);
                case BrowserTag.NIGHTLY:
                case BrowserTag.DEVEDITION:
                case BrowserTag.ESR:
                    throw new Error(`${tag.toUpperCase()} is not available for ChromeDriver`);
            }
        }
        case Browser.CHROMEHEADLESSSHELL: {
            switch (tag) {
                case BrowserTag.LATEST:
                case BrowserTag.CANARY:
                    return await resolveBuildId$3(ChromeReleaseChannel.CANARY);
                case BrowserTag.BETA:
                    return await resolveBuildId$3(ChromeReleaseChannel.BETA);
                case BrowserTag.DEV:
                    return await resolveBuildId$3(ChromeReleaseChannel.DEV);
                case BrowserTag.STABLE:
                    return await resolveBuildId$3(ChromeReleaseChannel.STABLE);
                case BrowserTag.NIGHTLY:
                case BrowserTag.DEVEDITION:
                case BrowserTag.ESR:
                    throw new Error(`${tag} is not available for chrome-headless-shell`);
            }
        }
        case Browser.CHROMIUM:
            switch (tag) {
                case BrowserTag.LATEST:
                    return await resolveBuildId$2(platform);
                case BrowserTag.NIGHTLY:
                case BrowserTag.CANARY:
                case BrowserTag.DEV:
                case BrowserTag.DEVEDITION:
                case BrowserTag.BETA:
                case BrowserTag.STABLE:
                case BrowserTag.ESR:
                    throw new Error(`${tag} is not supported for Chromium. Use 'latest' instead.`);
            }
    }
}
async function resolveBuildId(browser, platform, tag) {
    const browserTag = tag;
    if (Object.values(BrowserTag).includes(browserTag)) {
        return await resolveBuildIdForBrowserTag(browser, platform, browserTag);
    }
    switch (browser) {
        case Browser.FIREFOX:
            return tag;
        case Browser.CHROME:
            const chromeResult = await resolveBuildId$3(tag);
            if (chromeResult) {
                return chromeResult;
            }
            return tag;
        case Browser.CHROMEDRIVER:
            const chromeDriverResult = await resolveBuildId$3(tag);
            if (chromeDriverResult) {
                return chromeDriverResult;
            }
            return tag;
        case Browser.CHROMEHEADLESSSHELL:
            const chromeHeadlessShellResult = await resolveBuildId$3(tag);
            if (chromeHeadlessShellResult) {
                return chromeHeadlessShellResult;
            }
            return tag;
        case Browser.CHROMIUM:
            return tag;
    }
}
async function createProfile(browser, opts) {
    switch (browser) {
        case Browser.FIREFOX:
            return await createProfile$1(opts);
        case Browser.CHROME:
        case Browser.CHROMIUM:
            throw new Error(`Profile creation is not support for ${browser} yet`);
    }
}
function resolveSystemExecutablePaths(browser, platform, channel) {
    switch (browser) {
        case Browser.CHROMEDRIVER:
        case Browser.CHROMEHEADLESSSHELL:
        case Browser.FIREFOX:
        case Browser.CHROMIUM:
            throw new Error(`System browser detection is not supported for ${browser} yet.`);
        case Browser.CHROME:
            return resolveSystemExecutablePaths$1(platform, channel);
    }
}
function getVersionComparator(browser) {
    return versionComparators[browser];
}

/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
function detectBrowserPlatform() {
    const platform = os.platform();
    const arch = os.arch();
    switch (platform) {
        case 'darwin':
            return arch === 'arm64' ? BrowserPlatform.MAC_ARM : BrowserPlatform.MAC;
        case 'linux':
            return arch === 'arm64'
                ? BrowserPlatform.LINUX_ARM
                : BrowserPlatform.LINUX;
        case 'win32':
            return arch === 'x64' ||
                (arch === 'arm64' && isWindows11(os.release()))
                ? BrowserPlatform.WIN64
                : BrowserPlatform.WIN32;
        default:
            return undefined;
    }
}
function isWindows11(version) {
    const parts = version.split('.');
    if (parts.length > 2) {
        const major = parseInt(parts[0], 10);
        const minor = parseInt(parts[1], 10);
        const patch = parseInt(parts[2], 10);
        return (major > 10 ||
            (major === 10 && minor > 0) ||
            (major === 10 && minor === 0 && patch >= 22000));
    }
    return false;
}

/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const debugCache = debug$2('puppeteer:browsers:cache');
class InstalledBrowser {
    browser;
    buildId;
    platform;
    executablePath;
    #cache;
    constructor(cache, browser, buildId, platform) {
        this.#cache = cache;
        this.browser = browser;
        this.buildId = buildId;
        this.platform = platform;
        this.executablePath = cache.computeExecutablePath({
            browser,
            buildId,
            platform,
        });
    }
    get path() {
        return this.#cache.installationDir(this.browser, this.platform, this.buildId);
    }
    readMetadata() {
        return this.#cache.readMetadata(this.browser);
    }
    writeMetadata(metadata) {
        this.#cache.writeMetadata(this.browser, metadata);
    }
}
class Cache {
    #rootDir;
    constructor(rootDir) {
        this.#rootDir = rootDir;
    }
    get rootDir() {
        return this.#rootDir;
    }
    browserRoot(browser) {
        return path$1.join(this.#rootDir, browser);
    }
    metadataFile(browser) {
        return path$1.join(this.browserRoot(browser), '.metadata');
    }
    readMetadata(browser) {
        const metatadaPath = this.metadataFile(browser);
        if (!fs.existsSync(metatadaPath)) {
            return { aliases: {} };
        }
        const data = JSON.parse(fs.readFileSync(metatadaPath, 'utf8'));
        if (typeof data !== 'object') {
            throw new Error('.metadata is not an object');
        }
        return data;
    }
    writeMetadata(browser, metadata) {
        const metatadaPath = this.metadataFile(browser);
        fs.mkdirSync(path$1.dirname(metatadaPath), { recursive: true });
        fs.writeFileSync(metatadaPath, JSON.stringify(metadata, null, 2));
    }
    resolveAlias(browser, alias) {
        const metadata = this.readMetadata(browser);
        if (alias === 'latest') {
            return Object.values(metadata.aliases || {})
                .sort(getVersionComparator(browser))
                .at(-1);
        }
        return metadata.aliases[alias];
    }
    installationDir(browser, platform, buildId) {
        return path$1.join(this.browserRoot(browser), `${platform}-${buildId}`);
    }
    clear() {
        fs.rmSync(this.#rootDir, {
            force: true,
            recursive: true,
            maxRetries: 10,
            retryDelay: 500,
        });
    }
    uninstall(browser, platform, buildId) {
        const metadata = this.readMetadata(browser);
        for (const alias of Object.keys(metadata.aliases)) {
            if (metadata.aliases[alias] === buildId) {
                delete metadata.aliases[alias];
            }
        }
        fs.rmSync(this.installationDir(browser, platform, buildId), {
            force: true,
            recursive: true,
            maxRetries: 10,
            retryDelay: 500,
        });
    }
    getInstalledBrowsers() {
        if (!fs.existsSync(this.#rootDir)) {
            return [];
        }
        const types = fs.readdirSync(this.#rootDir);
        const browsers = types.filter((t) => {
            return Object.values(Browser).includes(t);
        });
        return browsers.flatMap(browser => {
            const files = fs.readdirSync(this.browserRoot(browser));
            return files
                .map(file => {
                const result = parseFolderPath(path$1.join(this.browserRoot(browser), file));
                if (!result) {
                    return null;
                }
                return new InstalledBrowser(this, browser, result.buildId, result.platform);
            })
                .filter((item) => {
                return item !== null;
            });
        });
    }
    computeExecutablePath(options) {
        options.platform ??= detectBrowserPlatform();
        if (!options.platform) {
            throw new Error(`Cannot download a binary for the provided platform: ${os.platform()} (${os.arch()})`);
        }
        try {
            options.buildId =
                this.resolveAlias(options.browser, options.buildId) ?? options.buildId;
        }
        catch {
            debugCache('could not read .metadata file for the browser');
        }
        const installationDir = this.installationDir(options.browser, options.platform, options.buildId);
        return path$1.join(installationDir, executablePathByBrowser[options.browser](options.platform, options.buildId));
    }
}
function parseFolderPath(folderPath) {
    const name = path$1.basename(folderPath);
    const splits = name.split('-');
    if (splits.length !== 2) {
        return;
    }
    const [platform, buildId] = splits;
    if (!buildId || !platform) {
        return;
    }
    return { platform, buildId };
}

/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const debugLaunch = debug$2('puppeteer:browsers:launcher');
function computeExecutablePath(options) {
    if (options.cacheDir === null) {
        options.platform ??= detectBrowserPlatform();
        if (options.platform === undefined) {
            throw new Error(`No platform specified. Couldn't auto-detect browser platform.`);
        }
        return executablePathByBrowser[options.browser](options.platform, options.buildId);
    }
    return new Cache(options.cacheDir).computeExecutablePath(options);
}
function computeSystemExecutablePath(options) {
    options.platform ??= detectBrowserPlatform();
    if (!options.platform) {
        throw new Error(`Cannot download a binary for the provided platform: ${os.platform()} (${os.arch()})`);
    }
    const paths = resolveSystemExecutablePaths(options.browser, options.platform, options.channel);
    for (const path of paths) {
        try {
            accessSync(path);
            return path;
        }
        catch { }
    }
    throw new Error(`Could not find Google Chrome executable for channel '${options.channel}' at:${paths.map(path => {
        return `\n - ${path}`;
    })}.`);
}
function launch$1(opts) {
    return new Process(opts);
}
const CDP_WEBSOCKET_ENDPOINT_REGEX = /^DevTools listening on (ws:\/\/.*)$/;
const WEBDRIVER_BIDI_WEBSOCKET_ENDPOINT_REGEX = /^WebDriver BiDi listening on (ws:\/\/.*)$/;
const processListeners = new Map();
const dispatchers = {
    exit: (...args) => {
        processListeners.get('exit')?.forEach(handler => {
            return handler(...args);
        });
    },
    SIGINT: (...args) => {
        processListeners.get('SIGINT')?.forEach(handler => {
            return handler(...args);
        });
    },
    SIGHUP: (...args) => {
        processListeners.get('SIGHUP')?.forEach(handler => {
            return handler(...args);
        });
    },
    SIGTERM: (...args) => {
        processListeners.get('SIGTERM')?.forEach(handler => {
            return handler(...args);
        });
    },
};
function subscribeToProcessEvent(event, handler) {
    const listeners = processListeners.get(event) || [];
    if (listeners.length === 0) {
        process.on(event, dispatchers[event]);
    }
    listeners.push(handler);
    processListeners.set(event, listeners);
}
function unsubscribeFromProcessEvent(event, handler) {
    const listeners = processListeners.get(event) || [];
    const existingListenerIdx = listeners.indexOf(handler);
    if (existingListenerIdx === -1) {
        return;
    }
    listeners.splice(existingListenerIdx, 1);
    processListeners.set(event, listeners);
    if (listeners.length === 0) {
        process.off(event, dispatchers[event]);
    }
}
class Process {
    #executablePath;
    #args;
    #browserProcess;
    #exited = false;
    #hooksRan = false;
    #onExitHook = async () => { };
    #browserProcessExiting;
    #logs = [];
    #maxLogLinesSize = 1000;
    #lineEmitter = new EventEmitter$1();
    constructor(opts) {
        this.#executablePath = opts.executablePath;
        this.#args = opts.args ?? [];
        opts.pipe ??= false;
        opts.dumpio ??= false;
        opts.handleSIGINT ??= true;
        opts.handleSIGTERM ??= true;
        opts.handleSIGHUP ??= true;
        opts.detached ??= process.platform !== 'win32';
        const stdio = this.#configureStdio({
            pipe: opts.pipe,
        });
        const env = opts.env || {};
        debugLaunch(`Launching ${this.#executablePath} ${this.#args.join(' ')}`, {
            detached: opts.detached,
            env: Object.keys(env).reduce((res, key) => {
                if (key.toLowerCase().startsWith('puppeteer_')) {
                    res[key] = env[key];
                }
                return res;
            }, {}),
            stdio,
        });
        this.#browserProcess = childProcess.spawn(this.#executablePath, this.#args, {
            detached: opts.detached,
            env,
            stdio,
        });
        this.#recordStream(this.#browserProcess.stderr);
        this.#recordStream(this.#browserProcess.stdout);
        debugLaunch(`Launched ${this.#browserProcess.pid}`);
        if (opts.dumpio) {
            this.#browserProcess.stderr?.pipe(process.stderr);
            this.#browserProcess.stdout?.pipe(process.stdout);
        }
        subscribeToProcessEvent('exit', this.#onDriverProcessExit);
        if (opts.handleSIGINT) {
            subscribeToProcessEvent('SIGINT', this.#onDriverProcessSignal);
        }
        if (opts.handleSIGTERM) {
            subscribeToProcessEvent('SIGTERM', this.#onDriverProcessSignal);
        }
        if (opts.handleSIGHUP) {
            subscribeToProcessEvent('SIGHUP', this.#onDriverProcessSignal);
        }
        if (opts.onExit) {
            this.#onExitHook = opts.onExit;
        }
        this.#browserProcessExiting = new Promise((resolve, reject) => {
            this.#browserProcess.once('exit', async () => {
                debugLaunch(`Browser process ${this.#browserProcess.pid} onExit`);
                this.#clearListeners();
                this.#exited = true;
                try {
                    await this.#runHooks();
                }
                catch (err) {
                    reject(err);
                    return;
                }
                resolve();
            });
        });
    }
    async #runHooks() {
        if (this.#hooksRan) {
            return;
        }
        this.#hooksRan = true;
        await this.#onExitHook();
    }
    get nodeProcess() {
        return this.#browserProcess;
    }
    #configureStdio(opts) {
        if (opts.pipe) {
            return ['pipe', 'pipe', 'pipe', 'pipe', 'pipe'];
        }
        else {
            return ['pipe', 'pipe', 'pipe'];
        }
    }
    #clearListeners() {
        unsubscribeFromProcessEvent('exit', this.#onDriverProcessExit);
        unsubscribeFromProcessEvent('SIGINT', this.#onDriverProcessSignal);
        unsubscribeFromProcessEvent('SIGTERM', this.#onDriverProcessSignal);
        unsubscribeFromProcessEvent('SIGHUP', this.#onDriverProcessSignal);
    }
    #onDriverProcessExit = (_code) => {
        this.kill();
    };
    #onDriverProcessSignal = (signal) => {
        switch (signal) {
            case 'SIGINT':
                this.kill();
                process.exit(130);
            case 'SIGTERM':
            case 'SIGHUP':
                void this.close();
                break;
        }
    };
    async close() {
        await this.#runHooks();
        if (!this.#exited) {
            this.kill();
        }
        return await this.#browserProcessExiting;
    }
    hasClosed() {
        return this.#browserProcessExiting;
    }
    kill() {
        debugLaunch(`Trying to kill ${this.#browserProcess.pid}`);
        if (this.#browserProcess &&
            this.#browserProcess.pid &&
            pidExists(this.#browserProcess.pid)) {
            try {
                debugLaunch(`Browser process ${this.#browserProcess.pid} exists`);
                if (process.platform === 'win32') {
                    try {
                        childProcess.execSync(`taskkill /pid ${this.#browserProcess.pid} /T /F`);
                    }
                    catch (error) {
                        debugLaunch(`Killing ${this.#browserProcess.pid} using taskkill failed`, error);
                        this.#browserProcess.kill();
                    }
                }
                else {
                    const processGroupId = -this.#browserProcess.pid;
                    try {
                        process.kill(processGroupId, 'SIGKILL');
                    }
                    catch (error) {
                        debugLaunch(`Killing ${this.#browserProcess.pid} using process.kill failed`, error);
                        this.#browserProcess.kill('SIGKILL');
                    }
                }
            }
            catch (error) {
                throw new Error(`${PROCESS_ERROR_EXPLANATION}\nError cause: ${isErrorLike(error) ? error.stack : error}`);
            }
        }
        this.#clearListeners();
    }
    #recordStream(stream) {
        const rl = readline.createInterface(stream);
        const cleanup = () => {
            rl.off('line', onLine);
            rl.off('close', onClose);
            try {
                rl.close();
            }
            catch { }
        };
        const onLine = (line) => {
            if (line.trim() === '') {
                return;
            }
            this.#logs.push(line);
            const delta = this.#logs.length - this.#maxLogLinesSize;
            if (delta) {
                this.#logs.splice(0, delta);
            }
            this.#lineEmitter.emit('line', line);
        };
        const onClose = () => {
            cleanup();
        };
        rl.on('line', onLine);
        rl.on('close', onClose);
    }
    getRecentLogs() {
        return [...this.#logs];
    }
    waitForLineOutput(regex, timeout = 0) {
        return new Promise((resolve, reject) => {
            const onClose = (errorOrCode) => {
                cleanup();
                reject(new Error([
                    `Failed to launch the browser process: ${errorOrCode instanceof Error
                        ? ` ${errorOrCode.message}`
                        : ` Code: ${errorOrCode}`}`,
                    '',
                    `stderr:`,
                    this.getRecentLogs().join('\n'),
                    '',
                    'TROUBLESHOOTING: https://pptr.dev/troubleshooting',
                    '',
                ].join('\n')));
            };
            this.#browserProcess.on('exit', onClose);
            this.#browserProcess.on('error', onClose);
            const timeoutId = timeout > 0 ? setTimeout(onTimeout, timeout) : undefined;
            this.#lineEmitter.on('line', onLine);
            const cleanup = () => {
                clearTimeout(timeoutId);
                this.#lineEmitter.off('line', onLine);
                this.#browserProcess.off('exit', onClose);
                this.#browserProcess.off('error', onClose);
            };
            function onTimeout() {
                cleanup();
                reject(new TimeoutError(`Timed out after ${timeout} ms while waiting for the WS endpoint URL to appear in stdout!`));
            }
            for (const line of this.#logs) {
                onLine(line);
            }
            function onLine(line) {
                const match = line.match(regex);
                if (!match) {
                    return;
                }
                cleanup();
                resolve(match[1]);
            }
        });
    }
}
const PROCESS_ERROR_EXPLANATION = `Puppeteer was unable to kill the process which ran the browser binary.
This means that, on future Puppeteer launches, Puppeteer might not be able to launch the browser.
Please check your open processes and ensure that the browser processes that Puppeteer launched have been killed.
If you think this is a bug, please report it on the Puppeteer issue tracker.`;
function pidExists(pid) {
    try {
        return process.kill(pid, 0);
    }
    catch (error) {
        if (isErrnoException(error)) {
            if (error.code && error.code === 'ESRCH') {
                return false;
            }
        }
        throw error;
    }
}
function isErrorLike(obj) {
    return (typeof obj === 'object' && obj !== null && 'name' in obj && 'message' in obj);
}
function isErrnoException(obj) {
    return (isErrorLike(obj) &&
        ('errno' in obj || 'code' in obj || 'path' in obj || 'syscall' in obj));
}
class TimeoutError extends Error {
    constructor(message) {
        super(message);
        this.name = this.constructor.name;
        Error.captureStackTrace(this, this.constructor);
    }
}

var nodeProgress = {exports: {}};

/*!
 * node-progress
 * Copyright(c) 2011 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

var hasRequiredNodeProgress;

function requireNodeProgress () {
	if (hasRequiredNodeProgress) return nodeProgress.exports;
	hasRequiredNodeProgress = 1;
	(function (module, exports) {
		module.exports = ProgressBar;
		function ProgressBar(fmt, options) {
		  this.stream = options.stream || process.stderr;
		  if (typeof(options) == 'number') {
		    var total = options;
		    options = {};
		    options.total = total;
		  } else {
		    options = options || {};
		    if ('string' != typeof fmt) throw new Error('format required');
		    if ('number' != typeof options.total) throw new Error('total required');
		  }
		  this.fmt = fmt;
		  this.curr = options.curr || 0;
		  this.total = options.total;
		  this.width = options.width || this.total;
		  this.clear = options.clear;
		  this.chars = {
		    complete   : options.complete || '=',
		    incomplete : options.incomplete || '-',
		    head       : options.head || (options.complete || '=')
		  };
		  this.renderThrottle = options.renderThrottle !== 0 ? (options.renderThrottle || 16) : 0;
		  this.lastRender = -Infinity;
		  this.callback = options.callback || function () {};
		  this.tokens = {};
		  this.lastDraw = '';
		}
		ProgressBar.prototype.tick = function(len, tokens){
		  if (len !== 0)
		    len = len || 1;
		  if ('object' == typeof len) tokens = len, len = 1;
		  if (tokens) this.tokens = tokens;
		  if (0 == this.curr) this.start = new Date;
		  this.curr += len;
		  this.render();
		  if (this.curr >= this.total) {
		    this.render(undefined, true);
		    this.complete = true;
		    this.terminate();
		    this.callback(this);
		    return;
		  }
		};
		ProgressBar.prototype.render = function (tokens, force) {
		  force = force !== undefined ? force : false;
		  if (tokens) this.tokens = tokens;
		  if (!this.stream.isTTY) return;
		  var now = Date.now();
		  var delta = now - this.lastRender;
		  if (!force && (delta < this.renderThrottle)) {
		    return;
		  } else {
		    this.lastRender = now;
		  }
		  var ratio = this.curr / this.total;
		  ratio = Math.min(Math.max(ratio, 0), 1);
		  var percent = Math.floor(ratio * 100);
		  var incomplete, complete, completeLength;
		  var elapsed = new Date - this.start;
		  var eta = (percent == 100) ? 0 : elapsed * (this.total / this.curr - 1);
		  var rate = this.curr / (elapsed / 1000);
		  var str = this.fmt
		    .replace(':current', this.curr)
		    .replace(':total', this.total)
		    .replace(':elapsed', isNaN(elapsed) ? '0.0' : (elapsed / 1000).toFixed(1))
		    .replace(':eta', (isNaN(eta) || !isFinite(eta)) ? '0.0' : (eta / 1000)
		      .toFixed(1))
		    .replace(':percent', percent.toFixed(0) + '%')
		    .replace(':rate', Math.round(rate));
		  var availableSpace = Math.max(0, this.stream.columns - str.replace(':bar', '').length);
		  if(availableSpace && process.platform === 'win32'){
		    availableSpace = availableSpace - 1;
		  }
		  var width = Math.min(this.width, availableSpace);
		  completeLength = Math.round(width * ratio);
		  complete = Array(Math.max(0, completeLength + 1)).join(this.chars.complete);
		  incomplete = Array(Math.max(0, width - completeLength + 1)).join(this.chars.incomplete);
		  if(completeLength > 0)
		    complete = complete.slice(0, -1) + this.chars.head;
		  str = str.replace(':bar', complete + incomplete);
		  if (this.tokens) for (var key in this.tokens) str = str.replace(':' + key, this.tokens[key]);
		  if (this.lastDraw !== str) {
		    this.stream.cursorTo(0);
		    this.stream.write(str);
		    this.stream.clearLine(1);
		    this.lastDraw = str;
		  }
		};
		ProgressBar.prototype.update = function (ratio, tokens) {
		  var goal = Math.floor(ratio * this.total);
		  var delta = goal - this.curr;
		  this.tick(delta, tokens);
		};
		ProgressBar.prototype.interrupt = function (message) {
		  this.stream.clearLine();
		  this.stream.cursorTo(0);
		  this.stream.write(message);
		  this.stream.write('\n');
		  this.stream.write(this.lastDraw);
		};
		ProgressBar.prototype.terminate = function () {
		  if (this.clear) {
		    if (this.stream.clearLine) {
		      this.stream.clearLine();
		      this.stream.cursorTo(0);
		    }
		  } else {
		    this.stream.write('\n');
		  }
		}; 
	} (nodeProgress));
	return nodeProgress.exports;
}

var progress;
var hasRequiredProgress;

function requireProgress () {
	if (hasRequiredProgress) return progress;
	hasRequiredProgress = 1;
	progress = requireNodeProgress();
	return progress;
}

requireProgress();

/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
debug$2('puppeteer:browsers:fileUtil');

/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
debug$2('puppeteer:browsers:install');
async function uninstall(options) {
    options.platform ??= detectBrowserPlatform();
    if (!options.platform) {
        throw new Error(`Cannot detect the browser platform for: ${os.platform()} (${os.arch()})`);
    }
    new Cache(options.cacheDir).uninstall(options.browser, options.platform, options.buildId);
}
async function getInstalledBrowsers(options) {
    return new Cache(options.cacheDir).getInstalledBrowsers();
}

var bufferUtil = {exports: {}};

var constants;
var hasRequiredConstants;

function requireConstants () {
	if (hasRequiredConstants) return constants;
	hasRequiredConstants = 1;
	const BINARY_TYPES = ['nodebuffer', 'arraybuffer', 'fragments'];
	const hasBlob = typeof Blob !== 'undefined';
	if (hasBlob) BINARY_TYPES.push('blob');
	constants = {
	  BINARY_TYPES,
	  EMPTY_BUFFER: Buffer.alloc(0),
	  GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',
	  hasBlob,
	  kForOnEventAttribute: Symbol('kIsForOnEventAttribute'),
	  kListener: Symbol('kListener'),
	  kStatusCode: Symbol('status-code'),
	  kWebSocket: Symbol('websocket'),
	  NOOP: () => {}
	};
	return constants;
}

var hasRequiredBufferUtil;

function requireBufferUtil () {
	if (hasRequiredBufferUtil) return bufferUtil.exports;
	hasRequiredBufferUtil = 1;
	const { EMPTY_BUFFER } = requireConstants();
	const FastBuffer = Buffer[Symbol.species];
	function concat(list, totalLength) {
	  if (list.length === 0) return EMPTY_BUFFER;
	  if (list.length === 1) return list[0];
	  const target = Buffer.allocUnsafe(totalLength);
	  let offset = 0;
	  for (let i = 0; i < list.length; i++) {
	    const buf = list[i];
	    target.set(buf, offset);
	    offset += buf.length;
	  }
	  if (offset < totalLength) {
	    return new FastBuffer(target.buffer, target.byteOffset, offset);
	  }
	  return target;
	}
	function _mask(source, mask, output, offset, length) {
	  for (let i = 0; i < length; i++) {
	    output[offset + i] = source[i] ^ mask[i & 3];
	  }
	}
	function _unmask(buffer, mask) {
	  for (let i = 0; i < buffer.length; i++) {
	    buffer[i] ^= mask[i & 3];
	  }
	}
	function toArrayBuffer(buf) {
	  if (buf.length === buf.buffer.byteLength) {
	    return buf.buffer;
	  }
	  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
	}
	function toBuffer(data) {
	  toBuffer.readOnly = true;
	  if (Buffer.isBuffer(data)) return data;
	  let buf;
	  if (data instanceof ArrayBuffer) {
	    buf = new FastBuffer(data);
	  } else if (ArrayBuffer.isView(data)) {
	    buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);
	  } else {
	    buf = Buffer.from(data);
	    toBuffer.readOnly = false;
	  }
	  return buf;
	}
	bufferUtil.exports = {
	  concat,
	  mask: _mask,
	  toArrayBuffer,
	  toBuffer,
	  unmask: _unmask
	};
	if (!process.env.WS_NO_BUFFER_UTIL) {
	  try {
	    const bufferUtil$1 = require('bufferutil');
	    bufferUtil.exports.mask = function (source, mask, output, offset, length) {
	      if (length < 48) _mask(source, mask, output, offset, length);
	      else bufferUtil$1.mask(source, mask, output, offset, length);
	    };
	    bufferUtil.exports.unmask = function (buffer, mask) {
	      if (buffer.length < 32) _unmask(buffer, mask);
	      else bufferUtil$1.unmask(buffer, mask);
	    };
	  } catch (e) {
	  }
	}
	return bufferUtil.exports;
}

var limiter;
var hasRequiredLimiter;

function requireLimiter () {
	if (hasRequiredLimiter) return limiter;
	hasRequiredLimiter = 1;
	const kDone = Symbol('kDone');
	const kRun = Symbol('kRun');
	class Limiter {
	  constructor(concurrency) {
	    this[kDone] = () => {
	      this.pending--;
	      this[kRun]();
	    };
	    this.concurrency = concurrency || Infinity;
	    this.jobs = [];
	    this.pending = 0;
	  }
	  add(job) {
	    this.jobs.push(job);
	    this[kRun]();
	  }
	  [kRun]() {
	    if (this.pending === this.concurrency) return;
	    if (this.jobs.length) {
	      const job = this.jobs.shift();
	      this.pending++;
	      job(this[kDone]);
	    }
	  }
	}
	limiter = Limiter;
	return limiter;
}

var permessageDeflate;
var hasRequiredPermessageDeflate;

function requirePermessageDeflate () {
	if (hasRequiredPermessageDeflate) return permessageDeflate;
	hasRequiredPermessageDeflate = 1;
	const zlib = require$$0$8;
	const bufferUtil = requireBufferUtil();
	const Limiter = requireLimiter();
	const { kStatusCode } = requireConstants();
	const FastBuffer = Buffer[Symbol.species];
	const TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);
	const kPerMessageDeflate = Symbol('permessage-deflate');
	const kTotalLength = Symbol('total-length');
	const kCallback = Symbol('callback');
	const kBuffers = Symbol('buffers');
	const kError = Symbol('error');
	let zlibLimiter;
	class PerMessageDeflate {
	  constructor(options, isServer, maxPayload) {
	    this._maxPayload = maxPayload | 0;
	    this._options = options || {};
	    this._threshold =
	      this._options.threshold !== undefined ? this._options.threshold : 1024;
	    this._isServer = !!isServer;
	    this._deflate = null;
	    this._inflate = null;
	    this.params = null;
	    if (!zlibLimiter) {
	      const concurrency =
	        this._options.concurrencyLimit !== undefined
	          ? this._options.concurrencyLimit
	          : 10;
	      zlibLimiter = new Limiter(concurrency);
	    }
	  }
	  static get extensionName() {
	    return 'permessage-deflate';
	  }
	  offer() {
	    const params = {};
	    if (this._options.serverNoContextTakeover) {
	      params.server_no_context_takeover = true;
	    }
	    if (this._options.clientNoContextTakeover) {
	      params.client_no_context_takeover = true;
	    }
	    if (this._options.serverMaxWindowBits) {
	      params.server_max_window_bits = this._options.serverMaxWindowBits;
	    }
	    if (this._options.clientMaxWindowBits) {
	      params.client_max_window_bits = this._options.clientMaxWindowBits;
	    } else if (this._options.clientMaxWindowBits == null) {
	      params.client_max_window_bits = true;
	    }
	    return params;
	  }
	  accept(configurations) {
	    configurations = this.normalizeParams(configurations);
	    this.params = this._isServer
	      ? this.acceptAsServer(configurations)
	      : this.acceptAsClient(configurations);
	    return this.params;
	  }
	  cleanup() {
	    if (this._inflate) {
	      this._inflate.close();
	      this._inflate = null;
	    }
	    if (this._deflate) {
	      const callback = this._deflate[kCallback];
	      this._deflate.close();
	      this._deflate = null;
	      if (callback) {
	        callback(
	          new Error(
	            'The deflate stream was closed while data was being processed'
	          )
	        );
	      }
	    }
	  }
	  acceptAsServer(offers) {
	    const opts = this._options;
	    const accepted = offers.find((params) => {
	      if (
	        (opts.serverNoContextTakeover === false &&
	          params.server_no_context_takeover) ||
	        (params.server_max_window_bits &&
	          (opts.serverMaxWindowBits === false ||
	            (typeof opts.serverMaxWindowBits === 'number' &&
	              opts.serverMaxWindowBits > params.server_max_window_bits))) ||
	        (typeof opts.clientMaxWindowBits === 'number' &&
	          !params.client_max_window_bits)
	      ) {
	        return false;
	      }
	      return true;
	    });
	    if (!accepted) {
	      throw new Error('None of the extension offers can be accepted');
	    }
	    if (opts.serverNoContextTakeover) {
	      accepted.server_no_context_takeover = true;
	    }
	    if (opts.clientNoContextTakeover) {
	      accepted.client_no_context_takeover = true;
	    }
	    if (typeof opts.serverMaxWindowBits === 'number') {
	      accepted.server_max_window_bits = opts.serverMaxWindowBits;
	    }
	    if (typeof opts.clientMaxWindowBits === 'number') {
	      accepted.client_max_window_bits = opts.clientMaxWindowBits;
	    } else if (
	      accepted.client_max_window_bits === true ||
	      opts.clientMaxWindowBits === false
	    ) {
	      delete accepted.client_max_window_bits;
	    }
	    return accepted;
	  }
	  acceptAsClient(response) {
	    const params = response[0];
	    if (
	      this._options.clientNoContextTakeover === false &&
	      params.client_no_context_takeover
	    ) {
	      throw new Error('Unexpected parameter "client_no_context_takeover"');
	    }
	    if (!params.client_max_window_bits) {
	      if (typeof this._options.clientMaxWindowBits === 'number') {
	        params.client_max_window_bits = this._options.clientMaxWindowBits;
	      }
	    } else if (
	      this._options.clientMaxWindowBits === false ||
	      (typeof this._options.clientMaxWindowBits === 'number' &&
	        params.client_max_window_bits > this._options.clientMaxWindowBits)
	    ) {
	      throw new Error(
	        'Unexpected or invalid parameter "client_max_window_bits"'
	      );
	    }
	    return params;
	  }
	  normalizeParams(configurations) {
	    configurations.forEach((params) => {
	      Object.keys(params).forEach((key) => {
	        let value = params[key];
	        if (value.length > 1) {
	          throw new Error(`Parameter "${key}" must have only a single value`);
	        }
	        value = value[0];
	        if (key === 'client_max_window_bits') {
	          if (value !== true) {
	            const num = +value;
	            if (!Number.isInteger(num) || num < 8 || num > 15) {
	              throw new TypeError(
	                `Invalid value for parameter "${key}": ${value}`
	              );
	            }
	            value = num;
	          } else if (!this._isServer) {
	            throw new TypeError(
	              `Invalid value for parameter "${key}": ${value}`
	            );
	          }
	        } else if (key === 'server_max_window_bits') {
	          const num = +value;
	          if (!Number.isInteger(num) || num < 8 || num > 15) {
	            throw new TypeError(
	              `Invalid value for parameter "${key}": ${value}`
	            );
	          }
	          value = num;
	        } else if (
	          key === 'client_no_context_takeover' ||
	          key === 'server_no_context_takeover'
	        ) {
	          if (value !== true) {
	            throw new TypeError(
	              `Invalid value for parameter "${key}": ${value}`
	            );
	          }
	        } else {
	          throw new Error(`Unknown parameter "${key}"`);
	        }
	        params[key] = value;
	      });
	    });
	    return configurations;
	  }
	  decompress(data, fin, callback) {
	    zlibLimiter.add((done) => {
	      this._decompress(data, fin, (err, result) => {
	        done();
	        callback(err, result);
	      });
	    });
	  }
	  compress(data, fin, callback) {
	    zlibLimiter.add((done) => {
	      this._compress(data, fin, (err, result) => {
	        done();
	        callback(err, result);
	      });
	    });
	  }
	  _decompress(data, fin, callback) {
	    const endpoint = this._isServer ? 'client' : 'server';
	    if (!this._inflate) {
	      const key = `${endpoint}_max_window_bits`;
	      const windowBits =
	        typeof this.params[key] !== 'number'
	          ? zlib.Z_DEFAULT_WINDOWBITS
	          : this.params[key];
	      this._inflate = zlib.createInflateRaw({
	        ...this._options.zlibInflateOptions,
	        windowBits
	      });
	      this._inflate[kPerMessageDeflate] = this;
	      this._inflate[kTotalLength] = 0;
	      this._inflate[kBuffers] = [];
	      this._inflate.on('error', inflateOnError);
	      this._inflate.on('data', inflateOnData);
	    }
	    this._inflate[kCallback] = callback;
	    this._inflate.write(data);
	    if (fin) this._inflate.write(TRAILER);
	    this._inflate.flush(() => {
	      const err = this._inflate[kError];
	      if (err) {
	        this._inflate.close();
	        this._inflate = null;
	        callback(err);
	        return;
	      }
	      const data = bufferUtil.concat(
	        this._inflate[kBuffers],
	        this._inflate[kTotalLength]
	      );
	      if (this._inflate._readableState.endEmitted) {
	        this._inflate.close();
	        this._inflate = null;
	      } else {
	        this._inflate[kTotalLength] = 0;
	        this._inflate[kBuffers] = [];
	        if (fin && this.params[`${endpoint}_no_context_takeover`]) {
	          this._inflate.reset();
	        }
	      }
	      callback(null, data);
	    });
	  }
	  _compress(data, fin, callback) {
	    const endpoint = this._isServer ? 'server' : 'client';
	    if (!this._deflate) {
	      const key = `${endpoint}_max_window_bits`;
	      const windowBits =
	        typeof this.params[key] !== 'number'
	          ? zlib.Z_DEFAULT_WINDOWBITS
	          : this.params[key];
	      this._deflate = zlib.createDeflateRaw({
	        ...this._options.zlibDeflateOptions,
	        windowBits
	      });
	      this._deflate[kTotalLength] = 0;
	      this._deflate[kBuffers] = [];
	      this._deflate.on('data', deflateOnData);
	    }
	    this._deflate[kCallback] = callback;
	    this._deflate.write(data);
	    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
	      if (!this._deflate) {
	        return;
	      }
	      let data = bufferUtil.concat(
	        this._deflate[kBuffers],
	        this._deflate[kTotalLength]
	      );
	      if (fin) {
	        data = new FastBuffer(data.buffer, data.byteOffset, data.length - 4);
	      }
	      this._deflate[kCallback] = null;
	      this._deflate[kTotalLength] = 0;
	      this._deflate[kBuffers] = [];
	      if (fin && this.params[`${endpoint}_no_context_takeover`]) {
	        this._deflate.reset();
	      }
	      callback(null, data);
	    });
	  }
	}
	permessageDeflate = PerMessageDeflate;
	function deflateOnData(chunk) {
	  this[kBuffers].push(chunk);
	  this[kTotalLength] += chunk.length;
	}
	function inflateOnData(chunk) {
	  this[kTotalLength] += chunk.length;
	  if (
	    this[kPerMessageDeflate]._maxPayload < 1 ||
	    this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload
	  ) {
	    this[kBuffers].push(chunk);
	    return;
	  }
	  this[kError] = new RangeError('Max payload size exceeded');
	  this[kError].code = 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH';
	  this[kError][kStatusCode] = 1009;
	  this.removeListener('data', inflateOnData);
	  this.reset();
	}
	function inflateOnError(err) {
	  this[kPerMessageDeflate]._inflate = null;
	  if (this[kError]) {
	    this[kCallback](this[kError]);
	    return;
	  }
	  err[kStatusCode] = 1007;
	  this[kCallback](err);
	}
	return permessageDeflate;
}

var validation = {exports: {}};

var hasRequiredValidation;

function requireValidation () {
	if (hasRequiredValidation) return validation.exports;
	hasRequiredValidation = 1;
	const { isUtf8 } = require$$0$6;
	const { hasBlob } = requireConstants();
	const tokenChars = [
	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0,
	  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,
	  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1,
	  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0
	];
	function isValidStatusCode(code) {
	  return (
	    (code >= 1000 &&
	      code <= 1014 &&
	      code !== 1004 &&
	      code !== 1005 &&
	      code !== 1006) ||
	    (code >= 3000 && code <= 4999)
	  );
	}
	function _isValidUTF8(buf) {
	  const len = buf.length;
	  let i = 0;
	  while (i < len) {
	    if ((buf[i] & 0x80) === 0) {
	      i++;
	    } else if ((buf[i] & 0xe0) === 0xc0) {
	      if (
	        i + 1 === len ||
	        (buf[i + 1] & 0xc0) !== 0x80 ||
	        (buf[i] & 0xfe) === 0xc0
	      ) {
	        return false;
	      }
	      i += 2;
	    } else if ((buf[i] & 0xf0) === 0xe0) {
	      if (
	        i + 2 >= len ||
	        (buf[i + 1] & 0xc0) !== 0x80 ||
	        (buf[i + 2] & 0xc0) !== 0x80 ||
	        (buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80) ||
	        (buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0)
	      ) {
	        return false;
	      }
	      i += 3;
	    } else if ((buf[i] & 0xf8) === 0xf0) {
	      if (
	        i + 3 >= len ||
	        (buf[i + 1] & 0xc0) !== 0x80 ||
	        (buf[i + 2] & 0xc0) !== 0x80 ||
	        (buf[i + 3] & 0xc0) !== 0x80 ||
	        (buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80) ||
	        (buf[i] === 0xf4 && buf[i + 1] > 0x8f) ||
	        buf[i] > 0xf4
	      ) {
	        return false;
	      }
	      i += 4;
	    } else {
	      return false;
	    }
	  }
	  return true;
	}
	function isBlob(value) {
	  return (
	    hasBlob &&
	    typeof value === 'object' &&
	    typeof value.arrayBuffer === 'function' &&
	    typeof value.type === 'string' &&
	    typeof value.stream === 'function' &&
	    (value[Symbol.toStringTag] === 'Blob' ||
	      value[Symbol.toStringTag] === 'File')
	  );
	}
	validation.exports = {
	  isBlob,
	  isValidStatusCode,
	  isValidUTF8: _isValidUTF8,
	  tokenChars
	};
	if (isUtf8) {
	  validation.exports.isValidUTF8 = function (buf) {
	    return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
	  };
	}  else if (!process.env.WS_NO_UTF_8_VALIDATE) {
	  try {
	    const isValidUTF8 = require('utf-8-validate');
	    validation.exports.isValidUTF8 = function (buf) {
	      return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);
	    };
	  } catch (e) {
	  }
	}
	return validation.exports;
}

var receiver;
var hasRequiredReceiver;

function requireReceiver () {
	if (hasRequiredReceiver) return receiver;
	hasRequiredReceiver = 1;
	const { Writable } = require$$1$3;
	const PerMessageDeflate = requirePermessageDeflate();
	const {
	  BINARY_TYPES,
	  EMPTY_BUFFER,
	  kStatusCode,
	  kWebSocket
	} = requireConstants();
	const { concat, toArrayBuffer, unmask } = requireBufferUtil();
	const { isValidStatusCode, isValidUTF8 } = requireValidation();
	const FastBuffer = Buffer[Symbol.species];
	const GET_INFO = 0;
	const GET_PAYLOAD_LENGTH_16 = 1;
	const GET_PAYLOAD_LENGTH_64 = 2;
	const GET_MASK = 3;
	const GET_DATA = 4;
	const INFLATING = 5;
	const DEFER_EVENT = 6;
	class Receiver extends Writable {
	  constructor(options = {}) {
	    super();
	    this._allowSynchronousEvents =
	      options.allowSynchronousEvents !== undefined
	        ? options.allowSynchronousEvents
	        : true;
	    this._binaryType = options.binaryType || BINARY_TYPES[0];
	    this._extensions = options.extensions || {};
	    this._isServer = !!options.isServer;
	    this._maxPayload = options.maxPayload | 0;
	    this._skipUTF8Validation = !!options.skipUTF8Validation;
	    this[kWebSocket] = undefined;
	    this._bufferedBytes = 0;
	    this._buffers = [];
	    this._compressed = false;
	    this._payloadLength = 0;
	    this._mask = undefined;
	    this._fragmented = 0;
	    this._masked = false;
	    this._fin = false;
	    this._opcode = 0;
	    this._totalPayloadLength = 0;
	    this._messageLength = 0;
	    this._fragments = [];
	    this._errored = false;
	    this._loop = false;
	    this._state = GET_INFO;
	  }
	  _write(chunk, encoding, cb) {
	    if (this._opcode === 0x08 && this._state == GET_INFO) return cb();
	    this._bufferedBytes += chunk.length;
	    this._buffers.push(chunk);
	    this.startLoop(cb);
	  }
	  consume(n) {
	    this._bufferedBytes -= n;
	    if (n === this._buffers[0].length) return this._buffers.shift();
	    if (n < this._buffers[0].length) {
	      const buf = this._buffers[0];
	      this._buffers[0] = new FastBuffer(
	        buf.buffer,
	        buf.byteOffset + n,
	        buf.length - n
	      );
	      return new FastBuffer(buf.buffer, buf.byteOffset, n);
	    }
	    const dst = Buffer.allocUnsafe(n);
	    do {
	      const buf = this._buffers[0];
	      const offset = dst.length - n;
	      if (n >= buf.length) {
	        dst.set(this._buffers.shift(), offset);
	      } else {
	        dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
	        this._buffers[0] = new FastBuffer(
	          buf.buffer,
	          buf.byteOffset + n,
	          buf.length - n
	        );
	      }
	      n -= buf.length;
	    } while (n > 0);
	    return dst;
	  }
	  startLoop(cb) {
	    this._loop = true;
	    do {
	      switch (this._state) {
	        case GET_INFO:
	          this.getInfo(cb);
	          break;
	        case GET_PAYLOAD_LENGTH_16:
	          this.getPayloadLength16(cb);
	          break;
	        case GET_PAYLOAD_LENGTH_64:
	          this.getPayloadLength64(cb);
	          break;
	        case GET_MASK:
	          this.getMask();
	          break;
	        case GET_DATA:
	          this.getData(cb);
	          break;
	        case INFLATING:
	        case DEFER_EVENT:
	          this._loop = false;
	          return;
	      }
	    } while (this._loop);
	    if (!this._errored) cb();
	  }
	  getInfo(cb) {
	    if (this._bufferedBytes < 2) {
	      this._loop = false;
	      return;
	    }
	    const buf = this.consume(2);
	    if ((buf[0] & 0x30) !== 0x00) {
	      const error = this.createError(
	        RangeError,
	        'RSV2 and RSV3 must be clear',
	        true,
	        1002,
	        'WS_ERR_UNEXPECTED_RSV_2_3'
	      );
	      cb(error);
	      return;
	    }
	    const compressed = (buf[0] & 0x40) === 0x40;
	    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
	      const error = this.createError(
	        RangeError,
	        'RSV1 must be clear',
	        true,
	        1002,
	        'WS_ERR_UNEXPECTED_RSV_1'
	      );
	      cb(error);
	      return;
	    }
	    this._fin = (buf[0] & 0x80) === 0x80;
	    this._opcode = buf[0] & 0x0f;
	    this._payloadLength = buf[1] & 0x7f;
	    if (this._opcode === 0x00) {
	      if (compressed) {
	        const error = this.createError(
	          RangeError,
	          'RSV1 must be clear',
	          true,
	          1002,
	          'WS_ERR_UNEXPECTED_RSV_1'
	        );
	        cb(error);
	        return;
	      }
	      if (!this._fragmented) {
	        const error = this.createError(
	          RangeError,
	          'invalid opcode 0',
	          true,
	          1002,
	          'WS_ERR_INVALID_OPCODE'
	        );
	        cb(error);
	        return;
	      }
	      this._opcode = this._fragmented;
	    } else if (this._opcode === 0x01 || this._opcode === 0x02) {
	      if (this._fragmented) {
	        const error = this.createError(
	          RangeError,
	          `invalid opcode ${this._opcode}`,
	          true,
	          1002,
	          'WS_ERR_INVALID_OPCODE'
	        );
	        cb(error);
	        return;
	      }
	      this._compressed = compressed;
	    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {
	      if (!this._fin) {
	        const error = this.createError(
	          RangeError,
	          'FIN must be set',
	          true,
	          1002,
	          'WS_ERR_EXPECTED_FIN'
	        );
	        cb(error);
	        return;
	      }
	      if (compressed) {
	        const error = this.createError(
	          RangeError,
	          'RSV1 must be clear',
	          true,
	          1002,
	          'WS_ERR_UNEXPECTED_RSV_1'
	        );
	        cb(error);
	        return;
	      }
	      if (
	        this._payloadLength > 0x7d ||
	        (this._opcode === 0x08 && this._payloadLength === 1)
	      ) {
	        const error = this.createError(
	          RangeError,
	          `invalid payload length ${this._payloadLength}`,
	          true,
	          1002,
	          'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH'
	        );
	        cb(error);
	        return;
	      }
	    } else {
	      const error = this.createError(
	        RangeError,
	        `invalid opcode ${this._opcode}`,
	        true,
	        1002,
	        'WS_ERR_INVALID_OPCODE'
	      );
	      cb(error);
	      return;
	    }
	    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
	    this._masked = (buf[1] & 0x80) === 0x80;
	    if (this._isServer) {
	      if (!this._masked) {
	        const error = this.createError(
	          RangeError,
	          'MASK must be set',
	          true,
	          1002,
	          'WS_ERR_EXPECTED_MASK'
	        );
	        cb(error);
	        return;
	      }
	    } else if (this._masked) {
	      const error = this.createError(
	        RangeError,
	        'MASK must be clear',
	        true,
	        1002,
	        'WS_ERR_UNEXPECTED_MASK'
	      );
	      cb(error);
	      return;
	    }
	    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;
	    else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;
	    else this.haveLength(cb);
	  }
	  getPayloadLength16(cb) {
	    if (this._bufferedBytes < 2) {
	      this._loop = false;
	      return;
	    }
	    this._payloadLength = this.consume(2).readUInt16BE(0);
	    this.haveLength(cb);
	  }
	  getPayloadLength64(cb) {
	    if (this._bufferedBytes < 8) {
	      this._loop = false;
	      return;
	    }
	    const buf = this.consume(8);
	    const num = buf.readUInt32BE(0);
	    if (num > Math.pow(2, 53 - 32) - 1) {
	      const error = this.createError(
	        RangeError,
	        'Unsupported WebSocket frame: payload length > 2^53 - 1',
	        false,
	        1009,
	        'WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH'
	      );
	      cb(error);
	      return;
	    }
	    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
	    this.haveLength(cb);
	  }
	  haveLength(cb) {
	    if (this._payloadLength && this._opcode < 0x08) {
	      this._totalPayloadLength += this._payloadLength;
	      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
	        const error = this.createError(
	          RangeError,
	          'Max payload size exceeded',
	          false,
	          1009,
	          'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'
	        );
	        cb(error);
	        return;
	      }
	    }
	    if (this._masked) this._state = GET_MASK;
	    else this._state = GET_DATA;
	  }
	  getMask() {
	    if (this._bufferedBytes < 4) {
	      this._loop = false;
	      return;
	    }
	    this._mask = this.consume(4);
	    this._state = GET_DATA;
	  }
	  getData(cb) {
	    let data = EMPTY_BUFFER;
	    if (this._payloadLength) {
	      if (this._bufferedBytes < this._payloadLength) {
	        this._loop = false;
	        return;
	      }
	      data = this.consume(this._payloadLength);
	      if (
	        this._masked &&
	        (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0
	      ) {
	        unmask(data, this._mask);
	      }
	    }
	    if (this._opcode > 0x07) {
	      this.controlMessage(data, cb);
	      return;
	    }
	    if (this._compressed) {
	      this._state = INFLATING;
	      this.decompress(data, cb);
	      return;
	    }
	    if (data.length) {
	      this._messageLength = this._totalPayloadLength;
	      this._fragments.push(data);
	    }
	    this.dataMessage(cb);
	  }
	  decompress(data, cb) {
	    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
	    perMessageDeflate.decompress(data, this._fin, (err, buf) => {
	      if (err) return cb(err);
	      if (buf.length) {
	        this._messageLength += buf.length;
	        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
	          const error = this.createError(
	            RangeError,
	            'Max payload size exceeded',
	            false,
	            1009,
	            'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'
	          );
	          cb(error);
	          return;
	        }
	        this._fragments.push(buf);
	      }
	      this.dataMessage(cb);
	      if (this._state === GET_INFO) this.startLoop(cb);
	    });
	  }
	  dataMessage(cb) {
	    if (!this._fin) {
	      this._state = GET_INFO;
	      return;
	    }
	    const messageLength = this._messageLength;
	    const fragments = this._fragments;
	    this._totalPayloadLength = 0;
	    this._messageLength = 0;
	    this._fragmented = 0;
	    this._fragments = [];
	    if (this._opcode === 2) {
	      let data;
	      if (this._binaryType === 'nodebuffer') {
	        data = concat(fragments, messageLength);
	      } else if (this._binaryType === 'arraybuffer') {
	        data = toArrayBuffer(concat(fragments, messageLength));
	      } else if (this._binaryType === 'blob') {
	        data = new Blob(fragments);
	      } else {
	        data = fragments;
	      }
	      if (this._allowSynchronousEvents) {
	        this.emit('message', data, true);
	        this._state = GET_INFO;
	      } else {
	        this._state = DEFER_EVENT;
	        setImmediate(() => {
	          this.emit('message', data, true);
	          this._state = GET_INFO;
	          this.startLoop(cb);
	        });
	      }
	    } else {
	      const buf = concat(fragments, messageLength);
	      if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
	        const error = this.createError(
	          Error,
	          'invalid UTF-8 sequence',
	          true,
	          1007,
	          'WS_ERR_INVALID_UTF8'
	        );
	        cb(error);
	        return;
	      }
	      if (this._state === INFLATING || this._allowSynchronousEvents) {
	        this.emit('message', buf, false);
	        this._state = GET_INFO;
	      } else {
	        this._state = DEFER_EVENT;
	        setImmediate(() => {
	          this.emit('message', buf, false);
	          this._state = GET_INFO;
	          this.startLoop(cb);
	        });
	      }
	    }
	  }
	  controlMessage(data, cb) {
	    if (this._opcode === 0x08) {
	      if (data.length === 0) {
	        this._loop = false;
	        this.emit('conclude', 1005, EMPTY_BUFFER);
	        this.end();
	      } else {
	        const code = data.readUInt16BE(0);
	        if (!isValidStatusCode(code)) {
	          const error = this.createError(
	            RangeError,
	            `invalid status code ${code}`,
	            true,
	            1002,
	            'WS_ERR_INVALID_CLOSE_CODE'
	          );
	          cb(error);
	          return;
	        }
	        const buf = new FastBuffer(
	          data.buffer,
	          data.byteOffset + 2,
	          data.length - 2
	        );
	        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
	          const error = this.createError(
	            Error,
	            'invalid UTF-8 sequence',
	            true,
	            1007,
	            'WS_ERR_INVALID_UTF8'
	          );
	          cb(error);
	          return;
	        }
	        this._loop = false;
	        this.emit('conclude', code, buf);
	        this.end();
	      }
	      this._state = GET_INFO;
	      return;
	    }
	    if (this._allowSynchronousEvents) {
	      this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);
	      this._state = GET_INFO;
	    } else {
	      this._state = DEFER_EVENT;
	      setImmediate(() => {
	        this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);
	        this._state = GET_INFO;
	        this.startLoop(cb);
	      });
	    }
	  }
	  createError(ErrorCtor, message, prefix, statusCode, errorCode) {
	    this._loop = false;
	    this._errored = true;
	    const err = new ErrorCtor(
	      prefix ? `Invalid WebSocket frame: ${message}` : message
	    );
	    Error.captureStackTrace(err, this.createError);
	    err.code = errorCode;
	    err[kStatusCode] = statusCode;
	    return err;
	  }
	}
	receiver = Receiver;
	return receiver;
}

var sender;
var hasRequiredSender;

function requireSender () {
	if (hasRequiredSender) return sender;
	hasRequiredSender = 1;
	const { Duplex } = require$$1$3;
	const { randomFillSync } = require$$2$1;
	const PerMessageDeflate = requirePermessageDeflate();
	const { EMPTY_BUFFER, kWebSocket, NOOP } = requireConstants();
	const { isBlob, isValidStatusCode } = requireValidation();
	const { mask: applyMask, toBuffer } = requireBufferUtil();
	const kByteLength = Symbol('kByteLength');
	const maskBuffer = Buffer.alloc(4);
	const RANDOM_POOL_SIZE = 8 * 1024;
	let randomPool;
	let randomPoolPointer = RANDOM_POOL_SIZE;
	const DEFAULT = 0;
	const DEFLATING = 1;
	const GET_BLOB_DATA = 2;
	class Sender {
	  constructor(socket, extensions, generateMask) {
	    this._extensions = extensions || {};
	    if (generateMask) {
	      this._generateMask = generateMask;
	      this._maskBuffer = Buffer.alloc(4);
	    }
	    this._socket = socket;
	    this._firstFragment = true;
	    this._compress = false;
	    this._bufferedBytes = 0;
	    this._queue = [];
	    this._state = DEFAULT;
	    this.onerror = NOOP;
	    this[kWebSocket] = undefined;
	  }
	  static frame(data, options) {
	    let mask;
	    let merge = false;
	    let offset = 2;
	    let skipMasking = false;
	    if (options.mask) {
	      mask = options.maskBuffer || maskBuffer;
	      if (options.generateMask) {
	        options.generateMask(mask);
	      } else {
	        if (randomPoolPointer === RANDOM_POOL_SIZE) {
	          if (randomPool === undefined) {
	            randomPool = Buffer.alloc(RANDOM_POOL_SIZE);
	          }
	          randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);
	          randomPoolPointer = 0;
	        }
	        mask[0] = randomPool[randomPoolPointer++];
	        mask[1] = randomPool[randomPoolPointer++];
	        mask[2] = randomPool[randomPoolPointer++];
	        mask[3] = randomPool[randomPoolPointer++];
	      }
	      skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
	      offset = 6;
	    }
	    let dataLength;
	    if (typeof data === 'string') {
	      if (
	        (!options.mask || skipMasking) &&
	        options[kByteLength] !== undefined
	      ) {
	        dataLength = options[kByteLength];
	      } else {
	        data = Buffer.from(data);
	        dataLength = data.length;
	      }
	    } else {
	      dataLength = data.length;
	      merge = options.mask && options.readOnly && !skipMasking;
	    }
	    let payloadLength = dataLength;
	    if (dataLength >= 65536) {
	      offset += 8;
	      payloadLength = 127;
	    } else if (dataLength > 125) {
	      offset += 2;
	      payloadLength = 126;
	    }
	    const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);
	    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;
	    if (options.rsv1) target[0] |= 0x40;
	    target[1] = payloadLength;
	    if (payloadLength === 126) {
	      target.writeUInt16BE(dataLength, 2);
	    } else if (payloadLength === 127) {
	      target[2] = target[3] = 0;
	      target.writeUIntBE(dataLength, 4, 6);
	    }
	    if (!options.mask) return [target, data];
	    target[1] |= 0x80;
	    target[offset - 4] = mask[0];
	    target[offset - 3] = mask[1];
	    target[offset - 2] = mask[2];
	    target[offset - 1] = mask[3];
	    if (skipMasking) return [target, data];
	    if (merge) {
	      applyMask(data, mask, target, offset, dataLength);
	      return [target];
	    }
	    applyMask(data, mask, data, 0, dataLength);
	    return [target, data];
	  }
	  close(code, data, mask, cb) {
	    let buf;
	    if (code === undefined) {
	      buf = EMPTY_BUFFER;
	    } else if (typeof code !== 'number' || !isValidStatusCode(code)) {
	      throw new TypeError('First argument must be a valid error code number');
	    } else if (data === undefined || !data.length) {
	      buf = Buffer.allocUnsafe(2);
	      buf.writeUInt16BE(code, 0);
	    } else {
	      const length = Buffer.byteLength(data);
	      if (length > 123) {
	        throw new RangeError('The message must not be greater than 123 bytes');
	      }
	      buf = Buffer.allocUnsafe(2 + length);
	      buf.writeUInt16BE(code, 0);
	      if (typeof data === 'string') {
	        buf.write(data, 2);
	      } else {
	        buf.set(data, 2);
	      }
	    }
	    const options = {
	      [kByteLength]: buf.length,
	      fin: true,
	      generateMask: this._generateMask,
	      mask,
	      maskBuffer: this._maskBuffer,
	      opcode: 0x08,
	      readOnly: false,
	      rsv1: false
	    };
	    if (this._state !== DEFAULT) {
	      this.enqueue([this.dispatch, buf, false, options, cb]);
	    } else {
	      this.sendFrame(Sender.frame(buf, options), cb);
	    }
	  }
	  ping(data, mask, cb) {
	    let byteLength;
	    let readOnly;
	    if (typeof data === 'string') {
	      byteLength = Buffer.byteLength(data);
	      readOnly = false;
	    } else if (isBlob(data)) {
	      byteLength = data.size;
	      readOnly = false;
	    } else {
	      data = toBuffer(data);
	      byteLength = data.length;
	      readOnly = toBuffer.readOnly;
	    }
	    if (byteLength > 125) {
	      throw new RangeError('The data size must not be greater than 125 bytes');
	    }
	    const options = {
	      [kByteLength]: byteLength,
	      fin: true,
	      generateMask: this._generateMask,
	      mask,
	      maskBuffer: this._maskBuffer,
	      opcode: 0x09,
	      readOnly,
	      rsv1: false
	    };
	    if (isBlob(data)) {
	      if (this._state !== DEFAULT) {
	        this.enqueue([this.getBlobData, data, false, options, cb]);
	      } else {
	        this.getBlobData(data, false, options, cb);
	      }
	    } else if (this._state !== DEFAULT) {
	      this.enqueue([this.dispatch, data, false, options, cb]);
	    } else {
	      this.sendFrame(Sender.frame(data, options), cb);
	    }
	  }
	  pong(data, mask, cb) {
	    let byteLength;
	    let readOnly;
	    if (typeof data === 'string') {
	      byteLength = Buffer.byteLength(data);
	      readOnly = false;
	    } else if (isBlob(data)) {
	      byteLength = data.size;
	      readOnly = false;
	    } else {
	      data = toBuffer(data);
	      byteLength = data.length;
	      readOnly = toBuffer.readOnly;
	    }
	    if (byteLength > 125) {
	      throw new RangeError('The data size must not be greater than 125 bytes');
	    }
	    const options = {
	      [kByteLength]: byteLength,
	      fin: true,
	      generateMask: this._generateMask,
	      mask,
	      maskBuffer: this._maskBuffer,
	      opcode: 0x0a,
	      readOnly,
	      rsv1: false
	    };
	    if (isBlob(data)) {
	      if (this._state !== DEFAULT) {
	        this.enqueue([this.getBlobData, data, false, options, cb]);
	      } else {
	        this.getBlobData(data, false, options, cb);
	      }
	    } else if (this._state !== DEFAULT) {
	      this.enqueue([this.dispatch, data, false, options, cb]);
	    } else {
	      this.sendFrame(Sender.frame(data, options), cb);
	    }
	  }
	  send(data, options, cb) {
	    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
	    let opcode = options.binary ? 2 : 1;
	    let rsv1 = options.compress;
	    let byteLength;
	    let readOnly;
	    if (typeof data === 'string') {
	      byteLength = Buffer.byteLength(data);
	      readOnly = false;
	    } else if (isBlob(data)) {
	      byteLength = data.size;
	      readOnly = false;
	    } else {
	      data = toBuffer(data);
	      byteLength = data.length;
	      readOnly = toBuffer.readOnly;
	    }
	    if (this._firstFragment) {
	      this._firstFragment = false;
	      if (
	        rsv1 &&
	        perMessageDeflate &&
	        perMessageDeflate.params[
	          perMessageDeflate._isServer
	            ? 'server_no_context_takeover'
	            : 'client_no_context_takeover'
	        ]
	      ) {
	        rsv1 = byteLength >= perMessageDeflate._threshold;
	      }
	      this._compress = rsv1;
	    } else {
	      rsv1 = false;
	      opcode = 0;
	    }
	    if (options.fin) this._firstFragment = true;
	    const opts = {
	      [kByteLength]: byteLength,
	      fin: options.fin,
	      generateMask: this._generateMask,
	      mask: options.mask,
	      maskBuffer: this._maskBuffer,
	      opcode,
	      readOnly,
	      rsv1
	    };
	    if (isBlob(data)) {
	      if (this._state !== DEFAULT) {
	        this.enqueue([this.getBlobData, data, this._compress, opts, cb]);
	      } else {
	        this.getBlobData(data, this._compress, opts, cb);
	      }
	    } else if (this._state !== DEFAULT) {
	      this.enqueue([this.dispatch, data, this._compress, opts, cb]);
	    } else {
	      this.dispatch(data, this._compress, opts, cb);
	    }
	  }
	  getBlobData(blob, compress, options, cb) {
	    this._bufferedBytes += options[kByteLength];
	    this._state = GET_BLOB_DATA;
	    blob
	      .arrayBuffer()
	      .then((arrayBuffer) => {
	        if (this._socket.destroyed) {
	          const err = new Error(
	            'The socket was closed while the blob was being read'
	          );
	          process.nextTick(callCallbacks, this, err, cb);
	          return;
	        }
	        this._bufferedBytes -= options[kByteLength];
	        const data = toBuffer(arrayBuffer);
	        if (!compress) {
	          this._state = DEFAULT;
	          this.sendFrame(Sender.frame(data, options), cb);
	          this.dequeue();
	        } else {
	          this.dispatch(data, compress, options, cb);
	        }
	      })
	      .catch((err) => {
	        process.nextTick(onError, this, err, cb);
	      });
	  }
	  dispatch(data, compress, options, cb) {
	    if (!compress) {
	      this.sendFrame(Sender.frame(data, options), cb);
	      return;
	    }
	    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
	    this._bufferedBytes += options[kByteLength];
	    this._state = DEFLATING;
	    perMessageDeflate.compress(data, options.fin, (_, buf) => {
	      if (this._socket.destroyed) {
	        const err = new Error(
	          'The socket was closed while data was being compressed'
	        );
	        callCallbacks(this, err, cb);
	        return;
	      }
	      this._bufferedBytes -= options[kByteLength];
	      this._state = DEFAULT;
	      options.readOnly = false;
	      this.sendFrame(Sender.frame(buf, options), cb);
	      this.dequeue();
	    });
	  }
	  dequeue() {
	    while (this._state === DEFAULT && this._queue.length) {
	      const params = this._queue.shift();
	      this._bufferedBytes -= params[3][kByteLength];
	      Reflect.apply(params[0], this, params.slice(1));
	    }
	  }
	  enqueue(params) {
	    this._bufferedBytes += params[3][kByteLength];
	    this._queue.push(params);
	  }
	  sendFrame(list, cb) {
	    if (list.length === 2) {
	      this._socket.cork();
	      this._socket.write(list[0]);
	      this._socket.write(list[1], cb);
	      this._socket.uncork();
	    } else {
	      this._socket.write(list[0], cb);
	    }
	  }
	}
	sender = Sender;
	function callCallbacks(sender, err, cb) {
	  if (typeof cb === 'function') cb(err);
	  for (let i = 0; i < sender._queue.length; i++) {
	    const params = sender._queue[i];
	    const callback = params[params.length - 1];
	    if (typeof callback === 'function') callback(err);
	  }
	}
	function onError(sender, err, cb) {
	  callCallbacks(sender, err, cb);
	  sender.onerror(err);
	}
	return sender;
}

var eventTarget;
var hasRequiredEventTarget;

function requireEventTarget () {
	if (hasRequiredEventTarget) return eventTarget;
	hasRequiredEventTarget = 1;
	const { kForOnEventAttribute, kListener } = requireConstants();
	const kCode = Symbol('kCode');
	const kData = Symbol('kData');
	const kError = Symbol('kError');
	const kMessage = Symbol('kMessage');
	const kReason = Symbol('kReason');
	const kTarget = Symbol('kTarget');
	const kType = Symbol('kType');
	const kWasClean = Symbol('kWasClean');
	class Event {
	  constructor(type) {
	    this[kTarget] = null;
	    this[kType] = type;
	  }
	  get target() {
	    return this[kTarget];
	  }
	  get type() {
	    return this[kType];
	  }
	}
	Object.defineProperty(Event.prototype, 'target', { enumerable: true });
	Object.defineProperty(Event.prototype, 'type', { enumerable: true });
	class CloseEvent extends Event {
	  constructor(type, options = {}) {
	    super(type);
	    this[kCode] = options.code === undefined ? 0 : options.code;
	    this[kReason] = options.reason === undefined ? '' : options.reason;
	    this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;
	  }
	  get code() {
	    return this[kCode];
	  }
	  get reason() {
	    return this[kReason];
	  }
	  get wasClean() {
	    return this[kWasClean];
	  }
	}
	Object.defineProperty(CloseEvent.prototype, 'code', { enumerable: true });
	Object.defineProperty(CloseEvent.prototype, 'reason', { enumerable: true });
	Object.defineProperty(CloseEvent.prototype, 'wasClean', { enumerable: true });
	class ErrorEvent extends Event {
	  constructor(type, options = {}) {
	    super(type);
	    this[kError] = options.error === undefined ? null : options.error;
	    this[kMessage] = options.message === undefined ? '' : options.message;
	  }
	  get error() {
	    return this[kError];
	  }
	  get message() {
	    return this[kMessage];
	  }
	}
	Object.defineProperty(ErrorEvent.prototype, 'error', { enumerable: true });
	Object.defineProperty(ErrorEvent.prototype, 'message', { enumerable: true });
	class MessageEvent extends Event {
	  constructor(type, options = {}) {
	    super(type);
	    this[kData] = options.data === undefined ? null : options.data;
	  }
	  get data() {
	    return this[kData];
	  }
	}
	Object.defineProperty(MessageEvent.prototype, 'data', { enumerable: true });
	const EventTarget = {
	  addEventListener(type, handler, options = {}) {
	    for (const listener of this.listeners(type)) {
	      if (
	        !options[kForOnEventAttribute] &&
	        listener[kListener] === handler &&
	        !listener[kForOnEventAttribute]
	      ) {
	        return;
	      }
	    }
	    let wrapper;
	    if (type === 'message') {
	      wrapper = function onMessage(data, isBinary) {
	        const event = new MessageEvent('message', {
	          data: isBinary ? data : data.toString()
	        });
	        event[kTarget] = this;
	        callListener(handler, this, event);
	      };
	    } else if (type === 'close') {
	      wrapper = function onClose(code, message) {
	        const event = new CloseEvent('close', {
	          code,
	          reason: message.toString(),
	          wasClean: this._closeFrameReceived && this._closeFrameSent
	        });
	        event[kTarget] = this;
	        callListener(handler, this, event);
	      };
	    } else if (type === 'error') {
	      wrapper = function onError(error) {
	        const event = new ErrorEvent('error', {
	          error,
	          message: error.message
	        });
	        event[kTarget] = this;
	        callListener(handler, this, event);
	      };
	    } else if (type === 'open') {
	      wrapper = function onOpen() {
	        const event = new Event('open');
	        event[kTarget] = this;
	        callListener(handler, this, event);
	      };
	    } else {
	      return;
	    }
	    wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
	    wrapper[kListener] = handler;
	    if (options.once) {
	      this.once(type, wrapper);
	    } else {
	      this.on(type, wrapper);
	    }
	  },
	  removeEventListener(type, handler) {
	    for (const listener of this.listeners(type)) {
	      if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
	        this.removeListener(type, listener);
	        break;
	      }
	    }
	  }
	};
	eventTarget = {
	  CloseEvent,
	  ErrorEvent,
	  Event,
	  EventTarget,
	  MessageEvent
	};
	function callListener(listener, thisArg, event) {
	  if (typeof listener === 'object' && listener.handleEvent) {
	    listener.handleEvent.call(listener, event);
	  } else {
	    listener.call(thisArg, event);
	  }
	}
	return eventTarget;
}

var extension;
var hasRequiredExtension;

function requireExtension () {
	if (hasRequiredExtension) return extension;
	hasRequiredExtension = 1;
	const { tokenChars } = requireValidation();
	function push(dest, name, elem) {
	  if (dest[name] === undefined) dest[name] = [elem];
	  else dest[name].push(elem);
	}
	function parse(header) {
	  const offers = Object.create(null);
	  let params = Object.create(null);
	  let mustUnescape = false;
	  let isEscaping = false;
	  let inQuotes = false;
	  let extensionName;
	  let paramName;
	  let start = -1;
	  let code = -1;
	  let end = -1;
	  let i = 0;
	  for (; i < header.length; i++) {
	    code = header.charCodeAt(i);
	    if (extensionName === undefined) {
	      if (end === -1 && tokenChars[code] === 1) {
	        if (start === -1) start = i;
	      } else if (
	        i !== 0 &&
	        (code === 0x20  || code === 0x09)
	      ) {
	        if (end === -1 && start !== -1) end = i;
	      } else if (code === 0x3b  || code === 0x2c ) {
	        if (start === -1) {
	          throw new SyntaxError(`Unexpected character at index ${i}`);
	        }
	        if (end === -1) end = i;
	        const name = header.slice(start, end);
	        if (code === 0x2c) {
	          push(offers, name, params);
	          params = Object.create(null);
	        } else {
	          extensionName = name;
	        }
	        start = end = -1;
	      } else {
	        throw new SyntaxError(`Unexpected character at index ${i}`);
	      }
	    } else if (paramName === undefined) {
	      if (end === -1 && tokenChars[code] === 1) {
	        if (start === -1) start = i;
	      } else if (code === 0x20 || code === 0x09) {
	        if (end === -1 && start !== -1) end = i;
	      } else if (code === 0x3b || code === 0x2c) {
	        if (start === -1) {
	          throw new SyntaxError(`Unexpected character at index ${i}`);
	        }
	        if (end === -1) end = i;
	        push(params, header.slice(start, end), true);
	        if (code === 0x2c) {
	          push(offers, extensionName, params);
	          params = Object.create(null);
	          extensionName = undefined;
	        }
	        start = end = -1;
	      } else if (code === 0x3d  && start !== -1 && end === -1) {
	        paramName = header.slice(start, i);
	        start = end = -1;
	      } else {
	        throw new SyntaxError(`Unexpected character at index ${i}`);
	      }
	    } else {
	      if (isEscaping) {
	        if (tokenChars[code] !== 1) {
	          throw new SyntaxError(`Unexpected character at index ${i}`);
	        }
	        if (start === -1) start = i;
	        else if (!mustUnescape) mustUnescape = true;
	        isEscaping = false;
	      } else if (inQuotes) {
	        if (tokenChars[code] === 1) {
	          if (start === -1) start = i;
	        } else if (code === 0x22  && start !== -1) {
	          inQuotes = false;
	          end = i;
	        } else if (code === 0x5c ) {
	          isEscaping = true;
	        } else {
	          throw new SyntaxError(`Unexpected character at index ${i}`);
	        }
	      } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {
	        inQuotes = true;
	      } else if (end === -1 && tokenChars[code] === 1) {
	        if (start === -1) start = i;
	      } else if (start !== -1 && (code === 0x20 || code === 0x09)) {
	        if (end === -1) end = i;
	      } else if (code === 0x3b || code === 0x2c) {
	        if (start === -1) {
	          throw new SyntaxError(`Unexpected character at index ${i}`);
	        }
	        if (end === -1) end = i;
	        let value = header.slice(start, end);
	        if (mustUnescape) {
	          value = value.replace(/\\/g, '');
	          mustUnescape = false;
	        }
	        push(params, paramName, value);
	        if (code === 0x2c) {
	          push(offers, extensionName, params);
	          params = Object.create(null);
	          extensionName = undefined;
	        }
	        paramName = undefined;
	        start = end = -1;
	      } else {
	        throw new SyntaxError(`Unexpected character at index ${i}`);
	      }
	    }
	  }
	  if (start === -1 || inQuotes || code === 0x20 || code === 0x09) {
	    throw new SyntaxError('Unexpected end of input');
	  }
	  if (end === -1) end = i;
	  const token = header.slice(start, end);
	  if (extensionName === undefined) {
	    push(offers, token, params);
	  } else {
	    if (paramName === undefined) {
	      push(params, token, true);
	    } else if (mustUnescape) {
	      push(params, paramName, token.replace(/\\/g, ''));
	    } else {
	      push(params, paramName, token);
	    }
	    push(offers, extensionName, params);
	  }
	  return offers;
	}
	function format(extensions) {
	  return Object.keys(extensions)
	    .map((extension) => {
	      let configurations = extensions[extension];
	      if (!Array.isArray(configurations)) configurations = [configurations];
	      return configurations
	        .map((params) => {
	          return [extension]
	            .concat(
	              Object.keys(params).map((k) => {
	                let values = params[k];
	                if (!Array.isArray(values)) values = [values];
	                return values
	                  .map((v) => (v === true ? k : `${k}=${v}`))
	                  .join('; ');
	              })
	            )
	            .join('; ');
	        })
	        .join(', ');
	    })
	    .join(', ');
	}
	extension = { format, parse };
	return extension;
}

var websocket;
var hasRequiredWebsocket;

function requireWebsocket () {
	if (hasRequiredWebsocket) return websocket;
	hasRequiredWebsocket = 1;
	const EventEmitter = require$$0$5;
	const https = require$$1$1;
	const http = require$$0$3;
	const net = require$$0$4;
	const tls = require$$1$2;
	const { randomBytes, createHash } = require$$2$1;
	const { Duplex, Readable } = require$$1$3;
	const { URL } = require$$5;
	const PerMessageDeflate = requirePermessageDeflate();
	const Receiver = requireReceiver();
	const Sender = requireSender();
	const { isBlob } = requireValidation();
	const {
	  BINARY_TYPES,
	  EMPTY_BUFFER,
	  GUID,
	  kForOnEventAttribute,
	  kListener,
	  kStatusCode,
	  kWebSocket,
	  NOOP
	} = requireConstants();
	const {
	  EventTarget: { addEventListener, removeEventListener }
	} = requireEventTarget();
	const { format, parse } = requireExtension();
	const { toBuffer } = requireBufferUtil();
	const closeTimeout = 30 * 1000;
	const kAborted = Symbol('kAborted');
	const protocolVersions = [8, 13];
	const readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];
	const subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;
	class WebSocket extends EventEmitter {
	  constructor(address, protocols, options) {
	    super();
	    this._binaryType = BINARY_TYPES[0];
	    this._closeCode = 1006;
	    this._closeFrameReceived = false;
	    this._closeFrameSent = false;
	    this._closeMessage = EMPTY_BUFFER;
	    this._closeTimer = null;
	    this._errorEmitted = false;
	    this._extensions = {};
	    this._paused = false;
	    this._protocol = '';
	    this._readyState = WebSocket.CONNECTING;
	    this._receiver = null;
	    this._sender = null;
	    this._socket = null;
	    if (address !== null) {
	      this._bufferedAmount = 0;
	      this._isServer = false;
	      this._redirects = 0;
	      if (protocols === undefined) {
	        protocols = [];
	      } else if (!Array.isArray(protocols)) {
	        if (typeof protocols === 'object' && protocols !== null) {
	          options = protocols;
	          protocols = [];
	        } else {
	          protocols = [protocols];
	        }
	      }
	      initAsClient(this, address, protocols, options);
	    } else {
	      this._autoPong = options.autoPong;
	      this._isServer = true;
	    }
	  }
	  get binaryType() {
	    return this._binaryType;
	  }
	  set binaryType(type) {
	    if (!BINARY_TYPES.includes(type)) return;
	    this._binaryType = type;
	    if (this._receiver) this._receiver._binaryType = type;
	  }
	  get bufferedAmount() {
	    if (!this._socket) return this._bufferedAmount;
	    return this._socket._writableState.length + this._sender._bufferedBytes;
	  }
	  get extensions() {
	    return Object.keys(this._extensions).join();
	  }
	  get isPaused() {
	    return this._paused;
	  }
	  get onclose() {
	    return null;
	  }
	  get onerror() {
	    return null;
	  }
	  get onopen() {
	    return null;
	  }
	  get onmessage() {
	    return null;
	  }
	  get protocol() {
	    return this._protocol;
	  }
	  get readyState() {
	    return this._readyState;
	  }
	  get url() {
	    return this._url;
	  }
	  setSocket(socket, head, options) {
	    const receiver = new Receiver({
	      allowSynchronousEvents: options.allowSynchronousEvents,
	      binaryType: this.binaryType,
	      extensions: this._extensions,
	      isServer: this._isServer,
	      maxPayload: options.maxPayload,
	      skipUTF8Validation: options.skipUTF8Validation
	    });
	    const sender = new Sender(socket, this._extensions, options.generateMask);
	    this._receiver = receiver;
	    this._sender = sender;
	    this._socket = socket;
	    receiver[kWebSocket] = this;
	    sender[kWebSocket] = this;
	    socket[kWebSocket] = this;
	    receiver.on('conclude', receiverOnConclude);
	    receiver.on('drain', receiverOnDrain);
	    receiver.on('error', receiverOnError);
	    receiver.on('message', receiverOnMessage);
	    receiver.on('ping', receiverOnPing);
	    receiver.on('pong', receiverOnPong);
	    sender.onerror = senderOnError;
	    if (socket.setTimeout) socket.setTimeout(0);
	    if (socket.setNoDelay) socket.setNoDelay();
	    if (head.length > 0) socket.unshift(head);
	    socket.on('close', socketOnClose);
	    socket.on('data', socketOnData);
	    socket.on('end', socketOnEnd);
	    socket.on('error', socketOnError);
	    this._readyState = WebSocket.OPEN;
	    this.emit('open');
	  }
	  emitClose() {
	    if (!this._socket) {
	      this._readyState = WebSocket.CLOSED;
	      this.emit('close', this._closeCode, this._closeMessage);
	      return;
	    }
	    if (this._extensions[PerMessageDeflate.extensionName]) {
	      this._extensions[PerMessageDeflate.extensionName].cleanup();
	    }
	    this._receiver.removeAllListeners();
	    this._readyState = WebSocket.CLOSED;
	    this.emit('close', this._closeCode, this._closeMessage);
	  }
	  close(code, data) {
	    if (this.readyState === WebSocket.CLOSED) return;
	    if (this.readyState === WebSocket.CONNECTING) {
	      const msg = 'WebSocket was closed before the connection was established';
	      abortHandshake(this, this._req, msg);
	      return;
	    }
	    if (this.readyState === WebSocket.CLOSING) {
	      if (
	        this._closeFrameSent &&
	        (this._closeFrameReceived || this._receiver._writableState.errorEmitted)
	      ) {
	        this._socket.end();
	      }
	      return;
	    }
	    this._readyState = WebSocket.CLOSING;
	    this._sender.close(code, data, !this._isServer, (err) => {
	      if (err) return;
	      this._closeFrameSent = true;
	      if (
	        this._closeFrameReceived ||
	        this._receiver._writableState.errorEmitted
	      ) {
	        this._socket.end();
	      }
	    });
	    setCloseTimer(this);
	  }
	  pause() {
	    if (
	      this.readyState === WebSocket.CONNECTING ||
	      this.readyState === WebSocket.CLOSED
	    ) {
	      return;
	    }
	    this._paused = true;
	    this._socket.pause();
	  }
	  ping(data, mask, cb) {
	    if (this.readyState === WebSocket.CONNECTING) {
	      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
	    }
	    if (typeof data === 'function') {
	      cb = data;
	      data = mask = undefined;
	    } else if (typeof mask === 'function') {
	      cb = mask;
	      mask = undefined;
	    }
	    if (typeof data === 'number') data = data.toString();
	    if (this.readyState !== WebSocket.OPEN) {
	      sendAfterClose(this, data, cb);
	      return;
	    }
	    if (mask === undefined) mask = !this._isServer;
	    this._sender.ping(data || EMPTY_BUFFER, mask, cb);
	  }
	  pong(data, mask, cb) {
	    if (this.readyState === WebSocket.CONNECTING) {
	      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
	    }
	    if (typeof data === 'function') {
	      cb = data;
	      data = mask = undefined;
	    } else if (typeof mask === 'function') {
	      cb = mask;
	      mask = undefined;
	    }
	    if (typeof data === 'number') data = data.toString();
	    if (this.readyState !== WebSocket.OPEN) {
	      sendAfterClose(this, data, cb);
	      return;
	    }
	    if (mask === undefined) mask = !this._isServer;
	    this._sender.pong(data || EMPTY_BUFFER, mask, cb);
	  }
	  resume() {
	    if (
	      this.readyState === WebSocket.CONNECTING ||
	      this.readyState === WebSocket.CLOSED
	    ) {
	      return;
	    }
	    this._paused = false;
	    if (!this._receiver._writableState.needDrain) this._socket.resume();
	  }
	  send(data, options, cb) {
	    if (this.readyState === WebSocket.CONNECTING) {
	      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
	    }
	    if (typeof options === 'function') {
	      cb = options;
	      options = {};
	    }
	    if (typeof data === 'number') data = data.toString();
	    if (this.readyState !== WebSocket.OPEN) {
	      sendAfterClose(this, data, cb);
	      return;
	    }
	    const opts = {
	      binary: typeof data !== 'string',
	      mask: !this._isServer,
	      compress: true,
	      fin: true,
	      ...options
	    };
	    if (!this._extensions[PerMessageDeflate.extensionName]) {
	      opts.compress = false;
	    }
	    this._sender.send(data || EMPTY_BUFFER, opts, cb);
	  }
	  terminate() {
	    if (this.readyState === WebSocket.CLOSED) return;
	    if (this.readyState === WebSocket.CONNECTING) {
	      const msg = 'WebSocket was closed before the connection was established';
	      abortHandshake(this, this._req, msg);
	      return;
	    }
	    if (this._socket) {
	      this._readyState = WebSocket.CLOSING;
	      this._socket.destroy();
	    }
	  }
	}
	Object.defineProperty(WebSocket, 'CONNECTING', {
	  enumerable: true,
	  value: readyStates.indexOf('CONNECTING')
	});
	Object.defineProperty(WebSocket.prototype, 'CONNECTING', {
	  enumerable: true,
	  value: readyStates.indexOf('CONNECTING')
	});
	Object.defineProperty(WebSocket, 'OPEN', {
	  enumerable: true,
	  value: readyStates.indexOf('OPEN')
	});
	Object.defineProperty(WebSocket.prototype, 'OPEN', {
	  enumerable: true,
	  value: readyStates.indexOf('OPEN')
	});
	Object.defineProperty(WebSocket, 'CLOSING', {
	  enumerable: true,
	  value: readyStates.indexOf('CLOSING')
	});
	Object.defineProperty(WebSocket.prototype, 'CLOSING', {
	  enumerable: true,
	  value: readyStates.indexOf('CLOSING')
	});
	Object.defineProperty(WebSocket, 'CLOSED', {
	  enumerable: true,
	  value: readyStates.indexOf('CLOSED')
	});
	Object.defineProperty(WebSocket.prototype, 'CLOSED', {
	  enumerable: true,
	  value: readyStates.indexOf('CLOSED')
	});
	[
	  'binaryType',
	  'bufferedAmount',
	  'extensions',
	  'isPaused',
	  'protocol',
	  'readyState',
	  'url'
	].forEach((property) => {
	  Object.defineProperty(WebSocket.prototype, property, { enumerable: true });
	});
	['open', 'error', 'close', 'message'].forEach((method) => {
	  Object.defineProperty(WebSocket.prototype, `on${method}`, {
	    enumerable: true,
	    get() {
	      for (const listener of this.listeners(method)) {
	        if (listener[kForOnEventAttribute]) return listener[kListener];
	      }
	      return null;
	    },
	    set(handler) {
	      for (const listener of this.listeners(method)) {
	        if (listener[kForOnEventAttribute]) {
	          this.removeListener(method, listener);
	          break;
	        }
	      }
	      if (typeof handler !== 'function') return;
	      this.addEventListener(method, handler, {
	        [kForOnEventAttribute]: true
	      });
	    }
	  });
	});
	WebSocket.prototype.addEventListener = addEventListener;
	WebSocket.prototype.removeEventListener = removeEventListener;
	websocket = WebSocket;
	function initAsClient(websocket, address, protocols, options) {
	  const opts = {
	    allowSynchronousEvents: true,
	    autoPong: true,
	    protocolVersion: protocolVersions[1],
	    maxPayload: 100 * 1024 * 1024,
	    skipUTF8Validation: false,
	    perMessageDeflate: true,
	    followRedirects: false,
	    maxRedirects: 10,
	    ...options,
	    socketPath: undefined,
	    hostname: undefined,
	    protocol: undefined,
	    timeout: undefined,
	    method: 'GET',
	    host: undefined,
	    path: undefined,
	    port: undefined
	  };
	  websocket._autoPong = opts.autoPong;
	  if (!protocolVersions.includes(opts.protocolVersion)) {
	    throw new RangeError(
	      `Unsupported protocol version: ${opts.protocolVersion} ` +
	        `(supported versions: ${protocolVersions.join(', ')})`
	    );
	  }
	  let parsedUrl;
	  if (address instanceof URL) {
	    parsedUrl = address;
	  } else {
	    try {
	      parsedUrl = new URL(address);
	    } catch (e) {
	      throw new SyntaxError(`Invalid URL: ${address}`);
	    }
	  }
	  if (parsedUrl.protocol === 'http:') {
	    parsedUrl.protocol = 'ws:';
	  } else if (parsedUrl.protocol === 'https:') {
	    parsedUrl.protocol = 'wss:';
	  }
	  websocket._url = parsedUrl.href;
	  const isSecure = parsedUrl.protocol === 'wss:';
	  const isIpcUrl = parsedUrl.protocol === 'ws+unix:';
	  let invalidUrlMessage;
	  if (parsedUrl.protocol !== 'ws:' && !isSecure && !isIpcUrl) {
	    invalidUrlMessage =
	      'The URL\'s protocol must be one of "ws:", "wss:", ' +
	      '"http:", "https:", or "ws+unix:"';
	  } else if (isIpcUrl && !parsedUrl.pathname) {
	    invalidUrlMessage = "The URL's pathname is empty";
	  } else if (parsedUrl.hash) {
	    invalidUrlMessage = 'The URL contains a fragment identifier';
	  }
	  if (invalidUrlMessage) {
	    const err = new SyntaxError(invalidUrlMessage);
	    if (websocket._redirects === 0) {
	      throw err;
	    } else {
	      emitErrorAndClose(websocket, err);
	      return;
	    }
	  }
	  const defaultPort = isSecure ? 443 : 80;
	  const key = randomBytes(16).toString('base64');
	  const request = isSecure ? https.request : http.request;
	  const protocolSet = new Set();
	  let perMessageDeflate;
	  opts.createConnection =
	    opts.createConnection || (isSecure ? tlsConnect : netConnect);
	  opts.defaultPort = opts.defaultPort || defaultPort;
	  opts.port = parsedUrl.port || defaultPort;
	  opts.host = parsedUrl.hostname.startsWith('[')
	    ? parsedUrl.hostname.slice(1, -1)
	    : parsedUrl.hostname;
	  opts.headers = {
	    ...opts.headers,
	    'Sec-WebSocket-Version': opts.protocolVersion,
	    'Sec-WebSocket-Key': key,
	    Connection: 'Upgrade',
	    Upgrade: 'websocket'
	  };
	  opts.path = parsedUrl.pathname + parsedUrl.search;
	  opts.timeout = opts.handshakeTimeout;
	  if (opts.perMessageDeflate) {
	    perMessageDeflate = new PerMessageDeflate(
	      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
	      false,
	      opts.maxPayload
	    );
	    opts.headers['Sec-WebSocket-Extensions'] = format({
	      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
	    });
	  }
	  if (protocols.length) {
	    for (const protocol of protocols) {
	      if (
	        typeof protocol !== 'string' ||
	        !subprotocolRegex.test(protocol) ||
	        protocolSet.has(protocol)
	      ) {
	        throw new SyntaxError(
	          'An invalid or duplicated subprotocol was specified'
	        );
	      }
	      protocolSet.add(protocol);
	    }
	    opts.headers['Sec-WebSocket-Protocol'] = protocols.join(',');
	  }
	  if (opts.origin) {
	    if (opts.protocolVersion < 13) {
	      opts.headers['Sec-WebSocket-Origin'] = opts.origin;
	    } else {
	      opts.headers.Origin = opts.origin;
	    }
	  }
	  if (parsedUrl.username || parsedUrl.password) {
	    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
	  }
	  if (isIpcUrl) {
	    const parts = opts.path.split(':');
	    opts.socketPath = parts[0];
	    opts.path = parts[1];
	  }
	  let req;
	  if (opts.followRedirects) {
	    if (websocket._redirects === 0) {
	      websocket._originalIpc = isIpcUrl;
	      websocket._originalSecure = isSecure;
	      websocket._originalHostOrSocketPath = isIpcUrl
	        ? opts.socketPath
	        : parsedUrl.host;
	      const headers = options && options.headers;
	      options = { ...options, headers: {} };
	      if (headers) {
	        for (const [key, value] of Object.entries(headers)) {
	          options.headers[key.toLowerCase()] = value;
	        }
	      }
	    } else if (websocket.listenerCount('redirect') === 0) {
	      const isSameHost = isIpcUrl
	        ? websocket._originalIpc
	          ? opts.socketPath === websocket._originalHostOrSocketPath
	          : false
	        : websocket._originalIpc
	          ? false
	          : parsedUrl.host === websocket._originalHostOrSocketPath;
	      if (!isSameHost || (websocket._originalSecure && !isSecure)) {
	        delete opts.headers.authorization;
	        delete opts.headers.cookie;
	        if (!isSameHost) delete opts.headers.host;
	        opts.auth = undefined;
	      }
	    }
	    if (opts.auth && !options.headers.authorization) {
	      options.headers.authorization =
	        'Basic ' + Buffer.from(opts.auth).toString('base64');
	    }
	    req = websocket._req = request(opts);
	    if (websocket._redirects) {
	      websocket.emit('redirect', websocket.url, req);
	    }
	  } else {
	    req = websocket._req = request(opts);
	  }
	  if (opts.timeout) {
	    req.on('timeout', () => {
	      abortHandshake(websocket, req, 'Opening handshake has timed out');
	    });
	  }
	  req.on('error', (err) => {
	    if (req === null || req[kAborted]) return;
	    req = websocket._req = null;
	    emitErrorAndClose(websocket, err);
	  });
	  req.on('response', (res) => {
	    const location = res.headers.location;
	    const statusCode = res.statusCode;
	    if (
	      location &&
	      opts.followRedirects &&
	      statusCode >= 300 &&
	      statusCode < 400
	    ) {
	      if (++websocket._redirects > opts.maxRedirects) {
	        abortHandshake(websocket, req, 'Maximum redirects exceeded');
	        return;
	      }
	      req.abort();
	      let addr;
	      try {
	        addr = new URL(location, address);
	      } catch (e) {
	        const err = new SyntaxError(`Invalid URL: ${location}`);
	        emitErrorAndClose(websocket, err);
	        return;
	      }
	      initAsClient(websocket, addr, protocols, options);
	    } else if (!websocket.emit('unexpected-response', req, res)) {
	      abortHandshake(
	        websocket,
	        req,
	        `Unexpected server response: ${res.statusCode}`
	      );
	    }
	  });
	  req.on('upgrade', (res, socket, head) => {
	    websocket.emit('upgrade', res);
	    if (websocket.readyState !== WebSocket.CONNECTING) return;
	    req = websocket._req = null;
	    const upgrade = res.headers.upgrade;
	    if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {
	      abortHandshake(websocket, socket, 'Invalid Upgrade header');
	      return;
	    }
	    const digest = createHash('sha1')
	      .update(key + GUID)
	      .digest('base64');
	    if (res.headers['sec-websocket-accept'] !== digest) {
	      abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');
	      return;
	    }
	    const serverProt = res.headers['sec-websocket-protocol'];
	    let protError;
	    if (serverProt !== undefined) {
	      if (!protocolSet.size) {
	        protError = 'Server sent a subprotocol but none was requested';
	      } else if (!protocolSet.has(serverProt)) {
	        protError = 'Server sent an invalid subprotocol';
	      }
	    } else if (protocolSet.size) {
	      protError = 'Server sent no subprotocol';
	    }
	    if (protError) {
	      abortHandshake(websocket, socket, protError);
	      return;
	    }
	    if (serverProt) websocket._protocol = serverProt;
	    const secWebSocketExtensions = res.headers['sec-websocket-extensions'];
	    if (secWebSocketExtensions !== undefined) {
	      if (!perMessageDeflate) {
	        const message =
	          'Server sent a Sec-WebSocket-Extensions header but no extension ' +
	          'was requested';
	        abortHandshake(websocket, socket, message);
	        return;
	      }
	      let extensions;
	      try {
	        extensions = parse(secWebSocketExtensions);
	      } catch (err) {
	        const message = 'Invalid Sec-WebSocket-Extensions header';
	        abortHandshake(websocket, socket, message);
	        return;
	      }
	      const extensionNames = Object.keys(extensions);
	      if (
	        extensionNames.length !== 1 ||
	        extensionNames[0] !== PerMessageDeflate.extensionName
	      ) {
	        const message = 'Server indicated an extension that was not requested';
	        abortHandshake(websocket, socket, message);
	        return;
	      }
	      try {
	        perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
	      } catch (err) {
	        const message = 'Invalid Sec-WebSocket-Extensions header';
	        abortHandshake(websocket, socket, message);
	        return;
	      }
	      websocket._extensions[PerMessageDeflate.extensionName] =
	        perMessageDeflate;
	    }
	    websocket.setSocket(socket, head, {
	      allowSynchronousEvents: opts.allowSynchronousEvents,
	      generateMask: opts.generateMask,
	      maxPayload: opts.maxPayload,
	      skipUTF8Validation: opts.skipUTF8Validation
	    });
	  });
	  if (opts.finishRequest) {
	    opts.finishRequest(req, websocket);
	  } else {
	    req.end();
	  }
	}
	function emitErrorAndClose(websocket, err) {
	  websocket._readyState = WebSocket.CLOSING;
	  websocket._errorEmitted = true;
	  websocket.emit('error', err);
	  websocket.emitClose();
	}
	function netConnect(options) {
	  options.path = options.socketPath;
	  return net.connect(options);
	}
	function tlsConnect(options) {
	  options.path = undefined;
	  if (!options.servername && options.servername !== '') {
	    options.servername = net.isIP(options.host) ? '' : options.host;
	  }
	  return tls.connect(options);
	}
	function abortHandshake(websocket, stream, message) {
	  websocket._readyState = WebSocket.CLOSING;
	  const err = new Error(message);
	  Error.captureStackTrace(err, abortHandshake);
	  if (stream.setHeader) {
	    stream[kAborted] = true;
	    stream.abort();
	    if (stream.socket && !stream.socket.destroyed) {
	      stream.socket.destroy();
	    }
	    process.nextTick(emitErrorAndClose, websocket, err);
	  } else {
	    stream.destroy(err);
	    stream.once('error', websocket.emit.bind(websocket, 'error'));
	    stream.once('close', websocket.emitClose.bind(websocket));
	  }
	}
	function sendAfterClose(websocket, data, cb) {
	  if (data) {
	    const length = isBlob(data) ? data.size : toBuffer(data).length;
	    if (websocket._socket) websocket._sender._bufferedBytes += length;
	    else websocket._bufferedAmount += length;
	  }
	  if (cb) {
	    const err = new Error(
	      `WebSocket is not open: readyState ${websocket.readyState} ` +
	        `(${readyStates[websocket.readyState]})`
	    );
	    process.nextTick(cb, err);
	  }
	}
	function receiverOnConclude(code, reason) {
	  const websocket = this[kWebSocket];
	  websocket._closeFrameReceived = true;
	  websocket._closeMessage = reason;
	  websocket._closeCode = code;
	  if (websocket._socket[kWebSocket] === undefined) return;
	  websocket._socket.removeListener('data', socketOnData);
	  process.nextTick(resume, websocket._socket);
	  if (code === 1005) websocket.close();
	  else websocket.close(code, reason);
	}
	function receiverOnDrain() {
	  const websocket = this[kWebSocket];
	  if (!websocket.isPaused) websocket._socket.resume();
	}
	function receiverOnError(err) {
	  const websocket = this[kWebSocket];
	  if (websocket._socket[kWebSocket] !== undefined) {
	    websocket._socket.removeListener('data', socketOnData);
	    process.nextTick(resume, websocket._socket);
	    websocket.close(err[kStatusCode]);
	  }
	  if (!websocket._errorEmitted) {
	    websocket._errorEmitted = true;
	    websocket.emit('error', err);
	  }
	}
	function receiverOnFinish() {
	  this[kWebSocket].emitClose();
	}
	function receiverOnMessage(data, isBinary) {
	  this[kWebSocket].emit('message', data, isBinary);
	}
	function receiverOnPing(data) {
	  const websocket = this[kWebSocket];
	  if (websocket._autoPong) websocket.pong(data, !this._isServer, NOOP);
	  websocket.emit('ping', data);
	}
	function receiverOnPong(data) {
	  this[kWebSocket].emit('pong', data);
	}
	function resume(stream) {
	  stream.resume();
	}
	function senderOnError(err) {
	  const websocket = this[kWebSocket];
	  if (websocket.readyState === WebSocket.CLOSED) return;
	  if (websocket.readyState === WebSocket.OPEN) {
	    websocket._readyState = WebSocket.CLOSING;
	    setCloseTimer(websocket);
	  }
	  this._socket.end();
	  if (!websocket._errorEmitted) {
	    websocket._errorEmitted = true;
	    websocket.emit('error', err);
	  }
	}
	function setCloseTimer(websocket) {
	  websocket._closeTimer = setTimeout(
	    websocket._socket.destroy.bind(websocket._socket),
	    closeTimeout
	  );
	}
	function socketOnClose() {
	  const websocket = this[kWebSocket];
	  this.removeListener('close', socketOnClose);
	  this.removeListener('data', socketOnData);
	  this.removeListener('end', socketOnEnd);
	  websocket._readyState = WebSocket.CLOSING;
	  let chunk;
	  if (
	    !this._readableState.endEmitted &&
	    !websocket._closeFrameReceived &&
	    !websocket._receiver._writableState.errorEmitted &&
	    (chunk = websocket._socket.read()) !== null
	  ) {
	    websocket._receiver.write(chunk);
	  }
	  websocket._receiver.end();
	  this[kWebSocket] = undefined;
	  clearTimeout(websocket._closeTimer);
	  if (
	    websocket._receiver._writableState.finished ||
	    websocket._receiver._writableState.errorEmitted
	  ) {
	    websocket.emitClose();
	  } else {
	    websocket._receiver.on('error', receiverOnFinish);
	    websocket._receiver.on('finish', receiverOnFinish);
	  }
	}
	function socketOnData(chunk) {
	  if (!this[kWebSocket]._receiver.write(chunk)) {
	    this.pause();
	  }
	}
	function socketOnEnd() {
	  const websocket = this[kWebSocket];
	  websocket._readyState = WebSocket.CLOSING;
	  websocket._receiver.end();
	  this.end();
	}
	function socketOnError() {
	  const websocket = this[kWebSocket];
	  this.removeListener('error', socketOnError);
	  this.on('error', NOOP);
	  if (websocket) {
	    websocket._readyState = WebSocket.CLOSING;
	    this.destroy();
	  }
	}
	return websocket;
}

var stream;
var hasRequiredStream;

function requireStream () {
	if (hasRequiredStream) return stream;
	hasRequiredStream = 1;
	requireWebsocket();
	const { Duplex } = require$$1$3;
	function emitClose(stream) {
	  stream.emit('close');
	}
	function duplexOnEnd() {
	  if (!this.destroyed && this._writableState.finished) {
	    this.destroy();
	  }
	}
	function duplexOnError(err) {
	  this.removeListener('error', duplexOnError);
	  this.destroy();
	  if (this.listenerCount('error') === 0) {
	    this.emit('error', err);
	  }
	}
	function createWebSocketStream(ws, options) {
	  let terminateOnDestroy = true;
	  const duplex = new Duplex({
	    ...options,
	    autoDestroy: false,
	    emitClose: false,
	    objectMode: false,
	    writableObjectMode: false
	  });
	  ws.on('message', function message(msg, isBinary) {
	    const data =
	      !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;
	    if (!duplex.push(data)) ws.pause();
	  });
	  ws.once('error', function error(err) {
	    if (duplex.destroyed) return;
	    terminateOnDestroy = false;
	    duplex.destroy(err);
	  });
	  ws.once('close', function close() {
	    if (duplex.destroyed) return;
	    duplex.push(null);
	  });
	  duplex._destroy = function (err, callback) {
	    if (ws.readyState === ws.CLOSED) {
	      callback(err);
	      process.nextTick(emitClose, duplex);
	      return;
	    }
	    let called = false;
	    ws.once('error', function error(err) {
	      called = true;
	      callback(err);
	    });
	    ws.once('close', function close() {
	      if (!called) callback(err);
	      process.nextTick(emitClose, duplex);
	    });
	    if (terminateOnDestroy) ws.terminate();
	  };
	  duplex._final = function (callback) {
	    if (ws.readyState === ws.CONNECTING) {
	      ws.once('open', function open() {
	        duplex._final(callback);
	      });
	      return;
	    }
	    if (ws._socket === null) return;
	    if (ws._socket._writableState.finished) {
	      callback();
	      if (duplex._readableState.endEmitted) duplex.destroy();
	    } else {
	      ws._socket.once('finish', function finish() {
	        callback();
	      });
	      ws.close();
	    }
	  };
	  duplex._read = function () {
	    if (ws.isPaused) ws.resume();
	  };
	  duplex._write = function (chunk, encoding, callback) {
	    if (ws.readyState === ws.CONNECTING) {
	      ws.once('open', function open() {
	        duplex._write(chunk, encoding, callback);
	      });
	      return;
	    }
	    ws.send(chunk, callback);
	  };
	  duplex.on('end', duplexOnEnd);
	  duplex.on('error', duplexOnError);
	  return duplex;
	}
	stream = createWebSocketStream;
	return stream;
}

requireStream();

requireReceiver();

requireSender();

var websocketExports = requireWebsocket();
var WebSocket$1 = /*@__PURE__*/getDefaultExportFromCjs(websocketExports);

var subprotocol;
var hasRequiredSubprotocol;

function requireSubprotocol () {
	if (hasRequiredSubprotocol) return subprotocol;
	hasRequiredSubprotocol = 1;
	const { tokenChars } = requireValidation();
	function parse(header) {
	  const protocols = new Set();
	  let start = -1;
	  let end = -1;
	  let i = 0;
	  for (i; i < header.length; i++) {
	    const code = header.charCodeAt(i);
	    if (end === -1 && tokenChars[code] === 1) {
	      if (start === -1) start = i;
	    } else if (
	      i !== 0 &&
	      (code === 0x20  || code === 0x09)
	    ) {
	      if (end === -1 && start !== -1) end = i;
	    } else if (code === 0x2c ) {
	      if (start === -1) {
	        throw new SyntaxError(`Unexpected character at index ${i}`);
	      }
	      if (end === -1) end = i;
	      const protocol = header.slice(start, end);
	      if (protocols.has(protocol)) {
	        throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
	      }
	      protocols.add(protocol);
	      start = end = -1;
	    } else {
	      throw new SyntaxError(`Unexpected character at index ${i}`);
	    }
	  }
	  if (start === -1 || end !== -1) {
	    throw new SyntaxError('Unexpected end of input');
	  }
	  const protocol = header.slice(start, i);
	  if (protocols.has(protocol)) {
	    throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
	  }
	  protocols.add(protocol);
	  return protocols;
	}
	subprotocol = { parse };
	return subprotocol;
}

var websocketServer;
var hasRequiredWebsocketServer;

function requireWebsocketServer () {
	if (hasRequiredWebsocketServer) return websocketServer;
	hasRequiredWebsocketServer = 1;
	const EventEmitter = require$$0$5;
	const http = require$$0$3;
	const { Duplex } = require$$1$3;
	const { createHash } = require$$2$1;
	const extension = requireExtension();
	const PerMessageDeflate = requirePermessageDeflate();
	const subprotocol = requireSubprotocol();
	const WebSocket = requireWebsocket();
	const { GUID, kWebSocket } = requireConstants();
	const keyRegex = /^[+/0-9A-Za-z]{22}==$/;
	const RUNNING = 0;
	const CLOSING = 1;
	const CLOSED = 2;
	class WebSocketServer extends EventEmitter {
	  constructor(options, callback) {
	    super();
	    options = {
	      allowSynchronousEvents: true,
	      autoPong: true,
	      maxPayload: 100 * 1024 * 1024,
	      skipUTF8Validation: false,
	      perMessageDeflate: false,
	      handleProtocols: null,
	      clientTracking: true,
	      verifyClient: null,
	      noServer: false,
	      backlog: null,
	      server: null,
	      host: null,
	      path: null,
	      port: null,
	      WebSocket,
	      ...options
	    };
	    if (
	      (options.port == null && !options.server && !options.noServer) ||
	      (options.port != null && (options.server || options.noServer)) ||
	      (options.server && options.noServer)
	    ) {
	      throw new TypeError(
	        'One and only one of the "port", "server", or "noServer" options ' +
	          'must be specified'
	      );
	    }
	    if (options.port != null) {
	      this._server = http.createServer((req, res) => {
	        const body = http.STATUS_CODES[426];
	        res.writeHead(426, {
	          'Content-Length': body.length,
	          'Content-Type': 'text/plain'
	        });
	        res.end(body);
	      });
	      this._server.listen(
	        options.port,
	        options.host,
	        options.backlog,
	        callback
	      );
	    } else if (options.server) {
	      this._server = options.server;
	    }
	    if (this._server) {
	      const emitConnection = this.emit.bind(this, 'connection');
	      this._removeListeners = addListeners(this._server, {
	        listening: this.emit.bind(this, 'listening'),
	        error: this.emit.bind(this, 'error'),
	        upgrade: (req, socket, head) => {
	          this.handleUpgrade(req, socket, head, emitConnection);
	        }
	      });
	    }
	    if (options.perMessageDeflate === true) options.perMessageDeflate = {};
	    if (options.clientTracking) {
	      this.clients = new Set();
	      this._shouldEmitClose = false;
	    }
	    this.options = options;
	    this._state = RUNNING;
	  }
	  address() {
	    if (this.options.noServer) {
	      throw new Error('The server is operating in "noServer" mode');
	    }
	    if (!this._server) return null;
	    return this._server.address();
	  }
	  close(cb) {
	    if (this._state === CLOSED) {
	      if (cb) {
	        this.once('close', () => {
	          cb(new Error('The server is not running'));
	        });
	      }
	      process.nextTick(emitClose, this);
	      return;
	    }
	    if (cb) this.once('close', cb);
	    if (this._state === CLOSING) return;
	    this._state = CLOSING;
	    if (this.options.noServer || this.options.server) {
	      if (this._server) {
	        this._removeListeners();
	        this._removeListeners = this._server = null;
	      }
	      if (this.clients) {
	        if (!this.clients.size) {
	          process.nextTick(emitClose, this);
	        } else {
	          this._shouldEmitClose = true;
	        }
	      } else {
	        process.nextTick(emitClose, this);
	      }
	    } else {
	      const server = this._server;
	      this._removeListeners();
	      this._removeListeners = this._server = null;
	      server.close(() => {
	        emitClose(this);
	      });
	    }
	  }
	  shouldHandle(req) {
	    if (this.options.path) {
	      const index = req.url.indexOf('?');
	      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;
	      if (pathname !== this.options.path) return false;
	    }
	    return true;
	  }
	  handleUpgrade(req, socket, head, cb) {
	    socket.on('error', socketOnError);
	    const key = req.headers['sec-websocket-key'];
	    const upgrade = req.headers.upgrade;
	    const version = +req.headers['sec-websocket-version'];
	    if (req.method !== 'GET') {
	      const message = 'Invalid HTTP method';
	      abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
	      return;
	    }
	    if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {
	      const message = 'Invalid Upgrade header';
	      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
	      return;
	    }
	    if (key === undefined || !keyRegex.test(key)) {
	      const message = 'Missing or invalid Sec-WebSocket-Key header';
	      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
	      return;
	    }
	    if (version !== 13 && version !== 8) {
	      const message = 'Missing or invalid Sec-WebSocket-Version header';
	      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message, {
	        'Sec-WebSocket-Version': '13, 8'
	      });
	      return;
	    }
	    if (!this.shouldHandle(req)) {
	      abortHandshake(socket, 400);
	      return;
	    }
	    const secWebSocketProtocol = req.headers['sec-websocket-protocol'];
	    let protocols = new Set();
	    if (secWebSocketProtocol !== undefined) {
	      try {
	        protocols = subprotocol.parse(secWebSocketProtocol);
	      } catch (err) {
	        const message = 'Invalid Sec-WebSocket-Protocol header';
	        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
	        return;
	      }
	    }
	    const secWebSocketExtensions = req.headers['sec-websocket-extensions'];
	    const extensions = {};
	    if (
	      this.options.perMessageDeflate &&
	      secWebSocketExtensions !== undefined
	    ) {
	      const perMessageDeflate = new PerMessageDeflate(
	        this.options.perMessageDeflate,
	        true,
	        this.options.maxPayload
	      );
	      try {
	        const offers = extension.parse(secWebSocketExtensions);
	        if (offers[PerMessageDeflate.extensionName]) {
	          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
	          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
	        }
	      } catch (err) {
	        const message =
	          'Invalid or unacceptable Sec-WebSocket-Extensions header';
	        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
	        return;
	      }
	    }
	    if (this.options.verifyClient) {
	      const info = {
	        origin:
	          req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],
	        secure: !!(req.socket.authorized || req.socket.encrypted),
	        req
	      };
	      if (this.options.verifyClient.length === 2) {
	        this.options.verifyClient(info, (verified, code, message, headers) => {
	          if (!verified) {
	            return abortHandshake(socket, code || 401, message, headers);
	          }
	          this.completeUpgrade(
	            extensions,
	            key,
	            protocols,
	            req,
	            socket,
	            head,
	            cb
	          );
	        });
	        return;
	      }
	      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
	    }
	    this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
	  }
	  completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
	    if (!socket.readable || !socket.writable) return socket.destroy();
	    if (socket[kWebSocket]) {
	      throw new Error(
	        'server.handleUpgrade() was called more than once with the same ' +
	          'socket, possibly due to a misconfiguration'
	      );
	    }
	    if (this._state > RUNNING) return abortHandshake(socket, 503);
	    const digest = createHash('sha1')
	      .update(key + GUID)
	      .digest('base64');
	    const headers = [
	      'HTTP/1.1 101 Switching Protocols',
	      'Upgrade: websocket',
	      'Connection: Upgrade',
	      `Sec-WebSocket-Accept: ${digest}`
	    ];
	    const ws = new this.options.WebSocket(null, undefined, this.options);
	    if (protocols.size) {
	      const protocol = this.options.handleProtocols
	        ? this.options.handleProtocols(protocols, req)
	        : protocols.values().next().value;
	      if (protocol) {
	        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
	        ws._protocol = protocol;
	      }
	    }
	    if (extensions[PerMessageDeflate.extensionName]) {
	      const params = extensions[PerMessageDeflate.extensionName].params;
	      const value = extension.format({
	        [PerMessageDeflate.extensionName]: [params]
	      });
	      headers.push(`Sec-WebSocket-Extensions: ${value}`);
	      ws._extensions = extensions;
	    }
	    this.emit('headers', headers, req);
	    socket.write(headers.concat('\r\n').join('\r\n'));
	    socket.removeListener('error', socketOnError);
	    ws.setSocket(socket, head, {
	      allowSynchronousEvents: this.options.allowSynchronousEvents,
	      maxPayload: this.options.maxPayload,
	      skipUTF8Validation: this.options.skipUTF8Validation
	    });
	    if (this.clients) {
	      this.clients.add(ws);
	      ws.on('close', () => {
	        this.clients.delete(ws);
	        if (this._shouldEmitClose && !this.clients.size) {
	          process.nextTick(emitClose, this);
	        }
	      });
	    }
	    cb(ws, req);
	  }
	}
	websocketServer = WebSocketServer;
	function addListeners(server, map) {
	  for (const event of Object.keys(map)) server.on(event, map[event]);
	  return function removeListeners() {
	    for (const event of Object.keys(map)) {
	      server.removeListener(event, map[event]);
	    }
	  };
	}
	function emitClose(server) {
	  server._state = CLOSED;
	  server.emit('close');
	}
	function socketOnError() {
	  this.destroy();
	}
	function abortHandshake(socket, code, message, headers) {
	  message = message || http.STATUS_CODES[code];
	  headers = {
	    Connection: 'close',
	    'Content-Type': 'text/html',
	    'Content-Length': Buffer.byteLength(message),
	    ...headers
	  };
	  socket.once('finish', socket.destroy);
	  socket.end(
	    `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r\n` +
	      Object.keys(headers)
	        .map((h) => `${h}: ${headers[h]}`)
	        .join('\r\n') +
	      '\r\n\r\n' +
	      message
	  );
	}
	function abortHandshakeOrEmitwsClientError(
	  server,
	  req,
	  socket,
	  code,
	  message,
	  headers
	) {
	  if (server.listenerCount('wsClientError')) {
	    const err = new Error(message);
	    Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);
	    server.emit('wsClientError', err, socket, req);
	  } else {
	    abortHandshake(socket, code, message, headers);
	  }
	}
	return websocketServer;
}

requireWebsocketServer();

/**
 * @license
 * Copyright 2018 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class NodeWebSocketTransport {
    static create(url, headers) {
        return new Promise((resolve, reject) => {
            const ws = new WebSocket$1(url, [], {
                followRedirects: true,
                perMessageDeflate: false,
                allowSynchronousEvents: false,
                maxPayload: 256 * 1024 * 1024,
                headers: {
                    'User-Agent': `Puppeteer ${packageVersion}`,
                    ...headers,
                },
            });
            ws.addEventListener('open', () => {
                return resolve(new NodeWebSocketTransport(ws));
            });
            ws.addEventListener('error', reject);
        });
    }
    #ws;
    onmessage;
    onclose;
    constructor(ws) {
        this.#ws = ws;
        this.#ws.addEventListener('message', event => {
            if (this.onmessage) {
                this.onmessage.call(null, event.data);
            }
        });
        this.#ws.addEventListener('close', () => {
            if (this.onclose) {
                this.onclose.call(null);
            }
        });
        this.#ws.addEventListener('error', () => { });
    }
    send(message) {
        this.#ws.send(message);
    }
    close() {
        this.#ws.close();
    }
}

var NodeWebSocketTransport$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	NodeWebSocketTransport: NodeWebSocketTransport
});

class PipeTransport {
    #pipeWrite;
    #subscriptions = new DisposableStack();
    #isClosed = false;
    #pendingMessage = [];
    onclose;
    onmessage;
    constructor(pipeWrite, pipeRead) {
        this.#pipeWrite = pipeWrite;
        const pipeReadEmitter = this.#subscriptions.use(
        new EventEmitter(pipeRead));
        pipeReadEmitter.on('data', buffer => {
            return this.#dispatch(buffer);
        });
        pipeReadEmitter.on('close', () => {
            if (this.onclose) {
                this.onclose.call(null);
            }
        });
        pipeReadEmitter.on('error', debugError);
        const pipeWriteEmitter = this.#subscriptions.use(
        new EventEmitter(pipeWrite));
        pipeWriteEmitter.on('error', debugError);
    }
    send(message) {
        assert(!this.#isClosed, '`PipeTransport` is closed.');
        this.#pipeWrite.write(message);
        this.#pipeWrite.write('\0');
    }
    #dispatch(buffer) {
        assert(!this.#isClosed, '`PipeTransport` is closed.');
        this.#pendingMessage.push(buffer);
        if (buffer.indexOf('\0') === -1) {
            return;
        }
        const concatBuffer = Buffer.concat(this.#pendingMessage);
        let start = 0;
        let end = concatBuffer.indexOf('\0');
        while (end !== -1) {
            const message = concatBuffer.toString(undefined, start, end);
            setImmediate(() => {
                if (this.onmessage) {
                    this.onmessage.call(null, message);
                }
            });
            start = end + 1;
            end = concatBuffer.indexOf('\0', start);
        }
        if (start >= concatBuffer.length) {
            this.#pendingMessage = [];
        }
        else {
            this.#pendingMessage = [concatBuffer.subarray(start)];
        }
    }
    close() {
        this.#isClosed = true;
        this.#subscriptions.dispose();
    }
}

/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class BrowserLauncher {
    #browser;
    puppeteer;
    constructor(puppeteer, browser) {
        this.puppeteer = puppeteer;
        this.#browser = browser;
    }
    get browser() {
        return this.#browser;
    }
    async launch(options = {}) {
        const { dumpio = false, enableExtensions = false, env = process.env, handleSIGINT = true, handleSIGTERM = true, handleSIGHUP = true, acceptInsecureCerts = false, networkEnabled = true, defaultViewport = DEFAULT_VIEWPORT, downloadBehavior, slowMo = 0, timeout = 30000, waitForInitialPage = true, protocolTimeout, handleDevToolsAsPage, } = options;
        let { protocol } = options;
        if (this.#browser === 'firefox' && protocol === undefined) {
            protocol = 'webDriverBiDi';
        }
        if (this.#browser === 'firefox' && protocol === 'cdp') {
            throw new Error('Connecting to Firefox using CDP is no longer supported');
        }
        const launchArgs = await this.computeLaunchArguments({
            ...options,
            protocol,
        });
        if (!existsSync(launchArgs.executablePath)) {
            throw new Error(`Browser was not found at the configured executablePath (${launchArgs.executablePath})`);
        }
        const usePipe = launchArgs.args.includes('--remote-debugging-pipe');
        const onProcessExit = async () => {
            await this.cleanUserDataDir(launchArgs.userDataDir, {
                isTemp: launchArgs.isTempUserDataDir,
            });
        };
        if (this.#browser === 'firefox' &&
            protocol === 'webDriverBiDi' &&
            usePipe) {
            throw new Error('Pipe connections are not supported with Firefox and WebDriver BiDi');
        }
        const browserProcess = launch$1({
            executablePath: launchArgs.executablePath,
            args: launchArgs.args,
            handleSIGHUP,
            handleSIGTERM,
            handleSIGINT,
            dumpio,
            env,
            pipe: usePipe,
            onExit: onProcessExit,
        });
        let browser;
        let cdpConnection;
        let closing = false;
        const browserCloseCallback = async () => {
            if (closing) {
                return;
            }
            closing = true;
            await this.closeBrowser(browserProcess, cdpConnection);
        };
        try {
            if (this.#browser === 'firefox') {
                browser = await this.createBiDiBrowser(browserProcess, browserCloseCallback, {
                    timeout,
                    protocolTimeout,
                    slowMo,
                    defaultViewport,
                    acceptInsecureCerts,
                    networkEnabled,
                });
            }
            else {
                if (usePipe) {
                    cdpConnection = await this.createCdpPipeConnection(browserProcess, {
                        timeout,
                        protocolTimeout,
                        slowMo,
                    });
                }
                else {
                    cdpConnection = await this.createCdpSocketConnection(browserProcess, {
                        timeout,
                        protocolTimeout,
                        slowMo,
                    });
                }
                if (protocol === 'webDriverBiDi') {
                    browser = await this.createBiDiOverCdpBrowser(browserProcess, cdpConnection, browserCloseCallback, {
                        defaultViewport,
                        acceptInsecureCerts,
                        networkEnabled,
                    });
                }
                else {
                    browser = await CdpBrowser._create(cdpConnection, [], acceptInsecureCerts, defaultViewport, downloadBehavior, browserProcess.nodeProcess, browserCloseCallback, options.targetFilter, undefined, undefined, networkEnabled, handleDevToolsAsPage);
                }
            }
        }
        catch (error) {
            void browserCloseCallback();
            const logs = browserProcess.getRecentLogs().join('\n');
            if (logs.includes('Failed to create a ProcessSingleton for your profile directory') ||
                (process.platform === 'win32' &&
                    existsSync(join$1(launchArgs.userDataDir, 'lockfile')))) {
                throw new Error(`The browser is already running for ${launchArgs.userDataDir}. Use a different \`userDataDir\` or stop the running browser first.`);
            }
            if (logs.includes('Missing X server') && options.headless === false) {
                throw new Error(`Missing X server to start the headful browser. Either set headless to true or use xvfb-run to run your Puppeteer script.`);
            }
            if (error instanceof TimeoutError) {
                throw new TimeoutError$1(error.message);
            }
            throw error;
        }
        if (Array.isArray(enableExtensions)) {
            if (this.#browser === 'chrome' && !usePipe) {
                throw new Error('To use `enableExtensions` with a list of paths in Chrome, you must be connected with `--remote-debugging-pipe` (`pipe: true`).');
            }
            await Promise.all([
                enableExtensions.map(path => {
                    return browser.installExtension(path);
                }),
            ]);
        }
        if (waitForInitialPage) {
            await this.waitForPageTarget(browser, timeout);
        }
        return browser;
    }
    async closeBrowser(browserProcess, cdpConnection) {
        if (cdpConnection) {
            try {
                await cdpConnection.closeBrowser();
                await browserProcess.hasClosed();
            }
            catch (error) {
                debugError(error);
                await browserProcess.close();
            }
        }
        else {
            await firstValueFrom(race(from(browserProcess.hasClosed()), timer(5000).pipe(map(() => {
                return from(browserProcess.close());
            }))));
        }
    }
    async waitForPageTarget(browser, timeout) {
        try {
            await browser.waitForTarget(t => {
                return t.type() === 'page';
            }, { timeout });
        }
        catch (error) {
            await browser.close();
            throw error;
        }
    }
    async createCdpSocketConnection(browserProcess, opts) {
        const browserWSEndpoint = await browserProcess.waitForLineOutput(CDP_WEBSOCKET_ENDPOINT_REGEX, opts.timeout);
        const transport = await NodeWebSocketTransport.create(browserWSEndpoint);
        return new Connection(browserWSEndpoint, transport, opts.slowMo, opts.protocolTimeout);
    }
    async createCdpPipeConnection(browserProcess, opts) {
        const { 3: pipeWrite, 4: pipeRead } = browserProcess.nodeProcess.stdio;
        const transport = new PipeTransport(pipeWrite, pipeRead);
        return new Connection('', transport, opts.slowMo, opts.protocolTimeout);
    }
    async createBiDiOverCdpBrowser(browserProcess, cdpConnection, closeCallback, opts) {
        const bidiOnly = process.env['PUPPETEER_WEBDRIVER_BIDI_ONLY'] === 'true';
        const BiDi = await import( '../../../node_modules/puppeteer-core/lib/esm/puppeteer/bidi/bidi.js');
        const bidiConnection = await BiDi.connectBidiOverCdp(cdpConnection);
        return await BiDi.BidiBrowser.create({
            connection: bidiConnection,
            cdpConnection: bidiOnly ? undefined : cdpConnection,
            closeCallback,
            process: browserProcess.nodeProcess,
            defaultViewport: opts.defaultViewport,
            acceptInsecureCerts: opts.acceptInsecureCerts,
            networkEnabled: opts.networkEnabled,
        });
    }
    async createBiDiBrowser(browserProcess, closeCallback, opts) {
        const browserWSEndpoint = (await browserProcess.waitForLineOutput(WEBDRIVER_BIDI_WEBSOCKET_ENDPOINT_REGEX, opts.timeout)) + '/session';
        const transport = await NodeWebSocketTransport.create(browserWSEndpoint);
        const BiDi = await import( '../../../node_modules/puppeteer-core/lib/esm/puppeteer/bidi/bidi.js');
        const bidiConnection = new BiDi.BidiConnection(browserWSEndpoint, transport, opts.slowMo, opts.protocolTimeout);
        return await BiDi.BidiBrowser.create({
            connection: bidiConnection,
            closeCallback,
            process: browserProcess.nodeProcess,
            defaultViewport: opts.defaultViewport,
            acceptInsecureCerts: opts.acceptInsecureCerts,
            networkEnabled: opts.networkEnabled ?? true,
        });
    }
    getProfilePath() {
        return join$1(this.puppeteer.configuration.temporaryDirectory ?? tmpdir(), `puppeteer_dev_${this.browser}_profile-`);
    }
    resolveExecutablePath(headless, validatePath = true) {
        let executablePath = this.puppeteer.configuration.executablePath;
        if (executablePath) {
            if (validatePath && !existsSync(executablePath)) {
                throw new Error(`Tried to find the browser at the configured path (${executablePath}), but no executable was found.`);
            }
            return executablePath;
        }
        function puppeteerBrowserToInstalledBrowser(browser, headless) {
            switch (browser) {
                case 'chrome':
                    if (headless === 'shell') {
                        return Browser.CHROMEHEADLESSSHELL;
                    }
                    return Browser.CHROME;
                case 'firefox':
                    return Browser.FIREFOX;
            }
            return Browser.CHROME;
        }
        const browserType = puppeteerBrowserToInstalledBrowser(this.browser, headless);
        executablePath = computeExecutablePath({
            cacheDir: this.puppeteer.defaultDownloadPath,
            browser: browserType,
            buildId: this.puppeteer.browserVersion,
        });
        if (validatePath && !existsSync(executablePath)) {
            const configVersion = this.puppeteer.configuration?.[this.browser]?.version;
            if (configVersion) {
                throw new Error(`Tried to find the browser at the configured path (${executablePath}) for version ${configVersion}, but no executable was found.`);
            }
            switch (this.browser) {
                case 'chrome':
                    throw new Error(`Could not find Chrome (ver. ${this.puppeteer.browserVersion}). This can occur if either\n` +
                        ` 1. you did not perform an installation before running the script (e.g. \`npx puppeteer browsers install ${browserType}\`) or\n` +
                        ` 2. your cache path is incorrectly configured (which is: ${this.puppeteer.configuration.cacheDirectory}).\n` +
                        'For (2), check out our guide on configuring puppeteer at https://pptr.dev/guides/configuration.');
                case 'firefox':
                    throw new Error(`Could not find Firefox (rev. ${this.puppeteer.browserVersion}). This can occur if either\n` +
                        ' 1. you did not perform an installation for Firefox before running the script (e.g. `npx puppeteer browsers install firefox`) or\n' +
                        ` 2. your cache path is incorrectly configured (which is: ${this.puppeteer.configuration.cacheDirectory}).\n` +
                        'For (2), check out our guide on configuring puppeteer at https://pptr.dev/guides/configuration.');
            }
        }
        return executablePath;
    }
}

/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const rmOptions = {
    force: true,
    recursive: true,
    maxRetries: 5,
};
async function rm(path) {
    await fs.promises.rm(path, rmOptions);
}

/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class ChromeLauncher extends BrowserLauncher {
    constructor(puppeteer) {
        super(puppeteer, 'chrome');
    }
    launch(options = {}) {
        if (this.puppeteer.configuration.logLevel === 'warn' &&
            process.platform === 'darwin' &&
            process.arch === 'x64') {
            const cpus = os.cpus();
            if (cpus[0]?.model.includes('Apple')) {
                console.warn([
                    '\x1B[1m\x1B[43m\x1B[30m',
                    'Degraded performance warning:\x1B[0m\x1B[33m',
                    'Launching Chrome on Mac Silicon (arm64) from an x64 Node installation results in',
                    'Rosetta translating the Chrome binary, even if Chrome is already arm64. This would',
                    'result in huge performance issues. To resolve this, you must run Puppeteer with',
                    'a version of Node built for arm64.',
                ].join('\n  '));
            }
        }
        return super.launch(options);
    }
    async computeLaunchArguments(options = {}) {
        const { ignoreDefaultArgs = false, args = [], pipe = false, debuggingPort, channel, executablePath, } = options;
        const chromeArguments = [];
        if (!ignoreDefaultArgs) {
            chromeArguments.push(...this.defaultArgs(options));
        }
        else if (Array.isArray(ignoreDefaultArgs)) {
            chromeArguments.push(...this.defaultArgs(options).filter(arg => {
                return !ignoreDefaultArgs.includes(arg);
            }));
        }
        else {
            chromeArguments.push(...args);
        }
        if (!chromeArguments.some(argument => {
            return argument.startsWith('--remote-debugging-');
        })) {
            if (pipe) {
                assert(!debuggingPort, 'Browser should be launched with either pipe or debugging port - not both.');
                chromeArguments.push('--remote-debugging-pipe');
            }
            else {
                chromeArguments.push(`--remote-debugging-port=${debuggingPort || 0}`);
            }
        }
        let isTempUserDataDir = false;
        let userDataDirIndex = chromeArguments.findIndex(arg => {
            return arg.startsWith('--user-data-dir');
        });
        if (userDataDirIndex < 0) {
            isTempUserDataDir = true;
            chromeArguments.push(`--user-data-dir=${await mkdtemp(this.getProfilePath())}`);
            userDataDirIndex = chromeArguments.length - 1;
        }
        const userDataDir = chromeArguments[userDataDirIndex].split('=', 2)[1];
        assert(typeof userDataDir === 'string', '`--user-data-dir` is malformed');
        let chromeExecutable = executablePath;
        if (!chromeExecutable) {
            assert(channel || !this.puppeteer._isPuppeteerCore, `An \`executablePath\` or \`channel\` must be specified for \`puppeteer-core\``);
            chromeExecutable = channel
                ? this.executablePath(channel)
                : this.resolveExecutablePath(options.headless ?? true);
        }
        return {
            executablePath: chromeExecutable,
            args: chromeArguments,
            isTempUserDataDir,
            userDataDir,
        };
    }
    async cleanUserDataDir(path, opts) {
        if (opts.isTemp) {
            try {
                await rm(path);
            }
            catch (error) {
                debugError(error);
                throw error;
            }
        }
    }
    defaultArgs(options = {}) {
        const userDisabledFeatures = getFeatures('--disable-features', options.args);
        if (options.args && userDisabledFeatures.length > 0) {
            removeMatchingFlags(options.args, '--disable-features');
        }
        const turnOnExperimentalFeaturesForTesting = process.env['PUPPETEER_TEST_EXPERIMENTAL_CHROME_FEATURES'] === 'true';
        const disabledFeatures = [
            'Translate',
            'AcceptCHFrame',
            'MediaRouter',
            'OptimizationHints',
            'RenderDocument',
            ...(turnOnExperimentalFeaturesForTesting
                ? []
                : [
                    'ProcessPerSiteUpToMainFrameThreshold',
                    'IsolateSandboxedIframes',
                ]),
            ...userDisabledFeatures,
        ].filter(feature => {
            return feature !== '';
        });
        const userEnabledFeatures = getFeatures('--enable-features', options.args);
        if (options.args && userEnabledFeatures.length > 0) {
            removeMatchingFlags(options.args, '--enable-features');
        }
        const enabledFeatures = [
            'PdfOopif',
            ...userEnabledFeatures,
        ].filter(feature => {
            return feature !== '';
        });
        const chromeArguments = [
            '--allow-pre-commit-input',
            '--disable-background-networking',
            '--disable-background-timer-throttling',
            '--disable-backgrounding-occluded-windows',
            '--disable-breakpad',
            '--disable-client-side-phishing-detection',
            '--disable-component-extensions-with-background-pages',
            '--disable-crash-reporter',
            '--disable-default-apps',
            '--disable-dev-shm-usage',
            '--disable-hang-monitor',
            '--disable-infobars',
            '--disable-ipc-flooding-protection',
            '--disable-popup-blocking',
            '--disable-prompt-on-repost',
            '--disable-renderer-backgrounding',
            '--disable-search-engine-choice-screen',
            '--disable-sync',
            '--enable-automation',
            '--export-tagged-pdf',
            '--force-color-profile=srgb',
            '--generate-pdf-document-outline',
            '--metrics-recording-only',
            '--no-first-run',
            '--password-store=basic',
            '--use-mock-keychain',
            `--disable-features=${disabledFeatures.join(',')}`,
            `--enable-features=${enabledFeatures.join(',')}`,
        ].filter(arg => {
            return arg !== '';
        });
        const { devtools = false, headless = !devtools, args = [], userDataDir, enableExtensions = false, } = options;
        if (userDataDir) {
            chromeArguments.push(`--user-data-dir=${path$1.resolve(userDataDir)}`);
        }
        if (devtools) {
            chromeArguments.push('--auto-open-devtools-for-tabs');
        }
        if (headless) {
            chromeArguments.push(headless === 'shell' ? '--headless' : '--headless=new', '--hide-scrollbars', '--mute-audio');
        }
        chromeArguments.push(enableExtensions
            ? '--enable-unsafe-extension-debugging'
            : '--disable-extensions');
        if (args.every(arg => {
            return arg.startsWith('-');
        })) {
            chromeArguments.push('about:blank');
        }
        chromeArguments.push(...args);
        return chromeArguments;
    }
    executablePath(channel, validatePath = true) {
        if (channel) {
            return computeSystemExecutablePath({
                browser: Browser.CHROME,
                channel: convertPuppeteerChannelToBrowsersChannel(channel),
            });
        }
        else {
            return this.resolveExecutablePath(undefined, validatePath);
        }
    }
}
function convertPuppeteerChannelToBrowsersChannel(channel) {
    switch (channel) {
        case 'chrome':
            return ChromeReleaseChannel.STABLE;
        case 'chrome-dev':
            return ChromeReleaseChannel.DEV;
        case 'chrome-beta':
            return ChromeReleaseChannel.BETA;
        case 'chrome-canary':
            return ChromeReleaseChannel.CANARY;
    }
}
function getFeatures(flag, options = []) {
    return options
        .filter(s => {
        return s.startsWith(flag.endsWith('=') ? flag : `${flag}=`);
    })
        .map(s => {
        return s.split(new RegExp(`${flag}=\\s*`))[1]?.trim();
    })
        .filter(s => {
        return s;
    });
}
function removeMatchingFlags(array, flag) {
    const regex = new RegExp(`^${flag}=.*`);
    let i = 0;
    while (i < array.length) {
        if (regex.test(array[i])) {
            array.splice(i, 1);
        }
        else {
            i++;
        }
    }
    return array;
}

/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class FirefoxLauncher extends BrowserLauncher {
    constructor(puppeteer) {
        super(puppeteer, 'firefox');
    }
    static getPreferences(extraPrefsFirefox) {
        return {
            ...extraPrefsFirefox,
            'fission.webContentIsolationStrategy': 0,
        };
    }
    async computeLaunchArguments(options = {}) {
        const { ignoreDefaultArgs = false, args = [], executablePath, pipe = false, extraPrefsFirefox = {}, debuggingPort = null, } = options;
        const firefoxArguments = [];
        if (!ignoreDefaultArgs) {
            firefoxArguments.push(...this.defaultArgs(options));
        }
        else if (Array.isArray(ignoreDefaultArgs)) {
            firefoxArguments.push(...this.defaultArgs(options).filter(arg => {
                return !ignoreDefaultArgs.includes(arg);
            }));
        }
        else {
            firefoxArguments.push(...args);
        }
        if (!firefoxArguments.some(argument => {
            return argument.startsWith('--remote-debugging-');
        })) {
            if (pipe) {
                assert(debuggingPort === null, 'Browser should be launched with either pipe or debugging port - not both.');
            }
            firefoxArguments.push(`--remote-debugging-port=${debuggingPort || 0}`);
        }
        let userDataDir;
        let isTempUserDataDir = true;
        const profileArgIndex = firefoxArguments.findIndex(arg => {
            return ['-profile', '--profile'].includes(arg);
        });
        if (profileArgIndex !== -1) {
            userDataDir = firefoxArguments[profileArgIndex + 1];
            if (!userDataDir) {
                throw new Error(`Missing value for profile command line argument`);
            }
            isTempUserDataDir = false;
        }
        else {
            userDataDir = await mkdtemp(this.getProfilePath());
            firefoxArguments.push('--profile');
            firefoxArguments.push(userDataDir);
        }
        await createProfile(Browser.FIREFOX, {
            path: userDataDir,
            preferences: FirefoxLauncher.getPreferences(extraPrefsFirefox),
        });
        let firefoxExecutable;
        if (this.puppeteer._isPuppeteerCore || executablePath) {
            assert(executablePath, `An \`executablePath\` must be specified for \`puppeteer-core\``);
            firefoxExecutable = executablePath;
        }
        else {
            firefoxExecutable = this.executablePath(undefined);
        }
        return {
            isTempUserDataDir,
            userDataDir,
            args: firefoxArguments,
            executablePath: firefoxExecutable,
        };
    }
    async cleanUserDataDir(userDataDir, opts) {
        if (opts.isTemp) {
            try {
                await rm(userDataDir);
            }
            catch (error) {
                debugError(error);
                throw error;
            }
        }
        else {
            try {
                const backupSuffix = '.puppeteer';
                const backupFiles = ['prefs.js', 'user.js'];
                const results = await Promise.allSettled(backupFiles.map(async (file) => {
                    const prefsBackupPath = path$1.join(userDataDir, file + backupSuffix);
                    if (fs.existsSync(prefsBackupPath)) {
                        const prefsPath = path$1.join(userDataDir, file);
                        await unlink(prefsPath);
                        await rename(prefsBackupPath, prefsPath);
                    }
                }));
                for (const result of results) {
                    if (result.status === 'rejected') {
                        throw result.reason;
                    }
                }
            }
            catch (error) {
                debugError(error);
            }
        }
    }
    executablePath(_, validatePath = true) {
        return this.resolveExecutablePath(undefined,
         validatePath);
    }
    defaultArgs(options = {}) {
        const { devtools = false, headless = !devtools, args = [], userDataDir = null, } = options;
        const firefoxArguments = [];
        switch (os.platform()) {
            case 'darwin':
                firefoxArguments.push('--foreground');
                break;
            case 'win32':
                firefoxArguments.push('--wait-for-browser');
                break;
        }
        if (userDataDir) {
            firefoxArguments.push('--profile');
            firefoxArguments.push(userDataDir);
        }
        if (headless) {
            firefoxArguments.push('--headless');
        }
        if (devtools) {
            firefoxArguments.push('--devtools');
        }
        if (args.every(arg => {
            return arg.startsWith('-');
        })) {
            firefoxArguments.push('about:blank');
        }
        firefoxArguments.push(...args);
        return firefoxArguments;
    }
}

/**
 * @license
 * Copyright 2020 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class PuppeteerNode extends Puppeteer {
    #launcher;
    #lastLaunchedBrowser;
    defaultBrowserRevision;
    configuration = {};
    constructor(settings) {
        const { configuration, ...commonSettings } = settings;
        super(commonSettings);
        if (configuration) {
            this.configuration = configuration;
        }
        switch (this.configuration.defaultBrowser) {
            case 'firefox':
                this.defaultBrowserRevision = PUPPETEER_REVISIONS.firefox;
                break;
            default:
                this.configuration.defaultBrowser = 'chrome';
                this.defaultBrowserRevision = PUPPETEER_REVISIONS.chrome;
                break;
        }
        this.connect = this.connect.bind(this);
        this.launch = this.launch.bind(this);
        this.executablePath = this.executablePath.bind(this);
        this.defaultArgs = this.defaultArgs.bind(this);
        this.trimCache = this.trimCache.bind(this);
    }
    connect(options) {
        return super.connect(options);
    }
    launch(options = {}) {
        const { browser = this.defaultBrowser } = options;
        this.#lastLaunchedBrowser = browser;
        switch (browser) {
            case 'chrome':
                this.defaultBrowserRevision = PUPPETEER_REVISIONS.chrome;
                break;
            case 'firefox':
                this.defaultBrowserRevision = PUPPETEER_REVISIONS.firefox;
                break;
            default:
                throw new Error(`Unknown product: ${browser}`);
        }
        this.#launcher = this.#getLauncher(browser);
        return this.#launcher.launch(options);
    }
    #getLauncher(browser) {
        if (this.#launcher && this.#launcher.browser === browser) {
            return this.#launcher;
        }
        switch (browser) {
            case 'chrome':
                return new ChromeLauncher(this);
            case 'firefox':
                return new FirefoxLauncher(this);
            default:
                throw new Error(`Unknown product: ${browser}`);
        }
    }
    executablePath(optsOrChannel) {
        if (optsOrChannel === undefined) {
            return this.#getLauncher(this.lastLaunchedBrowser).executablePath(undefined,
             false);
        }
        if (typeof optsOrChannel === 'string') {
            return this.#getLauncher('chrome').executablePath(optsOrChannel,
             false);
        }
        return this.#getLauncher(optsOrChannel.browser ?? this.lastLaunchedBrowser).resolveExecutablePath(optsOrChannel.headless,  false);
    }
    get browserVersion() {
        return (this.configuration?.[this.lastLaunchedBrowser]?.version ??
            this.defaultBrowserRevision);
    }
    get defaultDownloadPath() {
        return this.configuration.cacheDirectory;
    }
    get lastLaunchedBrowser() {
        return this.#lastLaunchedBrowser ?? this.defaultBrowser;
    }
    get defaultBrowser() {
        return this.configuration.defaultBrowser ?? 'chrome';
    }
    get product() {
        return this.lastLaunchedBrowser;
    }
    defaultArgs(options = {}) {
        return this.#getLauncher(options.browser ?? this.lastLaunchedBrowser).defaultArgs(options);
    }
    async trimCache() {
        const platform = detectBrowserPlatform();
        if (!platform) {
            throw new Error('The current platform is not supported.');
        }
        const cacheDir = this.configuration.cacheDirectory;
        const installedBrowsers = await getInstalledBrowsers({
            cacheDir,
        });
        const puppeteerBrowsers = [
            {
                product: 'chrome',
                browser: Browser.CHROME,
                currentBuildId: '',
            },
            {
                product: 'firefox',
                browser: Browser.FIREFOX,
                currentBuildId: '',
            },
        ];
        for (const item of puppeteerBrowsers) {
            const tag = this.configuration?.[item.product]?.version ??
                PUPPETEER_REVISIONS[item.product];
            item.currentBuildId = await resolveBuildId(item.browser, platform, tag);
        }
        const currentBrowserBuilds = new Set(puppeteerBrowsers.map(browser => {
            return `${browser.browser}_${browser.currentBuildId}`;
        }));
        const currentBrowsers = new Set(puppeteerBrowsers.map(browser => {
            return browser.browser;
        }));
        for (const installedBrowser of installedBrowsers) {
            if (!currentBrowsers.has(installedBrowser.browser)) {
                continue;
            }
            if (currentBrowserBuilds.has(`${installedBrowser.browser}_${installedBrowser.buildId}`)) {
                continue;
            }
            await uninstall({
                browser: installedBrowser.browser,
                platform,
                cacheDir,
                buildId: installedBrowser.buildId,
            });
        }
    }
}

/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var __runInitializers = (undefined && undefined.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate = (undefined && undefined.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
var __setFunctionName = (undefined && undefined.__setFunctionName) || function (f, name, prefix) {
    if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
    return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
};
const CRF_VALUE = 30;
const DEFAULT_FPS = 30;
const debugFfmpeg = debug$2('puppeteer:ffmpeg');
let ScreenRecorder = (() => {
    let _classSuper = PassThrough;
    let _instanceExtraInitializers = [];
    let _private_writeFrame_decorators;
    let _private_writeFrame_descriptor;
    let _stop_decorators;
    return class ScreenRecorder extends _classSuper {
        static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
            __esDecorate(this, _private_writeFrame_descriptor = { value: __setFunctionName(async function (buffer) {
                    const error = await new Promise(resolve => {
                        this.#process.stdin.write(buffer, resolve);
                    });
                    if (error) {
                        console.log(`ffmpeg failed to write: ${error.message}.`);
                    }
                }, "#writeFrame") }, _private_writeFrame_decorators, { kind: "method", name: "#writeFrame", static: false, private: true, access: { has: obj => #writeFrame in obj, get: obj => obj.#writeFrame }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _stop_decorators, { kind: "method", name: "stop", static: false, private: false, access: { has: obj => "stop" in obj, get: obj => obj.stop }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        #page = __runInitializers(this, _instanceExtraInitializers);
        #process;
        #controller = new AbortController();
        #lastFrame;
        #fps;
        constructor(page, width, height, { ffmpegPath, speed, scale, crop, format, fps, loop, delay, quality, colors, path, overwrite, } = {}) {
            super({ allowHalfOpen: false });
            ffmpegPath ??= 'ffmpeg';
            format ??= 'webm';
            fps ??= DEFAULT_FPS;
            loop ||= -1;
            delay ??= -1;
            quality ??= CRF_VALUE;
            colors ??= 256;
            overwrite ??= true;
            this.#fps = fps;
            const { error } = spawnSync(ffmpegPath);
            if (error) {
                throw error;
            }
            const filters = [
                `crop='min(${width},iw):min(${height},ih):0:0'`,
                `pad=${width}:${height}:0:0`,
            ];
            if (speed) {
                filters.push(`setpts=${1 / speed}*PTS`);
            }
            if (crop) {
                filters.push(`crop=${crop.width}:${crop.height}:${crop.x}:${crop.y}`);
            }
            if (scale) {
                filters.push(`scale=iw*${scale}:-1:flags=lanczos`);
            }
            const formatArgs = this.#getFormatArgs(format, fps, loop, delay, quality, colors);
            const vf = formatArgs.indexOf('-vf');
            if (vf !== -1) {
                filters.push(formatArgs.splice(vf, 2).at(-1) ?? '');
            }
            if (path) {
                fs.mkdirSync(dirname$1(path), { recursive: overwrite });
            }
            this.#process = spawn(ffmpegPath,
            [
                ['-loglevel', 'error'],
                ['-avioflags', 'direct'],
                [
                    '-fpsprobesize',
                    '0',
                    '-probesize',
                    '32',
                    '-analyzeduration',
                    '0',
                    '-fflags',
                    'nobuffer',
                ],
                ['-f', 'image2pipe', '-vcodec', 'png', '-i', 'pipe:0'],
                ['-an'],
                ['-threads', '1'],
                ['-framerate', `${fps}`],
                ['-b:v', '0'],
                formatArgs,
                ['-vf', filters.join()],
                [overwrite ? '-y' : '-n'],
                'pipe:1',
            ].flat(), { stdio: ['pipe', 'pipe', 'pipe'] });
            this.#process.stdout.pipe(this);
            this.#process.stderr.on('data', (data) => {
                debugFfmpeg(data.toString('utf8'));
            });
            this.#page = page;
            const { client } = this.#page.mainFrame();
            client.once(CDPSessionEvent.Disconnected, () => {
                void this.stop().catch(debugError);
            });
            this.#lastFrame = lastValueFrom(fromEmitterEvent(client, 'Page.screencastFrame').pipe(tap(event => {
                void client.send('Page.screencastFrameAck', {
                    sessionId: event.sessionId,
                });
            }), filter(event => {
                return event.metadata.timestamp !== undefined;
            }), map(event => {
                return {
                    buffer: Buffer.from(event.data, 'base64'),
                    timestamp: event.metadata.timestamp,
                };
            }), bufferCount(2, 1), concatMap(([{ timestamp: previousTimestamp, buffer }, { timestamp }]) => {
                return from(Array(Math.round(fps * Math.max(timestamp - previousTimestamp, 0))).fill(buffer));
            }), map(buffer => {
                void this.#writeFrame(buffer);
                return [buffer, performance.now()];
            }), takeUntil(fromEvent(this.#controller.signal, 'abort'))), { defaultValue: [Buffer.from([]), performance.now()] });
        }
        #getFormatArgs(format, fps, loop, delay, quality, colors) {
            const libvpx = [
                ['-vcodec', 'vp9'],
                ['-crf', `${quality}`],
                [
                    '-deadline',
                    'realtime',
                    '-cpu-used',
                    `${Math.min(os.cpus().length / 2, 8)}`,
                ],
            ];
            switch (format) {
                case 'webm':
                    return [
                        ...libvpx,
                        ['-f', 'webm'],
                    ].flat();
                case 'gif':
                    fps = DEFAULT_FPS === fps ? 20 : 'source_fps';
                    if (loop === Infinity) {
                        loop = 0;
                    }
                    if (delay !== -1) {
                        delay /= 10;
                    }
                    return [
                        [
                            '-vf',
                            `fps=${fps},split[s0][s1];[s0]palettegen=stats_mode=diff:max_colors=${colors}[p];[s1][p]paletteuse=dither=bayer`,
                        ],
                        ['-loop', `${loop}`],
                        ['-final_delay', `${delay}`],
                        ['-f', 'gif'],
                    ].flat();
                case 'mp4':
                    return [
                        ...libvpx,
                        ['-movflags', 'hybrid_fragmented'],
                        ['-f', 'mp4'],
                    ].flat();
            }
        }
        get #writeFrame() { return _private_writeFrame_descriptor.value; }
        async stop() {
            if (this.#controller.signal.aborted) {
                return;
            }
            await this.#page._stopScreencast().catch(debugError);
            this.#controller.abort();
            const [buffer, timestamp] = await this.#lastFrame;
            await Promise.all(Array(Math.max(1, Math.round((this.#fps * (performance.now() - timestamp)) / 1000)))
                .fill(buffer)
                .map(this.#writeFrame.bind(this)));
            this.#process.stdin.end();
            await new Promise(resolve => {
                this.#process.once('close', resolve);
            });
        }
        async [(_private_writeFrame_decorators = [guarded()], _stop_decorators = [guarded()], asyncDisposeSymbol)]() {
            await this.stop();
        }
    };
})();

/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
environment.value = {
    fs,
    path: path$1,
    ScreenRecorder: ScreenRecorder,
};
const puppeteer = new PuppeteerNode({
    isPuppeteerCore: true,
});
const {
connect,
defaultArgs,
executablePath,
launch, } = puppeteer;

var debug$3 = srcExports.debug;
export { Locator, McpServer, PredefinedNetworkConditions, SetLevelRequestSchema, StdioServerTransport, debug$3 as debug, hideBin, puppeteer, Yargs as yargs, z as zod };
