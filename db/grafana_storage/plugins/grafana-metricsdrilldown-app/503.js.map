{"version":3,"file":"503.js?_cache=60d29976a765e012e812","mappings":"qIAMAA,EAAOC,QAAU,SAASC,EAAMC,EAAGC,GACjC,GAAID,IAAMC,EAAG,OAAO,EAEpB,GAAID,GAAKC,GAAiB,iBAALD,GAA6B,iBAALC,EAAe,CAC1D,GAAID,EAAEE,cAAgBD,EAAEC,YAAa,OAAO,EAE5C,IAAIC,EAAQC,EAAGC,EACf,GAAIC,MAAMC,QAAQP,GAAI,CAEpB,IADAG,EAASH,EAAEG,SACGF,EAAEE,OAAQ,OAAO,EAC/B,IAAKC,EAAID,EAAgB,IAARC,KACf,IAAKL,EAAMC,EAAEI,GAAIH,EAAEG,IAAK,OAAO,EACjC,OAAO,CACT,CAIA,GAAIJ,EAAEE,cAAgBM,OAAQ,OAAOR,EAAES,SAAWR,EAAEQ,QAAUT,EAAEU,QAAUT,EAAES,MAC5E,GAAIV,EAAEW,UAAYC,OAAOC,UAAUF,QAAS,OAAOX,EAAEW,YAAcV,EAAEU,UACrE,GAAIX,EAAEc,WAAaF,OAAOC,UAAUC,SAAU,OAAOd,EAAEc,aAAeb,EAAEa,WAIxE,IADAX,GADAE,EAAOO,OAAOP,KAAKL,IACLG,UACCS,OAAOP,KAAKJ,GAAGE,OAAQ,OAAO,EAE7C,IAAKC,EAAID,EAAgB,IAARC,KACf,IAAKQ,OAAOC,UAAUE,eAAeC,KAAKf,EAAGI,EAAKD,IAAK,OAAO,EAEhE,IAAKA,EAAID,EAAgB,IAARC,KAAY,CAC3B,IAAIa,EAAMZ,EAAKD,GAEf,IAAKL,EAAMC,EAAEiB,GAAMhB,EAAEgB,IAAO,OAAO,CACrC,CAEA,OAAO,CACT,CAGA,OAAOjB,GAAIA,GAAKC,GAAIA,CACtB,C,mBC5CmEJ,EAAOC,QAGjE,WAAe,aAKpB,IAAIoB,EAAuB,CACvBC,SAAS,EACTC,eAAe,EACfC,WAAW,EACXC,SAAS,EACTC,YAAY,EACZC,eAAe,EACfC,YAAY,EACZC,cAAc,GAQdC,EAAQrB,MAAMO,UAAUc,MAU5B,SAASC,EAAWC,GAChB,IAAI1B,EAAS0B,EAAU1B,OACvB,OAAKA,EAGU,IAAXA,EACO,CAAC0B,EAAU,IAEP,IAAX1B,EACO,CAAC0B,EAAU,GAAIA,EAAU,IAErB,IAAX1B,EACO,CAAC0B,EAAU,GAAIA,EAAU,GAAIA,EAAU,IAE3CF,EAAMX,KAAKa,EAAW,GAXlB,EAYf,CAUA,SAASC,EAAiBC,GACtB,IAAIC,EAAgB,CAAC,EAErB,IAAK,IAAIf,KAAOc,EACPb,EAAqBD,KACtBe,EAAcf,GAAOc,EAAQd,IAIrC,OAAOe,CACX,CAUA,SAASC,EAAWC,GAChB,MAAqB,mBAAPA,GAAqBA,EAAGD,UAC1C,CAWA,SAASE,EAAgBC,EAASC,GAE9B,OAAOD,IAAYC,GAAYD,GAAYA,GAAWC,GAAYA,CACtE,CAWA,SAASC,EAAaC,EAAiBC,GACnC,IAAIC,EAAS,CAAC,EAEd,IAAK,IAAIxB,KAAOsB,EACZE,EAAOxB,GAAOsB,EAAgBtB,GAElC,IAAK,IAAIA,KAAOuB,EACZC,EAAOxB,GAAOuB,EAAWvB,GAG7B,OAAOwB,CACX,CAGA,IAAIC,EAAuB,WACvB,SAASA,EAAMX,GACXY,KAAKtC,KAAO,GACZsC,KAAKC,OAAS,GACdD,KAAKZ,QAAUA,EACf,IAAIc,EAAyD,mBAA1Bd,EAAQX,cACvCyB,EACAF,KAAKG,YAAcH,KAAKI,4BAEnBhB,EAAQT,QAAU,EACvBqB,KAAKG,YAAcH,KAAKK,oBAGxBL,KAAKG,YAAcH,KAAKM,sBAE5BN,KAAKO,gBAAkD,mBAAzBnB,EAAQL,aACtCiB,KAAKQ,qBAAuBR,KAAKO,iBAAmBL,EACpDF,KAAKS,kBAAkD,mBAAvBrB,EAAQR,WACxCoB,KAAKU,qBAAwD,mBAA1BtB,EAAQP,cAC3CmB,KAAKW,kBAAkD,mBAAvBvB,EAAQN,UAC5C,CAsKA,OArKAb,OAAO2C,eAAeb,EAAM7B,UAAW,OAAQ,CAI3C2C,IAAK,WACD,OAAOb,KAAKtC,KAAKF,MACrB,EACAsD,YAAY,EACZC,cAAc,IAElB9C,OAAO2C,eAAeb,EAAM7B,UAAW,WAAY,CAM/C2C,IAAK,WACD,MAAO,CACHnD,KAAMuB,EAAWe,KAAKtC,MACtBsD,KAAMhB,KAAKgB,KACXf,OAAQhB,EAAWe,KAAKC,QAEhC,EACAa,YAAY,EACZC,cAAc,IAKlBhB,EAAM7B,UAAUkC,4BAA8B,SAAUa,GACpD,IAAIC,EAAKlB,KAAKZ,QAASX,EAAgByC,EAAGzC,cAAeE,EAAUuC,EAAGvC,QAClEjB,EAAOsC,KAAKtC,KACZyD,EAAazD,EAAKF,OACtB,IAAK2D,EACD,OAAQ,EAEZ,GAAI1C,EAAcf,EAAK,GAAIuD,GACvB,OAAO,EAEX,GAAItC,EAAU,EACV,IAAK,IAAIyC,EAAQ,EAAGA,EAAQD,EAAYC,IACpC,GAAI3C,EAAcf,EAAK0D,GAAQH,GAC3B,OAAOG,EAInB,OAAQ,CACZ,EAIArB,EAAM7B,UAAUmC,oBAAsB,SAAUY,GAC5C,IAAIzC,EAAUwB,KAAKZ,QAAQZ,QACvBd,EAAOsC,KAAKtC,KACZyD,EAAazD,EAAKF,OACtB,IAAK2D,EACD,OAAQ,EAEZ,GAAmB,IAAfA,EACA,OAAOnB,KAAKM,sBAAsBW,GAEtC,IACII,EACAC,EAFAC,EAAYN,EAAWzD,OAG3B,GAAI+D,EAAY,GACZ,IAAK,IAAIH,EAAQ,EAAGA,EAAQD,EAAYC,IAEpC,IADAC,EAAc3D,EAAK0D,IACH5D,SAAW+D,EAAW,CAElC,IADAD,EAAW,EACJA,EAAWC,GACT/C,EAAQ6C,EAAYC,GAAWL,EAAWK,IADtBA,KAK7B,GAAIA,IAAaC,EACb,OAAOH,CAEf,OAIJ,IAASA,EAAQ,EAAGA,EAAQD,EAAYC,IAEpC,IADAC,EAAc3D,EAAK0D,IACH5D,SAAW+D,GACvB/C,EAAQ6C,EAAY,GAAIJ,EAAW,IACnC,OAAOG,EAInB,OAAQ,CACZ,EAIArB,EAAM7B,UAAUoC,sBAAwB,SAAUW,GAC9C,IAAIvD,EAAOsC,KAAKtC,KAChB,IAAKA,EAAKF,OACN,OAAQ,EAEZ,IAAI6D,EAAc3D,EAAK,GACnBF,EAAS6D,EAAY7D,OACzB,GAAIyD,EAAWzD,SAAWA,EACtB,OAAQ,EAEZ,IAAIgB,EAAUwB,KAAKZ,QAAQZ,QAC3B,GAAIhB,EAAS,EAAG,CACZ,IAAK,IAAI4D,EAAQ,EAAGA,EAAQ5D,EAAQ4D,IAChC,IAAK5C,EAAQ6C,EAAYD,GAAQH,EAAWG,IACxC,OAAQ,EAGhB,OAAO,CACX,CACA,OAAO5C,EAAQ6C,EAAY,GAAIJ,EAAW,IAAM,GAAK,CACzD,EAIAlB,EAAM7B,UAAUsD,WAAa,SAAUlD,EAAKmD,EAAOC,GAK/C,IAJA,IAAIhE,EAAOsC,KAAKtC,KACZuC,EAASD,KAAKC,OACd0B,EAAgBjE,EAAKF,OACrB4D,EAAQM,EACLN,KACH1D,EAAK0D,EAAQ,GAAK1D,EAAK0D,GACvBnB,EAAOmB,EAAQ,GAAKnB,EAAOmB,GAE/B1D,EAAK,GAAKY,EACV2B,EAAO,GAAKwB,EACZ,IAAI9C,EAAUqB,KAAKZ,QAAQT,QACvBgD,IAAkBhD,GAAW+C,IAAkBC,GAC/CjE,EAAKkE,MACL3B,EAAO2B,OAEFF,GAAiB/C,IAEtBjB,EAAKF,OAASyC,EAAOzC,OAASmB,EAEtC,EAKAoB,EAAM7B,UAAU2D,iBAAmB,SAAUC,GACzC,IAAIC,EAAQ/B,KACRkB,EAAKlB,KAAKZ,QAASP,EAAgBqC,EAAGrC,cAAeC,EAAaoC,EAAGpC,WACrEkD,EAAWhC,KAAKtC,KAAK,GACrBuE,EAAajC,KAAKC,OAAO,GAC7BD,KAAKC,OAAO,GAAKgC,EAAWC,KAAK,SAAUT,GAOvC,OANIM,EAAMpB,mBACN7B,EAAWiD,EAAOA,EAAM3C,QAAS0C,GAEjCC,EAAMrB,sBACN7B,EAAckD,EAAOA,EAAM3C,QAAS0C,GAEjCL,CACX,EAAG,SAAUU,GACT,IAAIC,EAAWL,EAAM5B,YAAY6B,GAKjC,MAJkB,IAAdI,IACAL,EAAMrE,KAAK2E,OAAOD,EAAU,GAC5BL,EAAM9B,OAAOoC,OAAOD,EAAU,IAE5BD,CACV,EACJ,EACOpC,CACX,CA3L0B,GA6L1B,SAASuC,EAAuB/C,EAAIH,GAEhC,QADgB,IAAZA,IAAsBA,EAAU,CAAC,GACjCE,EAAWC,GACX,OAAO+C,EAAuB/C,EAAGA,GAAII,EAAaJ,EAAGH,QAASA,IAElE,GAAkB,mBAAPG,EACP,MAAM,IAAIgD,UAAU,0CAExB,IAAIrB,EAAK9B,EAAQZ,QAASA,OAAiB,IAAP0C,EAAgB1B,EAAkB0B,EAAIzC,EAAgBW,EAAQX,cAAe+D,EAAKpD,EAAQV,UAAWA,OAAmB,IAAP8D,GAAwBA,EAAIC,EAAKrD,EAAQT,QAASA,OAAiB,IAAP8D,EAAgB,EAAIA,EAAI7D,EAAaQ,EAAQR,WAAYC,EAAgBO,EAAQP,cAAeC,EAAaM,EAAQN,WAAYC,EAAeK,EAAQL,aACrW2D,EAAoB/C,EAAa,CACjCnB,QAASA,EACTC,cAAeA,EACfC,UAAWA,EACXC,QAASA,EACTC,WAAYA,EACZC,cAAeA,EACfC,WAAYA,EACZC,aAAcA,GACfI,EAAiBC,IAChBuD,EAAQ,IAAI5C,EAAM2C,GAClBhF,EAAOiF,EAAMjF,KAAMuC,EAAS0C,EAAM1C,OAAQM,EAAkBoC,EAAMpC,gBAAiBC,EAAuBmC,EAAMnC,qBAAsBC,EAAoBkC,EAAMlC,kBAAmBC,EAAuBiC,EAAMjC,qBAAsBC,EAAoBgC,EAAMhC,kBAChQmB,EAAW,WACX,IAAIxD,EAAMkC,EACJvB,EAAW2D,WACXA,UACFrC,IACAjC,EAAMS,EAAaT,IAEvB,IAAI8D,EAAW1E,EAAKF,OAASmF,EAAMxC,YAAY7B,IAAQ,EACvD,IAAkB,IAAd8D,EACIzB,GACA7B,EAAW6D,EAAOD,EAAmBZ,GAErCM,IACAO,EAAMnB,WAAW9D,EAAK0E,GAAWnC,EAAOmC,GAAWA,GAC/C1B,GACA7B,EAAc8D,EAAOD,EAAmBZ,QAI/C,CACD,IAAIe,EAAWtD,EAAGuD,MAAM9C,KAAM4C,WAC1BG,EAASvC,EACPlC,EACAW,EAAW2D,WACjBD,EAAMnB,WAAWuB,EAAQF,EAAUnF,EAAKF,QACpCkB,GACAiE,EAAMd,iBAAiBC,GAEvBrB,GACA7B,EAAW+D,EAAOD,EAAmBZ,GAErCpB,GACA7B,EAAc8D,EAAOD,EAAmBZ,EAEhD,CACA,OAAO7B,EAAO,EAClB,EAKA,OAJA6B,EAASa,MAAQA,EACjBb,EAASvC,GAAKA,EACduC,EAASxC,YAAa,EACtBwC,EAAS1C,QAAUsD,EACZZ,CACX,CAEA,OAAOQ,CAEV,CAxXmFU,E,yxBCGpF,MAAMC,EAAe1D,GAAO,EAAQA,EAAI,CAAEf,QAAS,IACnD,SAAS0E,EAAmB3D,GAC1BA,EAAGoD,MAAMjF,KAAKF,OAAS,EACvB+B,EAAGoD,MAAM1C,OAAOzC,OAAS,CAC3B,CACA,IAAI2F,EACJ,MAAMC,EAA0BH,EAAY,CAACI,EAAQjE,IAC5C,IAAIkE,KAAKC,eAAeF,EAAQjE,IAEnCoE,EAA0BP,EAAY,CAACI,EAAQjE,IAC5C,IAAIkE,KAAKG,eAAeJ,EAAQjE,IAEnCsE,EAAaT,EACjB,CAACU,EAAQC,EAAS,CAAC,KACjB,MAAMnC,EAA0B,iBAAXkC,EAAsB,IAAIE,KAAKF,GAAUA,EAE9D,OADsBP,EAAwBD,EAAgBS,GACzCA,OAAOnC,KAG1BqC,EAAiBb,EACrB,CAACc,EAAU3E,EAAU,CAAC,IACEoE,EAAwBL,EAAgB/D,GACzCwE,OAAOG,IAG1BC,EAAkB,CAACC,EAAOC,EAAKN,EAAS,CAAC,KAC7C,MAAMO,EAAwB,iBAAVF,EAAqB,IAAIJ,KAAKI,GAASA,EACrDG,EAAoB,iBAARF,EAAmB,IAAIL,KAAKK,GAAOA,EAErD,OADsBd,EAAwBD,EAAgBS,GACzCS,YAAYF,EAAMC,IAEnCE,EAAsBC,IAC1BrB,EAAmBQ,GACnBR,EAAmBY,GACnBX,EAAiBoB,E","sources":["webpack://grafana-metricsdrilldown-app/../node_modules/fast-deep-equal/index.js","webpack://grafana-metricsdrilldown-app/../node_modules/micro-memoize/dist/micro-memoize.js","webpack://grafana-metricsdrilldown-app/../node_modules/@grafana/i18n/dist/esm/dates.mjs"],"sourcesContent":["'use strict';\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n","(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n    typeof define === 'function' && define.amd ? define(factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global[\"micro-memoize\"] = factory());\n})(this, (function () { 'use strict';\n\n    /**\n     * @constant DEFAULT_OPTIONS_KEYS the default options keys\n     */\n    var DEFAULT_OPTIONS_KEYS = {\n        isEqual: true,\n        isMatchingKey: true,\n        isPromise: true,\n        maxSize: true,\n        onCacheAdd: true,\n        onCacheChange: true,\n        onCacheHit: true,\n        transformKey: true,\n    };\n    /**\n     * @function slice\n     *\n     * @description\n     * slice.call() pre-bound\n     */\n    var slice = Array.prototype.slice;\n    /**\n     * @function cloneArray\n     *\n     * @description\n     * clone the array-like object and return the new array\n     *\n     * @param arrayLike the array-like object to clone\n     * @returns the clone as an array\n     */\n    function cloneArray(arrayLike) {\n        var length = arrayLike.length;\n        if (!length) {\n            return [];\n        }\n        if (length === 1) {\n            return [arrayLike[0]];\n        }\n        if (length === 2) {\n            return [arrayLike[0], arrayLike[1]];\n        }\n        if (length === 3) {\n            return [arrayLike[0], arrayLike[1], arrayLike[2]];\n        }\n        return slice.call(arrayLike, 0);\n    }\n    /**\n     * @function getCustomOptions\n     *\n     * @description\n     * get the custom options on the object passed\n     *\n     * @param options the memoization options passed\n     * @returns the custom options passed\n     */\n    function getCustomOptions(options) {\n        var customOptions = {};\n        /* eslint-disable no-restricted-syntax */\n        for (var key in options) {\n            if (!DEFAULT_OPTIONS_KEYS[key]) {\n                customOptions[key] = options[key];\n            }\n        }\n        /* eslint-enable */\n        return customOptions;\n    }\n    /**\n     * @function isMemoized\n     *\n     * @description\n     * is the function passed already memoized\n     *\n     * @param fn the function to test\n     * @returns is the function already memoized\n     */\n    function isMemoized(fn) {\n        return typeof fn === 'function' && fn.isMemoized;\n    }\n    /**\n     * @function isSameValueZero\n     *\n     * @description\n     * are the objects equal based on SameValueZero equality\n     *\n     * @param object1 the first object to compare\n     * @param object2 the second object to compare\n     * @returns are the two objects equal\n     */\n    function isSameValueZero(object1, object2) {\n        // eslint-disable-next-line no-self-compare\n        return object1 === object2 || (object1 !== object1 && object2 !== object2);\n    }\n    /**\n     * @function mergeOptions\n     *\n     * @description\n     * merge the options into the target\n     *\n     * @param existingOptions the options provided\n     * @param newOptions the options to include\n     * @returns the merged options\n     */\n    function mergeOptions(existingOptions, newOptions) {\n        var target = {};\n        /* eslint-disable no-restricted-syntax */\n        for (var key in existingOptions) {\n            target[key] = existingOptions[key];\n        }\n        for (var key in newOptions) {\n            target[key] = newOptions[key];\n        }\n        /* eslint-enable */\n        return target;\n    }\n\n    // utils\n    var Cache = /** @class */ (function () {\n        function Cache(options) {\n            this.keys = [];\n            this.values = [];\n            this.options = options;\n            var isMatchingKeyFunction = typeof options.isMatchingKey === 'function';\n            if (isMatchingKeyFunction) {\n                this.getKeyIndex = this._getKeyIndexFromMatchingKey;\n            }\n            else if (options.maxSize > 1) {\n                this.getKeyIndex = this._getKeyIndexForMany;\n            }\n            else {\n                this.getKeyIndex = this._getKeyIndexForSingle;\n            }\n            this.canTransformKey = typeof options.transformKey === 'function';\n            this.shouldCloneArguments = this.canTransformKey || isMatchingKeyFunction;\n            this.shouldUpdateOnAdd = typeof options.onCacheAdd === 'function';\n            this.shouldUpdateOnChange = typeof options.onCacheChange === 'function';\n            this.shouldUpdateOnHit = typeof options.onCacheHit === 'function';\n        }\n        Object.defineProperty(Cache.prototype, \"size\", {\n            /**\n             * The number of cached [key,value] results.\n             */\n            get: function () {\n                return this.keys.length;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(Cache.prototype, \"snapshot\", {\n            /**\n             * A copy of the cache at a moment in time. This is useful\n             * to compare changes over time, since the cache mutates\n             * internally for performance reasons.\n             */\n            get: function () {\n                return {\n                    keys: cloneArray(this.keys),\n                    size: this.size,\n                    values: cloneArray(this.values),\n                };\n            },\n            enumerable: false,\n            configurable: true\n        });\n        /**\n         * Gets the matching key index when a custom key matcher is used.\n         */\n        Cache.prototype._getKeyIndexFromMatchingKey = function (keyToMatch) {\n            var _a = this.options, isMatchingKey = _a.isMatchingKey, maxSize = _a.maxSize;\n            var keys = this.keys;\n            var keysLength = keys.length;\n            if (!keysLength) {\n                return -1;\n            }\n            if (isMatchingKey(keys[0], keyToMatch)) {\n                return 0;\n            }\n            if (maxSize > 1) {\n                for (var index = 1; index < keysLength; index++) {\n                    if (isMatchingKey(keys[index], keyToMatch)) {\n                        return index;\n                    }\n                }\n            }\n            return -1;\n        };\n        /**\n         * Gets the matching key index when multiple keys are used.\n         */\n        Cache.prototype._getKeyIndexForMany = function (keyToMatch) {\n            var isEqual = this.options.isEqual;\n            var keys = this.keys;\n            var keysLength = keys.length;\n            if (!keysLength) {\n                return -1;\n            }\n            if (keysLength === 1) {\n                return this._getKeyIndexForSingle(keyToMatch);\n            }\n            var keyLength = keyToMatch.length;\n            var existingKey;\n            var argIndex;\n            if (keyLength > 1) {\n                for (var index = 0; index < keysLength; index++) {\n                    existingKey = keys[index];\n                    if (existingKey.length === keyLength) {\n                        argIndex = 0;\n                        for (; argIndex < keyLength; argIndex++) {\n                            if (!isEqual(existingKey[argIndex], keyToMatch[argIndex])) {\n                                break;\n                            }\n                        }\n                        if (argIndex === keyLength) {\n                            return index;\n                        }\n                    }\n                }\n            }\n            else {\n                for (var index = 0; index < keysLength; index++) {\n                    existingKey = keys[index];\n                    if (existingKey.length === keyLength &&\n                        isEqual(existingKey[0], keyToMatch[0])) {\n                        return index;\n                    }\n                }\n            }\n            return -1;\n        };\n        /**\n         * Gets the matching key index when a single key is used.\n         */\n        Cache.prototype._getKeyIndexForSingle = function (keyToMatch) {\n            var keys = this.keys;\n            if (!keys.length) {\n                return -1;\n            }\n            var existingKey = keys[0];\n            var length = existingKey.length;\n            if (keyToMatch.length !== length) {\n                return -1;\n            }\n            var isEqual = this.options.isEqual;\n            if (length > 1) {\n                for (var index = 0; index < length; index++) {\n                    if (!isEqual(existingKey[index], keyToMatch[index])) {\n                        return -1;\n                    }\n                }\n                return 0;\n            }\n            return isEqual(existingKey[0], keyToMatch[0]) ? 0 : -1;\n        };\n        /**\n         * Order the array based on a Least-Recently-Used basis.\n         */\n        Cache.prototype.orderByLru = function (key, value, startingIndex) {\n            var keys = this.keys;\n            var values = this.values;\n            var currentLength = keys.length;\n            var index = startingIndex;\n            while (index--) {\n                keys[index + 1] = keys[index];\n                values[index + 1] = values[index];\n            }\n            keys[0] = key;\n            values[0] = value;\n            var maxSize = this.options.maxSize;\n            if (currentLength === maxSize && startingIndex === currentLength) {\n                keys.pop();\n                values.pop();\n            }\n            else if (startingIndex >= maxSize) {\n                // eslint-disable-next-line no-multi-assign\n                keys.length = values.length = maxSize;\n            }\n        };\n        /**\n         * Update the promise method to auto-remove from cache if rejected, and\n         * if resolved then fire cache hit / changed.\n         */\n        Cache.prototype.updateAsyncCache = function (memoized) {\n            var _this = this;\n            var _a = this.options, onCacheChange = _a.onCacheChange, onCacheHit = _a.onCacheHit;\n            var firstKey = this.keys[0];\n            var firstValue = this.values[0];\n            this.values[0] = firstValue.then(function (value) {\n                if (_this.shouldUpdateOnHit) {\n                    onCacheHit(_this, _this.options, memoized);\n                }\n                if (_this.shouldUpdateOnChange) {\n                    onCacheChange(_this, _this.options, memoized);\n                }\n                return value;\n            }, function (error) {\n                var keyIndex = _this.getKeyIndex(firstKey);\n                if (keyIndex !== -1) {\n                    _this.keys.splice(keyIndex, 1);\n                    _this.values.splice(keyIndex, 1);\n                }\n                throw error;\n            });\n        };\n        return Cache;\n    }());\n\n    function createMemoizedFunction(fn, options) {\n        if (options === void 0) { options = {}; }\n        if (isMemoized(fn)) {\n            return createMemoizedFunction(fn.fn, mergeOptions(fn.options, options));\n        }\n        if (typeof fn !== 'function') {\n            throw new TypeError('You must pass a function to `memoize`.');\n        }\n        var _a = options.isEqual, isEqual = _a === void 0 ? isSameValueZero : _a, isMatchingKey = options.isMatchingKey, _b = options.isPromise, isPromise = _b === void 0 ? false : _b, _c = options.maxSize, maxSize = _c === void 0 ? 1 : _c, onCacheAdd = options.onCacheAdd, onCacheChange = options.onCacheChange, onCacheHit = options.onCacheHit, transformKey = options.transformKey;\n        var normalizedOptions = mergeOptions({\n            isEqual: isEqual,\n            isMatchingKey: isMatchingKey,\n            isPromise: isPromise,\n            maxSize: maxSize,\n            onCacheAdd: onCacheAdd,\n            onCacheChange: onCacheChange,\n            onCacheHit: onCacheHit,\n            transformKey: transformKey,\n        }, getCustomOptions(options));\n        var cache = new Cache(normalizedOptions);\n        var keys = cache.keys, values = cache.values, canTransformKey = cache.canTransformKey, shouldCloneArguments = cache.shouldCloneArguments, shouldUpdateOnAdd = cache.shouldUpdateOnAdd, shouldUpdateOnChange = cache.shouldUpdateOnChange, shouldUpdateOnHit = cache.shouldUpdateOnHit;\n        var memoized = function () {\n            var key = shouldCloneArguments\n                ? cloneArray(arguments)\n                : arguments;\n            if (canTransformKey) {\n                key = transformKey(key);\n            }\n            var keyIndex = keys.length ? cache.getKeyIndex(key) : -1;\n            if (keyIndex !== -1) {\n                if (shouldUpdateOnHit) {\n                    onCacheHit(cache, normalizedOptions, memoized);\n                }\n                if (keyIndex) {\n                    cache.orderByLru(keys[keyIndex], values[keyIndex], keyIndex);\n                    if (shouldUpdateOnChange) {\n                        onCacheChange(cache, normalizedOptions, memoized);\n                    }\n                }\n            }\n            else {\n                var newValue = fn.apply(this, arguments);\n                var newKey = shouldCloneArguments\n                    ? key\n                    : cloneArray(arguments);\n                cache.orderByLru(newKey, newValue, keys.length);\n                if (isPromise) {\n                    cache.updateAsyncCache(memoized);\n                }\n                if (shouldUpdateOnAdd) {\n                    onCacheAdd(cache, normalizedOptions, memoized);\n                }\n                if (shouldUpdateOnChange) {\n                    onCacheChange(cache, normalizedOptions, memoized);\n                }\n            }\n            return values[0];\n        };\n        memoized.cache = cache;\n        memoized.fn = fn;\n        memoized.isMemoized = true;\n        memoized.options = normalizedOptions;\n        return memoized;\n    }\n\n    return createMemoizedFunction;\n\n}));\n","import deepEqual from 'fast-deep-equal';\nimport memoize from 'micro-memoize';\n\n\"use strict\";\nconst deepMemoize = (fn) => memoize(fn, { isEqual: deepEqual });\nfunction clearMemoizedCache(fn) {\n  fn.cache.keys.length = 0;\n  fn.cache.values.length = 0;\n}\nlet regionalFormat;\nconst createDateTimeFormatter = deepMemoize((locale, options) => {\n  return new Intl.DateTimeFormat(locale, options);\n});\nconst createDurationFormatter = deepMemoize((locale, options) => {\n  return new Intl.DurationFormat(locale, options);\n});\nconst formatDate = deepMemoize(\n  (_value, format = {}) => {\n    const value = typeof _value === \"string\" ? new Date(_value) : _value;\n    const dateFormatter = createDateTimeFormatter(regionalFormat, format);\n    return dateFormatter.format(value);\n  }\n);\nconst formatDuration = deepMemoize(\n  (duration, options = {}) => {\n    const dateFormatter = createDurationFormatter(regionalFormat, options);\n    return dateFormatter.format(duration);\n  }\n);\nconst formatDateRange = (_from, _to, format = {}) => {\n  const from = typeof _from === \"string\" ? new Date(_from) : _from;\n  const to = typeof _to === \"string\" ? new Date(_to) : _to;\n  const dateFormatter = createDateTimeFormatter(regionalFormat, format);\n  return dateFormatter.formatRange(from, to);\n};\nconst initRegionalFormat = (regionalFormatArg) => {\n  clearMemoizedCache(formatDate);\n  clearMemoizedCache(formatDuration);\n  regionalFormat = regionalFormatArg;\n};\n\nexport { formatDate, formatDateRange, formatDuration, initRegionalFormat };\n//# sourceMappingURL=dates.mjs.map\n"],"names":["module","exports","equal","a","b","constructor","length","i","keys","Array","isArray","RegExp","source","flags","valueOf","Object","prototype","toString","hasOwnProperty","call","key","DEFAULT_OPTIONS_KEYS","isEqual","isMatchingKey","isPromise","maxSize","onCacheAdd","onCacheChange","onCacheHit","transformKey","slice","cloneArray","arrayLike","getCustomOptions","options","customOptions","isMemoized","fn","isSameValueZero","object1","object2","mergeOptions","existingOptions","newOptions","target","Cache","this","values","isMatchingKeyFunction","getKeyIndex","_getKeyIndexFromMatchingKey","_getKeyIndexForMany","_getKeyIndexForSingle","canTransformKey","shouldCloneArguments","shouldUpdateOnAdd","shouldUpdateOnChange","shouldUpdateOnHit","defineProperty","get","enumerable","configurable","size","keyToMatch","_a","keysLength","index","existingKey","argIndex","keyLength","orderByLru","value","startingIndex","currentLength","pop","updateAsyncCache","memoized","_this","firstKey","firstValue","then","error","keyIndex","splice","createMemoizedFunction","TypeError","_b","_c","normalizedOptions","cache","arguments","newValue","apply","newKey","factory","deepMemoize","clearMemoizedCache","regionalFormat","createDateTimeFormatter","locale","Intl","DateTimeFormat","createDurationFormatter","DurationFormat","formatDate","_value","format","Date","formatDuration","duration","formatDateRange","_from","_to","from","to","formatRange","initRegionalFormat","regionalFormatArg"],"sourceRoot":""}